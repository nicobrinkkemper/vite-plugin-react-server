diff --git a/node_modules/react-dom/cjs/react-dom-client.development.js b/node_modules/react-dom/cjs/react-dom-client.development.js
index 465037e..af9cc6d 100644
--- a/node_modules/react-dom/cjs/react-dom-client.development.js
+++ b/node_modules/react-dom/cjs/react-dom-client.development.js
@@ -264,6 +264,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (
@@ -353,6 +355,8 @@
           return "SuspenseList";
         case 25:
           return "TracingMarker";
+        case 30:
+          return "ViewTransition";
         case 1:
         case 0:
         case 14:
@@ -559,61 +563,10 @@
             ));
         }
     }
-    function injectProfilingHooks(profilingHooks) {
-      injectedProfilingHooks = profilingHooks;
-    }
-    function markCommitStopped() {
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markCommitStopped &&
-        injectedProfilingHooks.markCommitStopped();
-    }
-    function markComponentRenderStarted(fiber) {
-      null !== injectedProfilingHooks &&
-        "function" ===
-          typeof injectedProfilingHooks.markComponentRenderStarted &&
-        injectedProfilingHooks.markComponentRenderStarted(fiber);
-    }
-    function markComponentRenderStopped() {
-      null !== injectedProfilingHooks &&
-        "function" ===
-          typeof injectedProfilingHooks.markComponentRenderStopped &&
-        injectedProfilingHooks.markComponentRenderStopped();
-    }
-    function markRenderStarted(lanes) {
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markRenderStarted &&
-        injectedProfilingHooks.markRenderStarted(lanes);
-    }
-    function markRenderStopped() {
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markRenderStopped &&
-        injectedProfilingHooks.markRenderStopped();
-    }
-    function markStateUpdateScheduled(fiber, lane) {
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markStateUpdateScheduled &&
-        injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
-    }
     function clz32Fallback(x) {
       x >>>= 0;
       return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
     }
-    function getLabelForLane(lane) {
-      if (lane & 1) return "SyncHydrationLane";
-      if (lane & 2) return "Sync";
-      if (lane & 4) return "InputContinuousHydration";
-      if (lane & 8) return "InputContinuous";
-      if (lane & 16) return "DefaultHydration";
-      if (lane & 32) return "Default";
-      if (lane & 64) return "TransitionHydration";
-      if (lane & 4194176) return "Transition";
-      if (lane & 62914560) return "Retry";
-      if (lane & 67108864) return "SelectiveHydration";
-      if (lane & 134217728) return "IdleHydration";
-      if (lane & 268435456) return "Idle";
-      if (lane & 536870912) return "Offscreen";
-      if (lane & 1073741824) return "Deferred";
-    }
     function getHighestPriorityLanes(lanes) {
       var pendingSyncLanes = lanes & 42;
       if (0 !== pendingSyncLanes) return pendingSyncLanes;
@@ -1369,6 +1322,27 @@
       "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
       return sampleLines;
     }
+    function formatOwnerStack(error) {
+      var prevPrepareStackTrace = Error.prepareStackTrace;
+      Error.prepareStackTrace = void 0;
+      error = error.stack;
+      Error.prepareStackTrace = prevPrepareStackTrace;
+      error.startsWith("Error: react-stack-top-frame\n") &&
+        (error = error.slice(29));
+      prevPrepareStackTrace = error.indexOf("\n");
+      -1 !== prevPrepareStackTrace &&
+        (error = error.slice(prevPrepareStackTrace + 1));
+      prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
+      -1 !== prevPrepareStackTrace &&
+        (prevPrepareStackTrace = error.lastIndexOf(
+          "\n",
+          prevPrepareStackTrace
+        ));
+      if (-1 !== prevPrepareStackTrace)
+        error = error.slice(0, prevPrepareStackTrace);
+      else return "";
+      return error;
+    }
     function describeFiber(fiber) {
       switch (fiber.tag) {
         case 26:
@@ -1388,6 +1362,8 @@
           return describeNativeComponentFrame(fiber.type.render, !1);
         case 1:
           return describeNativeComponentFrame(fiber.type, !0);
+        case 30:
+          return describeBuiltInComponentFrame("ViewTransition");
         default:
           return "";
       }
@@ -1417,13 +1393,75 @@
         return "\nError generating stack: " + x.message + "\n" + x.stack;
       }
     }
+    function describeFunctionComponentFrameWithoutLineNumber(fn) {
+      return (fn = fn ? fn.displayName || fn.name : "")
+        ? describeBuiltInComponentFrame(fn)
+        : "";
+    }
     function getCurrentFiberOwnerNameInDevOrNull() {
       if (null === current) return null;
       var owner = current._debugOwner;
       return null != owner ? getComponentNameFromOwner(owner) : null;
     }
     function getCurrentFiberStackInDev() {
-      return null === current ? "" : getStackByFiberInDevAndProd(current);
+      if (null === current) return "";
+      var workInProgress = current;
+      try {
+        var info = "";
+        6 === workInProgress.tag && (workInProgress = workInProgress.return);
+        switch (workInProgress.tag) {
+          case 26:
+          case 27:
+          case 5:
+            info += describeBuiltInComponentFrame(workInProgress.type);
+            break;
+          case 13:
+            info += describeBuiltInComponentFrame("Suspense");
+            break;
+          case 19:
+            info += describeBuiltInComponentFrame("SuspenseList");
+            break;
+          case 30:
+            info += describeBuiltInComponentFrame("SuspenseList");
+            break;
+          case 0:
+          case 15:
+          case 1:
+            workInProgress._debugOwner ||
+              "" !== info ||
+              (info += describeFunctionComponentFrameWithoutLineNumber(
+                workInProgress.type
+              ));
+            break;
+          case 11:
+            workInProgress._debugOwner ||
+              "" !== info ||
+              (info += describeFunctionComponentFrameWithoutLineNumber(
+                workInProgress.type.render
+              ));
+        }
+        for (; workInProgress; )
+          if ("number" === typeof workInProgress.tag) {
+            var fiber = workInProgress;
+            workInProgress = fiber._debugOwner;
+            var debugStack = fiber._debugStack;
+            workInProgress &&
+              debugStack &&
+              ("string" !== typeof debugStack &&
+                (fiber._debugStack = debugStack = formatOwnerStack(debugStack)),
+              "" !== debugStack && (info += "\n" + debugStack));
+          } else if (null != workInProgress.debugStack) {
+            var ownerStack = workInProgress.debugStack;
+            (workInProgress = workInProgress.owner) &&
+              ownerStack &&
+              (info += "\n" + formatOwnerStack(ownerStack));
+          } else break;
+        var JSCompiler_inline_result = info;
+      } catch (x) {
+        JSCompiler_inline_result =
+          "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+      return JSCompiler_inline_result;
     }
     function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
       var previousFiber = current;
@@ -1432,7 +1470,11 @@
       isRendering = !1;
       current = fiber;
       try {
-        return callback(arg0, arg1, arg2, arg3, arg4);
+        return null !== fiber && fiber._debugTask
+          ? fiber._debugTask.run(
+              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
+            )
+          : callback(arg0, arg1, arg2, arg3, arg4);
       } finally {
         current = previousFiber;
       }
@@ -2472,37 +2514,50 @@
         : findInvalidAncestorForTag(childTag, ancestorInfo);
       ancestorInfo = parentInfo || ancestorInfo;
       if (!ancestorInfo) return !0;
-      ancestorInfo = ancestorInfo.tag;
-      var warnKey = String(!!parentInfo) + "|" + childTag + "|" + ancestorInfo;
-      if (didWarn[warnKey]) return !1;
-      didWarn[warnKey] = !0;
-      var ancestor = (warnKey = current)
-        ? findAncestor(warnKey.return, ancestorInfo)
-        : null;
-      warnKey =
-        null !== warnKey && null !== ancestor
-          ? describeAncestors(ancestor, warnKey, null)
-          : "";
-      ancestor = "<" + childTag + ">";
+      var ancestorTag = ancestorInfo.tag;
+      ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
+      if (didWarn[ancestorInfo]) return !1;
+      didWarn[ancestorInfo] = !0;
+      var ancestor = (ancestorInfo = current)
+          ? findAncestor(ancestorInfo.return, ancestorTag)
+          : null,
+        ancestorDescription =
+          null !== ancestorInfo && null !== ancestor
+            ? describeAncestors(ancestor, ancestorInfo, null)
+            : "",
+        tagDisplayName = "<" + childTag + ">";
       parentInfo
         ? ((parentInfo = ""),
-          "table" === ancestorInfo &&
+          "table" === ancestorTag &&
             "tr" === childTag &&
             (parentInfo +=
               " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."),
           console.error(
             "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
-            ancestor,
-            ancestorInfo,
+            tagDisplayName,
+            ancestorTag,
             parentInfo,
-            warnKey
+            ancestorDescription
           ))
         : console.error(
             "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
-            ancestor,
-            ancestorInfo,
-            warnKey
+            tagDisplayName,
+            ancestorTag,
+            ancestorDescription
           );
+      ancestorInfo &&
+        ((childTag = ancestorInfo.return),
+        null === ancestor ||
+          null === childTag ||
+          (ancestor === childTag &&
+            childTag._debugOwner === ancestorInfo._debugOwner) ||
+          runWithFiberInDEV(ancestor, function () {
+            console.error(
+              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
+              ancestorTag,
+              tagDisplayName
+            );
+          }));
       return !1;
     }
     function validateTextNesting(childText, parentTag) {
@@ -2683,12 +2738,14 @@
               ? node.setProperty(styleName, "")
               : "float" === styleName
                 ? (node.cssFloat = "")
-                : (node[styleName] = ""));
+                : (node[styleName] = ""),
+            (viewTransitionMutationContext = !0));
         for (var _styleName in styles)
           (_key2 = styles[_styleName]),
             styles.hasOwnProperty(_styleName) &&
               prevStyles[_styleName] !== _key2 &&
-              setValueForStyle(node, _styleName, _key2);
+              (setValueForStyle(node, _styleName, _key2),
+              (viewTransitionMutationContext = !0));
       } else
         for (expandedUpdates in styles)
           styles.hasOwnProperty(expandedUpdates) &&
@@ -3870,6 +3927,38 @@
           staleFamilies
         );
     }
+    function startUpdateTimerByLane(lane) {
+      var JSCompiler_temp;
+      (JSCompiler_temp = 0 !== (lane & 3)) ||
+        (JSCompiler_temp = 0 !== (lane & 60));
+      if (JSCompiler_temp)
+        0 > blockingUpdateTime &&
+          ((blockingUpdateTime = now()),
+          (executionContext & (RenderContext | CommitContext)) !== NoContext &&
+            (blockingSpawnedUpdate = !0),
+          (lane = resolveEventTimeStamp()),
+          (JSCompiler_temp = resolveEventType()),
+          lane !== blockingEventTime || JSCompiler_temp !== blockingEventType
+            ? (blockingEventIsRepeat = !1)
+            : null !== JSCompiler_temp && (blockingSpawnedUpdate = !0),
+          (blockingEventTime = lane),
+          (blockingEventType = JSCompiler_temp));
+      else if (
+        0 !== (lane & 4194176) &&
+        0 > transitionUpdateTime &&
+        ((transitionUpdateTime = now()), 0 > transitionStartTime)
+      ) {
+        lane = resolveEventTimeStamp();
+        JSCompiler_temp = resolveEventType();
+        if (
+          lane !== transitionEventTime ||
+          JSCompiler_temp !== transitionEventType
+        )
+          transitionEventIsRepeat = !1;
+        transitionEventTime = lane;
+        transitionEventType = JSCompiler_temp;
+      }
+    }
     function pushNestedEffectDurations() {
       var prevEffectDuration = profilerEffectDuration;
       profilerEffectDuration = 0;
@@ -3885,6 +3974,23 @@
       profilerEffectDuration += prevEffectDuration;
       return elapsedTime;
     }
+    function resetComponentEffectTimers() {
+      componentEffectEndTime = componentEffectStartTime = -1.1;
+    }
+    function pushComponentEffectStart() {
+      var prevEffectStart = componentEffectStartTime;
+      componentEffectStartTime = -1.1;
+      componentEffectDuration = -0;
+      return prevEffectStart;
+    }
+    function popComponentEffectStart(prevEffectStart) {
+      0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
+    }
+    function pushComponentEffectErrors() {
+      var prevErrors = componentEffectErrors;
+      componentEffectErrors = null;
+      return prevErrors;
+    }
     function startProfilerTimer(fiber) {
       profilerStartTime = now();
       0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
@@ -3906,18 +4012,266 @@
     }
     function recordEffectDuration() {
       if (0 <= profilerStartTime) {
-        var elapsedTime = now() - profilerStartTime;
+        var endTime = now(),
+          elapsedTime = endTime - profilerStartTime;
         profilerStartTime = -1;
         profilerEffectDuration += elapsedTime;
+        componentEffectDuration += elapsedTime;
+        componentEffectEndTime = endTime;
       }
     }
+    function recordEffectError(errorInfo) {
+      null === componentEffectErrors && (componentEffectErrors = []);
+      componentEffectErrors.push(errorInfo);
+      null === commitErrors && (commitErrors = []);
+      commitErrors.push(errorInfo);
+    }
     function startEffectTimer() {
       profilerStartTime = now();
+      0 > componentEffectStartTime &&
+        (componentEffectStartTime = profilerStartTime);
     }
     function transferActualDuration(fiber) {
       for (var child = fiber.child; child; )
         (fiber.actualDuration += child.actualDuration), (child = child.sibling);
     }
+    function setCurrentTrackFromLanes(lanes) {
+      reusableLaneDevToolDetails.track =
+        lanes & 63
+          ? "Blocking"
+          : lanes & 4194240
+            ? "Transition"
+            : lanes & 62914560
+              ? "Suspense"
+              : lanes & 2080374784
+                ? "Idle"
+                : "Other";
+    }
+    function logComponentRender(fiber, startTime, endTime, wasHydrated) {
+      var name = getComponentNameFromFiber(fiber);
+      if (null !== name && supportsUserTiming) {
+        var selfTime = fiber.actualDuration;
+        if (null === fiber.alternate || fiber.alternate.child !== fiber.child)
+          for (fiber = fiber.child; null !== fiber; fiber = fiber.sibling)
+            selfTime -= fiber.actualDuration;
+        reusableComponentDevToolDetails.color =
+          0.5 > selfTime
+            ? wasHydrated
+              ? "tertiary-light"
+              : "primary-light"
+            : 10 > selfTime
+              ? wasHydrated
+                ? "tertiary"
+                : "primary"
+              : 100 > selfTime
+                ? wasHydrated
+                  ? "tertiary-dark"
+                  : "primary-dark"
+                : "error";
+        reusableComponentOptions.start = startTime;
+        reusableComponentOptions.end = endTime;
+        performance.measure(name, reusableComponentOptions);
+      }
+    }
+    function logComponentErrored(fiber, startTime, endTime, errors) {
+      if (supportsUserTiming) {
+        var name = getComponentNameFromFiber(fiber);
+        if (null !== name) {
+          for (var properties = [], i = 0; i < errors.length; i++) {
+            var error = errors[i].value;
+            properties.push([
+              "Error",
+              "object" === typeof error &&
+              null !== error &&
+              "string" === typeof error.message
+                ? String(error.message)
+                : String(error)
+            ]);
+          }
+          performance.measure(name, {
+            start: startTime,
+            end: endTime,
+            detail: {
+              devtools: {
+                color: "error",
+                track: COMPONENTS_TRACK,
+                tooltipText:
+                  13 === fiber.tag
+                    ? "Hydration failed"
+                    : "Error boundary caught an error",
+                properties: properties
+              }
+            }
+          });
+        }
+      }
+    }
+    function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
+      if (null !== errors) {
+        if (
+          supportsUserTiming &&
+          ((selfTime = getComponentNameFromFiber(fiber)), null !== selfTime)
+        ) {
+          fiber = [];
+          for (var i = 0; i < errors.length; i++) {
+            var error = errors[i].value;
+            fiber.push([
+              "Error",
+              "object" === typeof error &&
+              null !== error &&
+              "string" === typeof error.message
+                ? String(error.message)
+                : String(error)
+            ]);
+          }
+          performance.measure(selfTime, {
+            start: startTime,
+            end: endTime,
+            detail: {
+              devtools: {
+                color: "error",
+                track: COMPONENTS_TRACK,
+                tooltipText: "A lifecycle or effect errored",
+                properties: fiber
+              }
+            }
+          });
+        }
+      } else
+        (errors = getComponentNameFromFiber(fiber)),
+          null !== errors &&
+            supportsUserTiming &&
+            ((reusableComponentDevToolDetails.color =
+              1 > selfTime
+                ? "secondary-light"
+                : 100 > selfTime
+                  ? "secondary"
+                  : 500 > selfTime
+                    ? "secondary-dark"
+                    : "error"),
+            (reusableComponentOptions.start = startTime),
+            (reusableComponentOptions.end = endTime),
+            performance.measure(errors, reusableComponentOptions));
+    }
+    function logRenderPhase(startTime, endTime, lanes) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color =
+          (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure(
+          (lanes & 536870912) === lanes
+            ? "Prepared"
+            : (lanes & 201326677) === lanes
+              ? "Hydrated"
+              : "Render",
+          reusableLaneOptions
+        ));
+    }
+    function logSuspendedRenderPhase(startTime, endTime, lanes) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color =
+          (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Prewarm", reusableLaneOptions));
+    }
+    function logSuspendedWithDelayPhase(startTime, endTime, lanes) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color =
+          (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Suspended", reusableLaneOptions));
+    }
+    function logRecoveredRenderPhase(
+      startTime,
+      endTime,
+      lanes,
+      recoverableErrors,
+      hydrationFailed
+    ) {
+      if (supportsUserTiming) {
+        lanes = [];
+        for (var i = 0; i < recoverableErrors.length; i++) {
+          var error = recoverableErrors[i].value;
+          lanes.push([
+            "Recoverable Error",
+            "object" === typeof error &&
+            null !== error &&
+            "string" === typeof error.message
+              ? String(error.message)
+              : String(error)
+          ]);
+        }
+        performance.measure("Recovered", {
+          start: startTime,
+          end: endTime,
+          detail: {
+            devtools: {
+              color: "primary-dark",
+              track: reusableLaneDevToolDetails.track,
+              trackGroup: LANES_TRACK_GROUP,
+              tooltipText: hydrationFailed
+                ? "Hydration Failed"
+                : "Recovered after Error",
+              properties: lanes
+            }
+          }
+        });
+      }
+    }
+    function logErroredRenderPhase(startTime, endTime) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color = "error"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Errored", reusableLaneOptions));
+    }
+    function logSuspenseThrottlePhase(startTime, endTime) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color = "secondary-light"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Throttled", reusableLaneOptions));
+    }
+    function logSuspendedCommitPhase(startTime, endTime) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color = "secondary-light"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Suspended", reusableLaneOptions));
+    }
+    function logCommitErrored(startTime, endTime, errors, passive) {
+      if (supportsUserTiming) {
+        for (var properties = [], i = 0; i < errors.length; i++) {
+          var error = errors[i].value;
+          properties.push([
+            "Error",
+            "object" === typeof error &&
+            null !== error &&
+            "string" === typeof error.message
+              ? String(error.message)
+              : String(error)
+          ]);
+        }
+        performance.measure("Errored", {
+          start: startTime,
+          end: endTime,
+          detail: {
+            devtools: {
+              color: "error",
+              track: reusableLaneDevToolDetails.track,
+              trackGroup: LANES_TRACK_GROUP,
+              tooltipText: passive
+                ? "Remaining Effects Errored"
+                : "Commit Errored",
+              properties: properties
+            }
+          }
+        });
+      }
+    }
     function resetContextDependencies() {
       lastContextDependency = currentlyRenderingFiber$1 = null;
       isDisallowedContextReadInDEV = !1;
@@ -4147,7 +4501,8 @@
     function pingEngtangledActionScope() {
       if (
         0 === --currentEntangledPendingCount &&
-        null !== currentEntangledListeners
+        (-1 < transitionUpdateTime || (transitionStartTime = -1.1),
+        null !== currentEntangledListeners)
       ) {
         null !== currentEntangledActionThenable &&
           (currentEntangledActionThenable.status = "fulfilled");
@@ -4635,6 +4990,15 @@
       }
       return newProps;
     }
+    function getTreeId() {
+      var overflow = treeContextOverflow,
+        idWithLeadingBit = treeContextId;
+      return (
+        (
+          idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
+        ).toString(32) + overflow
+      );
+    }
     function pushTreeFork(workInProgress, totalChildren) {
       warnIfNotHydrating();
       forkStack[forkStackIndex++] = treeForkCount;
@@ -5705,7 +6069,7 @@
           ),
           node.isTransition ||
             console.error(
-              "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
+              "An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`"
             ))
         : onActionSuccess(actionQueue, node, returnValue);
     }
@@ -5942,6 +6306,43 @@
         ? mountEffectImpl(276826112, Passive, create, deps)
         : mountEffectImpl(8390656, Passive, create, deps);
     }
+    function useEffectEventImpl(payload) {
+      currentlyRenderingFiber.flags |= 4;
+      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
+      if (null === componentUpdateQueue)
+        (componentUpdateQueue = createFunctionComponentUpdateQueue()),
+          (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
+          (componentUpdateQueue.events = [payload]);
+      else {
+        var events = componentUpdateQueue.events;
+        null === events
+          ? (componentUpdateQueue.events = [payload])
+          : events.push(payload);
+      }
+    }
+    function mountEvent(callback) {
+      var hook = mountWorkInProgressHook(),
+        ref = { impl: callback };
+      hook.memoizedState = ref;
+      return function () {
+        if ((executionContext & RenderContext) !== NoContext)
+          throw Error(
+            "A function wrapped in useEffectEvent can't be called during rendering."
+          );
+        return ref.impl.apply(void 0, arguments);
+      };
+    }
+    function updateEvent(callback) {
+      var ref = updateWorkInProgressHook().memoizedState;
+      useEffectEventImpl({ ref: ref, nextImpl: callback });
+      return function () {
+        if ((executionContext & RenderContext) !== NoContext)
+          throw Error(
+            "A function wrapped in useEffectEvent can't be called during rendering."
+          );
+        return ref.impl.apply(void 0, arguments);
+      };
+    }
     function mountLayoutEffect(create, deps) {
       var fiberFlags = 4194308;
       (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode &&
@@ -6268,18 +6669,13 @@
       var hook = mountWorkInProgressHook(),
         identifierPrefix = workInProgressRoot.identifierPrefix;
       if (isHydrating) {
-        var treeId = treeContextOverflow;
-        var idWithLeadingBit = treeContextId;
-        treeId =
-          (
-            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
-          ).toString(32) + treeId;
+        var treeId = getTreeId();
         identifierPrefix = ":" + identifierPrefix + "R" + treeId;
         treeId = localIdCounter++;
         0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
         identifierPrefix += ":";
       } else
-        (treeId = globalClientIdCounter++),
+        (treeId = globalClientIdCounter$1++),
           (identifierPrefix =
             ":" + identifierPrefix + "r" + treeId.toString(32) + ":");
       return (hook.memoizedState = identifierPrefix);
@@ -6290,7 +6686,7 @@
         currentlyRenderingFiber
       ));
     }
-    function refreshCache(fiber, seedKey) {
+    function refreshCache(fiber, seedKey, seedValue) {
       for (var provider = fiber.return; null !== provider; ) {
         switch (provider.tag) {
           case 24:
@@ -6299,15 +6695,14 @@
             fiber = createUpdate(lane);
             var root = enqueueUpdate(provider, fiber, lane);
             null !== root &&
-              (scheduleUpdateOnFiber(root, provider, lane),
+              (startUpdateTimerByLane(lane),
+              scheduleUpdateOnFiber(root, provider, lane),
               entangleTransitions(root, provider, lane));
             provider = createCache();
             null !== seedKey &&
               void 0 !== seedKey &&
               null !== root &&
-              console.error(
-                "The seed argument is not enabled outside experimental channels."
-              );
+              provider.data.set(seedKey, seedValue);
             fiber.payload = { cache: provider };
             return;
         }
@@ -6333,9 +6728,9 @@
         ? enqueueRenderPhaseUpdate(queue, update)
         : ((update = enqueueConcurrentHookUpdate(fiber, queue, update, args)),
           null !== update &&
-            (scheduleUpdateOnFiber(update, fiber, args),
+            (startUpdateTimerByLane(args),
+            scheduleUpdateOnFiber(update, fiber, args),
             entangleTransitionUpdate(update, queue, args)));
-      markStateUpdateScheduled(fiber, args);
     }
     function dispatchSetState(fiber, queue, action) {
       var args = arguments;
@@ -6344,8 +6739,8 @@
           "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
         );
       args = requestUpdateLane(fiber);
-      dispatchSetStateInternal(fiber, queue, action, args);
-      markStateUpdateScheduled(fiber, args);
+      dispatchSetStateInternal(fiber, queue, action, args) &&
+        startUpdateTimerByLane(args);
     }
     function dispatchSetStateInternal(fiber, queue, action, lane) {
       var update = {
@@ -6424,8 +6819,8 @@
           2
         )),
           null !== throwIfDuringRender &&
-            scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
-      markStateUpdateScheduled(fiber, 2);
+            (startUpdateTimerByLane(2),
+            scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
     }
     function isRenderPhaseUpdate(fiber) {
       var alternate = fiber.alternate;
@@ -6608,6 +7003,7 @@
             )),
             (current.return = returnFiber),
             (current._debugOwner = returnFiber),
+            (current._debugTask = returnFiber._debugTask),
             (current._debugInfo = currentDebugInfo),
             current
           );
@@ -6682,6 +7078,7 @@
             )),
             (current.return = returnFiber),
             (current._debugOwner = returnFiber),
+            (current._debugTask = returnFiber._debugTask),
             (current._debugInfo = currentDebugInfo),
             current
           );
@@ -6704,6 +7101,7 @@
             )),
             (newChild.return = returnFiber),
             (newChild._debugOwner = returnFiber),
+            (newChild._debugTask = returnFiber._debugTask),
             (newChild._debugInfo = currentDebugInfo),
             newChild
           );
@@ -6741,7 +7139,11 @@
               currentDebugInfo = _prevDebugInfo;
               return returnFiber;
           }
-          if (isArrayImpl(newChild) || getIteratorFn(newChild))
+          if (
+            isArrayImpl(newChild) ||
+            getIteratorFn(newChild) ||
+            "function" === typeof newChild[ASYNC_ITERATOR]
+          )
             return (
               (lanes = createFiberFromFragment(
                 newChild,
@@ -6751,6 +7153,7 @@
               )),
               (lanes.return = returnFiber),
               (lanes._debugOwner = returnFiber),
+              (lanes._debugTask = returnFiber._debugTask),
               (returnFiber = pushDebugInfo(newChild._debugInfo)),
               (lanes._debugInfo = currentDebugInfo),
               (currentDebugInfo = returnFiber),
@@ -6822,7 +7225,11 @@
                 returnFiber
               );
           }
-          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
+          if (
+            isArrayImpl(newChild) ||
+            getIteratorFn(newChild) ||
+            "function" === typeof newChild[ASYNC_ITERATOR]
+          ) {
             if (null !== key) return null;
             key = pushDebugInfo(newChild._debugInfo);
             returnFiber = updateFragment(
@@ -6916,7 +7323,11 @@
               currentDebugInfo = _prevDebugInfo7;
               return returnFiber;
           }
-          if (isArrayImpl(newChild) || getIteratorFn(newChild))
+          if (
+            isArrayImpl(newChild) ||
+            getIteratorFn(newChild) ||
+            "function" === typeof newChild[ASYNC_ITERATOR]
+          )
             return (
               (newIdx = existingChildren.get(newIdx) || null),
               (existingChildren = pushDebugInfo(newChild._debugInfo)),
@@ -7102,6 +7513,37 @@
         isHydrating && pushTreeFork(returnFiber, newIdx);
         return resultingFirstChild;
       }
+      function reconcileChildrenAsyncIteratable(
+        returnFiber,
+        currentFirstChild,
+        newChildrenIterable,
+        lanes
+      ) {
+        var newChildren = newChildrenIterable[ASYNC_ITERATOR]();
+        newChildren !== newChildrenIterable ||
+          (0 === returnFiber.tag &&
+            "[object AsyncGeneratorFunction]" ===
+              Object.prototype.toString.call(returnFiber.type) &&
+            "[object AsyncGenerator]" ===
+              Object.prototype.toString.call(newChildren)) ||
+          (didWarnAboutGenerators ||
+            console.error(
+              "Using AsyncIterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You can use an AsyncIterable that can iterate multiple times over the same items."
+            ),
+          (didWarnAboutGenerators = !0));
+        if (null == newChildren)
+          throw Error("An iterable object provided no iterator.");
+        return reconcileChildrenIterator(
+          returnFiber,
+          currentFirstChild,
+          {
+            next: function () {
+              return unwrapThenable(newChildren.next());
+            }
+          },
+          lanes
+        );
+      }
       function reconcileChildrenIterator(
         returnFiber,
         currentFirstChild,
@@ -7288,6 +7730,7 @@
                     )),
                     (lanes.return = returnFiber),
                     (lanes._debugOwner = returnFiber),
+                    (lanes._debugTask = returnFiber._debugTask),
                     (lanes._debugInfo = currentDebugInfo),
                     validateFragmentProps(newChild, lanes, returnFiber),
                     (returnFiber = lanes))
@@ -7410,6 +7853,18 @@
             currentDebugInfo = prevDebugInfo;
             return returnFiber;
           }
+          if ("function" === typeof newChild[ASYNC_ITERATOR])
+            return (
+              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
+              (returnFiber = reconcileChildrenAsyncIteratable(
+                returnFiber,
+                currentFirstChild,
+                newChild,
+                lanes
+              )),
+              (currentDebugInfo = prevDebugInfo),
+              returnFiber
+            );
           if ("function" === typeof newChild.then)
             return (
               (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
@@ -7454,6 +7909,7 @@
                 )),
                 (lanes.return = returnFiber),
                 (lanes._debugOwner = returnFiber),
+                (lanes._debugTask = returnFiber._debugTask),
                 (lanes._debugInfo = currentDebugInfo),
                 (returnFiber = lanes)),
             placeSingleChild(returnFiber)
@@ -7483,10 +7939,12 @@
           fiber.return = returnFiber;
           var debugInfo = (fiber._debugInfo = currentDebugInfo);
           fiber._debugOwner = returnFiber._debugOwner;
+          fiber._debugTask = returnFiber._debugTask;
           if (null != debugInfo)
             for (var i = debugInfo.length - 1; 0 <= i; i--)
               if ("string" === typeof debugInfo[i].stack) {
                 fiber._debugOwner = debugInfo[i];
+                fiber._debugTask = debugInfo[i].debugTask;
                 break;
               }
           return fiber;
@@ -7567,63 +8025,62 @@
       }
       return null;
     }
-    function defaultOnUncaughtError(error, errorInfo) {
+    function defaultOnUncaughtError(error) {
       reportGlobalError(error);
-      error = componentName
-        ? "An error occurred in the <" + componentName + "> component."
-        : "An error occurred in one of your React components.";
-      var prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
-        componentStack =
-          null != errorInfo.componentStack ? errorInfo.componentStack : "";
-      ReactSharedInternals.getCurrentStack = function () {
-        return componentStack;
-      };
-      try {
-        console.warn(
-          "%s\n\n%s\n",
-          error,
-          "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
-        );
-      } finally {
-        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
-      }
+      console.warn(
+        "%s\n\n%s\n",
+        componentName
+          ? "An error occurred in the <" + componentName + "> component."
+          : "An error occurred in one of your React components.",
+        "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
+      );
     }
-    function defaultOnCaughtError(error, errorInfo) {
+    function defaultOnCaughtError(error) {
       var componentNameMessage = componentName
           ? "The above error occurred in the <" + componentName + "> component."
           : "The above error occurred in one of your React components.",
         recreateMessage =
           "React will try to recreate this component tree from scratch using the error boundary you provided, " +
-          ((errorBoundaryName || "Anonymous") + "."),
-        prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
-        componentStack =
-          null != errorInfo.componentStack ? errorInfo.componentStack : "";
-      ReactSharedInternals.getCurrentStack = function () {
-        return componentStack;
-      };
-      try {
+          ((errorBoundaryName || "Anonymous") + ".");
+      if (
         "object" === typeof error &&
         null !== error &&
         "string" === typeof error.environmentName
-          ? bindToConsole(
-              "error",
-              [
-                "%o\n\n%s\n\n%s\n",
-                error,
-                componentNameMessage,
-                recreateMessage
-              ],
-              error.environmentName
-            )()
-          : console.error(
-              "%o\n\n%s\n\n%s\n",
-              error,
-              componentNameMessage,
-              recreateMessage
+      ) {
+        var JSCompiler_inline_result = error.environmentName;
+        error = [
+          "%o\n\n%s\n\n%s\n",
+          error,
+          componentNameMessage,
+          recreateMessage
+        ].slice(0);
+        "string" === typeof error[0]
+          ? error.splice(
+              0,
+              1,
+              badgeFormat + error[0],
+              badgeStyle,
+              pad + JSCompiler_inline_result + pad,
+              resetStyle
+            )
+          : error.splice(
+              0,
+              0,
+              badgeFormat,
+              badgeStyle,
+              pad + JSCompiler_inline_result + pad,
+              resetStyle
             );
-      } finally {
-        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
-      }
+        error.unshift(console);
+        JSCompiler_inline_result = bind.apply(console.error, error);
+        JSCompiler_inline_result();
+      } else
+        console.error(
+          "%o\n\n%s\n\n%s\n",
+          error,
+          componentNameMessage,
+          recreateMessage
+        );
     }
     function defaultOnRecoverableError(error) {
       reportGlobalError(error);
@@ -7721,6 +8178,27 @@
               ));
         });
     }
+    function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
+      var currentSourceFiber = sourceFiber.alternate;
+      null !== currentSourceFiber &&
+        propagateParentContextChanges(
+          currentSourceFiber,
+          sourceFiber,
+          rootRenderLanes,
+          !0
+        );
+    }
+    function markSuspenseBoundaryShouldCapture(
+      suspenseBoundary,
+      returnFiber,
+      sourceFiber,
+      root,
+      rootRenderLanes
+    ) {
+      suspenseBoundary.flags |= 65536;
+      suspenseBoundary.lanes = rootRenderLanes;
+      return suspenseBoundary;
+    }
     function throwException(
       root,
       returnFiber,
@@ -7733,63 +8211,63 @@
       if (
         null !== value &&
         "object" === typeof value &&
-        "function" === typeof value.then
+        (value.$$typeof === REACT_POSTPONE_TYPE &&
+          (value = { then: function () {} }),
+        "function" === typeof value.then)
       ) {
-        returnFiber = sourceFiber.alternate;
-        null !== returnFiber &&
-          propagateParentContextChanges(
-            returnFiber,
-            sourceFiber,
-            rootRenderLanes,
-            !0
-          );
+        resetSuspendedComponent(sourceFiber, rootRenderLanes);
         isHydrating && (didSuspendOrErrorDEV = !0);
-        sourceFiber = suspenseHandlerStackCursor.current;
-        if (null !== sourceFiber) {
-          switch (sourceFiber.tag) {
+        var suspenseBoundary = suspenseHandlerStackCursor.current;
+        if (null !== suspenseBoundary) {
+          switch (suspenseBoundary.tag) {
             case 13:
               return (
                 null === shellBoundary
                   ? renderDidSuspendDelayIfPossible()
-                  : null === sourceFiber.alternate &&
+                  : null === suspenseBoundary.alternate &&
                     workInProgressRootExitStatus === RootInProgress &&
                     (workInProgressRootExitStatus = RootSuspended),
-                (sourceFiber.flags &= -257),
-                (sourceFiber.flags |= 65536),
-                (sourceFiber.lanes = rootRenderLanes),
+                (suspenseBoundary.flags &= -257),
+                markSuspenseBoundaryShouldCapture(
+                  suspenseBoundary,
+                  returnFiber,
+                  sourceFiber,
+                  root,
+                  rootRenderLanes
+                ),
                 value === noopSuspenseyCommitThenable
-                  ? (sourceFiber.flags |= 16384)
-                  : ((returnFiber = sourceFiber.updateQueue),
-                    null === returnFiber
-                      ? (sourceFiber.updateQueue = new Set([value]))
-                      : returnFiber.add(value),
+                  ? (suspenseBoundary.flags |= 16384)
+                  : ((sourceFiber = suspenseBoundary.updateQueue),
+                    null === sourceFiber
+                      ? (suspenseBoundary.updateQueue = new Set([value]))
+                      : sourceFiber.add(value),
                     attachPingListener(root, value, rootRenderLanes)),
                 !1
               );
             case 22:
               return (
-                (sourceFiber.flags |= 65536),
+                (suspenseBoundary.flags |= 65536),
                 value === noopSuspenseyCommitThenable
-                  ? (sourceFiber.flags |= 16384)
-                  : ((returnFiber = sourceFiber.updateQueue),
-                    null === returnFiber
-                      ? ((returnFiber = {
+                  ? (suspenseBoundary.flags |= 16384)
+                  : ((sourceFiber = suspenseBoundary.updateQueue),
+                    null === sourceFiber
+                      ? ((sourceFiber = {
                           transitions: null,
                           markerInstances: null,
                           retryQueue: new Set([value])
                         }),
-                        (sourceFiber.updateQueue = returnFiber))
-                      : ((sourceFiber = returnFiber.retryQueue),
-                        null === sourceFiber
-                          ? (returnFiber.retryQueue = new Set([value]))
-                          : sourceFiber.add(value)),
+                        (suspenseBoundary.updateQueue = sourceFiber))
+                      : ((returnFiber = sourceFiber.retryQueue),
+                        null === returnFiber
+                          ? (sourceFiber.retryQueue = new Set([value]))
+                          : returnFiber.add(value)),
                     attachPingListener(root, value, rootRenderLanes)),
                 !1
               );
           }
           throw Error(
             "Unexpected Suspense handler tag (" +
-              sourceFiber.tag +
+              suspenseBoundary.tag +
               "). This is a bug in React."
           );
         }
@@ -7800,11 +8278,17 @@
       if (isHydrating)
         return (
           (didSuspendOrErrorDEV = !0),
-          (returnFiber = suspenseHandlerStackCursor.current),
-          null !== returnFiber
-            ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
-              (returnFiber.flags |= 65536),
-              (returnFiber.lanes = rootRenderLanes),
+          (suspenseBoundary = suspenseHandlerStackCursor.current),
+          null !== suspenseBoundary
+            ? (0 === (suspenseBoundary.flags & 65536) &&
+                (suspenseBoundary.flags |= 256),
+              markSuspenseBoundaryShouldCapture(
+                suspenseBoundary,
+                returnFiber,
+                sourceFiber,
+                root,
+                rootRenderLanes
+              ),
               value !== HydrationMismatchException &&
                 queueHydrationError(
                   createCapturedValueAtFiber(
@@ -7829,10 +8313,10 @@
               (root.flags |= 65536),
               (rootRenderLanes &= -rootRenderLanes),
               (root.lanes |= rootRenderLanes),
-              (value = createCapturedValueAtFiber(value, sourceFiber)),
+              (sourceFiber = createCapturedValueAtFiber(value, sourceFiber)),
               (rootRenderLanes = createRootErrorUpdate(
                 root.stateNode,
-                value,
+                sourceFiber,
                 rootRenderLanes
               )),
               enqueueCapturedUpdate(root, rootRenderLanes),
@@ -7840,64 +8324,65 @@
                 (workInProgressRootExitStatus = RootErrored)),
           !1
         );
-      var error = createCapturedValueAtFiber(
-        Error(
-          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
-          { cause: value }
-        ),
-        sourceFiber
+      queueConcurrentError(
+        createCapturedValueAtFiber(
+          Error(
+            "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
+            { cause: value }
+          ),
+          sourceFiber
+        )
       );
-      null === workInProgressRootConcurrentErrors
-        ? (workInProgressRootConcurrentErrors = [error])
-        : workInProgressRootConcurrentErrors.push(error);
       workInProgressRootExitStatus !== RootSuspendedWithDelay &&
         (workInProgressRootExitStatus = RootErrored);
       if (null === returnFiber) return !0;
-      value = createCapturedValueAtFiber(value, sourceFiber);
-      sourceFiber = returnFiber;
+      sourceFiber = createCapturedValueAtFiber(value, sourceFiber);
+      value = returnFiber;
       do {
-        switch (sourceFiber.tag) {
+        switch (value.tag) {
           case 3:
             return (
-              (sourceFiber.flags |= 65536),
+              (value.flags |= 65536),
               (root = rootRenderLanes & -rootRenderLanes),
-              (sourceFiber.lanes |= root),
+              (value.lanes |= root),
               (root = createRootErrorUpdate(
-                sourceFiber.stateNode,
-                value,
+                value.stateNode,
+                sourceFiber,
                 root
               )),
-              enqueueCapturedUpdate(sourceFiber, root),
+              enqueueCapturedUpdate(value, root),
               !1
             );
           case 1:
             if (
-              ((returnFiber = sourceFiber.type),
-              (error = sourceFiber.stateNode),
-              0 === (sourceFiber.flags & 128) &&
+              ((returnFiber = value.type),
+              (suspenseBoundary = value.stateNode),
+              0 === (value.flags & 128) &&
                 ("function" === typeof returnFiber.getDerivedStateFromError ||
-                  (null !== error &&
-                    "function" === typeof error.componentDidCatch &&
+                  (null !== suspenseBoundary &&
+                    "function" === typeof suspenseBoundary.componentDidCatch &&
                     (null === legacyErrorBoundariesThatAlreadyFailed ||
-                      !legacyErrorBoundariesThatAlreadyFailed.has(error)))))
+                      !legacyErrorBoundariesThatAlreadyFailed.has(
+                        suspenseBoundary
+                      )))))
             )
               return (
-                (sourceFiber.flags |= 65536),
+                (value.flags |= 65536),
                 (rootRenderLanes &= -rootRenderLanes),
-                (sourceFiber.lanes |= rootRenderLanes),
+                (value.lanes |= rootRenderLanes),
                 (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
                 initializeClassErrorUpdate(
                   rootRenderLanes,
                   root,
-                  sourceFiber,
-                  value
+                  value,
+                  sourceFiber
                 ),
-                enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
+                enqueueCapturedUpdate(value, rootRenderLanes),
                 !1
               );
         }
-        sourceFiber = sourceFiber.return;
-      } while (null !== sourceFiber);
+        value = value.return;
+      } while (null !== value);
       return !1;
     }
     function reconcileChildren(
@@ -7931,7 +8416,6 @@
           "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
       } else propsWithoutRef = nextProps;
       prepareToReadContext(workInProgress);
-      markComponentRenderStarted(workInProgress);
       nextProps = renderWithHooks(
         current,
         workInProgress,
@@ -7941,7 +8425,6 @@
         renderLanes
       );
       key = checkDidRenderIdHook();
-      markComponentRenderStopped();
       if (null !== current && !didReceiveUpdate)
         return (
           bailoutHooks(current, workInProgress, renderLanes),
@@ -8187,7 +8670,6 @@
               componentName
             ))));
       prepareToReadContext(workInProgress);
-      markComponentRenderStarted(workInProgress);
       Component = renderWithHooks(
         current,
         workInProgress,
@@ -8197,7 +8679,6 @@
         renderLanes
       );
       nextProps = checkDidRenderIdHook();
-      markComponentRenderStopped();
       if (null !== current && !didReceiveUpdate)
         return (
           bailoutHooks(current, workInProgress, renderLanes),
@@ -8217,7 +8698,6 @@
       renderLanes
     ) {
       prepareToReadContext(workInProgress);
-      markComponentRenderStarted(workInProgress);
       hookTypesUpdateIndexDev = -1;
       ignorePreviousDependencies =
         null !== current && current.type !== workInProgress.type;
@@ -8230,7 +8710,6 @@
       );
       finishRenderingHooks(current, workInProgress);
       Component = checkDidRenderIdHook();
-      markComponentRenderStopped();
       if (null !== current && !didReceiveUpdate)
         return (
           bailoutHooks(current, workInProgress, renderLanes),
@@ -8746,18 +9225,16 @@
         current = workInProgress;
         if (state && "function" !== typeof Component.getDerivedStateFromError)
           (Component = null), (profilerStartTime = -1);
-        else {
-          markComponentRenderStarted(workInProgress);
-          Component = callRenderInDEV(lane);
-          if (workInProgress.mode & StrictLegacyMode) {
-            setIsStrictModeForDevtools(!0);
-            try {
-              callRenderInDEV(lane);
-            } finally {
-              setIsStrictModeForDevtools(!1);
-            }
+        else if (
+          ((Component = callRenderInDEV(lane)),
+          workInProgress.mode & StrictLegacyMode)
+        ) {
+          setIsStrictModeForDevtools(!0);
+          try {
+            callRenderInDEV(lane);
+          } finally {
+            setIsStrictModeForDevtools(!1);
           }
-          markComponentRenderStopped();
         }
         workInProgress.flags |= 1;
         null !== current$jscomp$0 && state
@@ -8848,32 +9325,33 @@
       return current;
     }
     function updateSuspenseComponent(current, workInProgress, renderLanes) {
-      var JSCompiler_object_inline_digest_2388;
-      var JSCompiler_object_inline_stack_2389 = workInProgress.pendingProps;
+      var JSCompiler_object_inline_componentStack_2552;
+      var JSCompiler_object_inline_stack_2551 = workInProgress.pendingProps;
       shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);
-      var JSCompiler_object_inline_componentStack_2390 = !1;
+      var JSCompiler_object_inline_message_2549 = !1;
       var didSuspend = 0 !== (workInProgress.flags & 128);
-      (JSCompiler_object_inline_digest_2388 = didSuspend) ||
-        (JSCompiler_object_inline_digest_2388 =
+      (JSCompiler_object_inline_componentStack_2552 = didSuspend) ||
+        (JSCompiler_object_inline_componentStack_2552 =
           null !== current && null === current.memoizedState
             ? !1
             : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
-      JSCompiler_object_inline_digest_2388 &&
-        ((JSCompiler_object_inline_componentStack_2390 = !0),
+      JSCompiler_object_inline_componentStack_2552 &&
+        ((JSCompiler_object_inline_message_2549 = !0),
         (workInProgress.flags &= -129));
-      JSCompiler_object_inline_digest_2388 = 0 !== (workInProgress.flags & 32);
+      JSCompiler_object_inline_componentStack_2552 =
+        0 !== (workInProgress.flags & 32);
       workInProgress.flags &= -33;
       if (null === current) {
         if (isHydrating) {
-          JSCompiler_object_inline_componentStack_2390
+          JSCompiler_object_inline_message_2549
             ? pushPrimaryTreeSuspenseHandler(workInProgress)
             : reuseSuspenseHandlerOnStack(workInProgress);
           if (isHydrating) {
-            var JSCompiler_object_inline_message_2387 = nextHydratableInstance;
+            var JSCompiler_object_inline_digest_2550 = nextHydratableInstance;
             var JSCompiler_temp;
-            if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2387)) {
+            if (!(JSCompiler_temp = !JSCompiler_object_inline_digest_2550)) {
               c: {
-                var instance = JSCompiler_object_inline_message_2387;
+                var instance = JSCompiler_object_inline_digest_2550;
                 for (
                   JSCompiler_temp = rootOrSingletonContext;
                   8 !== instance.nodeType;
@@ -8915,77 +9393,87 @@
             JSCompiler_temp &&
               (warnNonHydratedInstance(
                 workInProgress,
-                JSCompiler_object_inline_message_2387
+                JSCompiler_object_inline_digest_2550
               ),
               throwOnHydrationMismatch(workInProgress));
           }
-          JSCompiler_object_inline_message_2387 = workInProgress.memoizedState;
+          JSCompiler_object_inline_digest_2550 = workInProgress.memoizedState;
           if (
-            null !== JSCompiler_object_inline_message_2387 &&
-            ((JSCompiler_object_inline_message_2387 =
-              JSCompiler_object_inline_message_2387.dehydrated),
-            null !== JSCompiler_object_inline_message_2387)
+            null !== JSCompiler_object_inline_digest_2550 &&
+            ((JSCompiler_object_inline_digest_2550 =
+              JSCompiler_object_inline_digest_2550.dehydrated),
+            null !== JSCompiler_object_inline_digest_2550)
           )
             return (
-              isSuspenseInstanceFallback(JSCompiler_object_inline_message_2387)
+              isSuspenseInstanceFallback(JSCompiler_object_inline_digest_2550)
                 ? (workInProgress.lanes = 32)
                 : (workInProgress.lanes = 536870912),
               null
             );
           popSuspenseHandler(workInProgress);
         }
-        JSCompiler_object_inline_message_2387 =
-          JSCompiler_object_inline_stack_2389.children;
-        JSCompiler_object_inline_stack_2389 =
-          JSCompiler_object_inline_stack_2389.fallback;
-        if (JSCompiler_object_inline_componentStack_2390)
+        JSCompiler_object_inline_digest_2550 =
+          JSCompiler_object_inline_stack_2551.children;
+        JSCompiler_temp = JSCompiler_object_inline_stack_2551.fallback;
+        if (JSCompiler_object_inline_message_2549)
           return (
             reuseSuspenseHandlerOnStack(workInProgress),
-            (JSCompiler_object_inline_componentStack_2390 =
-              workInProgress.mode),
-            (JSCompiler_object_inline_message_2387 =
-              mountWorkInProgressOffscreenFiber(
-                {
-                  mode: "hidden",
-                  children: JSCompiler_object_inline_message_2387
-                },
-                JSCompiler_object_inline_componentStack_2390
+            (JSCompiler_object_inline_stack_2551 =
+              mountSuspenseFallbackChildren(
+                workInProgress,
+                JSCompiler_object_inline_digest_2550,
+                JSCompiler_temp,
+                renderLanes
               )),
-            (JSCompiler_object_inline_stack_2389 = createFiberFromFragment(
-              JSCompiler_object_inline_stack_2389,
-              JSCompiler_object_inline_componentStack_2390,
-              renderLanes,
-              null
-            )),
-            (JSCompiler_object_inline_message_2387.return = workInProgress),
-            (JSCompiler_object_inline_stack_2389.return = workInProgress),
-            (JSCompiler_object_inline_message_2387.sibling =
-              JSCompiler_object_inline_stack_2389),
-            (workInProgress.child = JSCompiler_object_inline_message_2387),
-            (JSCompiler_object_inline_componentStack_2390 =
-              workInProgress.child),
-            (JSCompiler_object_inline_componentStack_2390.memoizedState =
+            (JSCompiler_object_inline_message_2549 = workInProgress.child),
+            (JSCompiler_object_inline_message_2549.memoizedState =
+              mountSuspenseOffscreenState(renderLanes)),
+            (JSCompiler_object_inline_message_2549.childLanes =
+              getRemainingWorkInPrimaryTree(
+                current,
+                JSCompiler_object_inline_componentStack_2552,
+                renderLanes
+              )),
+            (workInProgress.memoizedState = SUSPENDED_MARKER),
+            JSCompiler_object_inline_stack_2551
+          );
+        if (
+          "number" ===
+          typeof JSCompiler_object_inline_stack_2551.unstable_expectedLoadTime
+        )
+          return (
+            reuseSuspenseHandlerOnStack(workInProgress),
+            (JSCompiler_object_inline_stack_2551 =
+              mountSuspenseFallbackChildren(
+                workInProgress,
+                JSCompiler_object_inline_digest_2550,
+                JSCompiler_temp,
+                renderLanes
+              )),
+            (JSCompiler_object_inline_message_2549 = workInProgress.child),
+            (JSCompiler_object_inline_message_2549.memoizedState =
               mountSuspenseOffscreenState(renderLanes)),
-            (JSCompiler_object_inline_componentStack_2390.childLanes =
+            (JSCompiler_object_inline_message_2549.childLanes =
               getRemainingWorkInPrimaryTree(
                 current,
-                JSCompiler_object_inline_digest_2388,
+                JSCompiler_object_inline_componentStack_2552,
                 renderLanes
               )),
             (workInProgress.memoizedState = SUSPENDED_MARKER),
-            JSCompiler_object_inline_stack_2389
+            (workInProgress.lanes = 4194304),
+            JSCompiler_object_inline_stack_2551
           );
         pushPrimaryTreeSuspenseHandler(workInProgress);
         return mountSuspensePrimaryChildren(
           workInProgress,
-          JSCompiler_object_inline_message_2387
+          JSCompiler_object_inline_digest_2550
         );
       }
       var prevState = current.memoizedState;
       if (
         null !== prevState &&
-        ((JSCompiler_object_inline_message_2387 = prevState.dehydrated),
-        null !== JSCompiler_object_inline_message_2387)
+        ((JSCompiler_object_inline_digest_2550 = prevState.dehydrated),
+        null !== JSCompiler_object_inline_digest_2550)
       ) {
         if (didSuspend)
           workInProgress.flags & 256
@@ -9002,94 +9490,94 @@
                 (workInProgress.flags |= 128),
                 (workInProgress = null))
               : (reuseSuspenseHandlerOnStack(workInProgress),
-                (JSCompiler_object_inline_componentStack_2390 =
-                  JSCompiler_object_inline_stack_2389.fallback),
-                (JSCompiler_object_inline_message_2387 = workInProgress.mode),
-                (JSCompiler_object_inline_stack_2389 =
+                (JSCompiler_object_inline_message_2549 =
+                  JSCompiler_object_inline_stack_2551.fallback),
+                (JSCompiler_object_inline_digest_2550 = workInProgress.mode),
+                (JSCompiler_object_inline_stack_2551 =
                   mountWorkInProgressOffscreenFiber(
                     {
                       mode: "visible",
-                      children: JSCompiler_object_inline_stack_2389.children
+                      children: JSCompiler_object_inline_stack_2551.children
                     },
-                    JSCompiler_object_inline_message_2387
+                    JSCompiler_object_inline_digest_2550
                   )),
-                (JSCompiler_object_inline_componentStack_2390 =
+                (JSCompiler_object_inline_message_2549 =
                   createFiberFromFragment(
-                    JSCompiler_object_inline_componentStack_2390,
-                    JSCompiler_object_inline_message_2387,
+                    JSCompiler_object_inline_message_2549,
+                    JSCompiler_object_inline_digest_2550,
                     renderLanes,
                     null
                   )),
-                (JSCompiler_object_inline_componentStack_2390.flags |= 2),
-                (JSCompiler_object_inline_stack_2389.return = workInProgress),
-                (JSCompiler_object_inline_componentStack_2390.return =
-                  workInProgress),
-                (JSCompiler_object_inline_stack_2389.sibling =
-                  JSCompiler_object_inline_componentStack_2390),
-                (workInProgress.child = JSCompiler_object_inline_stack_2389),
+                (JSCompiler_object_inline_message_2549.flags |= 2),
+                (JSCompiler_object_inline_stack_2551.return = workInProgress),
+                (JSCompiler_object_inline_message_2549.return = workInProgress),
+                (JSCompiler_object_inline_stack_2551.sibling =
+                  JSCompiler_object_inline_message_2549),
+                (workInProgress.child = JSCompiler_object_inline_stack_2551),
                 reconcileChildFibers(
                   workInProgress,
                   current.child,
                   null,
                   renderLanes
                 ),
-                (JSCompiler_object_inline_stack_2389 = workInProgress.child),
-                (JSCompiler_object_inline_stack_2389.memoizedState =
+                (JSCompiler_object_inline_stack_2551 = workInProgress.child),
+                (JSCompiler_object_inline_stack_2551.memoizedState =
                   mountSuspenseOffscreenState(renderLanes)),
-                (JSCompiler_object_inline_stack_2389.childLanes =
+                (JSCompiler_object_inline_stack_2551.childLanes =
                   getRemainingWorkInPrimaryTree(
                     current,
-                    JSCompiler_object_inline_digest_2388,
+                    JSCompiler_object_inline_componentStack_2552,
                     renderLanes
                   )),
                 (workInProgress.memoizedState = SUSPENDED_MARKER),
-                (workInProgress =
-                  JSCompiler_object_inline_componentStack_2390));
+                (workInProgress = JSCompiler_object_inline_message_2549));
         else if (
           (pushPrimaryTreeSuspenseHandler(workInProgress),
           isHydrating &&
             console.error(
               "We should not be hydrating here. This is a bug in React. Please file a bug."
             ),
-          isSuspenseInstanceFallback(JSCompiler_object_inline_message_2387))
+          isSuspenseInstanceFallback(JSCompiler_object_inline_digest_2550))
         ) {
-          JSCompiler_object_inline_digest_2388 =
-            JSCompiler_object_inline_message_2387.nextSibling &&
-            JSCompiler_object_inline_message_2387.nextSibling.dataset;
-          if (JSCompiler_object_inline_digest_2388) {
-            JSCompiler_temp = JSCompiler_object_inline_digest_2388.dgst;
-            var message = JSCompiler_object_inline_digest_2388.msg;
-            instance = JSCompiler_object_inline_digest_2388.stck;
-            var componentStack = JSCompiler_object_inline_digest_2388.cstck;
+          JSCompiler_object_inline_componentStack_2552 =
+            JSCompiler_object_inline_digest_2550.nextSibling &&
+            JSCompiler_object_inline_digest_2550.nextSibling.dataset;
+          if (JSCompiler_object_inline_componentStack_2552) {
+            JSCompiler_temp = JSCompiler_object_inline_componentStack_2552.dgst;
+            var message = JSCompiler_object_inline_componentStack_2552.msg;
+            instance = JSCompiler_object_inline_componentStack_2552.stck;
+            var componentStack =
+              JSCompiler_object_inline_componentStack_2552.cstck;
           }
-          JSCompiler_object_inline_message_2387 = message;
-          JSCompiler_object_inline_digest_2388 = JSCompiler_temp;
-          JSCompiler_object_inline_stack_2389 = instance;
-          JSCompiler_temp = JSCompiler_object_inline_componentStack_2390 =
+          JSCompiler_object_inline_message_2549 = message;
+          JSCompiler_object_inline_digest_2550 = JSCompiler_temp;
+          JSCompiler_object_inline_stack_2551 = instance;
+          JSCompiler_temp = JSCompiler_object_inline_componentStack_2552 =
             componentStack;
-          JSCompiler_object_inline_componentStack_2390 =
-            JSCompiler_object_inline_message_2387
-              ? Error(JSCompiler_object_inline_message_2387)
-              : Error(
-                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
-                );
-          JSCompiler_object_inline_componentStack_2390.stack =
-            JSCompiler_object_inline_stack_2389 || "";
-          JSCompiler_object_inline_componentStack_2390.digest =
-            JSCompiler_object_inline_digest_2388;
-          JSCompiler_object_inline_digest_2388 =
-            void 0 === JSCompiler_temp ? null : JSCompiler_temp;
-          JSCompiler_object_inline_stack_2389 = {
-            value: JSCompiler_object_inline_componentStack_2390,
-            source: null,
-            stack: JSCompiler_object_inline_digest_2388
-          };
-          "string" === typeof JSCompiler_object_inline_digest_2388 &&
-            CapturedStacks.set(
-              JSCompiler_object_inline_componentStack_2390,
-              JSCompiler_object_inline_stack_2389
-            );
-          queueHydrationError(JSCompiler_object_inline_stack_2389);
+          "POSTPONE" !== JSCompiler_object_inline_digest_2550 &&
+            ((JSCompiler_object_inline_componentStack_2552 =
+              JSCompiler_object_inline_message_2549
+                ? Error(JSCompiler_object_inline_message_2549)
+                : Error(
+                    "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
+                  )),
+            (JSCompiler_object_inline_componentStack_2552.stack =
+              JSCompiler_object_inline_stack_2551 || ""),
+            (JSCompiler_object_inline_componentStack_2552.digest =
+              JSCompiler_object_inline_digest_2550),
+            (JSCompiler_object_inline_stack_2551 =
+              void 0 === JSCompiler_temp ? null : JSCompiler_temp),
+            (JSCompiler_object_inline_message_2549 = {
+              value: JSCompiler_object_inline_componentStack_2552,
+              source: null,
+              stack: JSCompiler_object_inline_stack_2551
+            }),
+            "string" === typeof JSCompiler_object_inline_stack_2551 &&
+              CapturedStacks.set(
+                JSCompiler_object_inline_componentStack_2552,
+                JSCompiler_object_inline_message_2549
+              ),
+            queueHydrationError(JSCompiler_object_inline_message_2549));
           workInProgress = retrySuspenseComponentWithoutHydrating(
             current,
             workInProgress,
@@ -9103,44 +9591,44 @@
               renderLanes,
               !1
             ),
-          (JSCompiler_object_inline_digest_2388 =
+          (JSCompiler_object_inline_componentStack_2552 =
             0 !== (renderLanes & current.childLanes)),
-          didReceiveUpdate || JSCompiler_object_inline_digest_2388)
+          didReceiveUpdate || JSCompiler_object_inline_componentStack_2552)
         ) {
-          JSCompiler_object_inline_digest_2388 = workInProgressRoot;
+          JSCompiler_object_inline_componentStack_2552 = workInProgressRoot;
           if (
-            null !== JSCompiler_object_inline_digest_2388 &&
-            ((JSCompiler_object_inline_stack_2389 = renderLanes & -renderLanes),
-            (JSCompiler_object_inline_stack_2389 =
-              0 !== (JSCompiler_object_inline_stack_2389 & 42)
+            null !== JSCompiler_object_inline_componentStack_2552 &&
+            ((JSCompiler_object_inline_stack_2551 = renderLanes & -renderLanes),
+            (JSCompiler_object_inline_stack_2551 =
+              0 !== (JSCompiler_object_inline_stack_2551 & 42)
                 ? 1
                 : getBumpedLaneForHydrationByLane(
-                    JSCompiler_object_inline_stack_2389
+                    JSCompiler_object_inline_stack_2551
                   )),
-            (JSCompiler_object_inline_stack_2389 =
+            (JSCompiler_object_inline_stack_2551 =
               0 !==
-              (JSCompiler_object_inline_stack_2389 &
-                (JSCompiler_object_inline_digest_2388.suspendedLanes |
+              (JSCompiler_object_inline_stack_2551 &
+                (JSCompiler_object_inline_componentStack_2552.suspendedLanes |
                   renderLanes))
                 ? 0
-                : JSCompiler_object_inline_stack_2389),
-            0 !== JSCompiler_object_inline_stack_2389 &&
-              JSCompiler_object_inline_stack_2389 !== prevState.retryLane)
+                : JSCompiler_object_inline_stack_2551),
+            0 !== JSCompiler_object_inline_stack_2551 &&
+              JSCompiler_object_inline_stack_2551 !== prevState.retryLane)
           )
             throw (
-              ((prevState.retryLane = JSCompiler_object_inline_stack_2389),
+              ((prevState.retryLane = JSCompiler_object_inline_stack_2551),
               enqueueConcurrentRenderForLane(
                 current,
-                JSCompiler_object_inline_stack_2389
+                JSCompiler_object_inline_stack_2551
               ),
               scheduleUpdateOnFiber(
-                JSCompiler_object_inline_digest_2388,
+                JSCompiler_object_inline_componentStack_2552,
                 current,
-                JSCompiler_object_inline_stack_2389
+                JSCompiler_object_inline_stack_2551
               ),
               SelectiveHydrationException)
             );
-          JSCompiler_object_inline_message_2387.data ===
+          JSCompiler_object_inline_digest_2550.data ===
             SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
           workInProgress = retrySuspenseComponentWithoutHydrating(
             current,
@@ -9148,14 +9636,14 @@
             renderLanes
           );
         } else
-          JSCompiler_object_inline_message_2387.data ===
+          JSCompiler_object_inline_digest_2550.data ===
           SUSPENSE_PENDING_START_DATA
             ? ((workInProgress.flags |= 192),
               (workInProgress.child = current.child),
               (workInProgress = null))
             : ((current = prevState.treeContext),
               (nextHydratableInstance = getNextHydratable(
-                JSCompiler_object_inline_message_2387.nextSibling
+                JSCompiler_object_inline_digest_2550.nextSibling
               )),
               (hydrationParentFiber = workInProgress),
               (isHydrating = !0),
@@ -9173,57 +9661,54 @@
                 (treeContextProvider = workInProgress)),
               (workInProgress = mountSuspensePrimaryChildren(
                 workInProgress,
-                JSCompiler_object_inline_stack_2389.children
+                JSCompiler_object_inline_stack_2551.children
               )),
               (workInProgress.flags |= 4096));
         return workInProgress;
       }
-      if (JSCompiler_object_inline_componentStack_2390)
+      if (JSCompiler_object_inline_message_2549)
         return (
           reuseSuspenseHandlerOnStack(workInProgress),
-          (JSCompiler_object_inline_componentStack_2390 =
-            JSCompiler_object_inline_stack_2389.fallback),
-          (JSCompiler_object_inline_message_2387 = workInProgress.mode),
+          (JSCompiler_object_inline_message_2549 =
+            JSCompiler_object_inline_stack_2551.fallback),
+          (JSCompiler_object_inline_digest_2550 = workInProgress.mode),
           (JSCompiler_temp = current.child),
           (instance = JSCompiler_temp.sibling),
-          (JSCompiler_object_inline_stack_2389 = createWorkInProgress(
+          (JSCompiler_object_inline_stack_2551 = createWorkInProgress(
             JSCompiler_temp,
             {
               mode: "hidden",
-              children: JSCompiler_object_inline_stack_2389.children
+              children: JSCompiler_object_inline_stack_2551.children
             }
           )),
-          (JSCompiler_object_inline_stack_2389.subtreeFlags =
+          (JSCompiler_object_inline_stack_2551.subtreeFlags =
             JSCompiler_temp.subtreeFlags & 65011712),
           null !== instance
-            ? (JSCompiler_object_inline_componentStack_2390 =
-                createWorkInProgress(
-                  instance,
-                  JSCompiler_object_inline_componentStack_2390
-                ))
-            : ((JSCompiler_object_inline_componentStack_2390 =
-                createFiberFromFragment(
-                  JSCompiler_object_inline_componentStack_2390,
-                  JSCompiler_object_inline_message_2387,
-                  renderLanes,
-                  null
-                )),
-              (JSCompiler_object_inline_componentStack_2390.flags |= 2)),
-          (JSCompiler_object_inline_componentStack_2390.return =
-            workInProgress),
-          (JSCompiler_object_inline_stack_2389.return = workInProgress),
-          (JSCompiler_object_inline_stack_2389.sibling =
-            JSCompiler_object_inline_componentStack_2390),
-          (workInProgress.child = JSCompiler_object_inline_stack_2389),
-          (JSCompiler_object_inline_stack_2389 =
-            JSCompiler_object_inline_componentStack_2390),
-          (JSCompiler_object_inline_componentStack_2390 = workInProgress.child),
-          (JSCompiler_object_inline_message_2387 = current.child.memoizedState),
-          null === JSCompiler_object_inline_message_2387
-            ? (JSCompiler_object_inline_message_2387 =
+            ? (JSCompiler_object_inline_message_2549 = createWorkInProgress(
+                instance,
+                JSCompiler_object_inline_message_2549
+              ))
+            : ((JSCompiler_object_inline_message_2549 = createFiberFromFragment(
+                JSCompiler_object_inline_message_2549,
+                JSCompiler_object_inline_digest_2550,
+                renderLanes,
+                null
+              )),
+              (JSCompiler_object_inline_message_2549.flags |= 2)),
+          (JSCompiler_object_inline_message_2549.return = workInProgress),
+          (JSCompiler_object_inline_stack_2551.return = workInProgress),
+          (JSCompiler_object_inline_stack_2551.sibling =
+            JSCompiler_object_inline_message_2549),
+          (workInProgress.child = JSCompiler_object_inline_stack_2551),
+          (JSCompiler_object_inline_stack_2551 =
+            JSCompiler_object_inline_message_2549),
+          (JSCompiler_object_inline_message_2549 = workInProgress.child),
+          (JSCompiler_object_inline_digest_2550 = current.child.memoizedState),
+          null === JSCompiler_object_inline_digest_2550
+            ? (JSCompiler_object_inline_digest_2550 =
                 mountSuspenseOffscreenState(renderLanes))
             : ((JSCompiler_temp =
-                JSCompiler_object_inline_message_2387.cachePool),
+                JSCompiler_object_inline_digest_2550.cachePool),
               null !== JSCompiler_temp
                 ? ((instance = CacheContext._currentValue),
                   (JSCompiler_temp =
@@ -9231,37 +9716,38 @@
                       ? { parent: instance, pool: instance }
                       : JSCompiler_temp))
                 : (JSCompiler_temp = getSuspendedCache()),
-              (JSCompiler_object_inline_message_2387 = {
+              (JSCompiler_object_inline_digest_2550 = {
                 baseLanes:
-                  JSCompiler_object_inline_message_2387.baseLanes | renderLanes,
+                  JSCompiler_object_inline_digest_2550.baseLanes | renderLanes,
                 cachePool: JSCompiler_temp
               })),
-          (JSCompiler_object_inline_componentStack_2390.memoizedState =
-            JSCompiler_object_inline_message_2387),
-          (JSCompiler_object_inline_componentStack_2390.childLanes =
+          (JSCompiler_object_inline_message_2549.memoizedState =
+            JSCompiler_object_inline_digest_2550),
+          (JSCompiler_object_inline_message_2549.childLanes =
             getRemainingWorkInPrimaryTree(
               current,
-              JSCompiler_object_inline_digest_2388,
+              JSCompiler_object_inline_componentStack_2552,
               renderLanes
             )),
           (workInProgress.memoizedState = SUSPENDED_MARKER),
-          JSCompiler_object_inline_stack_2389
+          JSCompiler_object_inline_stack_2551
         );
       pushPrimaryTreeSuspenseHandler(workInProgress);
       renderLanes = current.child;
       current = renderLanes.sibling;
       renderLanes = createWorkInProgress(renderLanes, {
         mode: "visible",
-        children: JSCompiler_object_inline_stack_2389.children
+        children: JSCompiler_object_inline_stack_2551.children
       });
       renderLanes.return = workInProgress;
       renderLanes.sibling = null;
       null !== current &&
-        ((JSCompiler_object_inline_digest_2388 = workInProgress.deletions),
-        null === JSCompiler_object_inline_digest_2388
+        ((JSCompiler_object_inline_componentStack_2552 =
+          workInProgress.deletions),
+        null === JSCompiler_object_inline_componentStack_2552
           ? ((workInProgress.deletions = [current]),
             (workInProgress.flags |= 16))
-          : JSCompiler_object_inline_digest_2388.push(current));
+          : JSCompiler_object_inline_componentStack_2552.push(current));
       workInProgress.child = renderLanes;
       workInProgress.memoizedState = null;
       return renderLanes;
@@ -9274,6 +9760,29 @@
       primaryChildren.return = workInProgress;
       return (workInProgress.child = primaryChildren);
     }
+    function mountSuspenseFallbackChildren(
+      workInProgress,
+      primaryChildren,
+      fallbackChildren,
+      renderLanes
+    ) {
+      var mode = workInProgress.mode;
+      primaryChildren = mountWorkInProgressOffscreenFiber(
+        { mode: "hidden", children: primaryChildren },
+        mode
+      );
+      fallbackChildren = createFiberFromFragment(
+        fallbackChildren,
+        mode,
+        renderLanes,
+        null
+      );
+      primaryChildren.return = workInProgress;
+      fallbackChildren.return = workInProgress;
+      primaryChildren.sibling = fallbackChildren;
+      workInProgress.child = primaryChildren;
+      return fallbackChildren;
+    }
     function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
       return createFiberFromOffscreen(offscreenProps, mode, 0, null);
     }
@@ -9674,6 +10183,8 @@
           workInProgress.mode,
           workInProgress.lanes
         );
+        renderLanes._debugStack = workInProgress._debugStack;
+        renderLanes._debugTask = workInProgress._debugTask;
         var returnFiber = workInProgress.return;
         if (null === returnFiber) throw Error("Cannot swap the root fiber.");
         current.alternate = null;
@@ -10000,21 +10511,28 @@
               (nextHydratableInstance = getNextHydratable(
                 prevSibling.firstChild
               ))),
-            reconcileChildren(
-              current,
-              workInProgress,
-              workInProgress.pendingProps.children,
-              renderLanes
-            ),
-            markRef(current, workInProgress),
-            null === current && (workInProgress.flags |= 4194304),
-            workInProgress.child
-          );
-        case 5:
-          return (
-            null === current &&
-              isHydrating &&
-              ((nextProps = getHostContext()),
+            (returnFiber = workInProgress.pendingProps.children),
+            null !== current || isHydrating
+              ? reconcileChildren(
+                  current,
+                  workInProgress,
+                  returnFiber,
+                  renderLanes
+                )
+              : (workInProgress.child = reconcileChildFibers(
+                  workInProgress,
+                  null,
+                  returnFiber,
+                  renderLanes
+                )),
+            markRef(current, workInProgress),
+            workInProgress.child
+          );
+        case 5:
+          return (
+            null === current &&
+              isHydrating &&
+              ((nextProps = getHostContext()),
               (returnFiber = validateDOMNesting(
                 workInProgress.type,
                 nextProps.ancestorInfo
@@ -10207,13 +10725,11 @@
               ),
             prepareToReadContext(workInProgress),
             (prevSibling = readContext(prevSibling)),
-            markComponentRenderStarted(workInProgress),
             (returnFiber = callComponentInDEV(
               returnFiber,
               prevSibling,
               void 0
             )),
-            markComponentRenderStopped(),
             (workInProgress.flags |= 1),
             reconcileChildren(
               current,
@@ -10301,6 +10817,39 @@
             ),
             workInProgress.child
           );
+        case 30:
+          return (
+            (returnFiber = workInProgress.pendingProps),
+            (prevSibling = workInProgress.stateNode),
+            null != returnFiber.name && "auto" !== returnFiber.name
+              ? ((workInProgress.flags |= 2097152),
+                null === current &&
+                  trackAppearingViewTransition(prevSibling, returnFiber.name))
+              : null === prevSibling.autoName &&
+                ((nextProps = workInProgressRoot.identifierPrefix),
+                isHydrating
+                  ? ((nextState = getTreeId()),
+                    (nextProps =
+                      "\u00ab" + nextProps + "T" + nextState + "\u00bb"))
+                  : ((nextState = globalClientIdCounter++),
+                    (nextProps =
+                      "\u00ab" +
+                      nextProps +
+                      "t" +
+                      nextState.toString(32) +
+                      "\u00bb")),
+                (prevSibling.autoName = nextProps)),
+            null !== current && current.memoizedProps.name !== returnFiber.name
+              ? (workInProgress.flags |= 4194816)
+              : markRef(current, workInProgress),
+            reconcileChildren(
+              current,
+              workInProgress,
+              returnFiber.children,
+              renderLanes
+            ),
+            workInProgress.child
+          );
         case 29:
           throw workInProgress.pendingProps;
       }
@@ -10349,21 +10898,7 @@
           do {
             if (
               (updateQueue.tag & flags) === flags &&
-              ((flags & Passive) !== NoFlags
-                ? null !== injectedProfilingHooks &&
-                  "function" ===
-                    typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted &&
-                  injectedProfilingHooks.markComponentPassiveEffectMountStarted(
-                    finishedWork
-                  )
-                : (flags & Layout) !== NoFlags &&
-                  null !== injectedProfilingHooks &&
-                  "function" ===
-                    typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted &&
-                  injectedProfilingHooks.markComponentLayoutEffectMountStarted(
-                    finishedWork
-                  ),
-              (lastEffect = void 0),
+              ((lastEffect = void 0),
               (flags & Insertion) !== NoFlags &&
                 (isRunningInsertionEffect = !0),
               (lastEffect = runWithFiberInDEV(
@@ -10373,16 +10908,6 @@
               )),
               (flags & Insertion) !== NoFlags &&
                 (isRunningInsertionEffect = !1),
-              (flags & Passive) !== NoFlags
-                ? null !== injectedProfilingHooks &&
-                  "function" ===
-                    typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped &&
-                  injectedProfilingHooks.markComponentPassiveEffectMountStopped()
-                : (flags & Layout) !== NoFlags &&
-                  null !== injectedProfilingHooks &&
-                  "function" ===
-                    typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped &&
-                  injectedProfilingHooks.markComponentLayoutEffectMountStopped(),
               void 0 !== lastEffect && "function" !== typeof lastEffect)
             ) {
               var hookName = void 0;
@@ -10440,20 +10965,6 @@
                 destroy = inst.destroy;
               void 0 !== destroy &&
                 ((inst.destroy = void 0),
-                (flags & Passive) !== NoFlags
-                  ? null !== injectedProfilingHooks &&
-                    "function" ===
-                      typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted &&
-                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
-                      finishedWork
-                    )
-                  : (flags & Layout) !== NoFlags &&
-                    null !== injectedProfilingHooks &&
-                    "function" ===
-                      typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted &&
-                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
-                      finishedWork
-                    ),
                 (flags & Insertion) !== NoFlags &&
                   (isRunningInsertionEffect = !0),
                 runWithFiberInDEV(
@@ -10464,17 +10975,7 @@
                   destroy
                 ),
                 (flags & Insertion) !== NoFlags &&
-                  (isRunningInsertionEffect = !1),
-                (flags & Passive) !== NoFlags
-                  ? null !== injectedProfilingHooks &&
-                    "function" ===
-                      typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped &&
-                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped()
-                  : (flags & Layout) !== NoFlags &&
-                    null !== injectedProfilingHooks &&
-                    "function" ===
-                      typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped &&
-                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
+                  (isRunningInsertionEffect = !1));
             }
             updateQueue = updateQueue.next;
           } while (updateQueue !== firstEffect);
@@ -10623,6 +11124,16 @@
           case 5:
             var instanceToUse = finishedWork.stateNode;
             break;
+          case 30:
+            instanceToUse = finishedWork.stateNode;
+            var name = getViewTransitionName(
+              finishedWork.memoizedProps,
+              instanceToUse
+            );
+            if (null === instanceToUse.ref || instanceToUse.ref.name !== name)
+              instanceToUse.ref = createViewTransitionInstance(name);
+            instanceToUse = instanceToUse.ref;
+            break;
           default:
             instanceToUse = finishedWork.stateNode;
         }
@@ -10772,7 +11283,7 @@
         5 === fiber.tag ||
         3 === fiber.tag ||
         26 === fiber.tag ||
-        (27 === fiber.tag && "head" === fiber.type) ||
+        27 === fiber.tag ||
         4 === fiber.tag
       );
     }
@@ -10785,10 +11296,12 @@
         fiber.sibling.return = fiber.return;
         for (
           fiber = fiber.sibling;
-          5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;
+          5 !== fiber.tag &&
+          6 !== fiber.tag &&
+          27 !== fiber.tag &&
+          18 !== fiber.tag;
 
         ) {
-          if (27 === fiber.tag && "head" === fiber.type) continue a;
           if (fiber.flags & 2) continue a;
           if (null === fiber.child || 4 === fiber.tag) continue a;
           else (fiber.child.return = fiber), (fiber = fiber.child);
@@ -10799,47 +11312,21 @@
     function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
       var tag = node.tag;
       if (5 === tag || 6 === tag)
-        if (((node = node.stateNode), before)) {
-          switch (parent.nodeType) {
-            case 8:
-              parent = parent.parentNode;
-              break;
-            case 9:
-              parent = parent.body;
-              break;
-            default:
-              parent =
-                "HTML" === parent.nodeName ? parent.ownerDocument.body : parent;
-          }
-          parent.insertBefore(node, before);
-        } else
-          a: {
-            switch (parent.nodeType) {
-              case 8:
-                before = parent.parentNode;
-                before.insertBefore(node, parent);
-                break a;
-              case 9:
-                before = parent.body;
-                break;
-              default:
-                before =
-                  "HTML" === parent.nodeName
-                    ? parent.ownerDocument.body
-                    : parent;
-            }
-            before.appendChild(node);
-            parent = parent._reactRootContainer;
-            (null !== parent && void 0 !== parent) ||
-              null !== before.onclick ||
-              (before.onclick = noop$1);
-          }
-      else if (
-        4 !== tag &&
-        (27 === tag && "head" === node.type && (parent = node.stateNode),
-        (node = node.child),
-        null !== node)
-      )
+        (node = node.stateNode),
+          before
+            ? 8 === parent.nodeType
+              ? parent.parentNode.insertBefore(node, before)
+              : parent.insertBefore(node, before)
+            : (8 === parent.nodeType
+                ? ((before = parent.parentNode),
+                  before.insertBefore(node, parent))
+                : ((before = parent), before.appendChild(node)),
+              (parent = parent._reactRootContainer),
+              (null !== parent && void 0 !== parent) ||
+                null !== before.onclick ||
+                (before.onclick = noop$1)),
+          (viewTransitionMutationContext = !0);
+      else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
         for (
           insertOrAppendPlacementNodeIntoContainer(node, before, parent),
             node = node.sibling;
@@ -10853,13 +11340,9 @@
       var tag = node.tag;
       if (5 === tag || 6 === tag)
         (node = node.stateNode),
-          before ? parent.insertBefore(node, before) : parent.appendChild(node);
-      else if (
-        4 !== tag &&
-        (27 === tag && "head" === node.type && (parent = node.stateNode),
-        (node = node.child),
-        null !== node)
-      )
+          before ? parent.insertBefore(node, before) : parent.appendChild(node),
+          (viewTransitionMutationContext = !0);
+      else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
         for (
           insertOrAppendPlacementNode(node, before, parent),
             node = node.sibling;
@@ -10870,64 +11353,55 @@
             (node = node.sibling);
     }
     function commitPlacement(finishedWork) {
-      a: {
-        for (var parent = finishedWork.return; null !== parent; ) {
-          if (isHostParent(parent)) {
-            var parentFiber = parent;
-            break a;
+      if (27 !== finishedWork.tag) {
+        a: {
+          for (var parent = finishedWork.return; null !== parent; ) {
+            if (isHostParent(parent)) {
+              var parentFiber = parent;
+              break a;
+            }
+            parent = parent.return;
           }
-          parent = parent.return;
-        }
-        throw Error(
-          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
-        );
-      }
-      switch (parentFiber.tag) {
-        case 27:
-          parent = parentFiber.stateNode;
-          parentFiber = getHostSibling(finishedWork);
-          insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
-          break;
-        case 5:
-          parent = parentFiber.stateNode;
-          parentFiber.flags & 32 &&
-            (resetTextContent(parent), (parentFiber.flags &= -33));
-          parentFiber = getHostSibling(finishedWork);
-          insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
-          break;
-        case 3:
-        case 4:
-          parent = parentFiber.stateNode.containerInfo;
-          parentFiber = getHostSibling(finishedWork);
-          insertOrAppendPlacementNodeIntoContainer(
-            finishedWork,
-            parentFiber,
-            parent
-          );
-          break;
-        default:
           throw Error(
-            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
+            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
           );
+        }
+        switch (parentFiber.tag) {
+          case 27:
+            parent = parentFiber.stateNode;
+            parentFiber = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
+            break;
+          case 5:
+            parent = parentFiber.stateNode;
+            parentFiber.flags & 32 &&
+              (resetTextContent(parent), (parentFiber.flags &= -33));
+            parentFiber = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
+            break;
+          case 3:
+          case 4:
+            parent = parentFiber.stateNode.containerInfo;
+            parentFiber = getHostSibling(finishedWork);
+            insertOrAppendPlacementNodeIntoContainer(
+              finishedWork,
+              parentFiber,
+              parent
+            );
+            break;
+          default:
+            throw Error(
+              "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
+            );
+        }
       }
     }
-    function commitHostSingletonAcquisition(finishedWork) {
-      var singleton = finishedWork.stateNode,
-        props = finishedWork.memoizedProps;
-      try {
-        runWithFiberInDEV(
-          finishedWork,
-          acquireSingletonInstance,
-          finishedWork.type,
-          props,
-          singleton,
-          finishedWork
-        );
-      } catch (error) {
-        captureCommitPhaseError(finishedWork, finishedWork.return, error);
-      }
-    }
-    function commitBeforeMutationEffects(root, firstChild) {
+    function commitBeforeMutationEffects(
+      root,
+      firstChild,
+      committedLanes,
+      appearingViewTransitions
+    ) {
       root = root.containerInfo;
       eventsEnabled = _enabled;
       root = getActiveElementDeep(root);
@@ -11000,73 +11474,583 @@
         focusedElem: root,
         selectionRange: JSCompiler_temp
       };
-      _enabled = !1;
-      for (nextEffect = firstChild; null !== nextEffect; )
+      shouldStartViewTransition = _enabled = !1;
+      committedLanes = (committedLanes & 335544192) === committedLanes;
+      nextEffect = firstChild;
+      for (firstChild = committedLanes ? 9238 : 1028; null !== nextEffect; ) {
+        root = nextEffect;
         if (
-          ((firstChild = nextEffect),
-          (root = firstChild.child),
-          0 !== (firstChild.subtreeFlags & 1024) && null !== root)
+          committedLanes &&
+          ((JSCompiler_temp = root.deletions), null !== JSCompiler_temp)
         )
-          (root.return = firstChild), (nextEffect = root);
-        else
-          for (; null !== nextEffect; ) {
-            root = firstChild = nextEffect;
-            JSCompiler_temp = root.alternate;
-            anchorOffset = root.flags;
-            switch (root.tag) {
-              case 0:
-                break;
-              case 11:
-              case 15:
-                break;
-              case 1:
-                0 !== (anchorOffset & 1024) &&
-                  null !== JSCompiler_temp &&
-                  commitClassSnapshot(root, JSCompiler_temp);
-                break;
-              case 3:
-                if (0 !== (anchorOffset & 1024))
-                  if (
-                    ((root = root.stateNode.containerInfo),
-                    (JSCompiler_temp = root.nodeType),
-                    9 === JSCompiler_temp)
-                  )
-                    clearContainerSparingly(root);
-                  else if (1 === JSCompiler_temp)
-                    switch (root.nodeName) {
-                      case "HEAD":
-                      case "HTML":
-                      case "BODY":
-                        clearContainerSparingly(root);
-                        break;
-                      default:
-                        root.textContent = "";
-                    }
-                break;
-              case 5:
-              case 26:
-              case 27:
-              case 6:
-              case 4:
-              case 17:
-                break;
-              default:
-                if (0 !== (anchorOffset & 1024))
-                  throw Error(
-                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
+          for (
+            anchorOffset = 0;
+            anchorOffset < JSCompiler_temp.length;
+            anchorOffset++
+          )
+            committedLanes &&
+              commitExitViewTransitions(
+                JSCompiler_temp[anchorOffset],
+                appearingViewTransitions
+              );
+        if (null === root.alternate && 0 !== (root.flags & 2))
+          commitBeforeMutationEffects_complete(committedLanes);
+        else {
+          if (22 === root.tag)
+            if (
+              ((JSCompiler_temp = root.alternate), null !== root.memoizedState)
+            ) {
+              null !== JSCompiler_temp &&
+                null === JSCompiler_temp.memoizedState &&
+                committedLanes &&
+                commitExitViewTransitions(
+                  JSCompiler_temp,
+                  appearingViewTransitions
+                );
+              commitBeforeMutationEffects_complete(committedLanes);
+              continue;
+            } else if (
+              null !== JSCompiler_temp &&
+              null !== JSCompiler_temp.memoizedState
+            ) {
+              commitBeforeMutationEffects_complete(committedLanes);
+              continue;
+            }
+          JSCompiler_temp = root.child;
+          0 !== (root.subtreeFlags & firstChild) && null !== JSCompiler_temp
+            ? ((JSCompiler_temp.return = root), (nextEffect = JSCompiler_temp))
+            : (committedLanes && commitNestedViewTransitions(root),
+              commitBeforeMutationEffects_complete(committedLanes));
+        }
+      }
+    }
+    function commitBeforeMutationEffects_complete(
+      isViewTransitionEligible$jscomp$0
+    ) {
+      for (; null !== nextEffect; ) {
+        var fiber = nextEffect,
+          finishedWork = fiber,
+          isViewTransitionEligible = isViewTransitionEligible$jscomp$0,
+          current = finishedWork.alternate,
+          flags = finishedWork.flags;
+        switch (finishedWork.tag) {
+          case 0:
+            if (
+              0 !== (flags & 4) &&
+              ((isViewTransitionEligible = finishedWork.updateQueue),
+              (isViewTransitionEligible =
+                null !== isViewTransitionEligible
+                  ? isViewTransitionEligible.events
+                  : null),
+              null !== isViewTransitionEligible)
+            )
+              for (
+                finishedWork = 0;
+                finishedWork < isViewTransitionEligible.length;
+                finishedWork++
+              )
+                (current = isViewTransitionEligible[finishedWork]),
+                  (current.ref.impl = current.nextImpl);
+            break;
+          case 11:
+          case 15:
+            break;
+          case 1:
+            0 !== (flags & 1024) &&
+              null !== current &&
+              commitClassSnapshot(finishedWork, current);
+            break;
+          case 3:
+            if (0 !== (flags & 1024))
+              if (
+                ((isViewTransitionEligible =
+                  finishedWork.stateNode.containerInfo),
+                (finishedWork = isViewTransitionEligible.nodeType),
+                9 === finishedWork)
+              )
+                clearContainerSparingly(isViewTransitionEligible);
+              else if (1 === finishedWork)
+                switch (isViewTransitionEligible.nodeName) {
+                  case "HEAD":
+                  case "HTML":
+                  case "BODY":
+                    clearContainerSparingly(isViewTransitionEligible);
+                    break;
+                  default:
+                    isViewTransitionEligible.textContent = "";
+                }
+            break;
+          case 5:
+          case 26:
+          case 27:
+          case 6:
+          case 4:
+          case 17:
+            break;
+          case 30:
+            if (
+              isViewTransitionEligible &&
+              null !== current &&
+              0 !== (finishedWork.subtreeFlags & 8246)
+            )
+              a: {
+                isViewTransitionEligible = current;
+                current = finishedWork;
+                finishedWork = getViewTransitionName(
+                  isViewTransitionEligible.memoizedProps,
+                  isViewTransitionEligible.stateNode
+                );
+                current = current.memoizedProps;
+                flags = getViewTransitionClassName(
+                  current.className,
+                  current.update
+                );
+                if (
+                  "none" === flags &&
+                  ((flags = getViewTransitionClassName(
+                    current.className,
+                    current.layout
+                  )),
+                  "none" === flags)
+                )
+                  break a;
+                viewTransitionHostInstanceIdx = 0;
+                applyViewTransitionToHostInstances(
+                  isViewTransitionEligible.child,
+                  finishedWork,
+                  flags,
+                  (isViewTransitionEligible.memoizedState = []),
+                  !0
+                );
+              }
+            break;
+          default:
+            if (0 !== (flags & 1024))
+              throw Error(
+                "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
+              );
+        }
+        isViewTransitionEligible = fiber.sibling;
+        if (null !== isViewTransitionEligible) {
+          isViewTransitionEligible.return = fiber.return;
+          nextEffect = isViewTransitionEligible;
+          break;
+        }
+        nextEffect = fiber.return;
+      }
+    }
+    function applyViewTransitionToHostInstances(
+      child,
+      name,
+      className,
+      collectMeasurements,
+      stopAtNestedViewTransitions
+    ) {
+      for (var inViewport = !1; null !== child; ) {
+        if (5 === child.tag) {
+          shouldStartViewTransition = !0;
+          var instance = child.stateNode;
+          if (null !== collectMeasurements) {
+            var measurement = measureInstance(instance);
+            collectMeasurements.push(measurement);
+            measurement.view && (inViewport = !0);
+          } else
+            inViewport || (measureInstance(instance).view && (inViewport = !0));
+          measurement = className;
+          instance.style.viewTransitionName =
+            0 === viewTransitionHostInstanceIdx
+              ? name
+              : name + "_" + viewTransitionHostInstanceIdx;
+          null != measurement &&
+            (instance.style.viewTransitionClass = measurement);
+          viewTransitionHostInstanceIdx++;
+        } else if (22 !== child.tag || null === child.memoizedState)
+          (30 === child.tag && stopAtNestedViewTransitions) ||
+            (applyViewTransitionToHostInstances(
+              child.child,
+              name,
+              className,
+              collectMeasurements,
+              stopAtNestedViewTransitions
+            ) &&
+              (inViewport = !0));
+        child = child.sibling;
+      }
+      return inViewport;
+    }
+    function restoreViewTransitionOnHostInstances(
+      child,
+      stopAtNestedViewTransitions
+    ) {
+      for (; null !== child; ) {
+        if (5 === child.tag)
+          restoreViewTransitionName(child.stateNode, child.memoizedProps);
+        else if (22 !== child.tag || null === child.memoizedState)
+          (30 === child.tag && stopAtNestedViewTransitions) ||
+            restoreViewTransitionOnHostInstances(
+              child.child,
+              stopAtNestedViewTransitions
+            );
+        child = child.sibling;
+      }
+    }
+    function commitAppearingPairViewTransitions(placement) {
+      if (0 !== (placement.subtreeFlags & 2097152))
+        for (placement = placement.child; null !== placement; ) {
+          if (22 !== placement.tag || null !== placement.memoizedState)
+            if (
+              (commitAppearingPairViewTransitions(placement),
+              30 === placement.tag &&
+                0 !== (placement.flags & 2097152) &&
+                placement.stateNode.paired)
+            ) {
+              var props = placement.memoizedProps;
+              if (null == props.name || "auto" === props.name)
+                throw Error(
+                  "Found a pair with an auto name. This is a bug in React."
+                );
+              var name = props.name;
+              props = getViewTransitionClassName(props.className, props.share);
+              "none" !== props &&
+                ((viewTransitionHostInstanceIdx = 0),
+                applyViewTransitionToHostInstances(
+                  placement.child,
+                  name,
+                  props,
+                  null,
+                  !1
+                ) || restoreViewTransitionOnHostInstances(placement.child, !1));
+            }
+          placement = placement.sibling;
+        }
+    }
+    function commitEnterViewTransitions(placement) {
+      if (30 === placement.tag) {
+        var state = placement.stateNode,
+          props = placement.memoizedProps,
+          name = getViewTransitionName(props, state),
+          className = getViewTransitionClassName(
+            props.className,
+            state.paired ? props.share : props.enter
+          );
+        "none" !== className
+          ? ((viewTransitionHostInstanceIdx = 0),
+            applyViewTransitionToHostInstances(
+              placement.child,
+              name,
+              className,
+              null,
+              !1
+            )
+              ? (commitAppearingPairViewTransitions(placement),
+                state.paired ||
+                  scheduleViewTransitionEvent(placement, props.onEnter))
+              : restoreViewTransitionOnHostInstances(placement.child, !1))
+          : commitAppearingPairViewTransitions(placement);
+      } else if (0 !== (placement.subtreeFlags & 33554432))
+        for (placement = placement.child; null !== placement; )
+          commitEnterViewTransitions(placement),
+            (placement = placement.sibling);
+      else commitAppearingPairViewTransitions(placement);
+    }
+    function commitDeletedPairViewTransitions(
+      deletion,
+      appearingViewTransitions
+    ) {
+      if (
+        0 !== appearingViewTransitions.size &&
+        0 !== (deletion.subtreeFlags & 2097152)
+      )
+        for (deletion = deletion.child; null !== deletion; ) {
+          if (22 !== deletion.tag || null !== deletion.memoizedState) {
+            if (30 === deletion.tag && 0 !== (deletion.flags & 2097152)) {
+              var props = deletion.memoizedProps,
+                name = props.name;
+              if (null != name && "auto" !== name) {
+                var pair = appearingViewTransitions.get(name);
+                if (void 0 !== pair) {
+                  var className = getViewTransitionClassName(
+                    props.className,
+                    props.share
                   );
+                  "none" !== className &&
+                    ((viewTransitionHostInstanceIdx = 0),
+                    applyViewTransitionToHostInstances(
+                      deletion.child,
+                      name,
+                      className,
+                      null,
+                      !1
+                    )
+                      ? ((pair.paired = deletion.stateNode),
+                        scheduleViewTransitionEvent(deletion, props.onShare))
+                      : restoreViewTransitionOnHostInstances(
+                          deletion.child,
+                          !1
+                        ));
+                  appearingViewTransitions.delete(name);
+                  if (0 === appearingViewTransitions.size) break;
+                }
+              }
             }
-            root = firstChild.sibling;
-            if (null !== root) {
-              root.return = firstChild.return;
-              nextEffect = root;
-              break;
+            commitDeletedPairViewTransitions(
+              deletion,
+              appearingViewTransitions
+            );
+          }
+          deletion = deletion.sibling;
+        }
+    }
+    function commitExitViewTransitions(deletion, appearingViewTransitions) {
+      if (30 === deletion.tag) {
+        var props = deletion.memoizedProps,
+          name = getViewTransitionName(props, deletion.stateNode),
+          pair =
+            null !== appearingViewTransitions
+              ? appearingViewTransitions.get(name)
+              : void 0,
+          className = getViewTransitionClassName(
+            props.className,
+            void 0 !== pair ? props.share : props.exit
+          );
+        "none" !== className &&
+          ((viewTransitionHostInstanceIdx = 0),
+          applyViewTransitionToHostInstances(
+            deletion.child,
+            name,
+            className,
+            null,
+            !1
+          )
+            ? void 0 !== pair
+              ? ((pair.paired = deletion.stateNode),
+                appearingViewTransitions.delete(name),
+                scheduleViewTransitionEvent(deletion, props.onShare))
+              : scheduleViewTransitionEvent(deletion, props.onExit)
+            : restoreViewTransitionOnHostInstances(deletion.child, !1));
+        null !== appearingViewTransitions &&
+          commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+      } else if (0 !== (deletion.subtreeFlags & 33554432))
+        for (deletion = deletion.child; null !== deletion; )
+          commitExitViewTransitions(deletion, appearingViewTransitions),
+            (deletion = deletion.sibling);
+      else
+        null !== appearingViewTransitions &&
+          commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+    }
+    function commitNestedViewTransitions(changedParent) {
+      for (changedParent = changedParent.child; null !== changedParent; ) {
+        if (30 === changedParent.tag) {
+          var props = changedParent.memoizedProps,
+            name = getViewTransitionName(props, changedParent.stateNode);
+          props = getViewTransitionClassName(props.className, props.layout);
+          "none" !== props &&
+            ((viewTransitionHostInstanceIdx = 0),
+            applyViewTransitionToHostInstances(
+              changedParent.child,
+              name,
+              props,
+              (changedParent.memoizedState = []),
+              !1
+            ));
+        } else
+          0 !== (changedParent.subtreeFlags & 33554432) &&
+            commitNestedViewTransitions(changedParent);
+        changedParent = changedParent.sibling;
+      }
+    }
+    function restorePairedViewTransitions(parent) {
+      if (0 !== (parent.subtreeFlags & 2097152))
+        for (parent = parent.child; null !== parent; ) {
+          if (22 !== parent.tag || null !== parent.memoizedState) {
+            if (30 === parent.tag && 0 !== (parent.flags & 2097152)) {
+              var instance = parent.stateNode;
+              null !== instance.paired &&
+                ((instance.paired = null),
+                restoreViewTransitionOnHostInstances(parent.child, !1));
             }
-            nextEffect = firstChild.return;
+            restorePairedViewTransitions(parent);
           }
+          parent = parent.sibling;
+        }
+    }
+    function restoreEnterViewTransitions(placement) {
+      if (30 === placement.tag)
+        (placement.stateNode.paired = null),
+          restoreViewTransitionOnHostInstances(placement.child, !1),
+          restorePairedViewTransitions(placement);
+      else if (0 !== (placement.subtreeFlags & 33554432))
+        for (placement = placement.child; null !== placement; )
+          restoreEnterViewTransitions(placement),
+            (placement = placement.sibling);
+      else restorePairedViewTransitions(placement);
+    }
+    function restoreExitViewTransitions(deletion) {
+      if (30 === deletion.tag)
+        (deletion.stateNode.paired = null),
+          restoreViewTransitionOnHostInstances(deletion.child, !1),
+          restorePairedViewTransitions(deletion);
+      else if (0 !== (deletion.subtreeFlags & 33554432))
+        for (deletion = deletion.child; null !== deletion; )
+          restoreExitViewTransitions(deletion), (deletion = deletion.sibling);
+      else restorePairedViewTransitions(deletion);
+    }
+    function restoreNestedViewTransitions(changedParent) {
+      for (changedParent = changedParent.child; null !== changedParent; )
+        30 === changedParent.tag
+          ? ((changedParent.memoizedState = null),
+            restoreViewTransitionOnHostInstances(changedParent.child, !1))
+          : 0 !== (changedParent.subtreeFlags & 33554432) &&
+            restoreNestedViewTransitions(changedParent),
+          (changedParent = changedParent.sibling);
+    }
+    function cancelViewTransitionHostInstances(
+      currentViewTransition,
+      child,
+      stopAtNestedViewTransitions
+    ) {
+      for (; null !== child; ) {
+        if (5 === child.tag) {
+          var instance = child.stateNode,
+            oldName = getViewTransitionName(
+              currentViewTransition.memoizedProps,
+              currentViewTransition.stateNode
+            );
+          null === viewTransitionCancelableChildren &&
+            (viewTransitionCancelableChildren = []);
+          viewTransitionCancelableChildren.push(
+            instance,
+            oldName,
+            child.memoizedProps
+          );
+          viewTransitionHostInstanceIdx++;
+        } else if (22 !== child.tag || null === child.memoizedState)
+          (30 === child.tag && stopAtNestedViewTransitions) ||
+            cancelViewTransitionHostInstances(
+              currentViewTransition,
+              child.child,
+              stopAtNestedViewTransitions
+            );
+        child = child.sibling;
+      }
+    }
+    function measureViewTransitionHostInstances(
+      currentViewTransition,
+      parentViewTransition,
+      child,
+      name,
+      className,
+      previousMeasurements,
+      stopAtNestedViewTransitions
+    ) {
+      for (var inViewport = !1; null !== child; ) {
+        if (5 === child.tag) {
+          var instance = child.stateNode;
+          if (
+            null !== previousMeasurements &&
+            viewTransitionHostInstanceIdx < previousMeasurements.length
+          ) {
+            var previousMeasurement =
+                previousMeasurements[viewTransitionHostInstanceIdx],
+              nextMeasurement = measureInstance(instance);
+            if (previousMeasurement.view || nextMeasurement.view)
+              inViewport = !0;
+            var JSCompiler_temp;
+            if ((JSCompiler_temp = 0 === (parentViewTransition.flags & 4)))
+              if (nextMeasurement.clip) JSCompiler_temp = !0;
+              else {
+                JSCompiler_temp = previousMeasurement.rect;
+                var newRect = nextMeasurement.rect;
+                JSCompiler_temp =
+                  JSCompiler_temp.y !== newRect.y ||
+                  JSCompiler_temp.x !== newRect.x ||
+                  JSCompiler_temp.height !== newRect.height ||
+                  JSCompiler_temp.width !== newRect.width;
+              }
+            JSCompiler_temp && (parentViewTransition.flags |= 4);
+            nextMeasurement.abs
+              ? (nextMeasurement = !previousMeasurement.abs)
+              : ((previousMeasurement = previousMeasurement.rect),
+                (nextMeasurement = nextMeasurement.rect),
+                (nextMeasurement =
+                  previousMeasurement.height !== nextMeasurement.height ||
+                  previousMeasurement.width !== nextMeasurement.width));
+            nextMeasurement && (parentViewTransition.flags |= 32);
+          } else parentViewTransition.flags |= 32;
+          0 !== (parentViewTransition.flags & 4) &&
+            ((nextMeasurement = instance),
+            (previousMeasurement = className),
+            (nextMeasurement.style.viewTransitionName =
+              0 === viewTransitionHostInstanceIdx
+                ? name
+                : name + "_" + viewTransitionHostInstanceIdx),
+            null != previousMeasurement &&
+              (nextMeasurement.style.viewTransitionClass =
+                previousMeasurement));
+          (inViewport && 0 !== (parentViewTransition.flags & 4)) ||
+            ((nextMeasurement = getViewTransitionName(
+              currentViewTransition.memoizedProps,
+              currentViewTransition.stateNode
+            )),
+            null === viewTransitionCancelableChildren &&
+              (viewTransitionCancelableChildren = []),
+            viewTransitionCancelableChildren.push(
+              instance,
+              nextMeasurement,
+              child.memoizedProps
+            ));
+          viewTransitionHostInstanceIdx++;
+        } else if (22 !== child.tag || null === child.memoizedState)
+          30 === child.tag && stopAtNestedViewTransitions
+            ? (parentViewTransition.flags |= child.flags & 32)
+            : measureViewTransitionHostInstances(
+                currentViewTransition,
+                parentViewTransition,
+                child.child,
+                name,
+                className,
+                previousMeasurements,
+                stopAtNestedViewTransitions
+              ) && (inViewport = !0);
+        child = child.sibling;
+      }
+      return inViewport;
+    }
+    function measureNestedViewTransitions(changedParent) {
+      for (changedParent = changedParent.child; null !== changedParent; ) {
+        if (30 === changedParent.tag) {
+          var current = changedParent.alternate;
+          if (null !== current) {
+            var props = changedParent.memoizedProps,
+              name = getViewTransitionName(props, changedParent.stateNode),
+              className = getViewTransitionClassName(
+                props.className,
+                props.layout
+              );
+            viewTransitionHostInstanceIdx = 0;
+            current = measureViewTransitionHostInstances(
+              current,
+              changedParent,
+              changedParent.child,
+              name,
+              className,
+              changedParent.memoizedState,
+              !1
+            );
+            0 !== (changedParent.flags & 4) &&
+              current &&
+              scheduleViewTransitionEvent(changedParent, props.onLayout);
+          }
+        } else
+          0 !== (changedParent.subtreeFlags & 33554432) &&
+            measureNestedViewTransitions(changedParent);
+        changedParent = changedParent.sibling;
+      }
     }
     function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
-      var flags = finishedWork.flags;
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors(),
+        flags = finishedWork.flags;
       switch (finishedWork.tag) {
         case 0:
         case 11:
@@ -11181,11 +12165,11 @@
           }
           finishedRoot.effectDuration += popNestedEffectDurations(current);
           break;
-        case 27:
-          null === current &&
-            flags & 4 &&
-            commitHostSingletonAcquisition(finishedWork);
         case 26:
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+          break;
+        case 27:
         case 5:
           recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
           null === current && flags & 4 && commitHostMount(finishedWork);
@@ -11220,11 +12204,11 @@
             null !== finishedRoot &&
               ((finishedRoot = finishedRoot.dehydrated),
               null !== finishedRoot &&
-                ((finishedWork = retryDehydratedSuspenseBoundary.bind(
+                ((flags = retryDehydratedSuspenseBoundary.bind(
                   null,
                   finishedWork
                 )),
-                registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
+                registerSuspenseInstanceRetry(finishedRoot, flags))));
           break;
         case 22:
           prevProps =
@@ -11252,9 +12236,26 @@
               ? safelyAttachRef(finishedWork, finishedWork.return)
               : safelyDetachRef(finishedWork, finishedWork.return));
           break;
+        case 30:
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+          break;
         default:
           recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function detachFiberAfterEffects(fiber) {
       var alternate = fiber.alternate;
@@ -11328,19 +12329,16 @@
             safelyDetachRef(deletedFiber, nearestMountedAncestor);
           var prevHostParent = hostParent,
             prevHostParentIsContainer = hostParentIsContainer;
-          "head" === deletedFiber.type &&
-            ((hostParent = deletedFiber.stateNode),
-            (hostParentIsContainer = !1));
+          hostParent = deletedFiber.stateNode;
           recursivelyTraverseDeletionEffects(
             finishedRoot,
             nearestMountedAncestor,
             deletedFiber
           );
-          runWithFiberInDEV(
-            deletedFiber,
-            releaseSingletonInstance,
-            deletedFiber.stateNode
-          );
+          deletedFiber = deletedFiber.stateNode;
+          for (finishedRoot = deletedFiber.attributes; finishedRoot.length; )
+            deletedFiber.removeAttributeNode(finishedRoot[0]);
+          detachDeletedInstance(deletedFiber);
           hostParent = prevHostParent;
           hostParentIsContainer = prevHostParentIsContainer;
           break;
@@ -11366,7 +12364,8 @@
                   removeChildFromContainer,
                   hostParent,
                   deletedFiber.stateNode
-                );
+                ),
+                  (viewTransitionMutationContext = !0);
               } catch (error) {
                 captureCommitPhaseError(
                   deletedFiber,
@@ -11381,7 +12380,8 @@
                   removeChild,
                   hostParent,
                   deletedFiber.stateNode
-                );
+                ),
+                  (viewTransitionMutationContext = !0);
               } catch (error) {
                 captureCommitPhaseError(
                   deletedFiber,
@@ -11397,14 +12397,8 @@
                 (deletedFiber = deletedFiber.stateNode),
                 8 === finishedRoot.nodeType
                   ? clearSuspenseBoundary(finishedRoot.parentNode, deletedFiber)
-                  : 9 === finishedRoot.nodeType
-                    ? clearSuspenseBoundary(finishedRoot.body, deletedFiber)
-                    : "HTML" === finishedRoot.nodeName
-                      ? clearSuspenseBoundary(
-                          finishedRoot.ownerDocument.body,
-                          deletedFiber
-                        )
-                      : clearSuspenseBoundary(finishedRoot, deletedFiber),
+                  : 1 === finishedRoot.nodeType &&
+                    clearSuspenseBoundary(finishedRoot, deletedFiber),
                 retryIfBlockedOn(finishedRoot))
               : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
           break;
@@ -11547,7 +12541,11 @@
         }
       });
     }
-    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
+    function recursivelyTraverseMutationEffects(
+      root$jscomp$0,
+      parentFiber,
+      lanes
+    ) {
       var deletions = parentFiber.deletions;
       if (null !== deletions)
         for (var i = 0; i < deletions.length; i++) {
@@ -11558,12 +12556,6 @@
           a: for (; null !== parent; ) {
             switch (parent.tag) {
               case 27:
-                if ("head" === parent.type) {
-                  hostParent = parent.stateNode;
-                  hostParentIsContainer = !1;
-                  break a;
-                }
-                break;
               case 5:
                 hostParent = parent.stateNode;
                 hostParentIsContainer = !1;
@@ -11593,18 +12585,20 @@
         }
       if (parentFiber.subtreeFlags & 13878)
         for (parentFiber = parentFiber.child; null !== parentFiber; )
-          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
+          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0, lanes),
             (parentFiber = parentFiber.sibling);
     }
-    function commitMutationEffectsOnFiber(finishedWork, root) {
-      var current = finishedWork.alternate,
+    function commitMutationEffectsOnFiber(finishedWork, root, lanes) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors(),
+        current = finishedWork.alternate,
         flags = finishedWork.flags;
       switch (finishedWork.tag) {
         case 0:
         case 11:
         case 14:
         case 15:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           flags & 4 &&
             (commitHookEffectListUnmount(
@@ -11620,7 +12614,7 @@
             ));
           break;
         case 1:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           flags & 512 &&
             (offscreenSubtreeWasHidden ||
@@ -11628,17 +12622,17 @@
               safelyDetachRef(current, current.return));
           flags & 64 &&
             offscreenSubtreeIsHidden &&
-            ((finishedWork = finishedWork.updateQueue),
-            null !== finishedWork &&
-              ((flags = finishedWork.callbacks),
+            ((current = finishedWork.updateQueue),
+            null !== current &&
+              ((flags = current.callbacks),
               null !== flags &&
-                ((current = finishedWork.shared.hiddenCallbacks),
-                (finishedWork.shared.hiddenCallbacks =
-                  null === current ? flags : current.concat(flags)))));
+                ((root = current.shared.hiddenCallbacks),
+                (current.shared.hiddenCallbacks =
+                  null === root ? flags : root.concat(flags)))));
           break;
         case 26:
           var hoistableRoot = currentHoistableRoot;
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           flags & 512 &&
             (offscreenSubtreeWasHidden ||
@@ -11653,116 +12647,113 @@
               if (null === flags)
                 if (null === finishedWork.stateNode) {
                   a: {
-                    flags = finishedWork.type;
-                    current = finishedWork.memoizedProps;
+                    current = finishedWork.type;
+                    flags = finishedWork.memoizedProps;
                     root = hoistableRoot.ownerDocument || hoistableRoot;
-                    b: switch (flags) {
+                    b: switch (current) {
                       case "title":
-                        hoistableRoot = root.getElementsByTagName("title")[0];
+                        lanes = root.getElementsByTagName("title")[0];
                         if (
-                          !hoistableRoot ||
-                          hoistableRoot[internalHoistableMarker] ||
-                          hoistableRoot[internalInstanceKey] ||
-                          hoistableRoot.namespaceURI === SVG_NAMESPACE ||
-                          hoistableRoot.hasAttribute("itemprop")
+                          !lanes ||
+                          lanes[internalHoistableMarker] ||
+                          lanes[internalInstanceKey] ||
+                          lanes.namespaceURI === SVG_NAMESPACE ||
+                          lanes.hasAttribute("itemprop")
                         )
-                          (hoistableRoot = root.createElement(flags)),
+                          (lanes = root.createElement(current)),
                             root.head.insertBefore(
-                              hoistableRoot,
+                              lanes,
                               root.querySelector("head > title")
                             );
-                        setInitialProperties(hoistableRoot, flags, current);
-                        hoistableRoot[internalInstanceKey] = finishedWork;
-                        markNodeAsHoistable(hoistableRoot);
-                        flags = hoistableRoot;
+                        setInitialProperties(lanes, current, flags);
+                        lanes[internalInstanceKey] = finishedWork;
+                        markNodeAsHoistable(lanes);
+                        current = lanes;
                         break a;
                       case "link":
-                        var maybeNodes = getHydratableHoistableCache(
-                          "link",
-                          "href",
-                          root
-                        ).get(flags + (current.href || ""));
-                        if (maybeNodes)
-                          for (var i = 0; i < maybeNodes.length; i++)
+                        if (
+                          (hoistableRoot = getHydratableHoistableCache(
+                            "link",
+                            "href",
+                            root
+                          ).get(current + (flags.href || "")))
+                        )
+                          for (var i = 0; i < hoistableRoot.length; i++)
                             if (
-                              ((hoistableRoot = maybeNodes[i]),
-                              hoistableRoot.getAttribute("href") ===
-                                (null == current.href || "" === current.href
+                              ((lanes = hoistableRoot[i]),
+                              lanes.getAttribute("href") ===
+                                (null == flags.href || "" === flags.href
                                   ? null
-                                  : current.href) &&
-                                hoistableRoot.getAttribute("rel") ===
-                                  (null == current.rel ? null : current.rel) &&
-                                hoistableRoot.getAttribute("title") ===
-                                  (null == current.title
-                                    ? null
-                                    : current.title) &&
-                                hoistableRoot.getAttribute("crossorigin") ===
-                                  (null == current.crossOrigin
+                                  : flags.href) &&
+                                lanes.getAttribute("rel") ===
+                                  (null == flags.rel ? null : flags.rel) &&
+                                lanes.getAttribute("title") ===
+                                  (null == flags.title ? null : flags.title) &&
+                                lanes.getAttribute("crossorigin") ===
+                                  (null == flags.crossOrigin
                                     ? null
-                                    : current.crossOrigin))
+                                    : flags.crossOrigin))
                             ) {
-                              maybeNodes.splice(i, 1);
+                              hoistableRoot.splice(i, 1);
                               break b;
                             }
-                        hoistableRoot = root.createElement(flags);
-                        setInitialProperties(hoistableRoot, flags, current);
-                        root.head.appendChild(hoistableRoot);
+                        lanes = root.createElement(current);
+                        setInitialProperties(lanes, current, flags);
+                        root.head.appendChild(lanes);
                         break;
                       case "meta":
                         if (
-                          (maybeNodes = getHydratableHoistableCache(
+                          (hoistableRoot = getHydratableHoistableCache(
                             "meta",
                             "content",
                             root
-                          ).get(flags + (current.content || "")))
+                          ).get(current + (flags.content || "")))
                         )
-                          for (i = 0; i < maybeNodes.length; i++)
+                          for (i = 0; i < hoistableRoot.length; i++)
                             if (
-                              ((hoistableRoot = maybeNodes[i]),
+                              ((lanes = hoistableRoot[i]),
                               checkAttributeStringCoercion(
-                                current.content,
+                                flags.content,
                                 "content"
                               ),
-                              hoistableRoot.getAttribute("content") ===
-                                (null == current.content
+                              lanes.getAttribute("content") ===
+                                (null == flags.content
                                   ? null
-                                  : "" + current.content) &&
-                                hoistableRoot.getAttribute("name") ===
-                                  (null == current.name
-                                    ? null
-                                    : current.name) &&
-                                hoistableRoot.getAttribute("property") ===
-                                  (null == current.property
+                                  : "" + flags.content) &&
+                                lanes.getAttribute("name") ===
+                                  (null == flags.name ? null : flags.name) &&
+                                lanes.getAttribute("property") ===
+                                  (null == flags.property
                                     ? null
-                                    : current.property) &&
-                                hoistableRoot.getAttribute("http-equiv") ===
-                                  (null == current.httpEquiv
+                                    : flags.property) &&
+                                lanes.getAttribute("http-equiv") ===
+                                  (null == flags.httpEquiv
                                     ? null
-                                    : current.httpEquiv) &&
-                                hoistableRoot.getAttribute("charset") ===
-                                  (null == current.charSet
+                                    : flags.httpEquiv) &&
+                                lanes.getAttribute("charset") ===
+                                  (null == flags.charSet
                                     ? null
-                                    : current.charSet))
+                                    : flags.charSet))
                             ) {
-                              maybeNodes.splice(i, 1);
+                              hoistableRoot.splice(i, 1);
                               break b;
                             }
-                        hoistableRoot = root.createElement(flags);
-                        setInitialProperties(hoistableRoot, flags, current);
-                        root.head.appendChild(hoistableRoot);
+                        lanes = root.createElement(current);
+                        setInitialProperties(lanes, current, flags);
+                        root.head.appendChild(lanes);
                         break;
                       default:
                         throw Error(
                           'getNodesForType encountered a type it did not expect: "' +
-                            flags +
+                            current +
                             '". This is a bug in React.'
                         );
                     }
-                    hoistableRoot[internalInstanceKey] = finishedWork;
-                    markNodeAsHoistable(hoistableRoot);
-                    flags = hoistableRoot;
+                    lanes[internalInstanceKey] = finishedWork;
+                    markNodeAsHoistable(lanes);
+                    current = lanes;
                   }
-                  finishedWork.stateNode = flags;
+                  finishedWork.stateNode = current;
                 } else
                   mountHoistable(
                     hoistableRoot,
@@ -11802,22 +12793,37 @@
                   );
           break;
         case 27:
-          recursivelyTraverseMutationEffects(root, finishedWork);
-          commitReconciliationEffects(finishedWork);
-          flags & 512 &&
-            (offscreenSubtreeWasHidden ||
-              null === current ||
-              safelyDetachRef(current, current.return));
-          null !== current &&
-            flags & 4 &&
-            commitHostUpdate(
-              finishedWork,
-              finishedWork.memoizedProps,
-              current.memoizedProps
-            );
-          break;
+          if (flags & 4 && null === finishedWork.alternate) {
+            hoistableRoot = finishedWork.stateNode;
+            i = finishedWork.memoizedProps;
+            try {
+              for (var node = hoistableRoot.firstChild; node; ) {
+                var nextNode = node.nextSibling,
+                  nodeName = node.nodeName;
+                node[internalHoistableMarker] ||
+                  "HEAD" === nodeName ||
+                  "BODY" === nodeName ||
+                  "SCRIPT" === nodeName ||
+                  "STYLE" === nodeName ||
+                  ("LINK" === nodeName &&
+                    "stylesheet" === node.rel.toLowerCase()) ||
+                  hoistableRoot.removeChild(node);
+                node = nextNode;
+              }
+              runWithFiberInDEV(
+                finishedWork,
+                acquireSingletonInstance,
+                finishedWork.type,
+                i,
+                hoistableRoot,
+                finishedWork
+              );
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+          }
         case 5:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           flags & 512 &&
             (offscreenSubtreeWasHidden ||
@@ -11826,7 +12832,8 @@
           if (finishedWork.flags & 32) {
             root = finishedWork.stateNode;
             try {
-              runWithFiberInDEV(finishedWork, resetTextContent, root);
+              runWithFiberInDEV(finishedWork, resetTextContent, root),
+                (viewTransitionMutationContext = !0);
             } catch (error) {
               captureCommitPhaseError(finishedWork, finishedWork.return, error);
             }
@@ -11847,7 +12854,7 @@
               ));
           break;
         case 6:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           if (flags & 4) {
             if (null === finishedWork.stateNode)
@@ -11864,7 +12871,8 @@
                 root,
                 current,
                 flags
-              );
+              ),
+                (viewTransitionMutationContext = !0);
             } catch (error) {
               captureCommitPhaseError(finishedWork, finishedWork.return, error);
             }
@@ -11873,10 +12881,10 @@
         case 3:
           hoistableRoot = pushNestedEffectDurations();
           tagCaches = null;
-          maybeNodes = currentHoistableRoot;
+          i = currentHoistableRoot;
           currentHoistableRoot = getHoistableRoot(root.containerInfo);
-          recursivelyTraverseMutationEffects(root, finishedWork);
-          currentHoistableRoot = maybeNodes;
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          currentHoistableRoot = i;
           commitReconciliationEffects(finishedWork);
           if (
             flags & 4 &&
@@ -11897,50 +12905,48 @@
           root.effectDuration += popNestedEffectDurations(hoistableRoot);
           break;
         case 4:
-          flags = currentHoistableRoot;
+          current = currentHoistableRoot;
           currentHoistableRoot = getHoistableRoot(
             finishedWork.stateNode.containerInfo
           );
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
-          currentHoistableRoot = flags;
+          currentHoistableRoot = current;
           break;
         case 12:
-          flags = pushNestedEffectDurations();
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          current = pushNestedEffectDurations();
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           finishedWork.stateNode.effectDuration +=
-            bubbleNestedEffectDurations(flags);
+            bubbleNestedEffectDurations(current);
           break;
         case 13:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           finishedWork.child.flags & 8192 &&
             (null !== finishedWork.memoizedState) !==
               (null !== current && null !== current.memoizedState) &&
             (globalMostRecentFallbackTime = now$1());
           flags & 4 &&
-            ((flags = finishedWork.updateQueue),
-            null !== flags &&
+            ((current = finishedWork.updateQueue),
+            null !== current &&
               ((finishedWork.updateQueue = null),
-              attachSuspenseRetryListeners(finishedWork, flags)));
+              attachSuspenseRetryListeners(finishedWork, current)));
           break;
         case 22:
           flags & 512 &&
             (offscreenSubtreeWasHidden ||
               null === current ||
               safelyDetachRef(current, current.return));
-          hoistableRoot = null !== finishedWork.memoizedState;
-          var wasHidden = null !== current && null !== current.memoizedState,
-            prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-          offscreenSubtreeIsHidden =
-            prevOffscreenSubtreeIsHidden || hoistableRoot;
-          offscreenSubtreeWasHidden =
-            prevOffscreenSubtreeWasHidden || wasHidden;
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          node = null !== finishedWork.memoizedState;
+          nextNode = null !== current && null !== current.memoizedState;
+          nodeName = offscreenSubtreeIsHidden;
+          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+          offscreenSubtreeIsHidden = nodeName || node;
+          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || nextNode;
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
-          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+          offscreenSubtreeIsHidden = nodeName;
           commitReconciliationEffects(finishedWork);
           root = finishedWork.stateNode;
           root._current = finishedWork;
@@ -11948,51 +12954,51 @@
           root._visibility |= root._pendingVisibility & OffscreenDetached;
           if (
             flags & 8192 &&
-            ((root._visibility = hoistableRoot
+            ((root._visibility = node
               ? root._visibility & ~OffscreenVisible
               : root._visibility | OffscreenVisible),
-            hoistableRoot &&
-              (null === current ||
-                wasHidden ||
-                offscreenSubtreeIsHidden ||
-                offscreenSubtreeWasHidden ||
+            node &&
+              ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
+              null === current ||
+                nextNode ||
+                root ||
                 recursivelyTraverseDisappearLayoutEffects(finishedWork)),
             null === finishedWork.memoizedProps ||
               "manual" !== finishedWork.memoizedProps.mode)
           )
             a: for (current = null, root = finishedWork; ; ) {
-              if (5 === root.tag || 26 === root.tag) {
+              if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
                 if (null === current) {
-                  wasHidden = current = root;
+                  lanes = current = root;
                   try {
-                    (maybeNodes = wasHidden.stateNode),
-                      hoistableRoot
-                        ? runWithFiberInDEV(wasHidden, hideInstance, maybeNodes)
+                    (hoistableRoot = lanes.stateNode),
+                      node
+                        ? runWithFiberInDEV(lanes, hideInstance, hoistableRoot)
                         : runWithFiberInDEV(
-                            wasHidden,
+                            lanes,
                             unhideInstance,
-                            wasHidden.stateNode,
-                            wasHidden.memoizedProps
+                            lanes.stateNode,
+                            lanes.memoizedProps
                           );
                   } catch (error) {
-                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
+                    captureCommitPhaseError(lanes, lanes.return, error);
                   }
                 }
               } else if (6 === root.tag) {
                 if (null === current) {
-                  wasHidden = root;
+                  lanes = root;
                   try {
-                    (i = wasHidden.stateNode),
-                      hoistableRoot
-                        ? runWithFiberInDEV(wasHidden, hideTextInstance, i)
+                    (i = lanes.stateNode),
+                      node
+                        ? runWithFiberInDEV(lanes, hideTextInstance, i)
                         : runWithFiberInDEV(
-                            wasHidden,
+                            lanes,
                             unhideTextInstance,
                             i,
-                            wasHidden.memoizedProps
+                            lanes.memoizedProps
                           );
                   } catch (error) {
-                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
+                    captureCommitPhaseError(lanes, lanes.return, error);
                   }
                 }
               } else if (
@@ -12017,29 +13023,56 @@
               root = root.sibling;
             }
           flags & 4 &&
-            ((flags = finishedWork.updateQueue),
-            null !== flags &&
-              ((current = flags.retryQueue),
-              null !== current &&
-                ((flags.retryQueue = null),
-                attachSuspenseRetryListeners(finishedWork, current))));
+            ((current = finishedWork.updateQueue),
+            null !== current &&
+              ((flags = current.retryQueue),
+              null !== flags &&
+                ((current.retryQueue = null),
+                attachSuspenseRetryListeners(finishedWork, flags))));
           break;
         case 19:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           flags & 4 &&
-            ((flags = finishedWork.updateQueue),
-            null !== flags &&
+            ((current = finishedWork.updateQueue),
+            null !== current &&
               ((finishedWork.updateQueue = null),
-              attachSuspenseRetryListeners(finishedWork, flags)));
+              attachSuspenseRetryListeners(finishedWork, current)));
           break;
         case 30:
+          flags & 512 &&
+            (offscreenSubtreeWasHidden ||
+              null === current ||
+              safelyDetachRef(current, current.return));
+          flags = viewTransitionMutationContext;
+          viewTransitionMutationContext = !1;
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          (lanes & 335544192) === lanes &&
+            null !== current &&
+            viewTransitionMutationContext &&
+            (finishedWork.flags |= 4);
+          viewTransitionMutationContext = flags;
+          break;
         case 21:
           break;
         default:
-          recursivelyTraverseMutationEffects(root, finishedWork),
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes),
             commitReconciliationEffects(finishedWork);
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function commitReconciliationEffects(finishedWork) {
       var flags = finishedWork.flags;
@@ -12062,6 +13095,158 @@
           parentFiber = parentFiber.sibling;
         }
     }
+    function recursivelyTraverseAfterMutationEffects(root, parentFiber) {
+      if (parentFiber.subtreeFlags & 9238)
+        for (parentFiber = parentFiber.child; null !== parentFiber; )
+          commitAfterMutationEffectsOnFiber(parentFiber, root),
+            (parentFiber = parentFiber.sibling);
+      else measureNestedViewTransitions(parentFiber);
+    }
+    function commitAfterMutationEffectsOnFiber(finishedWork, root) {
+      var current = finishedWork.alternate;
+      if (null === current) commitEnterViewTransitions(finishedWork);
+      else
+        switch (finishedWork.tag) {
+          case 3:
+            viewTransitionContextChanged = !1;
+            viewTransitionCancelableChildren = null;
+            recursivelyTraverseAfterMutationEffects(root, finishedWork);
+            if (!viewTransitionContextChanged) {
+              finishedWork = viewTransitionCancelableChildren;
+              viewTransitionCancelableChildren = null;
+              if (null !== finishedWork)
+                for (var i = 0; i < finishedWork.length; i += 3) {
+                  var instance = finishedWork[i],
+                    oldName = finishedWork[i + 1];
+                  restoreViewTransitionName(instance, finishedWork[i + 2]);
+                  instance = instance.ownerDocument.documentElement;
+                  null !== instance &&
+                    instance.animate(
+                      { opacity: [0, 0], pointerEvents: ["none", "none"] },
+                      {
+                        duration: 0,
+                        fill: "forwards",
+                        pseudoElement:
+                          "::view-transition-group(" + oldName + ")"
+                      }
+                    );
+                }
+              finishedWork = root.containerInfo;
+              finishedWork =
+                9 === finishedWork.nodeType
+                  ? finishedWork.documentElement
+                  : finishedWork.ownerDocument.documentElement;
+              null !== finishedWork &&
+                "" === finishedWork.style.viewTransitionName &&
+                ((finishedWork.style.viewTransitionName = "none"),
+                finishedWork.animate(
+                  { opacity: [0, 0], pointerEvents: ["none", "none"] },
+                  {
+                    duration: 0,
+                    fill: "forwards",
+                    pseudoElement: "::view-transition-group(root)"
+                  }
+                ),
+                finishedWork.animate(
+                  { width: [0, 0], height: [0, 0] },
+                  {
+                    duration: 0,
+                    fill: "forwards",
+                    pseudoElement: "::view-transition"
+                  }
+                ));
+            }
+            break;
+          case 5:
+            recursivelyTraverseAfterMutationEffects(root, finishedWork);
+            break;
+          case 22:
+            null === finishedWork.memoizedState &&
+              (null !== current.memoizedState
+                ? commitEnterViewTransitions(finishedWork)
+                : recursivelyTraverseAfterMutationEffects(root, finishedWork));
+            break;
+          case 30:
+            if (0 !== (finishedWork.subtreeFlags & 8246)) {
+              i = 0 !== (finishedWork.flags & 4);
+              oldName = viewTransitionContextChanged;
+              instance = viewTransitionCancelableChildren;
+              viewTransitionContextChanged = !1;
+              viewTransitionCancelableChildren = null;
+              recursivelyTraverseAfterMutationEffects(root, finishedWork);
+              viewTransitionContextChanged && (finishedWork.flags |= 4);
+              a: {
+                root = finishedWork.memoizedProps;
+                var updateClassName = getViewTransitionClassName(
+                    root.className,
+                    root.update
+                  ),
+                  layoutClassName = getViewTransitionClassName(
+                    root.className,
+                    root.update
+                  );
+                if ("none" === updateClassName) {
+                  if ("none" === layoutClassName) {
+                    current = !1;
+                    break a;
+                  }
+                  finishedWork.flags &= -5;
+                  updateClassName = layoutClassName;
+                } else if (0 === (finishedWork.flags & 4)) {
+                  if ("none" === layoutClassName) {
+                    viewTransitionHostInstanceIdx = 0;
+                    cancelViewTransitionHostInstances(
+                      current,
+                      finishedWork.child,
+                      !0
+                    );
+                    current = !1;
+                    break a;
+                  }
+                  updateClassName = layoutClassName;
+                }
+                layoutClassName = getViewTransitionName(
+                  root,
+                  finishedWork.stateNode
+                );
+                viewTransitionHostInstanceIdx = 0;
+                root = current.memoizedState;
+                current = measureViewTransitionHostInstances(
+                  current,
+                  finishedWork,
+                  finishedWork.child,
+                  layoutClassName,
+                  updateClassName,
+                  root,
+                  !0
+                );
+                viewTransitionHostInstanceIdx !==
+                  (null === root ? 0 : root.length) &&
+                  (finishedWork.flags |= 32);
+              }
+              0 !== (finishedWork.flags & 4) && current
+                ? ((current = finishedWork.memoizedProps),
+                  scheduleViewTransitionEvent(
+                    finishedWork,
+                    i || viewTransitionContextChanged
+                      ? current.onUpdate
+                      : current.onLayout
+                  ),
+                  (viewTransitionCancelableChildren = instance))
+                : null !== instance &&
+                  (instance.push.apply(
+                    instance,
+                    viewTransitionCancelableChildren
+                  ),
+                  (viewTransitionCancelableChildren = instance));
+              viewTransitionContextChanged =
+                0 !== (finishedWork.flags & 32) ? !0 : oldName;
+            }
+            break;
+          default:
+            recursivelyTraverseAfterMutationEffects(root, finishedWork);
+        }
+    }
     function recursivelyTraverseLayoutEffects(root, parentFiber) {
       if (parentFiber.subtreeFlags & 8772)
         for (parentFiber = parentFiber.child; null !== parentFiber; )
@@ -12069,6 +13254,8 @@
             (parentFiber = parentFiber.sibling);
     }
     function disappearLayoutEffects(finishedWork) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
       switch (finishedWork.tag) {
         case 0:
         case 11:
@@ -12092,13 +13279,8 @@
             );
           recursivelyTraverseDisappearLayoutEffects(finishedWork);
           break;
-        case 27:
-          runWithFiberInDEV(
-            finishedWork,
-            releaseSingletonInstance,
-            finishedWork.stateNode
-          );
         case 26:
+        case 27:
         case 5:
           safelyDetachRef(finishedWork, finishedWork.return);
           recursivelyTraverseDisappearLayoutEffects(finishedWork);
@@ -12108,9 +13290,24 @@
           null === finishedWork.memoizedState &&
             recursivelyTraverseDisappearLayoutEffects(finishedWork);
           break;
+        case 30:
+          safelyDetachRef(finishedWork, finishedWork.return);
         default:
           recursivelyTraverseDisappearLayoutEffects(finishedWork);
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
       for (parentFiber = parentFiber.child; null !== parentFiber; )
@@ -12123,7 +13320,9 @@
       finishedWork,
       includeWorkInProgressEffects
     ) {
-      var flags = finishedWork.flags;
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors(),
+        flags = finishedWork.flags;
       switch (finishedWork.tag) {
         case 0:
         case 11:
@@ -12168,9 +13367,8 @@
             commitClassCallbacks(finishedWork);
           safelyAttachRef(finishedWork, finishedWork.return);
           break;
-        case 27:
-          commitHostSingletonAcquisition(finishedWork);
         case 26:
+        case 27:
         case 5:
           recursivelyTraverseReappearLayoutEffects(
             finishedRoot,
@@ -12232,6 +13430,14 @@
             );
           safelyAttachRef(finishedWork, finishedWork.return);
           break;
+        case 30:
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+          safelyAttachRef(finishedWork, finishedWork.return);
+          break;
         default:
           recursivelyTraverseReappearLayoutEffects(
             finishedRoot,
@@ -12239,6 +13445,19 @@
             includeWorkInProgressEffects
           );
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function recursivelyTraverseReappearLayoutEffects(
       finishedRoot,
@@ -12282,61 +13501,137 @@
       root,
       parentFiber,
       committedLanes,
-      committedTransitions
+      committedTransitions,
+      endTime
     ) {
-      if (parentFiber.subtreeFlags & 10256)
+      var isViewTransitionEligible =
+        (committedLanes & 335544192) === committedLanes;
+      if (
+        parentFiber.subtreeFlags & (isViewTransitionEligible ? 10262 : 10256) ||
+        (0 !== parentFiber.actualDuration &&
+          (null === parentFiber.alternate ||
+            parentFiber.alternate.child !== parentFiber.child))
+      )
         for (parentFiber = parentFiber.child; null !== parentFiber; )
-          commitPassiveMountOnFiber(
-            root,
-            parentFiber,
-            committedLanes,
-            committedTransitions
-          ),
-            (parentFiber = parentFiber.sibling);
+          (isViewTransitionEligible = parentFiber.sibling),
+            commitPassiveMountOnFiber(
+              root,
+              parentFiber,
+              committedLanes,
+              committedTransitions,
+              null !== isViewTransitionEligible
+                ? isViewTransitionEligible.actualStartTime
+                : endTime
+            ),
+            (parentFiber = isViewTransitionEligible);
+      else
+        isViewTransitionEligible && restoreNestedViewTransitions(parentFiber);
     }
     function commitPassiveMountOnFiber(
       finishedRoot,
       finishedWork,
       committedLanes,
-      committedTransitions
+      committedTransitions,
+      endTime
     ) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 < finishedWork.actualStartTime &&
+        0 !== (finishedWork.flags & 1) &&
+        logComponentRender(
+          finishedWork,
+          finishedWork.actualStartTime,
+          endTime,
+          inHydratedSubtree
+        );
+      var isViewTransitionEligible =
+        (committedLanes & 335544192) === committedLanes;
+      isViewTransitionEligible &&
+        null === finishedWork.alternate &&
+        null !== finishedWork.return &&
+        null !== finishedWork.return.alternate &&
+        restoreEnterViewTransitions(finishedWork);
       var flags = finishedWork.flags;
       switch (finishedWork.tag) {
         case 0:
         case 11:
         case 15:
+          (finishedWork.mode & ProfileMode) !== NoMode &&
+            0 < finishedWork.actualStartTime &&
+            0 !== (finishedWork.flags & 1) &&
+            logComponentRender(
+              finishedWork,
+              finishedWork.actualStartTime,
+              endTime,
+              inHydratedSubtree
+            );
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
           flags & 2048 &&
             commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
           break;
         case 1:
+          (finishedWork.mode & ProfileMode) !== NoMode &&
+            0 < finishedWork.actualStartTime &&
+            (0 !== (finishedWork.flags & 128)
+              ? logComponentErrored(
+                  finishedWork,
+                  finishedWork.actualStartTime,
+                  endTime,
+                  []
+                )
+              : 0 !== (finishedWork.flags & 1) &&
+                logComponentRender(
+                  finishedWork,
+                  finishedWork.actualStartTime,
+                  endTime,
+                  inHydratedSubtree
+                ));
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
           break;
         case 3:
-          var prevEffectDuration = pushNestedEffectDurations();
+          var prevEffectDuration = pushNestedEffectDurations(),
+            wasInHydratedSubtree = inHydratedSubtree;
+          inHydratedSubtree =
+            null !== finishedWork.alternate &&
+            finishedWork.alternate.memoizedState.isDehydrated &&
+            0 === (finishedWork.flags & 256);
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
+          inHydratedSubtree = wasInHydratedSubtree;
+          isViewTransitionEligible &&
+            ((committedLanes = finishedRoot.containerInfo),
+            (committedLanes =
+              9 === committedLanes.nodeType
+                ? committedLanes.documentElement
+                : committedLanes.ownerDocument.documentElement),
+            null !== committedLanes &&
+              "none" === committedLanes.style.viewTransitionName &&
+              (committedLanes.style.viewTransitionName = ""));
           flags & 2048 &&
             ((committedLanes = null),
             null !== finishedWork.alternate &&
               (committedLanes = finishedWork.alternate.memoizedState.cache),
-            (finishedWork = finishedWork.memoizedState.cache),
-            finishedWork !== committedLanes &&
-              (retainCache(finishedWork),
+            (committedTransitions = finishedWork.memoizedState.cache),
+            committedTransitions !== committedLanes &&
+              (retainCache(committedTransitions),
               null != committedLanes && releaseCache(committedLanes)));
           finishedRoot.passiveEffectDuration +=
             popNestedEffectDurations(prevEffectDuration);
@@ -12348,7 +13643,8 @@
               finishedRoot,
               finishedWork,
               committedLanes,
-              committedTransitions
+              committedTransitions,
+              endTime
             );
             finishedRoot = finishedWork.stateNode;
             finishedRoot.passiveEffectDuration +=
@@ -12370,99 +13666,191 @@
               finishedRoot,
               finishedWork,
               committedLanes,
-              committedTransitions
+              committedTransitions,
+              endTime
             );
           break;
         case 13:
+          flags = inHydratedSubtree;
+          prevEffectDuration =
+            null !== finishedWork.alternate
+              ? finishedWork.alternate.memoizedState
+              : null;
+          isViewTransitionEligible = finishedWork.memoizedState;
+          null === prevEffectDuration ||
+          null === prevEffectDuration.dehydrated ||
+          (null !== isViewTransitionEligible &&
+            null !== isViewTransitionEligible.dehydrated)
+            ? (inHydratedSubtree = !1)
+            : ((isViewTransitionEligible = finishedWork.deletions),
+              null !== isViewTransitionEligible &&
+              0 < isViewTransitionEligible.length &&
+              18 === isViewTransitionEligible[0].tag
+                ? ((inHydratedSubtree = !1),
+                  (prevEffectDuration = prevEffectDuration.hydrationErrors),
+                  null !== prevEffectDuration &&
+                    logComponentErrored(
+                      finishedWork,
+                      finishedWork.actualStartTime,
+                      endTime,
+                      prevEffectDuration
+                    ))
+                : (inHydratedSubtree = !0));
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
+          inHydratedSubtree = flags;
           break;
         case 23:
           break;
         case 22:
           prevEffectDuration = finishedWork.stateNode;
-          var _current = finishedWork.alternate;
+          wasInHydratedSubtree = finishedWork.alternate;
           null !== finishedWork.memoizedState
-            ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
-              ? recursivelyTraversePassiveMountEffects(
-                  finishedRoot,
-                  finishedWork,
-                  committedLanes,
-                  committedTransitions
-                )
-              : recursivelyTraverseAtomicPassiveEffects(
-                  finishedRoot,
-                  finishedWork
-                )
-            : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
-              ? recursivelyTraversePassiveMountEffects(
-                  finishedRoot,
-                  finishedWork,
-                  committedLanes,
-                  committedTransitions
-                )
-              : ((prevEffectDuration._visibility |=
-                  OffscreenPassiveEffectsConnected),
-                recursivelyTraverseReconnectPassiveEffects(
-                  finishedRoot,
-                  finishedWork,
-                  committedLanes,
-                  committedTransitions,
-                  0 !== (finishedWork.subtreeFlags & 10256)
-                ));
+            ? (isViewTransitionEligible &&
+                null !== wasInHydratedSubtree &&
+                null === wasInHydratedSubtree.memoizedState &&
+                restoreExitViewTransitions(wasInHydratedSubtree),
+              prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
+                ? recursivelyTraversePassiveMountEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    endTime
+                  )
+                : recursivelyTraverseAtomicPassiveEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    endTime
+                  ))
+            : (isViewTransitionEligible &&
+                null !== wasInHydratedSubtree &&
+                null !== wasInHydratedSubtree.memoizedState &&
+                restoreEnterViewTransitions(finishedWork),
+              prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
+                ? recursivelyTraversePassiveMountEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    endTime
+                  )
+                : ((prevEffectDuration._visibility |=
+                    OffscreenPassiveEffectsConnected),
+                  recursivelyTraverseReconnectPassiveEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    0 !== (finishedWork.subtreeFlags & 10256),
+                    endTime
+                  )));
           flags & 2048 &&
-            commitOffscreenPassiveMountEffects(_current, finishedWork);
+            commitOffscreenPassiveMountEffects(
+              wasInHydratedSubtree,
+              finishedWork
+            );
           break;
         case 24:
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
           flags & 2048 &&
             commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
           break;
+        case 30:
+          isViewTransitionEligible &&
+            ((flags = finishedWork.alternate),
+            null !== flags &&
+              0 !== (finishedWork.subtreeFlags & 8246) &&
+              ((finishedWork.memoizedState = null),
+              restoreViewTransitionOnHostInstances(flags.child, !0),
+              restoreViewTransitionOnHostInstances(finishedWork.child, !0)));
+          recursivelyTraversePassiveMountEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
+          break;
         default:
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function recursivelyTraverseReconnectPassiveEffects(
       finishedRoot,
       parentFiber,
       committedLanes,
       committedTransitions,
-      includeWorkInProgressEffects
+      includeWorkInProgressEffects,
+      endTime
     ) {
       includeWorkInProgressEffects =
         includeWorkInProgressEffects &&
         0 !== (parentFiber.subtreeFlags & 10256);
-      for (parentFiber = parentFiber.child; null !== parentFiber; )
+      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+        var nextSibling = parentFiber.sibling;
         reconnectPassiveEffects(
           finishedRoot,
           parentFiber,
           committedLanes,
           committedTransitions,
-          includeWorkInProgressEffects
-        ),
-          (parentFiber = parentFiber.sibling);
+          includeWorkInProgressEffects,
+          null !== nextSibling ? nextSibling.actualStartTime : endTime
+        );
+        parentFiber = nextSibling;
+      }
     }
     function reconnectPassiveEffects(
       finishedRoot,
       finishedWork,
       committedLanes,
       committedTransitions,
-      includeWorkInProgressEffects
+      includeWorkInProgressEffects,
+      endTime
     ) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 < finishedWork.actualStartTime &&
+        0 !== (finishedWork.flags & 1) &&
+        logComponentRender(
+          finishedWork,
+          finishedWork.actualStartTime,
+          endTime,
+          inHydratedSubtree
+        );
       var flags = finishedWork.flags;
       switch (finishedWork.tag) {
         case 0:
@@ -12473,7 +13861,8 @@
             finishedWork,
             committedLanes,
             committedTransitions,
-            includeWorkInProgressEffects
+            includeWorkInProgressEffects,
+            endTime
           );
           commitHookPassiveMountEffects(finishedWork, Passive);
           break;
@@ -12488,11 +13877,15 @@
                   finishedWork,
                   committedLanes,
                   committedTransitions,
-                  includeWorkInProgressEffects
+                  includeWorkInProgressEffects,
+                  endTime
                 )
               : recursivelyTraverseAtomicPassiveEffects(
                   finishedRoot,
-                  finishedWork
+                  finishedWork,
+                  committedLanes,
+                  committedTransitions,
+                  endTime
                 )
             : ((_instance2._visibility |= OffscreenPassiveEffectsConnected),
               recursivelyTraverseReconnectPassiveEffects(
@@ -12500,7 +13893,8 @@
                 finishedWork,
                 committedLanes,
                 committedTransitions,
-                includeWorkInProgressEffects
+                includeWorkInProgressEffects,
+                endTime
               ));
           includeWorkInProgressEffects &&
             flags & 2048 &&
@@ -12515,7 +13909,8 @@
             finishedWork,
             committedLanes,
             committedTransitions,
-            includeWorkInProgressEffects
+            includeWorkInProgressEffects,
+            endTime
           );
           includeWorkInProgressEffects &&
             flags & 2048 &&
@@ -12527,49 +13922,84 @@
             finishedWork,
             committedLanes,
             committedTransitions,
-            includeWorkInProgressEffects
+            includeWorkInProgressEffects,
+            endTime
           );
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function recursivelyTraverseAtomicPassiveEffects(
       finishedRoot$jscomp$0,
-      parentFiber
+      parentFiber,
+      committedLanes$jscomp$0,
+      committedTransitions$jscomp$0,
+      endTime$jscomp$0
     ) {
       if (parentFiber.subtreeFlags & 10256)
-        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+        for (var child = parentFiber.child; null !== child; ) {
+          parentFiber = child.sibling;
           var finishedRoot = finishedRoot$jscomp$0,
-            finishedWork = parentFiber,
-            flags = finishedWork.flags;
-          switch (finishedWork.tag) {
+            committedLanes = committedLanes$jscomp$0,
+            committedTransitions = committedTransitions$jscomp$0,
+            endTime =
+              null !== parentFiber
+                ? parentFiber.actualStartTime
+                : endTime$jscomp$0;
+          (child.mode & ProfileMode) !== NoMode &&
+            0 < child.actualStartTime &&
+            0 !== (child.flags & 1) &&
+            logComponentRender(
+              child,
+              child.actualStartTime,
+              endTime,
+              inHydratedSubtree
+            );
+          var flags = child.flags;
+          switch (child.tag) {
             case 22:
               recursivelyTraverseAtomicPassiveEffects(
                 finishedRoot,
-                finishedWork
+                child,
+                committedLanes,
+                committedTransitions,
+                endTime
               );
               flags & 2048 &&
-                commitOffscreenPassiveMountEffects(
-                  finishedWork.alternate,
-                  finishedWork
-                );
+                commitOffscreenPassiveMountEffects(child.alternate, child);
               break;
             case 24:
               recursivelyTraverseAtomicPassiveEffects(
                 finishedRoot,
-                finishedWork
+                child,
+                committedLanes,
+                committedTransitions,
+                endTime
               );
               flags & 2048 &&
-                commitCachePassiveMountEffect(
-                  finishedWork.alternate,
-                  finishedWork
-                );
+                commitCachePassiveMountEffect(child.alternate, child);
               break;
             default:
               recursivelyTraverseAtomicPassiveEffects(
                 finishedRoot,
-                finishedWork
+                child,
+                committedLanes,
+                committedTransitions,
+                endTime
               );
           }
-          parentFiber = parentFiber.sibling;
+          child = parentFiber;
         }
     }
     function recursivelyAccumulateSuspenseyCommit(parentFiber) {
@@ -12651,6 +14081,8 @@
             (parentFiber = parentFiber.sibling);
     }
     function commitPassiveUnmountOnFiber(finishedWork) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
       switch (finishedWork.tag) {
         case 0:
         case 11:
@@ -12688,6 +14120,19 @@
         default:
           recursivelyTraversePassiveUnmountEffects(finishedWork);
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
       var deletions = parentFiber.deletions;
@@ -12731,11 +14176,14 @@
     }
     function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
       deletedSubtreeRoot,
-      nearestMountedAncestor
+      nearestMountedAncestor$jscomp$0
     ) {
       for (; null !== nextEffect; ) {
         var fiber = nextEffect,
-          current = fiber;
+          current = fiber,
+          nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
+          prevEffectStart = pushComponentEffectStart(),
+          prevEffectErrors = pushComponentEffectErrors();
         switch (current.tag) {
           case 0:
           case 11:
@@ -12750,30 +14198,44 @@
           case 22:
             null !== current.memoizedState &&
               null !== current.memoizedState.cachePool &&
-              ((current = current.memoizedState.cachePool.pool),
-              null != current && retainCache(current));
+              ((nearestMountedAncestor = current.memoizedState.cachePool.pool),
+              null != nearestMountedAncestor &&
+                retainCache(nearestMountedAncestor));
             break;
           case 24:
             releaseCache(current.memoizedState.cache);
         }
+        (current.mode & ProfileMode) !== NoMode &&
+          0 <= componentEffectStartTime &&
+          0 <= componentEffectEndTime &&
+          0.05 < componentEffectDuration &&
+          logComponentEffect(
+            current,
+            componentEffectStartTime,
+            componentEffectEndTime,
+            componentEffectDuration,
+            componentEffectErrors
+          );
+        popComponentEffectStart(prevEffectStart);
+        componentEffectErrors = prevEffectErrors;
         current = fiber.child;
         if (null !== current) (current.return = fiber), (nextEffect = current);
         else
           a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
             current = nextEffect;
-            var sibling = current.sibling,
-              returnFiber = current.return;
+            prevEffectStart = current.sibling;
+            prevEffectErrors = current.return;
             detachFiberAfterEffects(current);
             if (current === fiber) {
               nextEffect = null;
               break a;
             }
-            if (null !== sibling) {
-              sibling.return = returnFiber;
-              nextEffect = sibling;
+            if (null !== prevEffectStart) {
+              prevEffectStart.return = prevEffectErrors;
+              nextEffect = prevEffectStart;
               break a;
             }
-            nextEffect = returnFiber;
+            nextEffect = prevEffectErrors;
           }
       }
     }
@@ -12803,7 +14265,11 @@
       this.actualDuration = -0;
       this.actualStartTime = -1.1;
       this.treeBaseDuration = this.selfBaseDuration = -0;
-      this._debugOwner = this._debugInfo = null;
+      this._debugTask =
+        this._debugStack =
+        this._debugOwner =
+        this._debugInfo =
+          null;
       this._debugNeedsRemount = !1;
       this._debugHookTypes = null;
       hasBadMapPolyfill ||
@@ -12827,6 +14293,8 @@
           (workInProgress.type = current.type),
           (workInProgress.stateNode = current.stateNode),
           (workInProgress._debugOwner = current._debugOwner),
+          (workInProgress._debugStack = current._debugStack),
+          (workInProgress._debugTask = current._debugTask),
           (workInProgress._debugHookTypes = current._debugHookTypes),
           (workInProgress.alternate = current),
           (current.alternate = workInProgress))
@@ -12976,6 +14444,15 @@
             );
           case REACT_OFFSCREEN_TYPE:
             return createFiberFromOffscreen(pendingProps, mode, lanes, key);
+          case REACT_LEGACY_HIDDEN_TYPE:
+          case REACT_VIEW_TRANSITION_TYPE:
+            return (
+              (key = createFiber(30, pendingProps, key, mode)),
+              (key.elementType = REACT_VIEW_TRANSITION_TYPE),
+              (key.lanes = lanes),
+              (key.stateNode = { autoName: null, paired: null, ref: null }),
+              key
+            );
           default:
             if ("object" === typeof type && null !== type)
               switch (type.$$typeof) {
@@ -13046,6 +14523,8 @@
         lanes
       );
       mode._debugOwner = element._owner;
+      mode._debugStack = element._debugStack;
+      mode._debugTask = element._debugTask;
       return mode;
     }
     function createFiberFromFragment(elements, mode, lanes, key) {
@@ -13362,6 +14841,20 @@
           diffRoot
         ));
     }
+    function getViewTransitionName(props, instance) {
+      return null != props.name && "auto" !== props.name
+        ? props.name
+        : instance.autoName;
+    }
+    function getViewTransitionClassName(className, eventClassName) {
+      return null == eventClassName
+        ? className
+        : "none" === eventClassName
+          ? eventClassName
+          : null != className
+            ? className + " " + eventClassName
+            : eventClassName;
+    }
     function markUpdate(workInProgress) {
       workInProgress.flags |= 4;
     }
@@ -13485,6 +14978,30 @@
       completedWork.childLanes = newChildLanes;
       return didBailout;
     }
+    function trackReappearingViewTransitions(workInProgress) {
+      if (0 !== (workInProgress.subtreeFlags & 2097152))
+        for (workInProgress = workInProgress.child; null !== workInProgress; ) {
+          if (
+            22 !== workInProgress.tag ||
+            null !== workInProgress.memoizedState
+          ) {
+            if (
+              30 === workInProgress.tag &&
+              0 !== (workInProgress.flags & 2097152)
+            ) {
+              var props = workInProgress.memoizedProps;
+              null != props.name &&
+                "auto" !== props.name &&
+                trackAppearingViewTransition(
+                  workInProgress.stateNode,
+                  props.name
+                );
+            }
+            trackReappearingViewTransitions(workInProgress);
+          }
+          workInProgress = workInProgress.sibling;
+        }
+    }
     function completeWork(current, workInProgress, renderLanes) {
       var newProps = workInProgress.pendingProps;
       popTreeContext(workInProgress);
@@ -13564,6 +15081,7 @@
                   "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                 );
               bubbleProperties(workInProgress);
+              workInProgress.subtreeFlags &= -33554433;
               return null;
             }
             current = getHostContext();
@@ -13580,6 +15098,7 @@
                 markUpdate(workInProgress));
           }
           bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
           return null;
         case 5:
           popHostContext(workInProgress);
@@ -13593,6 +15112,7 @@
                   "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                 );
               bubbleProperties(workInProgress);
+              workInProgress.subtreeFlags &= -33554433;
               return null;
             }
             _type = getHostContext();
@@ -13711,6 +15231,7 @@
             }
           }
           bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
           workInProgress.flags &= -16777217;
           return null;
         case 6:
@@ -13994,7 +15515,8 @@
             (newProps = null !== workInProgress.memoizedState),
             null !== current
               ? (null !== current.memoizedState) !== newProps &&
-                (workInProgress.flags |= 8192)
+                ((workInProgress.flags |= 8192),
+                newProps || trackReappearingViewTransitions(workInProgress))
               : newProps && (workInProgress.flags |= 8192),
             newProps
               ? 0 !== (renderLanes & 536870912) &&
@@ -14032,7 +15554,11 @@
         case 25:
           return null;
         case 30:
-          return null;
+          return (
+            (workInProgress.flags |= 33554432),
+            bubbleProperties(workInProgress),
+            null
+          );
       }
       throw Error(
         "Unknown unit of work tag (" +
@@ -14187,6 +15713,20 @@
       null !== suspenseHandler && (suspenseHandler.flags |= 32);
       return workInProgressDeferredLane;
     }
+    function scheduleViewTransitionEvent(fiber, callback) {
+      if (null != callback) {
+        var state = fiber.stateNode,
+          instance = state.ref;
+        null === instance &&
+          (instance = state.ref =
+            createViewTransitionInstance(
+              getViewTransitionName(fiber.memoizedProps, state)
+            ));
+        null === pendingViewTransitionEvents &&
+          (pendingViewTransitionEvents = []);
+        pendingViewTransitionEvents.push(callback.bind(null, instance));
+      }
+    }
     function scheduleUpdateOnFiber(root, fiber, lane) {
       isRunningInsertionEffect &&
         console.error("useInsertionEffect must not schedule updates.");
@@ -14252,32 +15792,82 @@
     function performWorkOnRoot(root, lanes, forceSync) {
       if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
         throw Error("Should not already be working.");
-      var shouldTimeSlice =
-          (!forceSync &&
-            0 === (lanes & 60) &&
-            0 === (lanes & root.expiredLanes)) ||
-          checkIfRootIsPrerendering(root, lanes),
-        exitStatus = shouldTimeSlice
-          ? renderRootConcurrent(root, lanes)
-          : renderRootSync(root, lanes, !0),
-        renderWasConcurrent = shouldTimeSlice;
+      if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {
+        var yieldEndTime = now$1();
+        switch (yieldReason) {
+          case SuspendedOnImmediate:
+          case SuspendedOnData:
+            var startTime = yieldStartTime;
+            supportsUserTiming &&
+              ((reusableComponentDevToolDetails.color = "primary-light"),
+              (reusableComponentOptions.start = startTime),
+              (reusableComponentOptions.end = yieldEndTime),
+              performance.measure("Suspended", reusableComponentOptions));
+            break;
+          case SuspendedOnAction:
+            startTime = yieldStartTime;
+            supportsUserTiming &&
+              ((reusableComponentDevToolDetails.color = "primary-light"),
+              (reusableComponentOptions.start = startTime),
+              (reusableComponentOptions.end = yieldEndTime),
+              performance.measure("Action", reusableComponentOptions));
+            break;
+          default:
+            if (((startTime = yieldStartTime), supportsUserTiming)) {
+              var yieldDuration = yieldEndTime - startTime;
+              1 > yieldDuration ||
+                ((reusableComponentDevToolDetails.color =
+                  5 > yieldDuration
+                    ? "primary-light"
+                    : 10 > yieldDuration
+                      ? "primary"
+                      : 100 > yieldDuration
+                        ? "primary-dark"
+                        : "error"),
+                (reusableComponentOptions.start = startTime),
+                (reusableComponentOptions.end = yieldEndTime),
+                performance.measure("Blocked", reusableComponentOptions));
+            }
+        }
+      }
+      yieldDuration = (forceSync =
+        (!forceSync &&
+          0 === (lanes & 60) &&
+          0 === (lanes & root.expiredLanes)) ||
+        checkIfRootIsPrerendering(root, lanes))
+        ? renderRootConcurrent(root, lanes)
+        : renderRootSync(root, lanes, !0);
+      var renderWasConcurrent = forceSync;
       do {
-        if (exitStatus === RootInProgress) {
+        if (yieldDuration === RootInProgress) {
           workInProgressRootIsPrerendering &&
-            !shouldTimeSlice &&
+            !forceSync &&
             markRootSuspended(root, lanes, 0, !1);
+          lanes = workInProgressSuspendedReason;
+          yieldStartTime = now();
+          yieldReason = lanes;
           break;
         } else {
-          forceSync = root.current.alternate;
+          startTime = now$1();
+          yieldEndTime = root.current.alternate;
           if (
             renderWasConcurrent &&
-            !isRenderConsistentWithExternalStores(forceSync)
+            !isRenderConsistentWithExternalStores(yieldEndTime)
           ) {
-            exitStatus = renderRootSync(root, lanes, !1);
+            setCurrentTrackFromLanes(lanes);
+            yieldEndTime = renderStartTime;
+            yieldDuration = startTime;
+            supportsUserTiming &&
+              ((reusableLaneDevToolDetails.color = "error"),
+              (reusableLaneOptions.start = yieldEndTime),
+              (reusableLaneOptions.end = yieldDuration),
+              performance.measure("Teared Render", reusableLaneOptions));
+            finalizeRender(lanes, startTime);
+            yieldDuration = renderRootSync(root, lanes, !1);
             renderWasConcurrent = !1;
             continue;
           }
-          if (exitStatus === RootErrored) {
+          if (yieldDuration === RootErrored) {
             renderWasConcurrent = lanes;
             if (root.errorRecoveryDisabledLanes & renderWasConcurrent)
               var errorRetryLanes = 0;
@@ -14290,67 +15880,77 @@
                       ? 536870912
                       : 0);
             if (0 !== errorRetryLanes) {
+              setCurrentTrackFromLanes(lanes);
+              logErroredRenderPhase(renderStartTime, startTime);
+              finalizeRender(lanes, startTime);
               lanes = errorRetryLanes;
               a: {
-                exitStatus = root;
-                var errorRetryLanes$jscomp$0 = errorRetryLanes;
-                errorRetryLanes = workInProgressRootConcurrentErrors;
+                startTime = root;
+                yieldDuration = renderWasConcurrent;
+                renderWasConcurrent = workInProgressRootConcurrentErrors;
                 var wasRootDehydrated =
-                  exitStatus.current.memoizedState.isDehydrated;
+                  startTime.current.memoizedState.isDehydrated;
                 wasRootDehydrated &&
-                  (prepareFreshStack(
-                    exitStatus,
-                    errorRetryLanes$jscomp$0
-                  ).flags |= 256);
-                errorRetryLanes$jscomp$0 = renderRootSync(
-                  exitStatus,
-                  errorRetryLanes$jscomp$0,
+                  (prepareFreshStack(startTime, errorRetryLanes).flags |= 256);
+                errorRetryLanes = renderRootSync(
+                  startTime,
+                  errorRetryLanes,
                   !1
                 );
-                if (errorRetryLanes$jscomp$0 !== RootErrored) {
+                if (errorRetryLanes !== RootErrored) {
                   if (
                     workInProgressRootDidAttachPingListener &&
                     !wasRootDehydrated
                   ) {
-                    exitStatus.errorRecoveryDisabledLanes |=
-                      renderWasConcurrent;
-                    workInProgressRootInterleavedUpdatedLanes |=
-                      renderWasConcurrent;
-                    exitStatus = RootSuspendedWithDelay;
+                    startTime.errorRecoveryDisabledLanes |= yieldDuration;
+                    workInProgressRootInterleavedUpdatedLanes |= yieldDuration;
+                    yieldDuration = RootSuspendedWithDelay;
                     break a;
                   }
-                  exitStatus = workInProgressRootRecoverableErrors;
-                  workInProgressRootRecoverableErrors = errorRetryLanes;
-                  null !== exitStatus &&
+                  startTime = workInProgressRootRecoverableErrors;
+                  workInProgressRootRecoverableErrors = renderWasConcurrent;
+                  null !== startTime &&
                     (null === workInProgressRootRecoverableErrors
-                      ? (workInProgressRootRecoverableErrors = exitStatus)
+                      ? (workInProgressRootRecoverableErrors = startTime)
                       : workInProgressRootRecoverableErrors.push.apply(
                           workInProgressRootRecoverableErrors,
-                          exitStatus
+                          startTime
                         ));
                 }
-                exitStatus = errorRetryLanes$jscomp$0;
+                yieldDuration = errorRetryLanes;
               }
               renderWasConcurrent = !1;
-              if (exitStatus !== RootErrored) continue;
+              if (yieldDuration !== RootErrored) continue;
+              else startTime = now$1();
             }
           }
-          if (exitStatus === RootFatalErrored) {
+          if (yieldDuration === RootFatalErrored) {
+            setCurrentTrackFromLanes(lanes);
+            logErroredRenderPhase(renderStartTime, startTime);
+            finalizeRender(lanes, startTime);
             prepareFreshStack(root, 0);
             markRootSuspended(root, lanes, 0, !0);
             break;
           }
           a: {
-            shouldTimeSlice = root;
-            switch (exitStatus) {
+            forceSync = root;
+            switch (yieldDuration) {
               case RootInProgress:
               case RootFatalErrored:
                 throw Error("Root did not complete. This is a bug in React.");
               case RootSuspendedWithDelay:
                 if ((lanes & 4194176) !== lanes) break;
               case RootSuspendedAtTheShell:
+                setCurrentTrackFromLanes(lanes);
+                logSuspendedRenderPhase(renderStartTime, startTime, lanes);
+                finalizeRender(lanes, startTime);
+                yieldEndTime = lanes;
+                0 !== (yieldEndTime & 3) || 0 !== (yieldEndTime & 60)
+                  ? (blockingSuspendedTime = startTime)
+                  : 0 !== (yieldEndTime & 4194176) &&
+                    (transitionSuspendedTime = startTime);
                 markRootSuspended(
-                  shouldTimeSlice,
+                  forceSync,
                   lanes,
                   workInProgressDeferredLane,
                   !workInProgressRootDidSkipSuspendedSiblings
@@ -14367,8 +15967,8 @@
             }
             if (null !== ReactSharedInternals.actQueue)
               commitRoot(
-                shouldTimeSlice,
                 forceSync,
+                yieldEndTime,
                 lanes,
                 workInProgressRootRecoverableErrors,
                 workInProgressTransitions,
@@ -14376,7 +15976,11 @@
                 workInProgressRootDidIncludeRecursiveRenderUpdate,
                 workInProgressDeferredLane,
                 workInProgressRootInterleavedUpdatedLanes,
-                workInProgressSuspendedRetryLanes
+                workInProgressSuspendedRetryLanes,
+                yieldDuration,
+                IMMEDIATE_COMMIT,
+                renderStartTime,
+                startTime
               );
             else {
               if (
@@ -14388,17 +15992,17 @@
                 10 < renderWasConcurrent)
               ) {
                 markRootSuspended(
-                  shouldTimeSlice,
+                  forceSync,
                   lanes,
                   workInProgressDeferredLane,
                   !workInProgressRootDidSkipSuspendedSiblings
                 );
-                if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
-                shouldTimeSlice.timeoutHandle = scheduleTimeout(
+                if (0 !== getNextLanes(forceSync, 0, !0)) break a;
+                forceSync.timeoutHandle = scheduleTimeout(
                   commitRootWhenReady.bind(
                     null,
-                    shouldTimeSlice,
                     forceSync,
+                    yieldEndTime,
                     workInProgressRootRecoverableErrors,
                     workInProgressTransitions,
                     workInProgressAppearingViewTransitions,
@@ -14408,18 +16012,18 @@
                     workInProgressRootInterleavedUpdatedLanes,
                     workInProgressSuspendedRetryLanes,
                     workInProgressRootDidSkipSuspendedSiblings,
-                    exitStatus,
+                    yieldDuration,
                     THROTTLED_COMMIT,
                     renderStartTime,
-                    0
+                    startTime
                   ),
                   renderWasConcurrent
                 );
                 break a;
               }
               commitRootWhenReady(
-                shouldTimeSlice,
                 forceSync,
+                yieldEndTime,
                 workInProgressRootRecoverableErrors,
                 workInProgressTransitions,
                 workInProgressAppearingViewTransitions,
@@ -14429,10 +16033,10 @@
                 workInProgressRootInterleavedUpdatedLanes,
                 workInProgressSuspendedRetryLanes,
                 workInProgressRootDidSkipSuspendedSiblings,
-                exitStatus,
+                yieldDuration,
                 IMMEDIATE_COMMIT,
                 renderStartTime,
-                0
+                startTime
               );
             }
           }
@@ -14459,20 +16063,38 @@
       completedRenderEndTime
     ) {
       root.timeoutHandle = noTimeout;
-      suspendedCommitReason = finishedWork.subtreeFlags;
-      if (
-        (suspendedCommitReason =
-          suspendedCommitReason & 8192 ||
-          16785408 === (suspendedCommitReason & 16785408))
-      )
-        if (
-          ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),
-          suspendedCommitReason &&
-            accumulateSuspenseyCommitOnFiber(finishedWork),
-          (suspendedCommitReason = waitForCommitToBeReady()),
-          null !== suspendedCommitReason)
-        ) {
-          root.cancelPendingCommit = suspendedCommitReason(
+      var subtreeFlags = finishedWork.subtreeFlags,
+        isViewTransitionEligible = (lanes & 335544192) === lanes;
+      subtreeFlags =
+        subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408);
+      if (isViewTransitionEligible || subtreeFlags) {
+        suspendedState = { stylesheets: null, count: 0, unsuspend: noop };
+        subtreeFlags && accumulateSuspenseyCommitOnFiber(finishedWork);
+        if (isViewTransitionEligible) {
+          subtreeFlags = root.containerInfo;
+          if (null === suspendedState)
+            throw Error(
+              "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
+            );
+          isViewTransitionEligible = suspendedState;
+          subtreeFlags = (
+            9 === subtreeFlags.nodeType
+              ? subtreeFlags
+              : subtreeFlags.ownerDocument
+          ).__reactViewTransition;
+          null != subtreeFlags &&
+            (isViewTransitionEligible.count++,
+            (isViewTransitionEligible = onUnsuspend.bind(
+              isViewTransitionEligible
+            )),
+            subtreeFlags.finished.then(
+              isViewTransitionEligible,
+              isViewTransitionEligible
+            ));
+        }
+        isViewTransitionEligible = waitForCommitToBeReady();
+        if (null !== isViewTransitionEligible) {
+          root.cancelPendingCommit = isViewTransitionEligible(
             commitRoot.bind(
               null,
               root,
@@ -14499,6 +16121,7 @@
           );
           return;
         }
+      }
       commitRoot(
         root,
         finishedWork,
@@ -14509,7 +16132,11 @@
         didIncludeRenderPhaseUpdate,
         spawnedLane,
         updatedLanes,
-        suspendedRetryLanes
+        suspendedRetryLanes,
+        exitStatus,
+        suspendedCommitReason,
+        completedRenderStartTime,
+        completedRenderEndTime
       );
     }
     function isRenderConsistentWithExternalStores(finishedWork) {
@@ -14589,16 +16216,179 @@
         workInProgress = null;
       }
     }
+    function finalizeRender(lanes, finalizationTime) {
+      if (0 !== (lanes & 3) || 0 !== (lanes & 60))
+        blockingClampTime = finalizationTime;
+      0 !== (lanes & 4194176) && (transitionClampTime = finalizationTime);
+    }
     function prepareFreshStack(root, lanes) {
-      var timeoutHandle = root.timeoutHandle;
-      timeoutHandle !== noTimeout &&
-        ((root.timeoutHandle = noTimeout), cancelTimeout(timeoutHandle));
-      timeoutHandle = root.cancelPendingCommit;
-      null !== timeoutHandle &&
-        ((root.cancelPendingCommit = null), timeoutHandle());
+      supportsUserTiming &&
+        (performance.mark("Blocking Track", blockingLaneMarker),
+        performance.mark("Transition Track", transitionLaneMarker),
+        performance.mark("Suspense Track", suspenseLaneMarker),
+        performance.mark("Idle Track", idleLaneMarker));
+      var previousRenderStartTime = renderStartTime;
+      renderStartTime = now();
+      if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {
+        setCurrentTrackFromLanes(workInProgressRootRenderLanes);
+        if (
+          workInProgressRootExitStatus === RootSuspended ||
+          workInProgressRootExitStatus === RootSuspendedWithDelay
+        )
+          logSuspendedRenderPhase(
+            previousRenderStartTime,
+            renderStartTime,
+            lanes
+          );
+        else {
+          var endTime = renderStartTime;
+          supportsUserTiming &&
+            ((reusableLaneDevToolDetails.color =
+              (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+            (reusableLaneOptions.start = previousRenderStartTime),
+            (reusableLaneOptions.end = endTime),
+            performance.measure(
+              (lanes & 536870912) === lanes
+                ? "Prewarm"
+                : (lanes & 201326677) === lanes
+                  ? "Interrupted Hydration"
+                  : "Interrupted Render",
+              reusableLaneOptions
+            ));
+        }
+        finalizeRender(workInProgressRootRenderLanes, renderStartTime);
+      }
+      if (0 !== (lanes & 3) || 0 !== (lanes & 60)) {
+        previousRenderStartTime =
+          0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime
+            ? blockingClampTime
+            : blockingUpdateTime;
+        endTime =
+          0 <= blockingEventTime && blockingEventTime < blockingClampTime
+            ? blockingClampTime
+            : blockingEventTime;
+        0 <= blockingSuspendedTime &&
+          (setCurrentTrackFromLanes(lanes),
+          logSuspendedWithDelayPhase(
+            blockingSuspendedTime,
+            0 <= endTime
+              ? endTime
+              : 0 <= previousRenderStartTime
+                ? previousRenderStartTime
+                : renderStartTime,
+            lanes
+          ));
+        var eventType = blockingEventType,
+          eventIsRepeat = blockingEventIsRepeat,
+          isSpawnedUpdate = blockingSpawnedUpdate,
+          renderStartTime$jscomp$0 = renderStartTime;
+        supportsUserTiming &&
+          ((reusableLaneDevToolDetails.track = "Blocking"),
+          0 < endTime &&
+            null !== eventType &&
+            ((reusableLaneDevToolDetails.color = eventIsRepeat
+              ? "secondary-light"
+              : "warning"),
+            (reusableLaneOptions.start = endTime),
+            (reusableLaneOptions.end =
+              0 < previousRenderStartTime
+                ? previousRenderStartTime
+                : renderStartTime$jscomp$0),
+            performance.measure(
+              eventIsRepeat ? "" : "Event: " + eventType,
+              reusableLaneOptions
+            )),
+          0 < previousRenderStartTime &&
+            ((reusableLaneDevToolDetails.color = isSpawnedUpdate
+              ? "error"
+              : (lanes & 738197589) === lanes
+                ? "tertiary-light"
+                : "primary-light"),
+            (reusableLaneOptions.start = previousRenderStartTime),
+            (reusableLaneOptions.end = renderStartTime$jscomp$0),
+            performance.measure(
+              isSpawnedUpdate ? "Cascade" : "Blocked",
+              reusableLaneOptions
+            )));
+        blockingSuspendedTime = blockingUpdateTime = -1.1;
+        blockingEventIsRepeat = !0;
+        blockingSpawnedUpdate = !1;
+      }
+      0 !== (lanes & 4194176) &&
+        ((previousRenderStartTime =
+          0 <= transitionStartTime && transitionStartTime < transitionClampTime
+            ? transitionClampTime
+            : transitionStartTime),
+        (endTime =
+          0 <= transitionUpdateTime &&
+          transitionUpdateTime < transitionClampTime
+            ? transitionClampTime
+            : transitionUpdateTime),
+        (eventType =
+          0 <= transitionEventTime && transitionEventTime < transitionClampTime
+            ? transitionClampTime
+            : transitionEventTime),
+        0 <= transitionSuspendedTime &&
+          (setCurrentTrackFromLanes(lanes),
+          logSuspendedWithDelayPhase(
+            transitionSuspendedTime,
+            0 <= eventType
+              ? eventType
+              : 0 <= endTime
+                ? endTime
+                : renderStartTime,
+            lanes
+          )),
+        (eventIsRepeat = transitionEventType),
+        (isSpawnedUpdate = transitionEventIsRepeat),
+        (renderStartTime$jscomp$0 = renderStartTime),
+        supportsUserTiming &&
+          ((reusableLaneDevToolDetails.track = "Transition"),
+          0 < eventType &&
+            null !== eventIsRepeat &&
+            ((reusableLaneDevToolDetails.color = isSpawnedUpdate
+              ? "secondary-light"
+              : "warning"),
+            (reusableLaneOptions.start = eventType),
+            (reusableLaneOptions.end =
+              0 < previousRenderStartTime
+                ? previousRenderStartTime
+                : 0 < endTime
+                  ? endTime
+                  : renderStartTime$jscomp$0),
+            performance.measure(
+              isSpawnedUpdate ? "" : "Event: " + eventIsRepeat,
+              reusableLaneOptions
+            )),
+          0 < previousRenderStartTime &&
+            ((reusableLaneDevToolDetails.color = "primary-dark"),
+            (reusableLaneOptions.start = previousRenderStartTime),
+            (reusableLaneOptions.end =
+              0 < endTime ? endTime : renderStartTime$jscomp$0),
+            performance.measure("Action", reusableLaneOptions)),
+          0 < endTime &&
+            ((reusableLaneDevToolDetails.color = "primary-light"),
+            (reusableLaneOptions.start = endTime),
+            (reusableLaneOptions.end = renderStartTime$jscomp$0),
+            performance.measure("Blocked", reusableLaneOptions))),
+        (transitionSuspendedTime =
+          transitionUpdateTime =
+          transitionStartTime =
+            -1.1),
+        (transitionEventIsRepeat = !0));
+      previousRenderStartTime = root.timeoutHandle;
+      previousRenderStartTime !== noTimeout &&
+        ((root.timeoutHandle = noTimeout),
+        cancelTimeout(previousRenderStartTime));
+      previousRenderStartTime = root.cancelPendingCommit;
+      null !== previousRenderStartTime &&
+        ((root.cancelPendingCommit = null), previousRenderStartTime());
       resetWorkInProgressStack();
       workInProgressRoot = root;
-      workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
+      workInProgress = previousRenderStartTime = createWorkInProgress(
+        root.current,
+        null
+      );
       workInProgressRootRenderLanes = lanes;
       workInProgressSuspendedReason = NotSuspended;
       workInProgressThrownValue = null;
@@ -14617,22 +16407,17 @@
       workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
       workInProgressAppearingViewTransitions = null;
       0 !== (lanes & 8) && (lanes |= lanes & 32);
-      var allEntangledLanes = root.entangledLanes;
-      if (0 !== allEntangledLanes)
-        for (
-          root = root.entanglements, allEntangledLanes &= lanes;
-          0 < allEntangledLanes;
-
-        ) {
-          var index = 31 - clz32(allEntangledLanes),
-            lane = 1 << index;
-          lanes |= root[index];
-          allEntangledLanes &= ~lane;
-        }
+      endTime = root.entangledLanes;
+      if (0 !== endTime)
+        for (root = root.entanglements, endTime &= lanes; 0 < endTime; )
+          (eventType = 31 - clz32(endTime)),
+            (eventIsRepeat = 1 << eventType),
+            (lanes |= root[eventType]),
+            (endTime &= ~eventIsRepeat);
       entangledRenderLanes = lanes;
       finishQueueingConcurrentUpdates();
       ReactStrictModeWarnings.discardPendingWarnings();
-      return timeoutHandle;
+      return previousRenderStartTime;
     }
     function handleThrow(root, thrownValue) {
       currentlyRenderingFiber = null;
@@ -14657,43 +16442,14 @@
                   : SuspendedOnError);
       workInProgressThrownValue = thrownValue;
       var erroredWork = workInProgress;
-      if (null === erroredWork)
-        (workInProgressRootExitStatus = RootFatalErrored),
+      null === erroredWork
+        ? ((workInProgressRootExitStatus = RootFatalErrored),
           logUncaughtError(
             root,
             createCapturedValueAtFiber(thrownValue, root.current)
-          );
-      else
-        switch (
-          (erroredWork.mode & ProfileMode &&
-            stopProfilerTimerIfRunningAndRecordDuration(erroredWork),
-          markComponentRenderStopped(),
-          workInProgressSuspendedReason)
-        ) {
-          case SuspendedOnError:
-            null !== injectedProfilingHooks &&
-              "function" ===
-                typeof injectedProfilingHooks.markComponentErrored &&
-              injectedProfilingHooks.markComponentErrored(
-                erroredWork,
-                thrownValue,
-                workInProgressRootRenderLanes
-              );
-            break;
-          case SuspendedOnData:
-          case SuspendedOnAction:
-          case SuspendedOnImmediate:
-          case SuspendedOnDeprecatedThrowPromise:
-          case SuspendedAndReadyToContinue:
-            null !== injectedProfilingHooks &&
-              "function" ===
-                typeof injectedProfilingHooks.markComponentSuspended &&
-              injectedProfilingHooks.markComponentSuspended(
-                erroredWork,
-                thrownValue,
-                workInProgressRootRenderLanes
-              );
-        }
+          ))
+        : erroredWork.mode & ProfileMode &&
+          stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
     }
     function pushDispatcher() {
       var prevDispatcher = ReactSharedInternals.H;
@@ -14722,6 +16478,23 @@
           !1
         );
     }
+    function queueConcurrentError(error) {
+      null === workInProgressRootConcurrentErrors
+        ? (workInProgressRootConcurrentErrors = [error])
+        : workInProgressRootConcurrentErrors.push(error);
+    }
+    function trackAppearingViewTransition(instance, name) {
+      if (null === workInProgressAppearingViewTransitions) {
+        if (
+          (workInProgressRootRenderLanes & 335544192) !==
+          workInProgressRootRenderLanes
+        )
+          return;
+        workInProgressAppearingViewTransitions = new Map();
+      }
+      instance.paired = null;
+      workInProgressAppearingViewTransitions.set(name, instance);
+    }
     function renderRootSync(root, lanes, shouldYieldForPrerendering) {
       var prevExecutionContext = executionContext;
       executionContext |= RenderContext;
@@ -14741,7 +16514,6 @@
         workInProgressTransitions = null;
         prepareFreshStack(root, lanes);
       }
-      markRenderStarted(lanes);
       lanes = !1;
       memoizedUpdaters = workInProgressRootExitStatus;
       a: do
@@ -14793,7 +16565,6 @@
       executionContext = prevExecutionContext;
       ReactSharedInternals.H = prevDispatcher;
       ReactSharedInternals.A = prevAsyncDispatcher;
-      markRenderStopped();
       null === workInProgress &&
         ((workInProgressRoot = null),
         (workInProgressRootRenderLanes = 0),
@@ -14827,7 +16598,6 @@
           root,
           lanes
         );
-      markRenderStarted(lanes);
       a: do
         try {
           if (
@@ -14956,14 +16726,7 @@
       ReactSharedInternals.H = prevDispatcher;
       ReactSharedInternals.A = prevAsyncDispatcher;
       executionContext = prevExecutionContext;
-      if (null !== workInProgress)
-        return (
-          null !== injectedProfilingHooks &&
-            "function" === typeof injectedProfilingHooks.markRenderYielded &&
-            injectedProfilingHooks.markRenderYielded(),
-          RootInProgress
-        );
-      markRenderStopped();
+      if (null !== workInProgress) return RootInProgress;
       workInProgressRoot = null;
       workInProgressRootRenderLanes = 0;
       finishQueueingConcurrentUpdates();
@@ -15178,7 +16941,11 @@
       didIncludeRenderPhaseUpdate,
       spawnedLane,
       updatedLanes,
-      suspendedRetryLanes
+      suspendedRetryLanes,
+      exitStatus,
+      suspendedCommitReason,
+      completedRenderStartTime,
+      completedRenderEndTime
     ) {
       root.cancelPendingCommit = null;
       do flushPendingEffects();
@@ -15187,11 +16954,29 @@
       ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
       if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
         throw Error("Should not already be working.");
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markCommitStarted &&
-        injectedProfilingHooks.markCommitStarted(lanes);
-      if (null === finishedWork) markCommitStopped();
-      else {
+      setCurrentTrackFromLanes(lanes);
+      exitStatus === RootErrored
+        ? logErroredRenderPhase(
+            completedRenderStartTime,
+            completedRenderEndTime
+          )
+        : null !== recoverableErrors
+          ? logRecoveredRenderPhase(
+              completedRenderStartTime,
+              completedRenderEndTime,
+              lanes,
+              recoverableErrors,
+              null !== finishedWork &&
+                null !== finishedWork.alternate &&
+                finishedWork.alternate.memoizedState.isDehydrated &&
+                0 !== (finishedWork.flags & 256)
+            )
+          : logRenderPhase(
+              completedRenderStartTime,
+              completedRenderEndTime,
+              lanes
+            );
+      if (null !== finishedWork) {
         0 === lanes &&
           console.error(
             "finishedLanes should not be empty during a commit. This is a bug in React."
@@ -15220,23 +17005,37 @@
         pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
         pendingPassiveTransitions = transitions;
         pendingRecoverableErrors = recoverableErrors;
-        0 !== (finishedWork.subtreeFlags & 10256) ||
-        0 !== (finishedWork.flags & 10256)
+        pendingViewTransitionEvents = null;
+        pendingEffectsRenderEndTime = completedRenderEndTime;
+        pendingSuspendedCommitReason = suspendedCommitReason;
+        recoverableErrors = (lanes & 335544192) === lanes ? 10262 : 10256;
+        0 !== finishedWork.actualDuration ||
+        0 !== (finishedWork.subtreeFlags & recoverableErrors) ||
+        0 !== (finishedWork.flags & recoverableErrors)
           ? ((root.callbackNode = null),
             (root.callbackPriority = 0),
             scheduleCallback$1(NormalPriority$1, function () {
+              schedulerEvent = window.event;
               flushPassiveEffects(!0);
               return null;
             }))
           : ((root.callbackNode = null), (root.callbackPriority = 0));
+        commitErrors = null;
         commitStartTime = now();
-        recoverableErrors = 0 !== (finishedWork.flags & 13878);
-        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
-          recoverableErrors = ReactSharedInternals.T;
+        suspendedCommitReason === SUSPENDED_COMMIT
+          ? logSuspendedCommitPhase(completedRenderEndTime, commitStartTime)
+          : suspendedCommitReason === THROTTLED_COMMIT &&
+            logSuspenseThrottlePhase(completedRenderEndTime, commitStartTime);
+        suspendedCommitReason = 0 !== (finishedWork.flags & 13878);
+        if (
+          0 !== (finishedWork.subtreeFlags & 13878) ||
+          suspendedCommitReason
+        ) {
+          suspendedCommitReason = ReactSharedInternals.T;
           ReactSharedInternals.T = null;
-          transitions = ReactDOMSharedInternals.p;
+          completedRenderEndTime = ReactDOMSharedInternals.p;
           ReactDOMSharedInternals.p = DiscreteEventPriority;
-          spawnedLane = executionContext;
+          recoverableErrors = executionContext;
           executionContext |= CommitContext;
           try {
             commitBeforeMutationEffects(
@@ -15246,16 +17045,32 @@
               appearingViewTransitions
             );
           } finally {
-            (executionContext = spawnedLane),
-              (ReactDOMSharedInternals.p = transitions),
-              (ReactSharedInternals.T = recoverableErrors);
+            (executionContext = recoverableErrors),
+              (ReactDOMSharedInternals.p = completedRenderEndTime),
+              (ReactSharedInternals.T = suspendedCommitReason);
           }
         }
         pendingEffectsStatus = PENDING_MUTATION_PHASE;
-        flushMutationEffects();
-        flushLayoutEffects();
-        flushSpawnedWork();
-      }
+        (shouldStartViewTransition &&
+          startViewTransition(
+            root.containerInfo,
+            flushMutationEffects,
+            flushLayoutEffects,
+            flushAfterMutationEffects,
+            flushSpawnedWork,
+            flushPassiveEffects
+          )) ||
+          (flushMutationEffects(), flushLayoutEffects(), flushSpawnedWork());
+      }
+    }
+    function flushAfterMutationEffects() {
+      pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE &&
+        ((pendingEffectsStatus = NO_PENDING_EFFECTS),
+        commitAfterMutationEffectsOnFiber(
+          pendingFinishedWork,
+          pendingEffectsRoot
+        ),
+        (pendingEffectsStatus = PENDING_SPAWNED_WORK));
     }
     function flushMutationEffects() {
       if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
@@ -15277,7 +17092,8 @@
           try {
             inProgressLanes = lanes;
             inProgressRoot = root;
-            commitMutationEffectsOnFiber(finishedWork, root);
+            resetComponentEffectTimers();
+            commitMutationEffectsOnFiber(finishedWork, root, lanes);
             inProgressRoot = inProgressLanes = null;
             lanes = selectionInformation;
             var curFocusedElem = getActiveElementDeep(root.containerInfo),
@@ -15404,22 +17220,15 @@
           var prevExecutionContext = executionContext;
           executionContext |= CommitContext;
           try {
-            null !== injectedProfilingHooks &&
-              "function" ===
-                typeof injectedProfilingHooks.markLayoutEffectsStarted &&
-              injectedProfilingHooks.markLayoutEffectsStarted(lanes),
-              (inProgressLanes = lanes),
+            (inProgressLanes = lanes),
               (inProgressRoot = root),
+              resetComponentEffectTimers(),
               commitLayoutEffectOnFiber(
                 root,
                 finishedWork.alternate,
                 finishedWork
               ),
-              (inProgressRoot = inProgressLanes = null),
-              null !== injectedProfilingHooks &&
-                "function" ===
-                  typeof injectedProfilingHooks.markLayoutEffectsStopped &&
-                injectedProfilingHooks.markLayoutEffectsStopped();
+              (inProgressRoot = inProgressLanes = null);
           } finally {
             (executionContext = prevExecutionContext),
               (ReactDOMSharedInternals.p = previousPriority),
@@ -15439,21 +17248,43 @@
         var root = pendingEffectsRoot,
           finishedWork = pendingFinishedWork,
           lanes = pendingEffectsLanes,
+          completedRenderEndTime = pendingEffectsRenderEndTime,
           recoverableErrors = pendingRecoverableErrors,
-          rootDidHavePassiveEffects =
-            0 !== (finishedWork.subtreeFlags & 10256) ||
-            0 !== (finishedWork.flags & 10256);
-        rootDidHavePassiveEffects
+          suspendedCommitReason = pendingSuspendedCommitReason;
+        commitEndTime = now();
+        completedRenderEndTime =
+          suspendedCommitReason === IMMEDIATE_COMMIT
+            ? completedRenderEndTime
+            : commitStartTime;
+        suspendedCommitReason = commitEndTime;
+        null !== commitErrors
+          ? logCommitErrored(
+              completedRenderEndTime,
+              suspendedCommitReason,
+              commitErrors,
+              !1
+            )
+          : supportsUserTiming &&
+            ((reusableLaneDevToolDetails.color = "secondary-dark"),
+            (reusableLaneOptions.start = completedRenderEndTime),
+            (reusableLaneOptions.end = suspendedCommitReason),
+            performance.measure("Commit", reusableLaneOptions));
+        completedRenderEndTime = (lanes & 335544192) === lanes ? 10262 : 10256;
+        (completedRenderEndTime =
+          0 !== finishedWork.actualDuration ||
+          0 !== (finishedWork.subtreeFlags & completedRenderEndTime) ||
+          0 !== (finishedWork.flags & completedRenderEndTime))
           ? (pendingEffectsStatus = PENDING_PASSIVE_PHASE)
           : ((pendingEffectsStatus = NO_PENDING_EFFECTS),
             (pendingEffectsRoot = null),
             releaseRootPooledCache(root, root.pendingLanes),
             (nestedPassiveUpdateCount = 0),
             (rootWithPassiveNestedUpdates = null));
-        var remainingLanes = root.pendingLanes;
-        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
-        rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root);
-        rootDidHavePassiveEffects = lanesToEventPriority(lanes);
+        suspendedCommitReason = root.pendingLanes;
+        0 === suspendedCommitReason &&
+          (legacyErrorBoundariesThatAlreadyFailed = null);
+        completedRenderEndTime || commitDoubleInvokeEffectsInDEV(root);
+        suspendedCommitReason = lanesToEventPriority(lanes);
         finishedWork = finishedWork.stateNode;
         if (
           injectedHook &&
@@ -15461,7 +17292,7 @@
         )
           try {
             var didError = 128 === (finishedWork.current.flags & 128);
-            switch (rootDidHavePassiveEffects) {
+            switch (suspendedCommitReason) {
               case DiscreteEventPriority:
                 var schedulerPriority = ImmediatePriority;
                 break;
@@ -15519,17 +17350,25 @@
               (ReactDOMSharedInternals.p = schedulerPriority);
           }
         }
+        recoverableErrors = pendingViewTransitionEvents;
+        if (null !== recoverableErrors)
+          for (
+            pendingViewTransitionEvents = null, onRecoverableError = 0;
+            onRecoverableError < recoverableErrors.length;
+            onRecoverableError++
+          )
+            (0, recoverableErrors[onRecoverableError])();
         0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
         ensureRootIsScheduled(root);
-        remainingLanes = root.pendingLanes;
-        0 !== (lanes & 4194218) && 0 !== (remainingLanes & 42)
+        suspendedCommitReason = root.pendingLanes;
+        0 !== (lanes & 4194218) && 0 !== (suspendedCommitReason & 42)
           ? ((nestedUpdateScheduled = !0),
             root === rootWithNestedUpdates
               ? nestedUpdateCount++
               : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)))
           : (nestedUpdateCount = 0);
+        completedRenderEndTime || finalizeRender(lanes, commitEndTime);
         flushSyncWorkAcrossRoots_impl(0, !1);
-        markCommitStopped();
       }
     }
     function makeErrorInfo(componentStack) {
@@ -15555,7 +17394,7 @@
       flushSpawnedWork();
       return flushPassiveEffects(wasDelayedCommit);
     }
-    function flushPassiveEffects() {
+    function flushPassiveEffects(wasDelayedCommit) {
       if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return !1;
       var root = pendingEffectsRoot,
         remainingLanes = pendingEffectsRemainingLanes;
@@ -15570,42 +17409,70 @@
       try {
         ReactDOMSharedInternals.p = priority;
         ReactSharedInternals.T = null;
-        priority = pendingPassiveTransitions;
+        var transitions = pendingPassiveTransitions;
         pendingPassiveTransitions = null;
-        var root$jscomp$0 = pendingEffectsRoot,
-          lanes = pendingEffectsLanes;
+        priority = pendingEffectsRoot;
+        var lanes = pendingEffectsLanes;
         pendingEffectsStatus = NO_PENDING_EFFECTS;
         pendingEffectsRoot = null;
         pendingEffectsLanes = 0;
         if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
           throw Error("Cannot flush passive effects while already rendering.");
+        setCurrentTrackFromLanes(lanes);
         isFlushingPassiveEffects = !0;
         didScheduleUpdateDuringPassiveEffects = !1;
-        null !== injectedProfilingHooks &&
-          "function" ===
-            typeof injectedProfilingHooks.markPassiveEffectsStarted &&
-          injectedProfilingHooks.markPassiveEffectsStarted(lanes);
-        var prevExecutionContext = executionContext;
+        var passiveEffectStartTime = 0;
+        commitErrors = null;
+        passiveEffectStartTime = now$1();
+        var startTime = commitEndTime,
+          endTime = passiveEffectStartTime;
+        wasDelayedCommit = !!wasDelayedCommit;
+        supportsUserTiming &&
+          ((reusableLaneDevToolDetails.color = "secondary-light"),
+          (reusableLaneOptions.start = startTime),
+          (reusableLaneOptions.end = endTime),
+          performance.measure(
+            wasDelayedCommit ? "Waiting for Paint" : "",
+            reusableLaneOptions
+          ));
+        wasDelayedCommit = executionContext;
         executionContext |= CommitContext;
-        commitPassiveUnmountOnFiber(root$jscomp$0.current);
+        var finishedWork = priority.current;
+        resetComponentEffectTimers();
+        commitPassiveUnmountOnFiber(finishedWork);
+        var finishedWork$jscomp$0 = priority.current;
+        finishedWork = pendingEffectsRenderEndTime;
+        resetComponentEffectTimers();
         commitPassiveMountOnFiber(
-          root$jscomp$0,
-          root$jscomp$0.current,
+          priority,
+          finishedWork$jscomp$0,
           lanes,
-          priority
+          transitions,
+          finishedWork
         );
-        null !== injectedProfilingHooks &&
-          "function" ===
-            typeof injectedProfilingHooks.markPassiveEffectsStopped &&
-          injectedProfilingHooks.markPassiveEffectsStopped();
-        commitDoubleInvokeEffectsInDEV(root$jscomp$0);
-        executionContext = prevExecutionContext;
+        commitDoubleInvokeEffectsInDEV(priority);
+        executionContext = wasDelayedCommit;
+        var passiveEffectsEndTime = now$1();
+        finishedWork$jscomp$0 = passiveEffectStartTime;
+        null !== commitErrors
+          ? logCommitErrored(
+              finishedWork$jscomp$0,
+              passiveEffectsEndTime,
+              commitErrors,
+              !0
+            )
+          : supportsUserTiming &&
+            ((reusableLaneDevToolDetails.color = "secondary-dark"),
+            (reusableLaneOptions.start = finishedWork$jscomp$0),
+            (reusableLaneOptions.end = passiveEffectsEndTime),
+            performance.measure("Remaining Effects", reusableLaneOptions));
+        finalizeRender(lanes, passiveEffectsEndTime);
         flushSyncWorkAcrossRoots_impl(0, !1);
         didScheduleUpdateDuringPassiveEffects
-          ? root$jscomp$0 === rootWithPassiveNestedUpdates
+          ? priority === rootWithPassiveNestedUpdates
             ? nestedPassiveUpdateCount++
             : ((nestedPassiveUpdateCount = 0),
-              (rootWithPassiveNestedUpdates = root$jscomp$0))
+              (rootWithPassiveNestedUpdates = priority))
           : (nestedPassiveUpdateCount = 0);
         didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;
         if (
@@ -15613,7 +17480,7 @@
           "function" === typeof injectedHook.onPostCommitFiberRoot
         )
           try {
-            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
+            injectedHook.onPostCommitFiberRoot(rendererID, priority);
           } catch (err) {
             hasLoggedError ||
               ((hasLoggedError = !0),
@@ -15622,7 +17489,7 @@
                 err
               ));
           }
-        var stateNode = root$jscomp$0.current.stateNode;
+        var stateNode = priority.current.stateNode;
         stateNode.effectDuration = 0;
         stateNode.passiveEffectDuration = 0;
         return !0;
@@ -15634,6 +17501,7 @@
     }
     function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
       sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+      recordEffectError(sourceFiber);
       sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
       rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
       null !== rootFiber &&
@@ -15667,6 +17535,7 @@
                   !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
             ) {
               sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+              recordEffectError(sourceFiber);
               error = createClassErrorUpdate(2);
               instance = enqueueUpdate(nearestMountedAncestor, error, 2);
               null !== instance &&
@@ -15711,6 +17580,12 @@
       null !== pingCache && pingCache.delete(wakeable);
       root.pingedLanes |= root.suspendedLanes & pingedLanes;
       root.warmLanes &= ~pingedLanes;
+      0 !== (pingedLanes & 3) || 0 !== (pingedLanes & 60)
+        ? 0 > blockingUpdateTime &&
+          (blockingClampTime = blockingUpdateTime = now())
+        : 0 !== (pingedLanes & 4194176) &&
+          0 > transitionUpdateTime &&
+          (transitionClampTime = transitionUpdateTime = now());
       isConcurrentActEnvironment() &&
         null === ReactSharedInternals.actQueue &&
         console.error(
@@ -15938,6 +17813,7 @@
       }
     }
     function processRootScheduleInImmediateTask() {
+      schedulerEvent = window.event;
       processRootScheduleInMicrotask();
     }
     function processRootScheduleInMicrotask() {
@@ -16008,47 +17884,49 @@
           (root.callbackPriority = 0)
         );
       if (
-        0 === (suspendedLanes & 3) ||
-        checkIfRootIsPrerendering(root, suspendedLanes)
-      ) {
-        currentTime = suspendedLanes & -suspendedLanes;
-        if (
-          currentTime !== root.callbackPriority ||
-          (null !== ReactSharedInternals.actQueue &&
-            pingedLanes !== fakeActCallbackNode)
-        )
-          cancelCallback(pingedLanes);
-        else return currentTime;
-        switch (lanesToEventPriority(suspendedLanes)) {
-          case DiscreteEventPriority:
-          case ContinuousEventPriority:
-            suspendedLanes = UserBlockingPriority;
-            break;
-          case DefaultEventPriority:
-            suspendedLanes = NormalPriority$1;
-            break;
-          case IdleEventPriority:
-            suspendedLanes = IdlePriority;
-            break;
-          default:
-            suspendedLanes = NormalPriority$1;
-        }
-        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
-        null !== ReactSharedInternals.actQueue
-          ? (ReactSharedInternals.actQueue.push(pingedLanes),
-            (suspendedLanes = fakeActCallbackNode))
-          : (suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes));
-        root.callbackPriority = currentTime;
-        root.callbackNode = suspendedLanes;
-        return currentTime;
-      }
-      null !== pingedLanes && cancelCallback(pingedLanes);
-      root.callbackPriority = 2;
-      root.callbackNode = null;
-      return 2;
+        0 !== (suspendedLanes & 3) &&
+        !checkIfRootIsPrerendering(root, suspendedLanes)
+      )
+        return (
+          null !== pingedLanes && cancelCallback(pingedLanes),
+          (root.callbackPriority = 2),
+          (root.callbackNode = null),
+          2
+        );
+      currentTime = suspendedLanes & -suspendedLanes;
+      if (
+        currentTime !== root.callbackPriority ||
+        (null !== ReactSharedInternals.actQueue &&
+          pingedLanes !== fakeActCallbackNode)
+      )
+        cancelCallback(pingedLanes);
+      else return currentTime;
+      switch (lanesToEventPriority(suspendedLanes)) {
+        case DiscreteEventPriority:
+        case ContinuousEventPriority:
+          suspendedLanes = UserBlockingPriority;
+          break;
+        case DefaultEventPriority:
+          suspendedLanes = NormalPriority$1;
+          break;
+        case IdleEventPriority:
+          suspendedLanes = IdlePriority;
+          break;
+        default:
+          suspendedLanes = NormalPriority$1;
+      }
+      pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
+      null !== ReactSharedInternals.actQueue
+        ? (ReactSharedInternals.actQueue.push(pingedLanes),
+          (suspendedLanes = fakeActCallbackNode))
+        : (suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes));
+      root.callbackPriority = currentTime;
+      root.callbackNode = suspendedLanes;
+      return currentTime;
     }
     function performWorkOnRootViaSchedulerTask(root, didTimeout) {
       nestedUpdateScheduled = currentUpdateIsNested = !1;
+      schedulerEvent = window.event;
       if (
         pendingEffectsStatus !== NO_PENDING_EFFECTS &&
         pendingEffectsStatus !== PENDING_PASSIVE_PHASE
@@ -16216,6 +18094,15 @@
         });
       }
     }
+    function executeDispatch(event, listener, currentTarget) {
+      event.currentTarget = currentTarget;
+      try {
+        listener(event);
+      } catch (error) {
+        reportGlobalError(error);
+      }
+      event.currentTarget = null;
+    }
     function processDispatchQueue(dispatchQueue, eventSystemFlags) {
       eventSystemFlags = 0 !== (eventSystemFlags & 4);
       for (var i = 0; i < dispatchQueue.length; i++) {
@@ -16236,14 +18123,15 @@
               _dispatchListeners$i = _dispatchListeners$i.listener;
               if (instance !== previousInstance && event.isPropagationStopped())
                 break a;
-              previousInstance = event;
-              previousInstance.currentTarget = currentTarget;
-              try {
-                _dispatchListeners$i(previousInstance);
-              } catch (error) {
-                reportGlobalError(error);
-              }
-              previousInstance.currentTarget = null;
+              null !== instance
+                ? runWithFiberInDEV(
+                    instance,
+                    executeDispatch,
+                    event,
+                    _dispatchListeners$i,
+                    currentTarget
+                  )
+                : executeDispatch(event, _dispatchListeners$i, currentTarget);
               previousInstance = instance;
             }
           else
@@ -16258,14 +18146,15 @@
               _dispatchListeners$i = _dispatchListeners$i.listener;
               if (instance !== previousInstance && event.isPropagationStopped())
                 break a;
-              previousInstance = event;
-              previousInstance.currentTarget = currentTarget;
-              try {
-                _dispatchListeners$i(previousInstance);
-              } catch (error) {
-                reportGlobalError(error);
-              }
-              previousInstance.currentTarget = null;
+              null !== instance
+                ? runWithFiberInDEV(
+                    instance,
+                    executeDispatch,
+                    event,
+                    _dispatchListeners$i,
+                    currentTarget
+                  )
+                : executeDispatch(event, _dispatchListeners$i, currentTarget);
               previousInstance = instance;
             }
         }
@@ -17050,6 +18939,7 @@
           else if ("number" === typeof value || "bigint" === typeof value)
             validateTextNesting("" + value, tag),
               "body" !== tag && setTextContent(domElement, "" + value);
+          else return;
           break;
         case "className":
           setValueForKnownAttribute(domElement, "class", value);
@@ -17066,7 +18956,7 @@
           break;
         case "style":
           setValueForStyles(domElement, value, prevValue);
-          break;
+          return;
         case "data":
           if ("object" !== tag) {
             setValueForKnownAttribute(domElement, "data", value);
@@ -17240,19 +19130,19 @@
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             (domElement.onclick = noop$1));
-          break;
+          return;
         case "onScroll":
           null != value &&
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             listenToNonDelegatedEvent("scroll", domElement));
-          break;
+          return;
         case "onScrollEnd":
           null != value &&
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             listenToNonDelegatedEvent("scrollend", domElement));
-          break;
+          return;
         case "dangerouslySetInnerHTML":
           if (null != value) {
             if ("object" !== typeof value || !("__html" in value))
@@ -17470,7 +19360,7 @@
           break;
         case "innerText":
         case "textContent":
-          break;
+          return;
         case "popoverTarget":
           didWarnPopoverTargetObject ||
             null == value ||
@@ -17481,16 +19371,22 @@
               value
             ));
         default:
-          !(2 < key.length) ||
-          ("o" !== key[0] && "O" !== key[0]) ||
-          ("n" !== key[1] && "N" !== key[1])
-            ? ((key = getAttributeAlias(key)),
-              setValueForAttribute(domElement, key, value))
-            : registrationNameDependencies.hasOwnProperty(key) &&
+          if (
+            !(2 < key.length) ||
+            ("o" !== key[0] && "O" !== key[0]) ||
+            ("n" !== key[1] && "N" !== key[1])
+          )
+            (key = getAttributeAlias(key)),
+              setValueForAttribute(domElement, key, value);
+          else {
+            registrationNameDependencies.hasOwnProperty(key) &&
               null != value &&
               "function" !== typeof value &&
               warnForInvalidEventListener(key, value);
+            return;
+          }
       }
+      viewTransitionMutationContext = !0;
     }
     function setPropOnCustomElement(
       domElement,
@@ -17503,7 +19399,7 @@
       switch (key) {
         case "style":
           setValueForStyles(domElement, value, prevValue);
-          break;
+          return;
         case "dangerouslySetInnerHTML":
           if (null != value) {
             if ("object" !== typeof value || !("__html" in value))
@@ -17521,37 +19417,37 @@
           }
           break;
         case "children":
-          "string" === typeof value
-            ? setTextContent(domElement, value)
-            : ("number" === typeof value || "bigint" === typeof value) &&
-              setTextContent(domElement, "" + value);
+          if ("string" === typeof value) setTextContent(domElement, value);
+          else if ("number" === typeof value || "bigint" === typeof value)
+            setTextContent(domElement, "" + value);
+          else return;
           break;
         case "onScroll":
           null != value &&
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             listenToNonDelegatedEvent("scroll", domElement));
-          break;
+          return;
         case "onScrollEnd":
           null != value &&
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             listenToNonDelegatedEvent("scrollend", domElement));
-          break;
+          return;
         case "onClick":
           null != value &&
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             (domElement.onclick = noop$1));
-          break;
+          return;
         case "suppressContentEditableWarning":
         case "suppressHydrationWarning":
         case "innerHTML":
         case "ref":
-          break;
+          return;
         case "innerText":
         case "textContent":
-          break;
+          return;
         default:
           if (registrationNameDependencies.hasOwnProperty(key))
             null != value &&
@@ -17579,13 +19475,16 @@
                 domElement.addEventListener(tag, value, props);
                 break a;
               }
+              viewTransitionMutationContext = !0;
               key in domElement
                 ? (domElement[key] = value)
                 : !0 === value
                   ? domElement.setAttribute(key, "")
                   : setValueForAttribute(domElement, key, value);
             }
+          return;
       }
+      viewTransitionMutationContext = !0;
     }
     function setInitialProperties(domElement, tag, props) {
       validatePropertiesInDevelopment(tag, props);
@@ -17903,21 +19802,27 @@
             )
               switch (_propKey8) {
                 case "type":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   type = propKey;
                   break;
                 case "name":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   name = propKey;
                   break;
                 case "checked":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   checked = propKey;
                   break;
                 case "defaultChecked":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   defaultChecked = propKey;
                   break;
                 case "value":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   value = propKey;
                   break;
                 case "defaultValue":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   defaultValue = propKey;
                   break;
                 case "children":
@@ -18005,13 +19910,19 @@
             )
               switch (name) {
                 case "value":
+                  type !== lastDefaultValue &&
+                    (viewTransitionMutationContext = !0);
                   _propKey8 = type;
                   break;
                 case "defaultValue":
+                  type !== lastDefaultValue &&
+                    (viewTransitionMutationContext = !0);
                   defaultValue = type;
                   break;
                 case "multiple":
-                  value = type;
+                  type !== lastDefaultValue &&
+                    (viewTransitionMutationContext = !0),
+                    (value = type);
                 default:
                   type !== lastDefaultValue &&
                     setProp(
@@ -18058,9 +19969,11 @@
             )
               switch (value) {
                 case "value":
+                  name !== type && (viewTransitionMutationContext = !0);
                   _propKey8 = name;
                   break;
                 case "defaultValue":
+                  name !== type && (viewTransitionMutationContext = !0);
                   propKey = name;
                   break;
                 case "children":
@@ -18109,6 +20022,7 @@
             )
               switch (lastDefaultValue) {
                 case "selected":
+                  _propKey8 !== propKey && (viewTransitionMutationContext = !0);
                   domElement.selected =
                     _propKey8 &&
                     "function" !== typeof _propKey8 &&
@@ -19171,6 +21085,14 @@
       currentPopstateTransitionEvent = null;
       return !1;
     }
+    function resolveEventType() {
+      var event = window.event;
+      return event && event !== schedulerEvent ? event.type : null;
+    }
+    function resolveEventTimeStamp() {
+      var event = window.event;
+      return event && event !== schedulerEvent ? event.timeStamp : -1.1;
+    }
     function handleErrorInNextTick(error) {
       setTimeout(function () {
         throw error;
@@ -19204,20 +21126,9 @@
       parentInstance.removeChild(child);
     }
     function removeChildFromContainer(container, child) {
-      switch (container.nodeType) {
-        case 8:
-          container = container.parentNode;
-          break;
-        case 9:
-          container = container.body;
-          break;
-        default:
-          container =
-            "HTML" === container.nodeName
-              ? container.ownerDocument.body
-              : container;
-      }
-      container.removeChild(child);
+      8 === container.nodeType
+        ? container.parentNode.removeChild(child)
+        : container.removeChild(child);
     }
     function clearSuspenseBoundary(parentInstance, suspenseInstance) {
       var node = suspenseInstance,
@@ -19263,6 +21174,134 @@
     function unhideTextInstance(textInstance, text) {
       textInstance.nodeValue = text;
     }
+    function restoreViewTransitionName(instance, props) {
+      props = props[STYLE];
+      var viewTransitionName =
+        null != props
+          ? props.hasOwnProperty("viewTransitionName")
+            ? props.viewTransitionName
+            : props.hasOwnProperty("view-transition-name")
+              ? props["view-transition-name"]
+              : null
+          : null;
+      instance.style.viewTransitionName =
+        null == viewTransitionName || "boolean" === typeof viewTransitionName
+          ? ""
+          : ("" + viewTransitionName).trim();
+      props =
+        null != props
+          ? props.hasOwnProperty("viewTransitionClass")
+            ? props.viewTransitionClass
+            : props.hasOwnProperty("view-transition-class")
+              ? props["view-transition-class"]
+              : null
+          : null;
+      instance.style.viewTransitionClass =
+        null == props || "boolean" === typeof props ? "" : ("" + props).trim();
+    }
+    function measureInstance(instance) {
+      var ownerWindow = instance.ownerDocument.defaultView,
+        rect = instance.getBoundingClientRect();
+      instance = getComputedStyle(instance);
+      return {
+        rect: rect,
+        abs: "absolute" === instance.position || "fixed" === instance.position,
+        clip:
+          "none" !== instance.clipPath ||
+          "visible" !== instance.overflow ||
+          "none" !== instance.filter ||
+          "none" !== instance.mask ||
+          "none" !== instance.mask ||
+          "0px" !== instance.borderRadius,
+        view:
+          0 <= rect.bottom &&
+          0 <= rect.right &&
+          rect.top <= ownerWindow.innerHeight &&
+          rect.left <= ownerWindow.innerWidth
+      };
+    }
+    function startViewTransition(
+      rootContainer,
+      mutationCallback,
+      layoutCallback,
+      afterMutationCallback,
+      spawnedWorkCallback,
+      passiveCallback
+    ) {
+      var ownerDocument =
+        9 === rootContainer.nodeType
+          ? rootContainer
+          : rootContainer.ownerDocument;
+      try {
+        var transition = ownerDocument.startViewTransition({
+          update: function () {
+            var ownerWindow = ownerDocument.defaultView;
+            ownerWindow =
+              ownerWindow.navigation && ownerWindow.navigation.transition;
+            var previousFontLoadingStatus = ownerDocument.fonts.status;
+            mutationCallback();
+            if (
+              "loaded" === previousFontLoadingStatus &&
+              (ownerDocument.documentElement.clientHeight,
+              "loading" === ownerDocument.fonts.status)
+            )
+              return (
+                (previousFontLoadingStatus = Promise.race([
+                  ownerDocument.fonts.ready,
+                  new Promise(function (resolve) {
+                    return setTimeout(resolve, SUSPENSEY_FONT_TIMEOUT);
+                  })
+                ]).then(layoutCallback, layoutCallback)),
+                (ownerWindow
+                  ? Promise.allSettled([
+                      ownerWindow.finished,
+                      previousFontLoadingStatus
+                    ])
+                  : previousFontLoadingStatus
+                ).then(afterMutationCallback, afterMutationCallback)
+              );
+            layoutCallback();
+            if (ownerWindow)
+              return ownerWindow.finished.then(
+                afterMutationCallback,
+                afterMutationCallback
+              );
+            afterMutationCallback();
+          },
+          types: null
+        });
+        ownerDocument.__reactViewTransition = transition;
+        transition.ready.then(void 0, function (reason) {
+          "object" === typeof reason &&
+            null !== reason &&
+            "TimeoutError" === reason.name &&
+            console.error(
+              "A ViewTransition timed out because a Navigation stalled. This can happen if a Navigation is blocked on React itself. Such as if it's resolved inside useEffect. This can be solved by moving the resolution to useLayoutEffect."
+            );
+        });
+        transition.ready.then(spawnedWorkCallback, spawnedWorkCallback);
+        transition.finished.then(function () {
+          ownerDocument.__reactViewTransition = null;
+          passiveCallback();
+        });
+        return !0;
+      } catch (x) {
+        return !1;
+      }
+    }
+    function ViewTransitionPseudoElement(pseudo, name) {
+      this._scope = document.documentElement;
+      this._selector = "::view-transition-" + pseudo + "(" + name + ")";
+    }
+    function createViewTransitionInstance(name) {
+      return {
+        name: name,
+        group: new ViewTransitionPseudoElement("group", name),
+        imagePair: new ViewTransitionPseudoElement("image-pair", name),
+        old: new ViewTransitionPseudoElement("old", name),
+        new: new ViewTransitionPseudoElement("new", name)
+      };
+    }
     function clearContainerSparingly(container) {
       var nextNode = container.firstChild;
       nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
@@ -19563,11 +21602,6 @@
       instance[internalInstanceKey] = internalInstanceHandle;
       instance[internalPropsKey] = props;
     }
-    function releaseSingletonInstance(instance) {
-      for (var attributes = instance.attributes; attributes.length; )
-        instance.removeAttributeNode(attributes[0]);
-      detachDeletedInstance(instance);
-    }
     function getHoistableRoot(container) {
       return "function" === typeof container.getRootNode
         ? container.getRootNode()
@@ -20253,38 +22287,6 @@
         resource.state.loading |= Inserted;
       }
     }
-    function bindToConsole(methodName, args, badgeName) {
-      var offset = 0;
-      switch (methodName) {
-        case "dir":
-        case "dirxml":
-        case "groupEnd":
-        case "table":
-          return bind.apply(console[methodName], [console].concat(args));
-        case "assert":
-          offset = 1;
-      }
-      args = args.slice(0);
-      "string" === typeof args[offset]
-        ? args.splice(
-            offset,
-            1,
-            badgeFormat + args[offset],
-            badgeStyle,
-            pad + badgeName + pad,
-            resetStyle
-          )
-        : args.splice(
-            offset,
-            0,
-            badgeFormat,
-            badgeStyle,
-            pad + badgeName + pad,
-            resetStyle
-          );
-      args.unshift(console);
-      return bind.apply(console[methodName], args);
-    }
     function FiberRootNode(
       containerInfo,
       tag,
@@ -20401,9 +22403,6 @@
               err
             ));
         }
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markRenderScheduled &&
-        injectedProfilingHooks.markRenderScheduled(lane);
       parentComponent = getContextForSubtree(parentComponent);
       null === container.context
         ? (container.context = parentComponent)
@@ -20428,7 +22427,8 @@
         (container.callback = callback));
       element = enqueueUpdate(rootFiber, container, lane);
       null !== element &&
-        (scheduleUpdateOnFiber(element, rootFiber, lane),
+        (startUpdateTimerByLane(lane),
+        scheduleUpdateOnFiber(element, rootFiber, lane),
         entangleTransitions(element, rootFiber, lane));
     }
     function markRetryLaneImpl(fiber, retryLane) {
@@ -20452,14 +22452,6 @@
     function getCurrentFiberForDevTools() {
       return current;
     }
-    function getLaneLabelMap() {
-      for (var map = new Map(), lane = 1, index = 0; 31 > index; index++) {
-        var label = getLabelForLane(lane);
-        map.set(lane, label);
-        lane *= 2;
-      }
-      return map;
-    }
     function dispatchDiscreteEvent(
       domEventName,
       eventSystemFlags,
@@ -21068,12 +23060,14 @@
       REACT_MEMO_TYPE = Symbol.for("react.memo"),
       REACT_LAZY_TYPE = Symbol.for("react.lazy");
     Symbol.for("react.scope");
-    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
-    Symbol.for("react.legacy_hidden");
+    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
+      REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
     Symbol.for("react.tracing_marker");
-    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-    Symbol.for("react.view_transition");
-    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+      REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+      REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
+      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+      ASYNC_ITERATOR = Symbol.asyncIterator,
       REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
       isArrayImpl = Array.isArray,
       ReactSharedInternals =
@@ -21109,7 +23103,6 @@
       unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
       rendererID = null,
       injectedHook = null,
-      injectedProfilingHooks = null,
       hasLoggedError = !1,
       isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__,
       clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
@@ -21147,6 +23140,7 @@
       ),
       illegalAttributeNameCache = {},
       validatedAttributeNameCache = {},
+      viewTransitionMutationContext = !1,
       disabledDepth = 0,
       prevLog,
       prevInfo,
@@ -22345,10 +24339,96 @@
       now = Scheduler.unstable_now,
       renderStartTime = -0,
       commitStartTime = -0,
+      commitEndTime = -0,
+      commitErrors = null,
       profilerStartTime = -1.1,
       profilerEffectDuration = -0,
+      componentEffectDuration = -0,
+      componentEffectStartTime = -1.1,
+      componentEffectEndTime = -1.1,
+      componentEffectErrors = null,
+      blockingClampTime = -0,
+      blockingUpdateTime = -1.1,
+      blockingEventTime = -1.1,
+      blockingEventType = null,
+      blockingEventIsRepeat = !1,
+      blockingSpawnedUpdate = !1,
+      blockingSuspendedTime = -1.1,
+      transitionClampTime = -0,
+      transitionStartTime = -1.1,
+      transitionUpdateTime = -1.1,
+      transitionEventTime = -1.1,
+      transitionEventType = null,
+      transitionEventIsRepeat = !1,
+      transitionSuspendedTime = -1.1,
+      yieldReason = 0,
+      yieldStartTime = -1.1,
       currentUpdateIsNested = !1,
       nestedUpdateScheduled = !1,
+      supportsUserTiming =
+        "undefined" !== typeof performance &&
+        "function" === typeof performance.measure,
+      COMPONENTS_TRACK = "Components \u269b",
+      reusableComponentDevToolDetails = {
+        color: "primary",
+        track: COMPONENTS_TRACK
+      },
+      reusableComponentOptions = {
+        start: -0,
+        end: -0,
+        detail: { devtools: reusableComponentDevToolDetails }
+      },
+      LANES_TRACK_GROUP = "Scheduler \u269b",
+      reusableLaneDevToolDetails = {
+        color: "primary",
+        track: "Blocking",
+        trackGroup: LANES_TRACK_GROUP
+      },
+      reusableLaneOptions = {
+        start: -0,
+        end: -0,
+        detail: { devtools: reusableLaneDevToolDetails }
+      },
+      blockingLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Blocking",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
+      transitionLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Transition",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
+      suspenseLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Suspense",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
+      idleLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Idle",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
       valueCursor = createCursor(null);
     var rendererCursorDEV = createCursor(null);
     var rendererSigil = {};
@@ -22619,9 +24699,9 @@
             (warnOnInvalidCallback(callback), (update.callback = callback));
           payload = enqueueUpdate(inst, update, lane);
           null !== payload &&
-            (scheduleUpdateOnFiber(payload, inst, lane),
+            (startUpdateTimerByLane(lane),
+            scheduleUpdateOnFiber(payload, inst, lane),
             entangleTransitions(payload, inst, lane));
-          markStateUpdateScheduled(inst, lane);
         },
         enqueueReplaceState: function (inst, payload, callback) {
           inst = inst._reactInternals;
@@ -22634,9 +24714,9 @@
             (warnOnInvalidCallback(callback), (update.callback = callback));
           payload = enqueueUpdate(inst, update, lane);
           null !== payload &&
-            (scheduleUpdateOnFiber(payload, inst, lane),
+            (startUpdateTimerByLane(lane),
+            scheduleUpdateOnFiber(payload, inst, lane),
             entangleTransitions(payload, inst, lane));
-          markStateUpdateScheduled(inst, lane);
         },
         enqueueForceUpdate: function (inst, callback) {
           inst = inst._reactInternals;
@@ -22648,12 +24728,9 @@
             (warnOnInvalidCallback(callback), (update.callback = callback));
           callback = enqueueUpdate(inst, update, lane);
           null !== callback &&
-            (scheduleUpdateOnFiber(callback, inst, lane),
+            (startUpdateTimerByLane(lane),
+            scheduleUpdateOnFiber(callback, inst, lane),
             entangleTransitions(callback, inst, lane));
-          null !== injectedProfilingHooks &&
-            "function" ===
-              typeof injectedProfilingHooks.markForceUpdateScheduled &&
-            injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
         }
       },
       forkStack = [],
@@ -22687,10 +24764,25 @@
       prevEntangledRenderLanesCursor = createCursor(0),
       prevOnStartTransitionFinish = ReactSharedInternals.S;
     ReactSharedInternals.S = function (transition, returnValue) {
-      "object" === typeof returnValue &&
+      if (
+        "object" === typeof returnValue &&
         null !== returnValue &&
-        "function" === typeof returnValue.then &&
+        "function" === typeof returnValue.then
+      ) {
+        if (0 > transitionStartTime && 0 > transitionUpdateTime) {
+          transitionStartTime = now();
+          var newEventTime = resolveEventTimeStamp(),
+            newEventType = resolveEventType();
+          if (
+            newEventTime !== transitionEventTime ||
+            newEventType !== transitionEventType
+          )
+            transitionEventIsRepeat = !1;
+          transitionEventTime = newEventTime;
+          transitionEventType = newEventType;
+        }
         entangleAsyncAction(transition, returnValue);
+      }
       null !== prevOnStartTransitionFinish &&
         prevOnStartTransitionFinish(transition, returnValue);
     };
@@ -22710,7 +24802,7 @@
       localIdCounter = 0,
       thenableIndexCounter$1 = 0,
       thenableState$1 = null,
-      globalClientIdCounter = 0,
+      globalClientIdCounter$1 = 0,
       RE_RENDER_LIMIT = 25,
       currentHookNameInDev = null,
       hookTypesDev = null,
@@ -22740,8 +24832,9 @@
         useOptimistic: throwInvalidHookError,
         useMemoCache: throwInvalidHookError,
         useCacheRefresh: throwInvalidHookError
-      },
-      HooksDispatcherOnMountInDEV = null,
+      };
+    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
+    var HooksDispatcherOnMountInDEV = null,
       HooksDispatcherOnMountWithHookTypesInDEV = null,
       HooksDispatcherOnUpdateInDEV = null,
       HooksDispatcherOnRerenderInDEV = null,
@@ -22881,6 +24974,11 @@
         currentHookNameInDev = "useCacheRefresh";
         mountHookTypesDev();
         return mountRefresh();
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        mountHookTypesDev();
+        return mountEvent(callback);
       }
     };
     HooksDispatcherOnMountWithHookTypesInDEV = {
@@ -23010,6 +25108,11 @@
         currentHookNameInDev = "useCacheRefresh";
         updateHookTypesDev();
         return mountRefresh();
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        updateHookTypesDev();
+        return mountEvent(callback);
       }
     };
     HooksDispatcherOnUpdateInDEV = {
@@ -23139,6 +25242,11 @@
         currentHookNameInDev = "useCacheRefresh";
         updateHookTypesDev();
         return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        updateHookTypesDev();
+        return updateEvent(callback);
       }
     };
     HooksDispatcherOnRerenderInDEV = {
@@ -23268,6 +25376,11 @@
         currentHookNameInDev = "useCacheRefresh";
         updateHookTypesDev();
         return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        updateHookTypesDev();
+        return updateEvent(callback);
       }
     };
     InvalidNestedHooksDispatcherOnMountInDEV = {
@@ -23421,6 +25534,12 @@
         currentHookNameInDev = "useCacheRefresh";
         mountHookTypesDev();
         return mountRefresh();
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountEvent(callback);
       }
     };
     InvalidNestedHooksDispatcherOnUpdateInDEV = {
@@ -23574,6 +25693,12 @@
         currentHookNameInDev = "useCacheRefresh";
         updateHookTypesDev();
         return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateEvent(callback);
       }
     };
     InvalidNestedHooksDispatcherOnRerenderInDEV = {
@@ -23727,6 +25852,12 @@
         currentHookNameInDev = "useCacheRefresh";
         updateHookTypesDev();
         return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateEvent(callback);
       }
     };
     var callComponent = {
@@ -23972,9 +26103,14 @@
       nextEffect = null,
       inProgressLanes = null,
       inProgressRoot = null,
+      shouldStartViewTransition = !1,
+      viewTransitionContextChanged = !1,
+      viewTransitionCancelableChildren = null,
+      viewTransitionHostInstanceIdx = 0,
       hostParent = null,
       hostParentIsContainer = !1,
       currentHoistableRoot = null,
+      inHydratedSubtree = !1,
       suspenseyCommitFlag = 8192;
     var hasBadMapPolyfill = !1;
     try {
@@ -23994,6 +26130,7 @@
       HydrationMismatchException = Error(
         "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
       ),
+      globalClientIdCounter = 0,
       DefaultAsyncDispatcher = {
         getCacheForType: function (resourceType) {
           var cache = readContext(CacheContext),
@@ -24077,8 +26214,11 @@
       pendingFinishedWork = null,
       pendingEffectsLanes = 0,
       pendingEffectsRemainingLanes = 0,
+      pendingEffectsRenderEndTime = -0,
       pendingPassiveTransitions = null,
       pendingRecoverableErrors = null,
+      pendingViewTransitionEvents = null,
+      pendingSuspendedCommitReason = IMMEDIATE_COMMIT,
       NESTED_UPDATE_LIMIT = 50,
       nestedUpdateCount = 0,
       rootWithNestedUpdates = null,
@@ -24192,6 +26332,7 @@
       selectionInformation = null,
       warnedUnknownTags = { dialog: !0, webview: !0 },
       currentPopstateTransitionEvent = null,
+      schedulerEvent = void 0,
       scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
       cancelTimeout =
         "function" === typeof clearTimeout ? clearTimeout : void 0,
@@ -24208,7 +26349,37 @@
                   .catch(handleErrorInNextTick);
               }
             : scheduleTimeout,
-      NotLoaded = 0,
+      SUSPENSEY_FONT_TIMEOUT = 500;
+    ViewTransitionPseudoElement.prototype.animate = function (
+      keyframes,
+      options
+    ) {
+      options =
+        "number" === typeof options
+          ? { duration: options }
+          : assign({}, options);
+      options.pseudoElement = this._selector;
+      return this._scope.animate(keyframes, options);
+    };
+    ViewTransitionPseudoElement.prototype.getAnimations = function () {
+      for (
+        var scope = this._scope,
+          selector = this._selector,
+          animations = scope.getAnimations({ subtree: !0 }),
+          result = [],
+          i = 0;
+        i < animations.length;
+        i++
+      ) {
+        var effect = animations[i].effect;
+        null !== effect &&
+          effect.target === scope &&
+          effect.pseudoElement === selector &&
+          result.push(animations[i]);
+      }
+      return result;
+    };
+    var NotLoaded = 0,
       Loaded = 1,
       Errored = 2,
       Settled = 3,
@@ -24623,11 +26794,11 @@
     };
     (function () {
       var isomorphicReactPackageVersion = React.version;
-      if ("19.1.0-canary-c492f975-20250128" !== isomorphicReactPackageVersion)
+      if ("19.1.0-experimental-b3a95caf-20250113" !== isomorphicReactPackageVersion)
         throw Error(
           'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
             (isomorphicReactPackageVersion +
-              "\n  - react-dom:  19.1.0-canary-c492f975-20250128\nLearn more: https://react.dev/warnings/version-mismatch")
+              "\n  - react-dom:  19.1.0-experimental-b3a95caf-20250113\nLearn more: https://react.dev/warnings/version-mismatch")
         );
     })();
     ("function" === typeof Map &&
@@ -24664,10 +26835,10 @@
       !(function () {
         var internals = {
           bundleType: 1,
-          version: "19.1.0-canary-c492f975-20250128",
+          version: "19.1.0-experimental-b3a95caf-20250113",
           rendererPackageName: "react-dom",
           currentDispatcherRef: ReactSharedInternals,
-          reconcilerVersion: "19.1.0-canary-c492f975-20250128"
+          reconcilerVersion: "19.1.0-experimental-b3a95caf-20250113"
         };
         internals.overrideHookState = overrideHookState;
         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
@@ -24682,8 +26853,6 @@
         internals.scheduleRoot = scheduleRoot;
         internals.setRefreshHandler = setRefreshHandler;
         internals.getCurrentFiber = getCurrentFiberForDevTools;
-        internals.getLaneLabelMap = getLaneLabelMap;
-        internals.injectProfilingHooks = injectProfilingHooks;
         return injectInternals(internals);
       })() &&
       canUseDOM &&
@@ -24813,7 +26982,7 @@
       listenToAllSupportedEvents(container);
       return new ReactDOMHydrationRoot(initialChildren);
     };
-    exports.version = "19.1.0-canary-c492f975-20250128";
+    exports.version = "19.1.0-experimental-b3a95caf-20250113";
     "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
       "function" ===
         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
diff --git a/node_modules/react-dom/cjs/react-dom-client.production.js b/node_modules/react-dom/cjs/react-dom-client.production.js
index 67a6d90..8dddd06 100644
--- a/node_modules/react-dom/cjs/react-dom-client.production.js
+++ b/node_modules/react-dom/cjs/react-dom-client.production.js
@@ -158,12 +158,13 @@ var assign = Object.assign,
   REACT_MEMO_TYPE = Symbol.for("react.memo"),
   REACT_LAZY_TYPE = Symbol.for("react.lazy");
 Symbol.for("react.scope");
-var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
-Symbol.for("react.legacy_hidden");
+var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
+  REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
 Symbol.for("react.tracing_marker");
-var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-Symbol.for("react.view_transition");
-var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+  REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
+  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
 function getIteratorFn(maybeIterable) {
   if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
   maybeIterable =
@@ -171,7 +172,8 @@ function getIteratorFn(maybeIterable) {
     maybeIterable["@@iterator"];
   return "function" === typeof maybeIterable ? maybeIterable : null;
 }
-var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
+var ASYNC_ITERATOR = Symbol.asyncIterator,
+  REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
 function getComponentNameFromType(type) {
   if (null == type) return null;
   if ("function" === typeof type)
@@ -192,6 +194,8 @@ function getComponentNameFromType(type) {
       return "Suspense";
     case REACT_SUSPENSE_LIST_TYPE:
       return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
   }
   if ("object" === typeof type)
     switch (type.$$typeof) {
@@ -741,6 +745,7 @@ function isAttributeNameSafe(attributeName) {
   illegalAttributeNameCache[attributeName] = !0;
   return !1;
 }
+var viewTransitionMutationContext = !1;
 function setValueForAttribute(node, name, value) {
   if (isAttributeNameSafe(name))
     if (null === value) node.removeAttribute(name);
@@ -959,6 +964,8 @@ function describeFiber(fiber) {
       return describeNativeComponentFrame(fiber.type.render, !1);
     case 1:
       return describeNativeComponentFrame(fiber.type, !0);
+    case 30:
+      return describeBuiltInComponentFrame("ViewTransition");
     default:
       return "";
   }
@@ -1271,12 +1278,14 @@ function setValueForStyles(node, styles, prevStyles) {
           ? node.setProperty(styleName, "")
           : "float" === styleName
             ? (node.cssFloat = "")
-            : (node[styleName] = ""));
+            : (node[styleName] = ""),
+        (viewTransitionMutationContext = !0));
     for (var styleName$16 in styles)
       (styleName = styles[styleName$16]),
         styles.hasOwnProperty(styleName$16) &&
           prevStyles[styleName$16] !== styleName &&
-          setValueForStyle(node, styleName$16, styleName);
+          (setValueForStyle(node, styleName$16, styleName),
+          (viewTransitionMutationContext = !0));
   } else
     for (var styleName$17 in styles)
       styles.hasOwnProperty(styleName$17) &&
@@ -2014,19 +2023,19 @@ function getTargetInstForChangeEvent(domEventName, targetInst) {
 }
 var isInputEventSupported = !1;
 if (canUseDOM) {
-  var JSCompiler_inline_result$jscomp$281;
+  var JSCompiler_inline_result$jscomp$285;
   if (canUseDOM) {
-    var isSupported$jscomp$inline_416 = "oninput" in document;
-    if (!isSupported$jscomp$inline_416) {
-      var element$jscomp$inline_417 = document.createElement("div");
-      element$jscomp$inline_417.setAttribute("oninput", "return;");
-      isSupported$jscomp$inline_416 =
-        "function" === typeof element$jscomp$inline_417.oninput;
+    var isSupported$jscomp$inline_423 = "oninput" in document;
+    if (!isSupported$jscomp$inline_423) {
+      var element$jscomp$inline_424 = document.createElement("div");
+      element$jscomp$inline_424.setAttribute("oninput", "return;");
+      isSupported$jscomp$inline_423 =
+        "function" === typeof element$jscomp$inline_424.oninput;
     }
-    JSCompiler_inline_result$jscomp$281 = isSupported$jscomp$inline_416;
-  } else JSCompiler_inline_result$jscomp$281 = !1;
+    JSCompiler_inline_result$jscomp$285 = isSupported$jscomp$inline_423;
+  } else JSCompiler_inline_result$jscomp$285 = !1;
   isInputEventSupported =
-    JSCompiler_inline_result$jscomp$281 &&
+    JSCompiler_inline_result$jscomp$285 &&
     (!document.documentMode || 9 < document.documentMode);
 }
 function stopWatchingForValueChange() {
@@ -2994,6 +3003,15 @@ var forkStack = [],
   treeContextProvider = null,
   treeContextId = 1,
   treeContextOverflow = "";
+function getTreeId() {
+  var overflow = treeContextOverflow,
+    idWithLeadingBit = treeContextId;
+  return (
+    (idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))).toString(
+      32
+    ) + overflow
+  );
+}
 function pushTreeFork(workInProgress, totalChildren) {
   forkStack[forkStackIndex++] = treeForkCount;
   forkStack[forkStackIndex++] = treeForkProvider;
@@ -3177,7 +3195,7 @@ var renderLanes = 0,
   localIdCounter = 0,
   thenableIndexCounter$1 = 0,
   thenableState$1 = null,
-  globalClientIdCounter = 0;
+  globalClientIdCounter$1 = 0;
 function throwInvalidHookError() {
   throw Error(formatProdErrorMessage(321));
 }
@@ -3955,6 +3973,28 @@ function mountEffect(create, deps) {
 function updateEffect(create, deps) {
   updateEffectImpl(2048, 8, create, deps);
 }
+function useEffectEventImpl(payload) {
+  currentlyRenderingFiber.flags |= 4;
+  var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
+  if (null === componentUpdateQueue)
+    (componentUpdateQueue = createFunctionComponentUpdateQueue()),
+      (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
+      (componentUpdateQueue.events = [payload]);
+  else {
+    var events = componentUpdateQueue.events;
+    null === events
+      ? (componentUpdateQueue.events = [payload])
+      : events.push(payload);
+  }
+}
+function updateEvent(callback) {
+  var ref = updateWorkInProgressHook().memoizedState;
+  useEffectEventImpl({ ref: ref, nextImpl: callback });
+  return function () {
+    if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
+    return ref.impl.apply(void 0, arguments);
+  };
+}
 function updateInsertionEffect(create, deps) {
   return updateEffectImpl(4, 2, create, deps);
 }
@@ -4146,7 +4186,7 @@ function updateId() {
 function updateRefresh() {
   return updateWorkInProgressHook().memoizedState;
 }
-function refreshCache(fiber) {
+function refreshCache(fiber, seedKey, seedValue) {
   for (var provider = fiber.return; null !== provider; ) {
     switch (provider.tag) {
       case 24:
@@ -4157,8 +4197,12 @@ function refreshCache(fiber) {
         null !== root$42 &&
           (scheduleUpdateOnFiber(root$42, provider, lane),
           entangleTransitions(root$42, provider, lane));
-        provider = { cache: createCache() };
-        fiber.payload = provider;
+        provider = createCache();
+        null !== seedKey &&
+          void 0 !== seedKey &&
+          null !== root$42 &&
+          provider.data.set(seedKey, seedValue);
+        fiber.payload = { cache: provider };
         return;
     }
     provider = provider.return;
@@ -4273,31 +4317,32 @@ function entangleTransitionUpdate(root, queue, lane) {
   }
 }
 var ContextOnlyDispatcher = {
-    readContext: readContext,
-    use: use,
-    useCallback: throwInvalidHookError,
-    useContext: throwInvalidHookError,
-    useEffect: throwInvalidHookError,
-    useImperativeHandle: throwInvalidHookError,
-    useLayoutEffect: throwInvalidHookError,
-    useInsertionEffect: throwInvalidHookError,
-    useMemo: throwInvalidHookError,
-    useReducer: throwInvalidHookError,
-    useRef: throwInvalidHookError,
-    useState: throwInvalidHookError,
-    useDebugValue: throwInvalidHookError,
-    useDeferredValue: throwInvalidHookError,
-    useTransition: throwInvalidHookError,
-    useSyncExternalStore: throwInvalidHookError,
-    useId: throwInvalidHookError,
-    useHostTransitionStatus: throwInvalidHookError,
-    useFormState: throwInvalidHookError,
-    useActionState: throwInvalidHookError,
-    useOptimistic: throwInvalidHookError,
-    useMemoCache: throwInvalidHookError,
-    useCacheRefresh: throwInvalidHookError
-  },
-  HooksDispatcherOnMount = {
+  readContext: readContext,
+  use: use,
+  useCallback: throwInvalidHookError,
+  useContext: throwInvalidHookError,
+  useEffect: throwInvalidHookError,
+  useImperativeHandle: throwInvalidHookError,
+  useLayoutEffect: throwInvalidHookError,
+  useInsertionEffect: throwInvalidHookError,
+  useMemo: throwInvalidHookError,
+  useReducer: throwInvalidHookError,
+  useRef: throwInvalidHookError,
+  useState: throwInvalidHookError,
+  useDebugValue: throwInvalidHookError,
+  useDeferredValue: throwInvalidHookError,
+  useTransition: throwInvalidHookError,
+  useSyncExternalStore: throwInvalidHookError,
+  useId: throwInvalidHookError,
+  useHostTransitionStatus: throwInvalidHookError,
+  useFormState: throwInvalidHookError,
+  useActionState: throwInvalidHookError,
+  useOptimistic: throwInvalidHookError,
+  useMemoCache: throwInvalidHookError,
+  useCacheRefresh: throwInvalidHookError
+};
+ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
+var HooksDispatcherOnMount = {
     readContext: readContext,
     use: use,
     useCallback: function (callback, deps) {
@@ -4436,26 +4481,15 @@ var ContextOnlyDispatcher = {
       var hook = mountWorkInProgressHook(),
         identifierPrefix = workInProgressRoot.identifierPrefix;
       if (isHydrating) {
-        var JSCompiler_inline_result = treeContextOverflow;
-        var idWithLeadingBit = treeContextId;
-        JSCompiler_inline_result =
-          (
-            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
-          ).toString(32) + JSCompiler_inline_result;
-        identifierPrefix =
-          ":" + identifierPrefix + "R" + JSCompiler_inline_result;
-        JSCompiler_inline_result = localIdCounter++;
-        0 < JSCompiler_inline_result &&
-          (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
+        var treeId = getTreeId();
+        identifierPrefix = ":" + identifierPrefix + "R" + treeId;
+        treeId = localIdCounter++;
+        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
         identifierPrefix += ":";
       } else
-        (JSCompiler_inline_result = globalClientIdCounter++),
+        (treeId = globalClientIdCounter$1++),
           (identifierPrefix =
-            ":" +
-            identifierPrefix +
-            "r" +
-            JSCompiler_inline_result.toString(32) +
-            ":");
+            ":" + identifierPrefix + "r" + treeId.toString(32) + ":");
       return (hook.memoizedState = identifierPrefix);
     },
     useHostTransitionStatus: useHostTransitionStatus,
@@ -4487,6 +4521,16 @@ var ContextOnlyDispatcher = {
         null,
         currentlyRenderingFiber
       ));
+    },
+    useEffectEvent: function (callback) {
+      var hook = mountWorkInProgressHook(),
+        ref = { impl: callback };
+      hook.memoizedState = ref;
+      return function () {
+        if (0 !== (executionContext & 2))
+          throw Error(formatProdErrorMessage(440));
+        return ref.impl.apply(void 0, arguments);
+      };
     }
   },
   HooksDispatcherOnUpdate = {
@@ -4535,60 +4579,62 @@ var ContextOnlyDispatcher = {
     },
     useMemoCache: useMemoCache,
     useCacheRefresh: updateRefresh
+  };
+HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
+var HooksDispatcherOnRerender = {
+  readContext: readContext,
+  use: use,
+  useCallback: updateCallback,
+  useContext: readContext,
+  useEffect: updateEffect,
+  useImperativeHandle: updateImperativeHandle,
+  useInsertionEffect: updateInsertionEffect,
+  useLayoutEffect: updateLayoutEffect,
+  useMemo: updateMemo,
+  useReducer: rerenderReducer,
+  useRef: updateRef,
+  useState: function () {
+    return rerenderReducer(basicStateReducer);
   },
-  HooksDispatcherOnRerender = {
-    readContext: readContext,
-    use: use,
-    useCallback: updateCallback,
-    useContext: readContext,
-    useEffect: updateEffect,
-    useImperativeHandle: updateImperativeHandle,
-    useInsertionEffect: updateInsertionEffect,
-    useLayoutEffect: updateLayoutEffect,
-    useMemo: updateMemo,
-    useReducer: rerenderReducer,
-    useRef: updateRef,
-    useState: function () {
-      return rerenderReducer(basicStateReducer);
-    },
-    useDebugValue: mountDebugValue,
-    useDeferredValue: function (value, initialValue) {
-      var hook = updateWorkInProgressHook();
-      return null === currentHook
-        ? mountDeferredValueImpl(hook, value, initialValue)
-        : updateDeferredValueImpl(
-            hook,
-            currentHook.memoizedState,
-            value,
-            initialValue
-          );
-    },
-    useTransition: function () {
-      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
-        start = updateWorkInProgressHook().memoizedState;
-      return [
-        "boolean" === typeof booleanOrThenable
-          ? booleanOrThenable
-          : useThenable(booleanOrThenable),
-        start
-      ];
-    },
-    useSyncExternalStore: updateSyncExternalStore,
-    useId: updateId,
-    useHostTransitionStatus: useHostTransitionStatus,
-    useFormState: rerenderActionState,
-    useActionState: rerenderActionState,
-    useOptimistic: function (passthrough, reducer) {
-      var hook = updateWorkInProgressHook();
-      if (null !== currentHook)
-        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
-      hook.baseState = passthrough;
-      return [passthrough, hook.queue.dispatch];
-    },
-    useMemoCache: useMemoCache,
-    useCacheRefresh: updateRefresh
+  useDebugValue: mountDebugValue,
+  useDeferredValue: function (value, initialValue) {
+    var hook = updateWorkInProgressHook();
+    return null === currentHook
+      ? mountDeferredValueImpl(hook, value, initialValue)
+      : updateDeferredValueImpl(
+          hook,
+          currentHook.memoizedState,
+          value,
+          initialValue
+        );
   },
-  thenableState = null,
+  useTransition: function () {
+    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
+      start = updateWorkInProgressHook().memoizedState;
+    return [
+      "boolean" === typeof booleanOrThenable
+        ? booleanOrThenable
+        : useThenable(booleanOrThenable),
+      start
+    ];
+  },
+  useSyncExternalStore: updateSyncExternalStore,
+  useId: updateId,
+  useHostTransitionStatus: useHostTransitionStatus,
+  useFormState: rerenderActionState,
+  useActionState: rerenderActionState,
+  useOptimistic: function (passthrough, reducer) {
+    var hook = updateWorkInProgressHook();
+    if (null !== currentHook)
+      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
+    hook.baseState = passthrough;
+    return [passthrough, hook.queue.dispatch];
+  },
+  useMemoCache: useMemoCache,
+  useCacheRefresh: updateRefresh
+};
+HooksDispatcherOnRerender.useEffectEvent = updateEvent;
+var thenableState = null,
   thenableIndexCounter = 0;
 function unwrapThenable(thenable) {
   var index = thenableIndexCounter;
@@ -4793,7 +4839,11 @@ function createChildReconciler(shouldTrackSideEffects) {
           newChild = init(newChild._payload);
           return createChild(returnFiber, newChild, lanes);
       }
-      if (isArrayImpl(newChild) || getIteratorFn(newChild))
+      if (
+        isArrayImpl(newChild) ||
+        getIteratorFn(newChild) ||
+        "function" === typeof newChild[ASYNC_ITERATOR]
+      )
         return (
           (newChild = createFiberFromFragment(
             newChild,
@@ -4843,7 +4893,11 @@ function createChildReconciler(shouldTrackSideEffects) {
             updateSlot(returnFiber, oldFiber, newChild, lanes)
           );
       }
-      if (isArrayImpl(newChild) || getIteratorFn(newChild))
+      if (
+        isArrayImpl(newChild) ||
+        getIteratorFn(newChild) ||
+        "function" === typeof newChild[ASYNC_ITERATOR]
+      )
         return null !== key
           ? null
           : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
@@ -4910,7 +4964,11 @@ function createChildReconciler(shouldTrackSideEffects) {
             lanes
           );
       }
-      if (isArrayImpl(newChild) || getIteratorFn(newChild))
+      if (
+        isArrayImpl(newChild) ||
+        getIteratorFn(newChild) ||
+        "function" === typeof newChild[ASYNC_ITERATOR]
+      )
         return (
           (existingChildren = existingChildren.get(newIdx) || null),
           updateFragment(returnFiber, existingChildren, newChild, lanes, null)
@@ -5030,6 +5088,25 @@ function createChildReconciler(shouldTrackSideEffects) {
     isHydrating && pushTreeFork(returnFiber, newIdx);
     return resultingFirstChild;
   }
+  function reconcileChildrenAsyncIteratable(
+    returnFiber,
+    currentFirstChild,
+    newChildrenIterable,
+    lanes
+  ) {
+    var newChildren = newChildrenIterable[ASYNC_ITERATOR]();
+    if (null == newChildren) throw Error(formatProdErrorMessage(151));
+    return reconcileChildrenIterator(
+      returnFiber,
+      currentFirstChild,
+      {
+        next: function () {
+          return unwrapThenable(newChildren.next());
+        }
+      },
+      lanes
+    );
+  }
   function reconcileChildrenIterator(
     returnFiber,
     currentFirstChild,
@@ -5243,6 +5320,13 @@ function createChildReconciler(shouldTrackSideEffects) {
           lanes
         );
       }
+      if ("function" === typeof newChild[ASYNC_ITERATOR])
+        return reconcileChildrenAsyncIteratable(
+          returnFiber,
+          currentFirstChild,
+          newChild,
+          lanes
+        );
       if ("function" === typeof newChild.then)
         return reconcileChildFibersImpl(
           returnFiber,
@@ -5404,9 +5488,9 @@ function logUncaughtError(root, errorInfo) {
   try {
     var onUncaughtError = root.onUncaughtError;
     onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
-  } catch (e$74) {
+  } catch (e$75) {
     setTimeout(function () {
-      throw e$74;
+      throw e$75;
     });
   }
 }
@@ -5417,9 +5501,9 @@ function logCaughtError(root, boundary, errorInfo) {
       componentStack: errorInfo.stack,
       errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
     });
-  } catch (e$75) {
+  } catch (e$76) {
     setTimeout(function () {
-      throw e$75;
+      throw e$76;
     });
   }
 }
@@ -5463,6 +5547,27 @@ function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
       });
     });
 }
+function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
+  var currentSourceFiber = sourceFiber.alternate;
+  null !== currentSourceFiber &&
+    propagateParentContextChanges(
+      currentSourceFiber,
+      sourceFiber,
+      rootRenderLanes,
+      !0
+    );
+}
+function markSuspenseBoundaryShouldCapture(
+  suspenseBoundary,
+  returnFiber,
+  sourceFiber,
+  root,
+  rootRenderLanes
+) {
+  suspenseBoundary.flags |= 65536;
+  suspenseBoundary.lanes = rootRenderLanes;
+  return suspenseBoundary;
+}
 function throwException(
   root,
   returnFiber,
@@ -5474,60 +5579,60 @@ function throwException(
   if (
     null !== value &&
     "object" === typeof value &&
-    "function" === typeof value.then
+    (value.$$typeof === REACT_POSTPONE_TYPE &&
+      (value = { then: function () {} }),
+    "function" === typeof value.then)
   ) {
-    returnFiber = sourceFiber.alternate;
-    null !== returnFiber &&
-      propagateParentContextChanges(
-        returnFiber,
-        sourceFiber,
-        rootRenderLanes,
-        !0
-      );
-    sourceFiber = suspenseHandlerStackCursor.current;
-    if (null !== sourceFiber) {
-      switch (sourceFiber.tag) {
+    resetSuspendedComponent(sourceFiber, rootRenderLanes);
+    var suspenseBoundary = suspenseHandlerStackCursor.current;
+    if (null !== suspenseBoundary) {
+      switch (suspenseBoundary.tag) {
         case 13:
           return (
             null === shellBoundary
               ? renderDidSuspendDelayIfPossible()
-              : null === sourceFiber.alternate &&
+              : null === suspenseBoundary.alternate &&
                 0 === workInProgressRootExitStatus &&
                 (workInProgressRootExitStatus = 3),
-            (sourceFiber.flags &= -257),
-            (sourceFiber.flags |= 65536),
-            (sourceFiber.lanes = rootRenderLanes),
+            (suspenseBoundary.flags &= -257),
+            markSuspenseBoundaryShouldCapture(
+              suspenseBoundary,
+              returnFiber,
+              sourceFiber,
+              root,
+              rootRenderLanes
+            ),
             value === noopSuspenseyCommitThenable
-              ? (sourceFiber.flags |= 16384)
-              : ((returnFiber = sourceFiber.updateQueue),
-                null === returnFiber
-                  ? (sourceFiber.updateQueue = new Set([value]))
-                  : returnFiber.add(value),
+              ? (suspenseBoundary.flags |= 16384)
+              : ((sourceFiber = suspenseBoundary.updateQueue),
+                null === sourceFiber
+                  ? (suspenseBoundary.updateQueue = new Set([value]))
+                  : sourceFiber.add(value),
                 attachPingListener(root, value, rootRenderLanes)),
             !1
           );
         case 22:
           return (
-            (sourceFiber.flags |= 65536),
+            (suspenseBoundary.flags |= 65536),
             value === noopSuspenseyCommitThenable
-              ? (sourceFiber.flags |= 16384)
-              : ((returnFiber = sourceFiber.updateQueue),
-                null === returnFiber
-                  ? ((returnFiber = {
+              ? (suspenseBoundary.flags |= 16384)
+              : ((sourceFiber = suspenseBoundary.updateQueue),
+                null === sourceFiber
+                  ? ((sourceFiber = {
                       transitions: null,
                       markerInstances: null,
                       retryQueue: new Set([value])
                     }),
-                    (sourceFiber.updateQueue = returnFiber))
-                  : ((sourceFiber = returnFiber.retryQueue),
-                    null === sourceFiber
-                      ? (returnFiber.retryQueue = new Set([value]))
-                      : sourceFiber.add(value)),
+                    (suspenseBoundary.updateQueue = sourceFiber))
+                  : ((returnFiber = sourceFiber.retryQueue),
+                    null === returnFiber
+                      ? (sourceFiber.retryQueue = new Set([value]))
+                      : returnFiber.add(value)),
                 attachPingListener(root, value, rootRenderLanes)),
             !1
           );
       }
-      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
+      throw Error(formatProdErrorMessage(435, suspenseBoundary.tag));
     }
     attachPingListener(root, value, rootRenderLanes);
     renderDidSuspendDelayIfPossible();
@@ -5535,11 +5640,17 @@ function throwException(
   }
   if (isHydrating)
     return (
-      (returnFiber = suspenseHandlerStackCursor.current),
-      null !== returnFiber
-        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
-          (returnFiber.flags |= 65536),
-          (returnFiber.lanes = rootRenderLanes),
+      (suspenseBoundary = suspenseHandlerStackCursor.current),
+      null !== suspenseBoundary
+        ? (0 === (suspenseBoundary.flags & 65536) &&
+            (suspenseBoundary.flags |= 256),
+          markSuspenseBoundaryShouldCapture(
+            suspenseBoundary,
+            returnFiber,
+            sourceFiber,
+            root,
+            rootRenderLanes
+          ),
           value !== HydrationMismatchException &&
             ((root = Error(formatProdErrorMessage(422), { cause: value })),
             queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
@@ -5554,10 +5665,10 @@ function throwException(
           (root.flags |= 65536),
           (rootRenderLanes &= -rootRenderLanes),
           (root.lanes |= rootRenderLanes),
-          (value = createCapturedValueAtFiber(value, sourceFiber)),
+          (sourceFiber = createCapturedValueAtFiber(value, sourceFiber)),
           (rootRenderLanes = createRootErrorUpdate(
             root.stateNode,
-            value,
+            sourceFiber,
             rootRenderLanes
           )),
           enqueueCapturedUpdate(root, rootRenderLanes),
@@ -5565,54 +5676,58 @@ function throwException(
             (workInProgressRootExitStatus = 2)),
       !1
     );
-  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
-  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
-  null === workInProgressRootConcurrentErrors
-    ? (workInProgressRootConcurrentErrors = [wrapperError])
-    : workInProgressRootConcurrentErrors.push(wrapperError);
+  suspenseBoundary = Error(formatProdErrorMessage(520), { cause: value });
+  queueConcurrentError(
+    createCapturedValueAtFiber(suspenseBoundary, sourceFiber)
+  );
   4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
   if (null === returnFiber) return !0;
-  value = createCapturedValueAtFiber(value, sourceFiber);
-  sourceFiber = returnFiber;
+  sourceFiber = createCapturedValueAtFiber(value, sourceFiber);
   do {
-    switch (sourceFiber.tag) {
+    switch (returnFiber.tag) {
       case 3:
         return (
-          (sourceFiber.flags |= 65536),
+          (returnFiber.flags |= 65536),
           (root = rootRenderLanes & -rootRenderLanes),
-          (sourceFiber.lanes |= root),
-          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
-          enqueueCapturedUpdate(sourceFiber, root),
+          (returnFiber.lanes |= root),
+          (root = createRootErrorUpdate(
+            returnFiber.stateNode,
+            sourceFiber,
+            root
+          )),
+          enqueueCapturedUpdate(returnFiber, root),
           !1
         );
       case 1:
         if (
-          ((returnFiber = sourceFiber.type),
-          (wrapperError = sourceFiber.stateNode),
-          0 === (sourceFiber.flags & 128) &&
-            ("function" === typeof returnFiber.getDerivedStateFromError ||
-              (null !== wrapperError &&
-                "function" === typeof wrapperError.componentDidCatch &&
+          ((value = returnFiber.type),
+          (suspenseBoundary = returnFiber.stateNode),
+          0 === (returnFiber.flags & 128) &&
+            ("function" === typeof value.getDerivedStateFromError ||
+              (null !== suspenseBoundary &&
+                "function" === typeof suspenseBoundary.componentDidCatch &&
                 (null === legacyErrorBoundariesThatAlreadyFailed ||
-                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))
+                  !legacyErrorBoundariesThatAlreadyFailed.has(
+                    suspenseBoundary
+                  )))))
         )
           return (
-            (sourceFiber.flags |= 65536),
+            (returnFiber.flags |= 65536),
             (rootRenderLanes &= -rootRenderLanes),
-            (sourceFiber.lanes |= rootRenderLanes),
+            (returnFiber.lanes |= rootRenderLanes),
             (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
             initializeClassErrorUpdate(
               rootRenderLanes,
               root,
-              sourceFiber,
-              value
+              returnFiber,
+              sourceFiber
             ),
-            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
+            enqueueCapturedUpdate(returnFiber, rootRenderLanes),
             !1
           );
     }
-    sourceFiber = sourceFiber.return;
-  } while (null !== sourceFiber);
+    returnFiber = returnFiber.return;
+  } while (null !== returnFiber);
   return !1;
 }
 var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
@@ -6268,25 +6383,35 @@ function updateSuspenseComponent(current, workInProgress, renderLanes) {
       popSuspenseHandler(workInProgress);
     }
     nextInstance = nextProps.children;
-    nextProps = nextProps.fallback;
+    JSCompiler_temp$jscomp$0 = nextProps.fallback;
     if (showFallback)
       return (
         reuseSuspenseHandlerOnStack(workInProgress),
-        (showFallback = workInProgress.mode),
-        (nextInstance = mountWorkInProgressOffscreenFiber(
-          { mode: "hidden", children: nextInstance },
-          showFallback
+        (nextProps = mountSuspenseFallbackChildren(
+          workInProgress,
+          nextInstance,
+          JSCompiler_temp$jscomp$0,
+          renderLanes
         )),
-        (nextProps = createFiberFromFragment(
-          nextProps,
-          showFallback,
-          renderLanes,
-          null
+        (showFallback = workInProgress.child),
+        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
+        (showFallback.childLanes = getRemainingWorkInPrimaryTree(
+          current,
+          JSCompiler_temp,
+          renderLanes
+        )),
+        (workInProgress.memoizedState = SUSPENDED_MARKER),
+        nextProps
+      );
+    if ("number" === typeof nextProps.unstable_expectedLoadTime)
+      return (
+        reuseSuspenseHandlerOnStack(workInProgress),
+        (nextProps = mountSuspenseFallbackChildren(
+          workInProgress,
+          nextInstance,
+          JSCompiler_temp$jscomp$0,
+          renderLanes
         )),
-        (nextInstance.return = workInProgress),
-        (nextProps.return = workInProgress),
-        (nextInstance.sibling = nextProps),
-        (workInProgress.child = nextInstance),
         (showFallback = workInProgress.child),
         (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
         (showFallback.childLanes = getRemainingWorkInPrimaryTree(
@@ -6295,6 +6420,7 @@ function updateSuspenseComponent(current, workInProgress, renderLanes) {
           renderLanes
         )),
         (workInProgress.memoizedState = SUSPENDED_MARKER),
+        (workInProgress.lanes = 4194304),
         nextProps
       );
     pushPrimaryTreeSuspenseHandler(workInProgress);
@@ -6362,10 +6488,11 @@ function updateSuspenseComponent(current, workInProgress, renderLanes) {
         nextInstance.nextSibling && nextInstance.nextSibling.dataset;
       if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
       JSCompiler_temp = digest;
-      nextProps = Error(formatProdErrorMessage(419));
-      nextProps.stack = "";
-      nextProps.digest = JSCompiler_temp;
-      queueHydrationError({ value: nextProps, source: null, stack: null });
+      "POSTPONE" !== JSCompiler_temp &&
+        ((nextProps = Error(formatProdErrorMessage(419))),
+        (nextProps.stack = ""),
+        (nextProps.digest = JSCompiler_temp),
+        queueHydrationError({ value: nextProps, source: null, stack: null }));
       workInProgress = retrySuspenseComponentWithoutHydrating(
         current,
         workInProgress,
@@ -6508,6 +6635,29 @@ function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
   primaryChildren.return = workInProgress;
   return (workInProgress.child = primaryChildren);
 }
+function mountSuspenseFallbackChildren(
+  workInProgress,
+  primaryChildren,
+  fallbackChildren,
+  renderLanes
+) {
+  var mode = workInProgress.mode;
+  primaryChildren = mountWorkInProgressOffscreenFiber(
+    { mode: "hidden", children: primaryChildren },
+    mode
+  );
+  fallbackChildren = createFiberFromFragment(
+    fallbackChildren,
+    mode,
+    renderLanes,
+    null
+  );
+  primaryChildren.return = workInProgress;
+  fallbackChildren.return = workInProgress;
+  primaryChildren.sibling = fallbackChildren;
+  workInProgress.child = primaryChildren;
+  return fallbackChildren;
+}
 function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
   return createFiberFromOffscreen(offscreenProps, mode, 0, null);
 }
@@ -7003,14 +7153,21 @@ function beginWork(current, workInProgress, renderLanes) {
           (nextHydratableInstance = getNextHydratable(
             lazyComponent.firstChild
           ))),
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps.children,
-          renderLanes
-        ),
+        (lazyComponent = workInProgress.pendingProps.children),
+        null !== current || isHydrating
+          ? reconcileChildren(
+              current,
+              workInProgress,
+              lazyComponent,
+              renderLanes
+            )
+          : (workInProgress.child = reconcileChildFibers(
+              workInProgress,
+              null,
+              lazyComponent,
+              renderLanes
+            )),
         markRef(current, workInProgress),
-        null === current && (workInProgress.flags |= 4194304),
         workInProgress.child
       );
     case 5:
@@ -7236,6 +7393,38 @@ function beginWork(current, workInProgress, renderLanes) {
         ),
         workInProgress.child
       );
+    case 30:
+      return (
+        (lazyComponent = workInProgress.pendingProps),
+        (init = workInProgress.stateNode),
+        null != lazyComponent.name && "auto" !== lazyComponent.name
+          ? ((workInProgress.flags |= 2097152),
+            null === current &&
+              trackAppearingViewTransition(init, lazyComponent.name))
+          : null === init.autoName &&
+            ((nextProps = workInProgressRoot.identifierPrefix),
+            isHydrating
+              ? ((nextState = getTreeId()),
+                (nextProps = "\u00ab" + nextProps + "T" + nextState + "\u00bb"))
+              : ((nextState = globalClientIdCounter++),
+                (nextProps =
+                  "\u00ab" +
+                  nextProps +
+                  "t" +
+                  nextState.toString(32) +
+                  "\u00bb")),
+            (init.autoName = nextProps)),
+        null !== current && current.memoizedProps.name !== lazyComponent.name
+          ? (workInProgress.flags |= 4194816)
+          : markRef(current, workInProgress),
+        reconcileChildren(
+          current,
+          workInProgress,
+          lazyComponent.children,
+          renderLanes
+        ),
+        workInProgress.child
+      );
     case 29:
       throw workInProgress.pendingProps;
   }
@@ -7337,6 +7526,13 @@ function safelyAttachRef(current, nearestMountedAncestor) {
         case 5:
           var instanceToUse = current.stateNode;
           break;
+        case 30:
+          var instance = current.stateNode,
+            name = getViewTransitionName(current.memoizedProps, instance);
+          if (null === instance.ref || instance.ref.name !== name)
+            instance.ref = createViewTransitionInstance(name);
+          instanceToUse = instance.ref;
+          break;
         default:
           instanceToUse = current.stateNode;
       }
@@ -7365,8 +7561,8 @@ function safelyDetachRef(current, nearestMountedAncestor) {
     else if ("function" === typeof ref)
       try {
         ref(null);
-      } catch (error$112) {
-        captureCommitPhaseError(current, nearestMountedAncestor, error$112);
+      } catch (error$115) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error$115);
       }
     else ref.current = null;
 }
@@ -7405,7 +7601,7 @@ function isHostParent(fiber) {
     5 === fiber.tag ||
     3 === fiber.tag ||
     26 === fiber.tag ||
-    (27 === fiber.tag && "head" === fiber.type) ||
+    27 === fiber.tag ||
     4 === fiber.tag
   );
 }
@@ -7418,10 +7614,12 @@ function getHostSibling(fiber) {
     fiber.sibling.return = fiber.return;
     for (
       fiber = fiber.sibling;
-      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;
+      5 !== fiber.tag &&
+      6 !== fiber.tag &&
+      27 !== fiber.tag &&
+      18 !== fiber.tag;
 
     ) {
-      if (27 === fiber.tag && "head" === fiber.type) continue a;
       if (fiber.flags & 2) continue a;
       if (null === fiber.child || 4 === fiber.tag) continue a;
       else (fiber.child.return = fiber), (fiber = fiber.child);
@@ -7432,45 +7630,20 @@ function getHostSibling(fiber) {
 function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
   var tag = node.tag;
   if (5 === tag || 6 === tag)
-    if (((node = node.stateNode), before)) {
-      switch (parent.nodeType) {
-        case 8:
-          parent = parent.parentNode;
-          break;
-        case 9:
-          parent = parent.body;
-          break;
-        default:
-          parent =
-            "HTML" === parent.nodeName ? parent.ownerDocument.body : parent;
-      }
-      parent.insertBefore(node, before);
-    } else
-      a: {
-        switch (parent.nodeType) {
-          case 8:
-            before = parent.parentNode;
-            before.insertBefore(node, parent);
-            break a;
-          case 9:
-            before = parent.body;
-            break;
-          default:
-            before =
-              "HTML" === parent.nodeName ? parent.ownerDocument.body : parent;
-        }
-        before.appendChild(node);
-        parent = parent._reactRootContainer;
-        (null !== parent && void 0 !== parent) ||
-          null !== before.onclick ||
-          (before.onclick = noop$1);
-      }
-  else if (
-    4 !== tag &&
-    (27 === tag && "head" === node.type && (parent = node.stateNode),
-    (node = node.child),
-    null !== node)
-  )
+    (node = node.stateNode),
+      before
+        ? 8 === parent.nodeType
+          ? parent.parentNode.insertBefore(node, before)
+          : parent.insertBefore(node, before)
+        : (8 === parent.nodeType
+            ? ((before = parent.parentNode), before.insertBefore(node, parent))
+            : ((before = parent), before.appendChild(node)),
+          (parent = parent._reactRootContainer),
+          (null !== parent && void 0 !== parent) ||
+            null !== before.onclick ||
+            (before.onclick = noop$1)),
+      (viewTransitionMutationContext = !0);
+  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
     for (
       insertOrAppendPlacementNodeIntoContainer(node, before, parent),
         node = node.sibling;
@@ -7484,13 +7657,9 @@ function insertOrAppendPlacementNode(node, before, parent) {
   var tag = node.tag;
   if (5 === tag || 6 === tag)
     (node = node.stateNode),
-      before ? parent.insertBefore(node, before) : parent.appendChild(node);
-  else if (
-    4 !== tag &&
-    (27 === tag && "head" === node.type && (parent = node.stateNode),
-    (node = node.child),
-    null !== node)
-  )
+      before ? parent.insertBefore(node, before) : parent.appendChild(node),
+      (viewTransitionMutationContext = !0);
+  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
     for (
       insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
       null !== node;
@@ -7498,29 +7667,20 @@ function insertOrAppendPlacementNode(node, before, parent) {
     )
       insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
 }
-function commitHostSingletonAcquisition(finishedWork) {
-  var singleton = finishedWork.stateNode,
-    props = finishedWork.memoizedProps;
-  try {
-    for (
-      var type = finishedWork.type, attributes = singleton.attributes;
-      attributes.length;
-
-    )
-      singleton.removeAttributeNode(attributes[0]);
-    setInitialProperties(singleton, type, props);
-    singleton[internalInstanceKey] = finishedWork;
-    singleton[internalPropsKey] = props;
-  } catch (error) {
-    captureCommitPhaseError(finishedWork, finishedWork.return, error);
-  }
-}
 var offscreenSubtreeIsHidden = !1,
   offscreenSubtreeWasHidden = !1,
   needsFormReset = !1,
   PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
-  nextEffect = null;
-function commitBeforeMutationEffects(root, firstChild) {
+  nextEffect = null,
+  shouldStartViewTransition = !1,
+  viewTransitionContextChanged = !1,
+  viewTransitionCancelableChildren = null;
+function commitBeforeMutationEffects(
+  root,
+  firstChild,
+  committedLanes,
+  appearingViewTransitions
+) {
   root = root.containerInfo;
   eventsEnabled = _enabled;
   root = getActiveElementDeep(root);
@@ -7590,125 +7750,602 @@ function commitBeforeMutationEffects(root, firstChild) {
     JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
   } else JSCompiler_temp = null;
   selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
-  _enabled = !1;
-  for (nextEffect = firstChild; null !== nextEffect; )
+  shouldStartViewTransition = _enabled = !1;
+  committedLanes = (committedLanes & 335544192) === committedLanes;
+  nextEffect = firstChild;
+  for (firstChild = committedLanes ? 9238 : 1028; null !== nextEffect; ) {
+    root = nextEffect;
     if (
-      ((firstChild = nextEffect),
-      (root = firstChild.child),
-      0 !== (firstChild.subtreeFlags & 1024) && null !== root)
+      committedLanes &&
+      ((JSCompiler_temp = root.deletions), null !== JSCompiler_temp)
     )
-      (root.return = firstChild), (nextEffect = root);
-    else
-      for (; null !== nextEffect; ) {
-        firstChild = nextEffect;
-        focusNode = firstChild.alternate;
-        root = firstChild.flags;
-        switch (firstChild.tag) {
-          case 0:
-            break;
-          case 11:
-          case 15:
-            break;
-          case 1:
-            if (0 !== (root & 1024) && null !== focusNode) {
-              root = void 0;
-              JSCompiler_temp = firstChild;
-              anchorOffset = focusNode.memoizedProps;
-              focusNode = focusNode.memoizedState;
-              selection = JSCompiler_temp.stateNode;
-              try {
-                var resolvedPrevProps = resolveClassComponentProps(
-                  JSCompiler_temp.type,
-                  anchorOffset,
-                  JSCompiler_temp.elementType === JSCompiler_temp.type
-                );
-                root = selection.getSnapshotBeforeUpdate(
-                  resolvedPrevProps,
-                  focusNode
-                );
-                selection.__reactInternalSnapshotBeforeUpdate = root;
-              } catch (error) {
-                captureCommitPhaseError(
-                  JSCompiler_temp,
-                  JSCompiler_temp.return,
-                  error
-                );
-              }
-            }
-            break;
-          case 3:
-            if (0 !== (root & 1024))
-              if (
-                ((root = firstChild.stateNode.containerInfo),
-                (JSCompiler_temp = root.nodeType),
-                9 === JSCompiler_temp)
-              )
-                clearContainerSparingly(root);
-              else if (1 === JSCompiler_temp)
-                switch (root.nodeName) {
-                  case "HEAD":
-                  case "HTML":
-                  case "BODY":
-                    clearContainerSparingly(root);
-                    break;
-                  default:
-                    root.textContent = "";
-                }
-            break;
-          case 5:
-          case 26:
-          case 27:
-          case 6:
-          case 4:
-          case 17:
-            break;
-          default:
-            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
-        }
-        root = firstChild.sibling;
-        if (null !== root) {
-          root.return = firstChild.return;
-          nextEffect = root;
-          break;
-        }
-        nextEffect = firstChild.return;
-      }
-}
-function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
-  var flags = finishedWork.flags;
-  switch (finishedWork.tag) {
-    case 0:
-    case 11:
-    case 15:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 4 && commitHookEffectListMount(5, finishedWork);
-      break;
-    case 1:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      if (flags & 4)
-        if (((finishedRoot = finishedWork.stateNode), null === current))
-          try {
-            finishedRoot.componentDidMount();
-          } catch (error) {
-            captureCommitPhaseError(finishedWork, finishedWork.return, error);
-          }
-        else {
-          var prevProps = resolveClassComponentProps(
-            finishedWork.type,
-            current.memoizedProps
+      for (
+        anchorOffset = 0;
+        anchorOffset < JSCompiler_temp.length;
+        anchorOffset++
+      )
+        committedLanes &&
+          commitExitViewTransitions(
+            JSCompiler_temp[anchorOffset],
+            appearingViewTransitions
           );
-          current = current.memoizedState;
-          try {
-            finishedRoot.componentDidUpdate(
-              prevProps,
-              current,
-              finishedRoot.__reactInternalSnapshotBeforeUpdate
+    if (null === root.alternate && 0 !== (root.flags & 2))
+      commitBeforeMutationEffects_complete(committedLanes);
+    else {
+      if (22 === root.tag)
+        if (((JSCompiler_temp = root.alternate), null !== root.memoizedState)) {
+          null !== JSCompiler_temp &&
+            null === JSCompiler_temp.memoizedState &&
+            committedLanes &&
+            commitExitViewTransitions(
+              JSCompiler_temp,
+              appearingViewTransitions
             );
-          } catch (error$111) {
-            captureCommitPhaseError(
+          commitBeforeMutationEffects_complete(committedLanes);
+          continue;
+        } else if (
+          null !== JSCompiler_temp &&
+          null !== JSCompiler_temp.memoizedState
+        ) {
+          commitBeforeMutationEffects_complete(committedLanes);
+          continue;
+        }
+      JSCompiler_temp = root.child;
+      0 !== (root.subtreeFlags & firstChild) && null !== JSCompiler_temp
+        ? ((JSCompiler_temp.return = root), (nextEffect = JSCompiler_temp))
+        : (committedLanes && commitNestedViewTransitions(root),
+          commitBeforeMutationEffects_complete(committedLanes));
+    }
+  }
+}
+function commitBeforeMutationEffects_complete(
+  isViewTransitionEligible$jscomp$0
+) {
+  for (; null !== nextEffect; ) {
+    var fiber = nextEffect,
+      isViewTransitionEligible = isViewTransitionEligible$jscomp$0,
+      current = fiber.alternate,
+      flags = fiber.flags;
+    switch (fiber.tag) {
+      case 0:
+        if (
+          0 !== (flags & 4) &&
+          ((current = fiber.updateQueue),
+          (current = null !== current ? current.events : null),
+          null !== current)
+        )
+          for (
+            isViewTransitionEligible = 0;
+            isViewTransitionEligible < current.length;
+            isViewTransitionEligible++
+          )
+            (flags = current[isViewTransitionEligible]),
+              (flags.ref.impl = flags.nextImpl);
+        break;
+      case 11:
+      case 15:
+        break;
+      case 1:
+        if (0 !== (flags & 1024) && null !== current) {
+          isViewTransitionEligible = void 0;
+          flags = current.memoizedProps;
+          current = current.memoizedState;
+          var instance = fiber.stateNode;
+          try {
+            var resolvedPrevProps = resolveClassComponentProps(
+              fiber.type,
+              flags,
+              fiber.elementType === fiber.type
+            );
+            isViewTransitionEligible = instance.getSnapshotBeforeUpdate(
+              resolvedPrevProps,
+              current
+            );
+            instance.__reactInternalSnapshotBeforeUpdate =
+              isViewTransitionEligible;
+          } catch (error) {
+            captureCommitPhaseError(fiber, fiber.return, error);
+          }
+        }
+        break;
+      case 3:
+        if (0 !== (flags & 1024))
+          if (
+            ((current = fiber.stateNode.containerInfo),
+            (isViewTransitionEligible = current.nodeType),
+            9 === isViewTransitionEligible)
+          )
+            clearContainerSparingly(current);
+          else if (1 === isViewTransitionEligible)
+            switch (current.nodeName) {
+              case "HEAD":
+              case "HTML":
+              case "BODY":
+                clearContainerSparingly(current);
+                break;
+              default:
+                current.textContent = "";
+            }
+        break;
+      case 5:
+      case 26:
+      case 27:
+      case 6:
+      case 4:
+      case 17:
+        break;
+      case 30:
+        if (
+          isViewTransitionEligible &&
+          null !== current &&
+          0 !== (fiber.subtreeFlags & 8246)
+        )
+          a: {
+            isViewTransitionEligible = getViewTransitionName(
+              current.memoizedProps,
+              current.stateNode
+            );
+            flags = fiber.memoizedProps;
+            instance = getViewTransitionClassName(
+              flags.className,
+              flags.update
+            );
+            if (
+              "none" === instance &&
+              ((instance = getViewTransitionClassName(
+                flags.className,
+                flags.layout
+              )),
+              "none" === instance)
+            )
+              break a;
+            viewTransitionHostInstanceIdx = 0;
+            applyViewTransitionToHostInstances(
+              current.child,
+              isViewTransitionEligible,
+              instance,
+              (current.memoizedState = []),
+              !0
+            );
+          }
+        break;
+      default:
+        if (0 !== (flags & 1024)) throw Error(formatProdErrorMessage(163));
+    }
+    current = fiber.sibling;
+    if (null !== current) {
+      current.return = fiber.return;
+      nextEffect = current;
+      break;
+    }
+    nextEffect = fiber.return;
+  }
+}
+var viewTransitionHostInstanceIdx = 0;
+function applyViewTransitionToHostInstances(
+  child,
+  name,
+  className,
+  collectMeasurements,
+  stopAtNestedViewTransitions
+) {
+  for (var inViewport = !1; null !== child; ) {
+    if (5 === child.tag) {
+      shouldStartViewTransition = !0;
+      var instance = child.stateNode;
+      if (null !== collectMeasurements) {
+        var measurement = measureInstance(instance);
+        collectMeasurements.push(measurement);
+        measurement.view && (inViewport = !0);
+      } else
+        inViewport || (measureInstance(instance).view && (inViewport = !0));
+      measurement = className;
+      instance.style.viewTransitionName =
+        0 === viewTransitionHostInstanceIdx
+          ? name
+          : name + "_" + viewTransitionHostInstanceIdx;
+      null != measurement && (instance.style.viewTransitionClass = measurement);
+      viewTransitionHostInstanceIdx++;
+    } else if (22 !== child.tag || null === child.memoizedState)
+      (30 === child.tag && stopAtNestedViewTransitions) ||
+        (applyViewTransitionToHostInstances(
+          child.child,
+          name,
+          className,
+          collectMeasurements,
+          stopAtNestedViewTransitions
+        ) &&
+          (inViewport = !0));
+    child = child.sibling;
+  }
+  return inViewport;
+}
+function restoreViewTransitionOnHostInstances(
+  child,
+  stopAtNestedViewTransitions
+) {
+  for (; null !== child; ) {
+    if (5 === child.tag)
+      restoreViewTransitionName(child.stateNode, child.memoizedProps);
+    else if (22 !== child.tag || null === child.memoizedState)
+      (30 === child.tag && stopAtNestedViewTransitions) ||
+        restoreViewTransitionOnHostInstances(
+          child.child,
+          stopAtNestedViewTransitions
+        );
+    child = child.sibling;
+  }
+}
+function commitAppearingPairViewTransitions(placement) {
+  if (0 !== (placement.subtreeFlags & 2097152))
+    for (placement = placement.child; null !== placement; ) {
+      if (22 !== placement.tag || null !== placement.memoizedState)
+        if (
+          (commitAppearingPairViewTransitions(placement),
+          30 === placement.tag &&
+            0 !== (placement.flags & 2097152) &&
+            placement.stateNode.paired)
+        ) {
+          var props = placement.memoizedProps;
+          if (null == props.name || "auto" === props.name)
+            throw Error(formatProdErrorMessage(544));
+          var name = props.name;
+          props = getViewTransitionClassName(props.className, props.share);
+          "none" !== props &&
+            ((viewTransitionHostInstanceIdx = 0),
+            applyViewTransitionToHostInstances(
+              placement.child,
+              name,
+              props,
+              null,
+              !1
+            ) || restoreViewTransitionOnHostInstances(placement.child, !1));
+        }
+      placement = placement.sibling;
+    }
+}
+function commitEnterViewTransitions(placement) {
+  if (30 === placement.tag) {
+    var state = placement.stateNode,
+      props = placement.memoizedProps,
+      name = getViewTransitionName(props, state),
+      className = getViewTransitionClassName(
+        props.className,
+        state.paired ? props.share : props.enter
+      );
+    "none" !== className
+      ? ((viewTransitionHostInstanceIdx = 0),
+        applyViewTransitionToHostInstances(
+          placement.child,
+          name,
+          className,
+          null,
+          !1
+        )
+          ? (commitAppearingPairViewTransitions(placement),
+            state.paired ||
+              scheduleViewTransitionEvent(placement, props.onEnter))
+          : restoreViewTransitionOnHostInstances(placement.child, !1))
+      : commitAppearingPairViewTransitions(placement);
+  } else if (0 !== (placement.subtreeFlags & 33554432))
+    for (placement = placement.child; null !== placement; )
+      commitEnterViewTransitions(placement), (placement = placement.sibling);
+  else commitAppearingPairViewTransitions(placement);
+}
+function commitDeletedPairViewTransitions(deletion, appearingViewTransitions) {
+  if (
+    0 !== appearingViewTransitions.size &&
+    0 !== (deletion.subtreeFlags & 2097152)
+  )
+    for (deletion = deletion.child; null !== deletion; ) {
+      if (22 !== deletion.tag || null !== deletion.memoizedState) {
+        if (30 === deletion.tag && 0 !== (deletion.flags & 2097152)) {
+          var props = deletion.memoizedProps,
+            name = props.name;
+          if (null != name && "auto" !== name) {
+            var pair = appearingViewTransitions.get(name);
+            if (void 0 !== pair) {
+              var className = getViewTransitionClassName(
+                props.className,
+                props.share
+              );
+              "none" !== className &&
+                ((viewTransitionHostInstanceIdx = 0),
+                applyViewTransitionToHostInstances(
+                  deletion.child,
+                  name,
+                  className,
+                  null,
+                  !1
+                )
+                  ? ((pair.paired = deletion.stateNode),
+                    scheduleViewTransitionEvent(deletion, props.onShare))
+                  : restoreViewTransitionOnHostInstances(deletion.child, !1));
+              appearingViewTransitions.delete(name);
+              if (0 === appearingViewTransitions.size) break;
+            }
+          }
+        }
+        commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+      }
+      deletion = deletion.sibling;
+    }
+}
+function commitExitViewTransitions(deletion, appearingViewTransitions) {
+  if (30 === deletion.tag) {
+    var props = deletion.memoizedProps,
+      name = getViewTransitionName(props, deletion.stateNode),
+      pair =
+        null !== appearingViewTransitions
+          ? appearingViewTransitions.get(name)
+          : void 0,
+      className = getViewTransitionClassName(
+        props.className,
+        void 0 !== pair ? props.share : props.exit
+      );
+    "none" !== className &&
+      ((viewTransitionHostInstanceIdx = 0),
+      applyViewTransitionToHostInstances(
+        deletion.child,
+        name,
+        className,
+        null,
+        !1
+      )
+        ? void 0 !== pair
+          ? ((pair.paired = deletion.stateNode),
+            appearingViewTransitions.delete(name),
+            scheduleViewTransitionEvent(deletion, props.onShare))
+          : scheduleViewTransitionEvent(deletion, props.onExit)
+        : restoreViewTransitionOnHostInstances(deletion.child, !1));
+    null !== appearingViewTransitions &&
+      commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+  } else if (0 !== (deletion.subtreeFlags & 33554432))
+    for (deletion = deletion.child; null !== deletion; )
+      commitExitViewTransitions(deletion, appearingViewTransitions),
+        (deletion = deletion.sibling);
+  else
+    null !== appearingViewTransitions &&
+      commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+}
+function commitNestedViewTransitions(changedParent) {
+  for (changedParent = changedParent.child; null !== changedParent; ) {
+    if (30 === changedParent.tag) {
+      var props = changedParent.memoizedProps,
+        name = getViewTransitionName(props, changedParent.stateNode);
+      props = getViewTransitionClassName(props.className, props.layout);
+      "none" !== props &&
+        ((viewTransitionHostInstanceIdx = 0),
+        applyViewTransitionToHostInstances(
+          changedParent.child,
+          name,
+          props,
+          (changedParent.memoizedState = []),
+          !1
+        ));
+    } else
+      0 !== (changedParent.subtreeFlags & 33554432) &&
+        commitNestedViewTransitions(changedParent);
+    changedParent = changedParent.sibling;
+  }
+}
+function restorePairedViewTransitions(parent) {
+  if (0 !== (parent.subtreeFlags & 2097152))
+    for (parent = parent.child; null !== parent; ) {
+      if (22 !== parent.tag || null !== parent.memoizedState) {
+        if (30 === parent.tag && 0 !== (parent.flags & 2097152)) {
+          var instance = parent.stateNode;
+          null !== instance.paired &&
+            ((instance.paired = null),
+            restoreViewTransitionOnHostInstances(parent.child, !1));
+        }
+        restorePairedViewTransitions(parent);
+      }
+      parent = parent.sibling;
+    }
+}
+function restoreEnterViewTransitions(placement) {
+  if (30 === placement.tag)
+    (placement.stateNode.paired = null),
+      restoreViewTransitionOnHostInstances(placement.child, !1),
+      restorePairedViewTransitions(placement);
+  else if (0 !== (placement.subtreeFlags & 33554432))
+    for (placement = placement.child; null !== placement; )
+      restoreEnterViewTransitions(placement), (placement = placement.sibling);
+  else restorePairedViewTransitions(placement);
+}
+function restoreExitViewTransitions(deletion) {
+  if (30 === deletion.tag)
+    (deletion.stateNode.paired = null),
+      restoreViewTransitionOnHostInstances(deletion.child, !1),
+      restorePairedViewTransitions(deletion);
+  else if (0 !== (deletion.subtreeFlags & 33554432))
+    for (deletion = deletion.child; null !== deletion; )
+      restoreExitViewTransitions(deletion), (deletion = deletion.sibling);
+  else restorePairedViewTransitions(deletion);
+}
+function restoreNestedViewTransitions(changedParent) {
+  for (changedParent = changedParent.child; null !== changedParent; )
+    30 === changedParent.tag
+      ? ((changedParent.memoizedState = null),
+        restoreViewTransitionOnHostInstances(changedParent.child, !1))
+      : 0 !== (changedParent.subtreeFlags & 33554432) &&
+        restoreNestedViewTransitions(changedParent),
+      (changedParent = changedParent.sibling);
+}
+function cancelViewTransitionHostInstances(
+  currentViewTransition,
+  child,
+  stopAtNestedViewTransitions
+) {
+  for (; null !== child; ) {
+    if (5 === child.tag) {
+      var instance = child.stateNode,
+        oldName = getViewTransitionName(
+          currentViewTransition.memoizedProps,
+          currentViewTransition.stateNode
+        );
+      null === viewTransitionCancelableChildren &&
+        (viewTransitionCancelableChildren = []);
+      viewTransitionCancelableChildren.push(
+        instance,
+        oldName,
+        child.memoizedProps
+      );
+      viewTransitionHostInstanceIdx++;
+    } else if (22 !== child.tag || null === child.memoizedState)
+      (30 === child.tag && stopAtNestedViewTransitions) ||
+        cancelViewTransitionHostInstances(
+          currentViewTransition,
+          child.child,
+          stopAtNestedViewTransitions
+        );
+    child = child.sibling;
+  }
+}
+function measureViewTransitionHostInstances(
+  currentViewTransition,
+  parentViewTransition,
+  child,
+  name,
+  className,
+  previousMeasurements,
+  stopAtNestedViewTransitions
+) {
+  for (var inViewport = !1; null !== child; ) {
+    if (5 === child.tag) {
+      var instance = child.stateNode;
+      if (
+        null !== previousMeasurements &&
+        viewTransitionHostInstanceIdx < previousMeasurements.length
+      ) {
+        var previousMeasurement =
+            previousMeasurements[viewTransitionHostInstanceIdx],
+          nextMeasurement = measureInstance(instance);
+        if (previousMeasurement.view || nextMeasurement.view) inViewport = !0;
+        var JSCompiler_temp;
+        if ((JSCompiler_temp = 0 === (parentViewTransition.flags & 4)))
+          if (nextMeasurement.clip) JSCompiler_temp = !0;
+          else {
+            JSCompiler_temp = previousMeasurement.rect;
+            var newRect = nextMeasurement.rect;
+            JSCompiler_temp =
+              JSCompiler_temp.y !== newRect.y ||
+              JSCompiler_temp.x !== newRect.x ||
+              JSCompiler_temp.height !== newRect.height ||
+              JSCompiler_temp.width !== newRect.width;
+          }
+        JSCompiler_temp && (parentViewTransition.flags |= 4);
+        nextMeasurement.abs
+          ? (nextMeasurement = !previousMeasurement.abs)
+          : ((previousMeasurement = previousMeasurement.rect),
+            (nextMeasurement = nextMeasurement.rect),
+            (nextMeasurement =
+              previousMeasurement.height !== nextMeasurement.height ||
+              previousMeasurement.width !== nextMeasurement.width));
+        nextMeasurement && (parentViewTransition.flags |= 32);
+      } else parentViewTransition.flags |= 32;
+      0 !== (parentViewTransition.flags & 4) &&
+        ((nextMeasurement = instance),
+        (previousMeasurement = className),
+        (nextMeasurement.style.viewTransitionName =
+          0 === viewTransitionHostInstanceIdx
+            ? name
+            : name + "_" + viewTransitionHostInstanceIdx),
+        null != previousMeasurement &&
+          (nextMeasurement.style.viewTransitionClass = previousMeasurement));
+      (inViewport && 0 !== (parentViewTransition.flags & 4)) ||
+        ((nextMeasurement = getViewTransitionName(
+          currentViewTransition.memoizedProps,
+          currentViewTransition.stateNode
+        )),
+        null === viewTransitionCancelableChildren &&
+          (viewTransitionCancelableChildren = []),
+        viewTransitionCancelableChildren.push(
+          instance,
+          nextMeasurement,
+          child.memoizedProps
+        ));
+      viewTransitionHostInstanceIdx++;
+    } else if (22 !== child.tag || null === child.memoizedState)
+      30 === child.tag && stopAtNestedViewTransitions
+        ? (parentViewTransition.flags |= child.flags & 32)
+        : measureViewTransitionHostInstances(
+            currentViewTransition,
+            parentViewTransition,
+            child.child,
+            name,
+            className,
+            previousMeasurements,
+            stopAtNestedViewTransitions
+          ) && (inViewport = !0);
+    child = child.sibling;
+  }
+  return inViewport;
+}
+function measureNestedViewTransitions(changedParent) {
+  for (changedParent = changedParent.child; null !== changedParent; ) {
+    if (30 === changedParent.tag) {
+      var current = changedParent.alternate;
+      if (null !== current) {
+        var props = changedParent.memoizedProps,
+          name = getViewTransitionName(props, changedParent.stateNode),
+          className = getViewTransitionClassName(props.className, props.layout);
+        viewTransitionHostInstanceIdx = 0;
+        current = measureViewTransitionHostInstances(
+          current,
+          changedParent,
+          changedParent.child,
+          name,
+          className,
+          changedParent.memoizedState,
+          !1
+        );
+        0 !== (changedParent.flags & 4) &&
+          current &&
+          scheduleViewTransitionEvent(changedParent, props.onLayout);
+      }
+    } else
+      0 !== (changedParent.subtreeFlags & 33554432) &&
+        measureNestedViewTransitions(changedParent);
+    changedParent = changedParent.sibling;
+  }
+}
+function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
+  var flags = finishedWork.flags;
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 15:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 4 && commitHookEffectListMount(5, finishedWork);
+      break;
+    case 1:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      if (flags & 4)
+        if (((finishedRoot = finishedWork.stateNode), null === current))
+          try {
+            finishedRoot.componentDidMount();
+          } catch (error) {
+            captureCommitPhaseError(finishedWork, finishedWork.return, error);
+          }
+        else {
+          var prevProps = resolveClassComponentProps(
+            finishedWork.type,
+            current.memoizedProps
+          );
+          current = current.memoizedState;
+          try {
+            finishedRoot.componentDidUpdate(
+              prevProps,
+              current,
+              finishedRoot.__reactInternalSnapshotBeforeUpdate
+            );
+          } catch (error$114) {
+            captureCommitPhaseError(
               finishedWork,
               finishedWork.return,
-              error$111
+              error$114
             );
           }
         }
@@ -7735,11 +8372,11 @@ function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
         }
       }
       break;
-    case 27:
-      null === current &&
-        flags & 4 &&
-        commitHostSingletonAcquisition(finishedWork);
     case 26:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+      break;
+    case 27:
     case 5:
       recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
       null === current && flags & 4 && commitHostMount(finishedWork);
@@ -7787,6 +8424,10 @@ function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
           ? safelyAttachRef(finishedWork, finishedWork.return)
           : safelyDetachRef(finishedWork, finishedWork.return));
       break;
+    case 30:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+      break;
     default:
       recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
   }
@@ -7850,14 +8491,20 @@ function commitDeletionEffectsOnFiber(
         safelyDetachRef(deletedFiber, nearestMountedAncestor);
       var prevHostParent = hostParent,
         prevHostParentIsContainer = hostParentIsContainer;
-      "head" === deletedFiber.type &&
-        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !1));
+      hostParent = deletedFiber.stateNode;
       recursivelyTraverseDeletionEffects(
         finishedRoot,
         nearestMountedAncestor,
         deletedFiber
       );
-      releaseSingletonInstance(deletedFiber.stateNode);
+      deletedFiber = deletedFiber.stateNode;
+      for (
+        nearestMountedAncestor = deletedFiber.attributes;
+        nearestMountedAncestor.length;
+
+      )
+        deletedFiber.removeAttributeNode(nearestMountedAncestor[0]);
+      detachDeletedInstance(deletedFiber);
       hostParent = prevHostParent;
       hostParentIsContainer = prevHostParentIsContainer;
       break;
@@ -7865,33 +8512,25 @@ function commitDeletionEffectsOnFiber(
       offscreenSubtreeWasHidden ||
         safelyDetachRef(deletedFiber, nearestMountedAncestor);
     case 6:
-      prevHostParent = hostParent;
-      prevHostParentIsContainer = hostParentIsContainer;
+      prevHostParentIsContainer = hostParent;
+      var prevHostParentIsContainer$122 = hostParentIsContainer;
       hostParent = null;
       recursivelyTraverseDeletionEffects(
         finishedRoot,
         nearestMountedAncestor,
         deletedFiber
       );
-      hostParent = prevHostParent;
-      hostParentIsContainer = prevHostParentIsContainer;
+      hostParent = prevHostParentIsContainer;
+      hostParentIsContainer = prevHostParentIsContainer$122;
       if (null !== hostParent)
         if (hostParentIsContainer)
           try {
-            switch (hostParent.nodeType) {
-              case 8:
-                var parentNode = hostParent.parentNode;
-                break;
-              case 9:
-                parentNode = hostParent.body;
-                break;
-              default:
-                parentNode =
-                  "HTML" === hostParent.nodeName
-                    ? hostParent.ownerDocument.body
-                    : hostParent;
-            }
-            parentNode.removeChild(deletedFiber.stateNode);
+            (finishedRoot = hostParent),
+              (prevHostParent = deletedFiber.stateNode),
+              8 === finishedRoot.nodeType
+                ? finishedRoot.parentNode.removeChild(prevHostParent)
+                : finishedRoot.removeChild(prevHostParent),
+              (viewTransitionMutationContext = !0);
           } catch (error) {
             captureCommitPhaseError(
               deletedFiber,
@@ -7901,7 +8540,8 @@ function commitDeletionEffectsOnFiber(
           }
         else
           try {
-            hostParent.removeChild(deletedFiber.stateNode);
+            hostParent.removeChild(deletedFiber.stateNode),
+              (viewTransitionMutationContext = !0);
           } catch (error) {
             captureCommitPhaseError(
               deletedFiber,
@@ -7913,19 +8553,16 @@ function commitDeletionEffectsOnFiber(
     case 18:
       null !== hostParent &&
         (hostParentIsContainer
-          ? ((finishedRoot = hostParent),
+          ? ((nearestMountedAncestor = hostParent),
             (deletedFiber = deletedFiber.stateNode),
-            8 === finishedRoot.nodeType
-              ? clearSuspenseBoundary(finishedRoot.parentNode, deletedFiber)
-              : 9 === finishedRoot.nodeType
-                ? clearSuspenseBoundary(finishedRoot.body, deletedFiber)
-                : "HTML" === finishedRoot.nodeName
-                  ? clearSuspenseBoundary(
-                      finishedRoot.ownerDocument.body,
-                      deletedFiber
-                    )
-                  : clearSuspenseBoundary(finishedRoot, deletedFiber),
-            retryIfBlockedOn(finishedRoot))
+            8 === nearestMountedAncestor.nodeType
+              ? clearSuspenseBoundary(
+                  nearestMountedAncestor.parentNode,
+                  deletedFiber
+                )
+              : 1 === nearestMountedAncestor.nodeType &&
+                clearSuspenseBoundary(nearestMountedAncestor, deletedFiber),
+            retryIfBlockedOn(nearestMountedAncestor))
           : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
       break;
     case 4:
@@ -8042,7 +8679,7 @@ function attachSuspenseRetryListeners(finishedWork, wakeables) {
       (retryCache.add(wakeable), wakeable.then(retry, retry));
   });
 }
-function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
+function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber, lanes) {
   var deletions = parentFiber.deletions;
   if (null !== deletions)
     for (var i = 0; i < deletions.length; i++) {
@@ -8053,12 +8690,6 @@ function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
       a: for (; null !== parent; ) {
         switch (parent.tag) {
           case 27:
-            if ("head" === parent.type) {
-              hostParent = parent.stateNode;
-              hostParentIsContainer = !1;
-              break a;
-            }
-            break;
           case 5:
             hostParent = parent.stateNode;
             hostParentIsContainer = !1;
@@ -8084,11 +8715,11 @@ function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
     }
   if (parentFiber.subtreeFlags & 13878)
     for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
+      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0, lanes),
         (parentFiber = parentFiber.sibling);
 }
 var currentHoistableRoot = null;
-function commitMutationEffectsOnFiber(finishedWork, root) {
+function commitMutationEffectsOnFiber(finishedWork, root, lanes) {
   var current = finishedWork.alternate,
     flags = finishedWork.flags;
   switch (finishedWork.tag) {
@@ -8096,7 +8727,7 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
     case 11:
     case 14:
     case 15:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       flags & 4 &&
         (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
@@ -8104,7 +8735,7 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
         commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
       break;
     case 1:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       flags & 512 &&
         (offscreenSubtreeWasHidden ||
@@ -8122,117 +8753,118 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
       break;
     case 26:
       var hoistableRoot = currentHoistableRoot;
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       flags & 512 &&
         (offscreenSubtreeWasHidden ||
           null === current ||
           safelyDetachRef(current, current.return));
-      if (flags & 4) {
-        var currentResource = null !== current ? current.memoizedState : null;
-        flags = finishedWork.memoizedState;
-        if (null === current)
+      if (flags & 4)
+        if (
+          ((root = null !== current ? current.memoizedState : null),
+          (flags = finishedWork.memoizedState),
+          null === current)
+        )
           if (null === flags)
             if (null === finishedWork.stateNode) {
               a: {
                 flags = finishedWork.type;
                 current = finishedWork.memoizedProps;
-                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
+                root = hoistableRoot.ownerDocument || hoistableRoot;
                 b: switch (flags) {
                   case "title":
-                    currentResource =
-                      hoistableRoot.getElementsByTagName("title")[0];
+                    lanes = root.getElementsByTagName("title")[0];
                     if (
-                      !currentResource ||
-                      currentResource[internalHoistableMarker] ||
-                      currentResource[internalInstanceKey] ||
-                      "http://www.w3.org/2000/svg" ===
-                        currentResource.namespaceURI ||
-                      currentResource.hasAttribute("itemprop")
+                      !lanes ||
+                      lanes[internalHoistableMarker] ||
+                      lanes[internalInstanceKey] ||
+                      "http://www.w3.org/2000/svg" === lanes.namespaceURI ||
+                      lanes.hasAttribute("itemprop")
                     )
-                      (currentResource = hoistableRoot.createElement(flags)),
-                        hoistableRoot.head.insertBefore(
-                          currentResource,
-                          hoistableRoot.querySelector("head > title")
+                      (lanes = root.createElement(flags)),
+                        root.head.insertBefore(
+                          lanes,
+                          root.querySelector("head > title")
                         );
-                    setInitialProperties(currentResource, flags, current);
-                    currentResource[internalInstanceKey] = finishedWork;
-                    markNodeAsHoistable(currentResource);
-                    flags = currentResource;
+                    setInitialProperties(lanes, flags, current);
+                    lanes[internalInstanceKey] = finishedWork;
+                    markNodeAsHoistable(lanes);
+                    flags = lanes;
                     break a;
                   case "link":
-                    var maybeNodes = getHydratableHoistableCache(
-                      "link",
-                      "href",
-                      hoistableRoot
-                    ).get(flags + (current.href || ""));
-                    if (maybeNodes)
-                      for (var i = 0; i < maybeNodes.length; i++)
+                    if (
+                      (hoistableRoot = getHydratableHoistableCache(
+                        "link",
+                        "href",
+                        root
+                      ).get(flags + (current.href || "")))
+                    )
+                      for (var i = 0; i < hoistableRoot.length; i++)
                         if (
-                          ((currentResource = maybeNodes[i]),
-                          currentResource.getAttribute("href") ===
+                          ((lanes = hoistableRoot[i]),
+                          lanes.getAttribute("href") ===
                             (null == current.href || "" === current.href
                               ? null
                               : current.href) &&
-                            currentResource.getAttribute("rel") ===
+                            lanes.getAttribute("rel") ===
                               (null == current.rel ? null : current.rel) &&
-                            currentResource.getAttribute("title") ===
+                            lanes.getAttribute("title") ===
                               (null == current.title ? null : current.title) &&
-                            currentResource.getAttribute("crossorigin") ===
+                            lanes.getAttribute("crossorigin") ===
                               (null == current.crossOrigin
                                 ? null
                                 : current.crossOrigin))
                         ) {
-                          maybeNodes.splice(i, 1);
+                          hoistableRoot.splice(i, 1);
                           break b;
                         }
-                    currentResource = hoistableRoot.createElement(flags);
-                    setInitialProperties(currentResource, flags, current);
-                    hoistableRoot.head.appendChild(currentResource);
+                    lanes = root.createElement(flags);
+                    setInitialProperties(lanes, flags, current);
+                    root.head.appendChild(lanes);
                     break;
                   case "meta":
                     if (
-                      (maybeNodes = getHydratableHoistableCache(
+                      (hoistableRoot = getHydratableHoistableCache(
                         "meta",
                         "content",
-                        hoistableRoot
+                        root
                       ).get(flags + (current.content || "")))
                     )
-                      for (i = 0; i < maybeNodes.length; i++)
+                      for (i = 0; i < hoistableRoot.length; i++)
                         if (
-                          ((currentResource = maybeNodes[i]),
-                          currentResource.getAttribute("content") ===
+                          ((lanes = hoistableRoot[i]),
+                          lanes.getAttribute("content") ===
                             (null == current.content
                               ? null
                               : "" + current.content) &&
-                            currentResource.getAttribute("name") ===
+                            lanes.getAttribute("name") ===
                               (null == current.name ? null : current.name) &&
-                            currentResource.getAttribute("property") ===
+                            lanes.getAttribute("property") ===
                               (null == current.property
                                 ? null
                                 : current.property) &&
-                            currentResource.getAttribute("http-equiv") ===
+                            lanes.getAttribute("http-equiv") ===
                               (null == current.httpEquiv
                                 ? null
                                 : current.httpEquiv) &&
-                            currentResource.getAttribute("charset") ===
+                            lanes.getAttribute("charset") ===
                               (null == current.charSet
                                 ? null
                                 : current.charSet))
                         ) {
-                          maybeNodes.splice(i, 1);
+                          hoistableRoot.splice(i, 1);
                           break b;
                         }
-                    currentResource = hoistableRoot.createElement(flags);
-                    setInitialProperties(currentResource, flags, current);
-                    hoistableRoot.head.appendChild(currentResource);
+                    lanes = root.createElement(flags);
+                    setInitialProperties(lanes, flags, current);
+                    root.head.appendChild(lanes);
                     break;
                   default:
                     throw Error(formatProdErrorMessage(468, flags));
                 }
-                currentResource[internalInstanceKey] = finishedWork;
-                markNodeAsHoistable(currentResource);
-                flags = currentResource;
+                lanes[internalInstanceKey] = finishedWork;
+                markNodeAsHoistable(lanes);
+                flags = lanes;
               }
               finishedWork.stateNode = flags;
             } else
@@ -8248,12 +8880,12 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
               finishedWork.memoizedProps
             );
         else
-          currentResource !== flags
-            ? (null === currentResource
+          root !== flags
+            ? (null === root
                 ? null !== current.stateNode &&
                   ((current = current.stateNode),
                   current.parentNode.removeChild(current))
-                : currentResource.count--,
+                : root.count--,
               null === flags
                 ? mountHoistable(
                     hoistableRoot,
@@ -8272,50 +8904,65 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
                 finishedWork.memoizedProps,
                 current.memoizedProps
               );
-      }
       break;
     case 27:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 512 &&
-        (offscreenSubtreeWasHidden ||
-          null === current ||
-          safelyDetachRef(current, current.return));
-      null !== current &&
-        flags & 4 &&
-        commitHostUpdate(
-          finishedWork,
-          finishedWork.memoizedProps,
-          current.memoizedProps
-        );
-      break;
+      if (flags & 4 && null === finishedWork.alternate) {
+        hoistableRoot = finishedWork.stateNode;
+        i = finishedWork.memoizedProps;
+        try {
+          for (var node = hoistableRoot.firstChild; node; ) {
+            var nextNode = node.nextSibling,
+              nodeName = node.nodeName;
+            node[internalHoistableMarker] ||
+              "HEAD" === nodeName ||
+              "BODY" === nodeName ||
+              "SCRIPT" === nodeName ||
+              "STYLE" === nodeName ||
+              ("LINK" === nodeName &&
+                "stylesheet" === node.rel.toLowerCase()) ||
+              hoistableRoot.removeChild(node);
+            node = nextNode;
+          }
+          for (
+            var type = finishedWork.type, attributes = hoistableRoot.attributes;
+            attributes.length;
+
+          )
+            hoistableRoot.removeAttributeNode(attributes[0]);
+          setInitialProperties(hoistableRoot, type, i);
+          hoistableRoot[internalInstanceKey] = finishedWork;
+          hoistableRoot[internalPropsKey] = i;
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      }
     case 5:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       flags & 512 &&
         (offscreenSubtreeWasHidden ||
           null === current ||
           safelyDetachRef(current, current.return));
       if (finishedWork.flags & 32) {
-        hoistableRoot = finishedWork.stateNode;
+        root = finishedWork.stateNode;
         try {
-          setTextContent(hoistableRoot, "");
+          setTextContent(root, ""), (viewTransitionMutationContext = !0);
         } catch (error) {
           captureCommitPhaseError(finishedWork, finishedWork.return, error);
         }
       }
       flags & 4 &&
         null != finishedWork.stateNode &&
-        ((hoistableRoot = finishedWork.memoizedProps),
+        ((root = finishedWork.memoizedProps),
         commitHostUpdate(
           finishedWork,
-          hoistableRoot,
-          null !== current ? current.memoizedProps : hoistableRoot
+          root,
+          null !== current ? current.memoizedProps : root
         ));
       flags & 1024 && (needsFormReset = !0);
       break;
     case 6:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       if (flags & 4) {
         if (null === finishedWork.stateNode)
@@ -8323,7 +8970,7 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
         flags = finishedWork.memoizedProps;
         current = finishedWork.stateNode;
         try {
-          current.nodeValue = flags;
+          (current.nodeValue = flags), (viewTransitionMutationContext = !0);
         } catch (error) {
           captureCommitPhaseError(finishedWork, finishedWork.return, error);
         }
@@ -8333,7 +8980,7 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
       tagCaches = null;
       hoistableRoot = currentHoistableRoot;
       currentHoistableRoot = getHoistableRoot(root.containerInfo);
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       currentHoistableRoot = hoistableRoot;
       commitReconciliationEffects(finishedWork);
       if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
@@ -8350,16 +8997,16 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
       currentHoistableRoot = getHoistableRoot(
         finishedWork.stateNode.containerInfo
       );
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       currentHoistableRoot = flags;
       break;
     case 12:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       break;
     case 13:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       finishedWork.child.flags & 8192 &&
         (null !== finishedWork.memoizedState) !==
@@ -8376,15 +9023,15 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
         (offscreenSubtreeWasHidden ||
           null === current ||
           safelyDetachRef(current, current.return));
-      hoistableRoot = null !== finishedWork.memoizedState;
-      var wasHidden = null !== current && null !== current.memoizedState,
-        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
-      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
-      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+      node = null !== finishedWork.memoizedState;
+      nextNode = null !== current && null !== current.memoizedState;
+      nodeName = offscreenSubtreeIsHidden;
+      type = offscreenSubtreeWasHidden;
+      offscreenSubtreeIsHidden = nodeName || node;
+      offscreenSubtreeWasHidden = type || nextNode;
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      offscreenSubtreeWasHidden = type;
+      offscreenSubtreeIsHidden = nodeName;
       commitReconciliationEffects(finishedWork);
       root = finishedWork.stateNode;
       root._current = finishedWork;
@@ -8392,55 +9039,53 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
       root._visibility |= root._pendingVisibility & 2;
       if (
         flags & 8192 &&
-        ((root._visibility = hoistableRoot
+        ((root._visibility = node
           ? root._visibility & -2
           : root._visibility | 1),
-        hoistableRoot &&
-          (null === current ||
-            wasHidden ||
-            offscreenSubtreeIsHidden ||
-            offscreenSubtreeWasHidden ||
+        node &&
+          ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
+          null === current ||
+            nextNode ||
+            root ||
             recursivelyTraverseDisappearLayoutEffects(finishedWork)),
         null === finishedWork.memoizedProps ||
           "manual" !== finishedWork.memoizedProps.mode)
       )
         a: for (current = null, root = finishedWork; ; ) {
-          if (5 === root.tag || 26 === root.tag) {
+          if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
             if (null === current) {
-              wasHidden = current = root;
+              lanes = current = root;
               try {
-                if (((currentResource = wasHidden.stateNode), hoistableRoot))
-                  (maybeNodes = currentResource.style),
-                    "function" === typeof maybeNodes.setProperty
-                      ? maybeNodes.setProperty("display", "none", "important")
-                      : (maybeNodes.display = "none");
+                if (((hoistableRoot = lanes.stateNode), node))
+                  (i = hoistableRoot.style),
+                    "function" === typeof i.setProperty
+                      ? i.setProperty("display", "none", "important")
+                      : (i.display = "none");
                 else {
-                  i = wasHidden.stateNode;
-                  var styleProp = wasHidden.memoizedProps.style,
+                  var instance = lanes.stateNode,
+                    styleProp = lanes.memoizedProps.style,
                     display =
                       void 0 !== styleProp &&
                       null !== styleProp &&
                       styleProp.hasOwnProperty("display")
                         ? styleProp.display
                         : null;
-                  i.style.display =
+                  instance.style.display =
                     null == display || "boolean" === typeof display
                       ? ""
                       : ("" + display).trim();
                 }
               } catch (error) {
-                captureCommitPhaseError(wasHidden, wasHidden.return, error);
+                captureCommitPhaseError(lanes, lanes.return, error);
               }
             }
           } else if (6 === root.tag) {
             if (null === current) {
-              wasHidden = root;
+              lanes = root;
               try {
-                wasHidden.stateNode.nodeValue = hoistableRoot
-                  ? ""
-                  : wasHidden.memoizedProps;
+                lanes.stateNode.nodeValue = node ? "" : lanes.memoizedProps;
               } catch (error) {
-                captureCommitPhaseError(wasHidden, wasHidden.return, error);
+                captureCommitPhaseError(lanes, lanes.return, error);
               }
             }
           } else if (
@@ -8472,7 +9117,7 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
             attachSuspenseRetryListeners(finishedWork, current))));
       break;
     case 19:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       flags & 4 &&
         ((flags = finishedWork.updateQueue),
@@ -8481,10 +9126,24 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
           attachSuspenseRetryListeners(finishedWork, flags)));
       break;
     case 30:
+      flags & 512 &&
+        (offscreenSubtreeWasHidden ||
+          null === current ||
+          safelyDetachRef(current, current.return));
+      flags = viewTransitionMutationContext;
+      viewTransitionMutationContext = !1;
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      (lanes & 335544192) === lanes &&
+        null !== current &&
+        viewTransitionMutationContext &&
+        (finishedWork.flags |= 4);
+      viewTransitionMutationContext = flags;
+      break;
     case 21:
       break;
     default:
-      recursivelyTraverseMutationEffects(root, finishedWork),
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes),
         commitReconciliationEffects(finishedWork);
   }
 }
@@ -8492,42 +9151,44 @@ function commitReconciliationEffects(finishedWork) {
   var flags = finishedWork.flags;
   if (flags & 2) {
     try {
-      a: {
-        for (var parent = finishedWork.return; null !== parent; ) {
-          if (isHostParent(parent)) {
-            var JSCompiler_inline_result = parent;
-            break a;
+      if (27 !== finishedWork.tag) {
+        a: {
+          for (var parent = finishedWork.return; null !== parent; ) {
+            if (isHostParent(parent)) {
+              var JSCompiler_inline_result = parent;
+              break a;
+            }
+            parent = parent.return;
           }
-          parent = parent.return;
+          throw Error(formatProdErrorMessage(160));
+        }
+        switch (JSCompiler_inline_result.tag) {
+          case 27:
+            var parent$jscomp$0 = JSCompiler_inline_result.stateNode,
+              before = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
+            break;
+          case 5:
+            var parent$116 = JSCompiler_inline_result.stateNode;
+            JSCompiler_inline_result.flags & 32 &&
+              (setTextContent(parent$116, ""),
+              (JSCompiler_inline_result.flags &= -33));
+            var before$117 = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, before$117, parent$116);
+            break;
+          case 3:
+          case 4:
+            var parent$118 = JSCompiler_inline_result.stateNode.containerInfo,
+              before$119 = getHostSibling(finishedWork);
+            insertOrAppendPlacementNodeIntoContainer(
+              finishedWork,
+              before$119,
+              parent$118
+            );
+            break;
+          default:
+            throw Error(formatProdErrorMessage(161));
         }
-        throw Error(formatProdErrorMessage(160));
-      }
-      switch (JSCompiler_inline_result.tag) {
-        case 27:
-          var parent$jscomp$0 = JSCompiler_inline_result.stateNode,
-            before = getHostSibling(finishedWork);
-          insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
-          break;
-        case 5:
-          var parent$113 = JSCompiler_inline_result.stateNode;
-          JSCompiler_inline_result.flags & 32 &&
-            (setTextContent(parent$113, ""),
-            (JSCompiler_inline_result.flags &= -33));
-          var before$114 = getHostSibling(finishedWork);
-          insertOrAppendPlacementNode(finishedWork, before$114, parent$113);
-          break;
-        case 3:
-        case 4:
-          var parent$115 = JSCompiler_inline_result.stateNode.containerInfo,
-            before$116 = getHostSibling(finishedWork);
-          insertOrAppendPlacementNodeIntoContainer(
-            finishedWork,
-            before$116,
-            parent$115
-          );
-          break;
-        default:
-          throw Error(formatProdErrorMessage(161));
       }
     } catch (error) {
       captureCommitPhaseError(finishedWork, finishedWork.return, error);
@@ -8545,6 +9206,153 @@ function recursivelyResetForms(parentFiber) {
       parentFiber = parentFiber.sibling;
     }
 }
+function recursivelyTraverseAfterMutationEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 9238)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitAfterMutationEffectsOnFiber(parentFiber, root),
+        (parentFiber = parentFiber.sibling);
+  else measureNestedViewTransitions(parentFiber);
+}
+function commitAfterMutationEffectsOnFiber(finishedWork, root) {
+  var current = finishedWork.alternate;
+  if (null === current) commitEnterViewTransitions(finishedWork);
+  else
+    switch (finishedWork.tag) {
+      case 3:
+        viewTransitionContextChanged = !1;
+        viewTransitionCancelableChildren = null;
+        recursivelyTraverseAfterMutationEffects(root, finishedWork);
+        if (!viewTransitionContextChanged) {
+          finishedWork = viewTransitionCancelableChildren;
+          viewTransitionCancelableChildren = null;
+          if (null !== finishedWork)
+            for (var i = 0; i < finishedWork.length; i += 3) {
+              var instance = finishedWork[i],
+                oldName = finishedWork[i + 1];
+              restoreViewTransitionName(instance, finishedWork[i + 2]);
+              instance = instance.ownerDocument.documentElement;
+              null !== instance &&
+                instance.animate(
+                  { opacity: [0, 0], pointerEvents: ["none", "none"] },
+                  {
+                    duration: 0,
+                    fill: "forwards",
+                    pseudoElement: "::view-transition-group(" + oldName + ")"
+                  }
+                );
+            }
+          finishedWork = root.containerInfo;
+          finishedWork =
+            9 === finishedWork.nodeType
+              ? finishedWork.documentElement
+              : finishedWork.ownerDocument.documentElement;
+          null !== finishedWork &&
+            "" === finishedWork.style.viewTransitionName &&
+            ((finishedWork.style.viewTransitionName = "none"),
+            finishedWork.animate(
+              { opacity: [0, 0], pointerEvents: ["none", "none"] },
+              {
+                duration: 0,
+                fill: "forwards",
+                pseudoElement: "::view-transition-group(root)"
+              }
+            ),
+            finishedWork.animate(
+              { width: [0, 0], height: [0, 0] },
+              {
+                duration: 0,
+                fill: "forwards",
+                pseudoElement: "::view-transition"
+              }
+            ));
+        }
+        break;
+      case 5:
+        recursivelyTraverseAfterMutationEffects(root, finishedWork);
+        break;
+      case 22:
+        null === finishedWork.memoizedState &&
+          (null !== current.memoizedState
+            ? commitEnterViewTransitions(finishedWork)
+            : recursivelyTraverseAfterMutationEffects(root, finishedWork));
+        break;
+      case 30:
+        if (0 !== (finishedWork.subtreeFlags & 8246)) {
+          i = 0 !== (finishedWork.flags & 4);
+          oldName = viewTransitionContextChanged;
+          instance = viewTransitionCancelableChildren;
+          viewTransitionContextChanged = !1;
+          viewTransitionCancelableChildren = null;
+          recursivelyTraverseAfterMutationEffects(root, finishedWork);
+          viewTransitionContextChanged && (finishedWork.flags |= 4);
+          a: {
+            root = finishedWork.memoizedProps;
+            var updateClassName = getViewTransitionClassName(
+                root.className,
+                root.update
+              ),
+              layoutClassName = getViewTransitionClassName(
+                root.className,
+                root.update
+              );
+            if ("none" === updateClassName) {
+              if ("none" === layoutClassName) {
+                current = !1;
+                break a;
+              }
+              finishedWork.flags &= -5;
+              updateClassName = layoutClassName;
+            } else if (0 === (finishedWork.flags & 4)) {
+              if ("none" === layoutClassName) {
+                viewTransitionHostInstanceIdx = 0;
+                cancelViewTransitionHostInstances(
+                  current,
+                  finishedWork.child,
+                  !0
+                );
+                current = !1;
+                break a;
+              }
+              updateClassName = layoutClassName;
+            }
+            layoutClassName = getViewTransitionName(
+              root,
+              finishedWork.stateNode
+            );
+            viewTransitionHostInstanceIdx = 0;
+            root = current.memoizedState;
+            current = measureViewTransitionHostInstances(
+              current,
+              finishedWork,
+              finishedWork.child,
+              layoutClassName,
+              updateClassName,
+              root,
+              !0
+            );
+            viewTransitionHostInstanceIdx !==
+              (null === root ? 0 : root.length) && (finishedWork.flags |= 32);
+          }
+          0 !== (finishedWork.flags & 4) && current
+            ? ((current = finishedWork.memoizedProps),
+              scheduleViewTransitionEvent(
+                finishedWork,
+                i || viewTransitionContextChanged
+                  ? current.onUpdate
+                  : current.onLayout
+              ),
+              (viewTransitionCancelableChildren = instance))
+            : null !== instance &&
+              (instance.push.apply(instance, viewTransitionCancelableChildren),
+              (viewTransitionCancelableChildren = instance));
+          viewTransitionContextChanged =
+            0 !== (finishedWork.flags & 32) ? !0 : oldName;
+        }
+        break;
+      default:
+        recursivelyTraverseAfterMutationEffects(root, finishedWork);
+    }
+}
 function recursivelyTraverseLayoutEffects(root, parentFiber) {
   if (parentFiber.subtreeFlags & 8772)
     for (parentFiber = parentFiber.child; null !== parentFiber; )
@@ -8573,9 +9381,8 @@ function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
           );
         recursivelyTraverseDisappearLayoutEffects(finishedWork);
         break;
-      case 27:
-        releaseSingletonInstance(finishedWork.stateNode);
       case 26:
+      case 27:
       case 5:
         safelyDetachRef(finishedWork, finishedWork.return);
         recursivelyTraverseDisappearLayoutEffects(finishedWork);
@@ -8585,6 +9392,8 @@ function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
         null === finishedWork.memoizedState &&
           recursivelyTraverseDisappearLayoutEffects(finishedWork);
         break;
+      case 30:
+        safelyDetachRef(finishedWork, finishedWork.return);
       default:
         recursivelyTraverseDisappearLayoutEffects(finishedWork);
     }
@@ -8650,9 +9459,8 @@ function recursivelyTraverseReappearLayoutEffects(
           commitClassCallbacks(finishedWork);
         safelyAttachRef(finishedWork, finishedWork.return);
         break;
-      case 27:
-        commitHostSingletonAcquisition(finishedWork);
       case 26:
+      case 27:
       case 5:
         recursivelyTraverseReappearLayoutEffects(
           finishedRoot,
@@ -8691,6 +9499,14 @@ function recursivelyTraverseReappearLayoutEffects(
           );
         safelyAttachRef(finishedWork, finishedWork.return);
         break;
+      case 30:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
       default:
         recursivelyTraverseReappearLayoutEffects(
           finishedRoot,
@@ -8729,7 +9545,9 @@ function recursivelyTraversePassiveMountEffects(
   committedLanes,
   committedTransitions
 ) {
-  if (parentFiber.subtreeFlags & 10256)
+  var isViewTransitionEligible =
+    (committedLanes & 335544192) === committedLanes;
+  if (parentFiber.subtreeFlags & (isViewTransitionEligible ? 10262 : 10256))
     for (parentFiber = parentFiber.child; null !== parentFiber; )
       commitPassiveMountOnFiber(
         root,
@@ -8738,6 +9556,7 @@ function recursivelyTraversePassiveMountEffects(
         committedTransitions
       ),
         (parentFiber = parentFiber.sibling);
+  else isViewTransitionEligible && restoreNestedViewTransitions(parentFiber);
 }
 function commitPassiveMountOnFiber(
   finishedRoot,
@@ -8745,6 +9564,13 @@ function commitPassiveMountOnFiber(
   committedLanes,
   committedTransitions
 ) {
+  var isViewTransitionEligible =
+    (committedLanes & 335544192) === committedLanes;
+  isViewTransitionEligible &&
+    null === finishedWork.alternate &&
+    null !== finishedWork.return &&
+    null !== finishedWork.return.alternate &&
+    restoreEnterViewTransitions(finishedWork);
   var flags = finishedWork.flags;
   switch (finishedWork.tag) {
     case 0:
@@ -8773,14 +9599,22 @@ function commitPassiveMountOnFiber(
         committedLanes,
         committedTransitions
       );
+      isViewTransitionEligible &&
+        ((finishedRoot = finishedRoot.containerInfo),
+        (finishedRoot =
+          9 === finishedRoot.nodeType
+            ? finishedRoot.documentElement
+            : finishedRoot.ownerDocument.documentElement),
+        null !== finishedRoot &&
+          "none" === finishedRoot.style.viewTransitionName &&
+          (finishedRoot.style.viewTransitionName = ""));
       flags & 2048 &&
-        ((finishedRoot = null),
+        ((flags = null),
         null !== finishedWork.alternate &&
-          (finishedRoot = finishedWork.alternate.memoizedState.cache),
+          (flags = finishedWork.alternate.memoizedState.cache),
         (finishedWork = finishedWork.memoizedState.cache),
-        finishedWork !== finishedRoot &&
-          (finishedWork.refCount++,
-          null != finishedRoot && releaseCache(finishedRoot)));
+        finishedWork !== flags &&
+          (finishedWork.refCount++, null != flags && releaseCache(flags)));
       break;
     case 12:
       if (flags & 2048) {
@@ -8790,7 +9624,7 @@ function commitPassiveMountOnFiber(
           committedLanes,
           committedTransitions
         );
-        finishedRoot = finishedWork.stateNode;
+        flags = finishedWork.stateNode;
         try {
           var _finishedWork$memoize2 = finishedWork.memoizedProps,
             id = _finishedWork$memoize2.id,
@@ -8799,7 +9633,7 @@ function commitPassiveMountOnFiber(
             onPostCommit(
               id,
               null === finishedWork.alternate ? "mount" : "update",
-              finishedRoot.passiveEffectDuration,
+              flags.passiveEffectDuration,
               -0
             );
         } catch (error) {
@@ -8827,29 +9661,40 @@ function commitPassiveMountOnFiber(
       _finishedWork$memoize2 = finishedWork.stateNode;
       id = finishedWork.alternate;
       null !== finishedWork.memoizedState
-        ? _finishedWork$memoize2._visibility & 4
-          ? recursivelyTraversePassiveMountEffects(
-              finishedRoot,
-              finishedWork,
-              committedLanes,
-              committedTransitions
-            )
-          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
-        : _finishedWork$memoize2._visibility & 4
-          ? recursivelyTraversePassiveMountEffects(
-              finishedRoot,
-              finishedWork,
-              committedLanes,
-              committedTransitions
-            )
-          : ((_finishedWork$memoize2._visibility |= 4),
-            recursivelyTraverseReconnectPassiveEffects(
-              finishedRoot,
-              finishedWork,
-              committedLanes,
-              committedTransitions,
-              0 !== (finishedWork.subtreeFlags & 10256)
-            ));
+        ? (isViewTransitionEligible &&
+            null !== id &&
+            null === id.memoizedState &&
+            restoreExitViewTransitions(id),
+          _finishedWork$memoize2._visibility & 4
+            ? recursivelyTraversePassiveMountEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions
+              )
+            : recursivelyTraverseAtomicPassiveEffects(
+                finishedRoot,
+                finishedWork
+              ))
+        : (isViewTransitionEligible &&
+            null !== id &&
+            null !== id.memoizedState &&
+            restoreEnterViewTransitions(finishedWork),
+          _finishedWork$memoize2._visibility & 4
+            ? recursivelyTraversePassiveMountEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions
+              )
+            : ((_finishedWork$memoize2._visibility |= 4),
+              recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions,
+                0 !== (finishedWork.subtreeFlags & 10256)
+              )));
       flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
       break;
     case 24:
@@ -8862,6 +9707,21 @@ function commitPassiveMountOnFiber(
       flags & 2048 &&
         commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
       break;
+    case 30:
+      isViewTransitionEligible &&
+        ((flags = finishedWork.alternate),
+        null !== flags &&
+          0 !== (finishedWork.subtreeFlags & 8246) &&
+          ((finishedWork.memoizedState = null),
+          restoreViewTransitionOnHostInstances(flags.child, !0),
+          restoreViewTransitionOnHostInstances(finishedWork.child, !0)));
+      recursivelyTraversePassiveMountEffects(
+        finishedRoot,
+        finishedWork,
+        committedLanes,
+        committedTransitions
+      );
+      break;
     default:
       recursivelyTraversePassiveMountEffects(
         finishedRoot,
@@ -9322,6 +10182,15 @@ function createFiberFromTypeAndProps(
         );
       case REACT_OFFSCREEN_TYPE:
         return createFiberFromOffscreen(pendingProps, mode, lanes, key);
+      case REACT_LEGACY_HIDDEN_TYPE:
+      case REACT_VIEW_TRANSITION_TYPE:
+        return (
+          (type = createFiberImplClass(30, pendingProps, key, mode)),
+          (type.elementType = REACT_VIEW_TRANSITION_TYPE),
+          (type.lanes = lanes),
+          (type.stateNode = { autoName: null, paired: null, ref: null }),
+          type
+        );
       default:
         if ("object" === typeof type && null !== type)
           switch (type.$$typeof) {
@@ -9580,6 +10449,21 @@ function queueHydrationError(error) {
     ? (hydrationErrors = [error])
     : hydrationErrors.push(error);
 }
+var globalClientIdCounter = 0;
+function getViewTransitionName(props, instance) {
+  return null != props.name && "auto" !== props.name
+    ? props.name
+    : instance.autoName;
+}
+function getViewTransitionClassName(className, eventClassName) {
+  return null == eventClassName
+    ? className
+    : "none" === eventClassName
+      ? eventClassName
+      : null != className
+        ? className + " " + eventClassName
+        : eventClassName;
+}
 function markUpdate(workInProgress) {
   workInProgress.flags |= 4;
 }
@@ -9628,14 +10512,14 @@ function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
         break;
       case "collapsed":
         lastTailNode = renderState.tail;
-        for (var lastTailNode$133 = null; null !== lastTailNode; )
-          null !== lastTailNode.alternate && (lastTailNode$133 = lastTailNode),
+        for (var lastTailNode$135 = null; null !== lastTailNode; )
+          null !== lastTailNode.alternate && (lastTailNode$135 = lastTailNode),
             (lastTailNode = lastTailNode.sibling);
-        null === lastTailNode$133
+        null === lastTailNode$135
           ? hasRenderedATailFallback || null === renderState.tail
             ? (renderState.tail = null)
             : (renderState.tail.sibling = null)
-          : (lastTailNode$133.sibling = null);
+          : (lastTailNode$135.sibling = null);
     }
 }
 function bubbleProperties(completedWork) {
@@ -9645,23 +10529,41 @@ function bubbleProperties(completedWork) {
     newChildLanes = 0,
     subtreeFlags = 0;
   if (didBailout)
-    for (var child$134 = completedWork.child; null !== child$134; )
-      (newChildLanes |= child$134.lanes | child$134.childLanes),
-        (subtreeFlags |= child$134.subtreeFlags & 65011712),
-        (subtreeFlags |= child$134.flags & 65011712),
-        (child$134.return = completedWork),
-        (child$134 = child$134.sibling);
+    for (var child$136 = completedWork.child; null !== child$136; )
+      (newChildLanes |= child$136.lanes | child$136.childLanes),
+        (subtreeFlags |= child$136.subtreeFlags & 65011712),
+        (subtreeFlags |= child$136.flags & 65011712),
+        (child$136.return = completedWork),
+        (child$136 = child$136.sibling);
   else
-    for (child$134 = completedWork.child; null !== child$134; )
-      (newChildLanes |= child$134.lanes | child$134.childLanes),
-        (subtreeFlags |= child$134.subtreeFlags),
-        (subtreeFlags |= child$134.flags),
-        (child$134.return = completedWork),
-        (child$134 = child$134.sibling);
+    for (child$136 = completedWork.child; null !== child$136; )
+      (newChildLanes |= child$136.lanes | child$136.childLanes),
+        (subtreeFlags |= child$136.subtreeFlags),
+        (subtreeFlags |= child$136.flags),
+        (child$136.return = completedWork),
+        (child$136 = child$136.sibling);
   completedWork.subtreeFlags |= subtreeFlags;
   completedWork.childLanes = newChildLanes;
   return didBailout;
 }
+function trackReappearingViewTransitions(workInProgress) {
+  if (0 !== (workInProgress.subtreeFlags & 2097152))
+    for (workInProgress = workInProgress.child; null !== workInProgress; ) {
+      if (22 !== workInProgress.tag || null !== workInProgress.memoizedState) {
+        if (
+          30 === workInProgress.tag &&
+          0 !== (workInProgress.flags & 2097152)
+        ) {
+          var props = workInProgress.memoizedProps;
+          null != props.name &&
+            "auto" !== props.name &&
+            trackAppearingViewTransition(workInProgress.stateNode, props.name);
+        }
+        trackReappearingViewTransitions(workInProgress);
+      }
+      workInProgress = workInProgress.sibling;
+    }
+}
 function completeWork(current, workInProgress, renderLanes) {
   var newProps = workInProgress.pendingProps;
   popTreeContext(workInProgress);
@@ -9732,6 +10634,7 @@ function completeWork(current, workInProgress, renderLanes) {
           if (null === workInProgress.stateNode)
             throw Error(formatProdErrorMessage(166));
           bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
           return null;
         }
         current = contextStackCursor.current;
@@ -9742,6 +10645,7 @@ function completeWork(current, workInProgress, renderLanes) {
             markUpdate(workInProgress));
       }
       bubbleProperties(workInProgress);
+      workInProgress.subtreeFlags &= -33554433;
       return null;
     case 5:
       popHostContext(workInProgress);
@@ -9753,6 +10657,7 @@ function completeWork(current, workInProgress, renderLanes) {
           if (null === workInProgress.stateNode)
             throw Error(formatProdErrorMessage(166));
           bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
           return null;
         }
         current = contextStackCursor.current;
@@ -9849,6 +10754,7 @@ function completeWork(current, workInProgress, renderLanes) {
         }
       }
       bubbleProperties(workInProgress);
+      workInProgress.subtreeFlags &= -33554433;
       workInProgress.flags &= -16777217;
       return null;
     case 6:
@@ -9934,11 +10840,11 @@ function completeWork(current, workInProgress, renderLanes) {
           null !== newProps.alternate.memoizedState &&
           null !== newProps.alternate.memoizedState.cachePool &&
           (type = newProps.alternate.memoizedState.cachePool.pool);
-        var cache$147 = null;
+        var cache$149 = null;
         null !== newProps.memoizedState &&
           null !== newProps.memoizedState.cachePool &&
-          (cache$147 = newProps.memoizedState.cachePool.pool);
-        cache$147 !== type && (newProps.flags |= 2048);
+          (cache$149 = newProps.memoizedState.cachePool.pool);
+        cache$149 !== type && (newProps.flags |= 2048);
       }
       renderLanes !== current &&
         renderLanes &&
@@ -9963,8 +10869,8 @@ function completeWork(current, workInProgress, renderLanes) {
       type = workInProgress.memoizedState;
       if (null === type) return bubbleProperties(workInProgress), null;
       newProps = 0 !== (workInProgress.flags & 128);
-      cache$147 = type.rendering;
-      if (null === cache$147)
+      cache$149 = type.rendering;
+      if (null === cache$149)
         if (newProps) cutOffTailIfNeeded(type, !1);
         else {
           if (
@@ -9972,11 +10878,11 @@ function completeWork(current, workInProgress, renderLanes) {
             (null !== current && 0 !== (current.flags & 128))
           )
             for (current = workInProgress.child; null !== current; ) {
-              cache$147 = findFirstSuspended(current);
-              if (null !== cache$147) {
+              cache$149 = findFirstSuspended(current);
+              if (null !== cache$149) {
                 workInProgress.flags |= 128;
                 cutOffTailIfNeeded(type, !1);
-                current = cache$147.updateQueue;
+                current = cache$149.updateQueue;
                 workInProgress.updateQueue = current;
                 scheduleRetryEffect(workInProgress, current);
                 workInProgress.subtreeFlags = 0;
@@ -10001,7 +10907,7 @@ function completeWork(current, workInProgress, renderLanes) {
         }
       else {
         if (!newProps)
-          if (((current = findFirstSuspended(cache$147)), null !== current)) {
+          if (((current = findFirstSuspended(cache$149)), null !== current)) {
             if (
               ((workInProgress.flags |= 128),
               (newProps = !0),
@@ -10011,7 +10917,7 @@ function completeWork(current, workInProgress, renderLanes) {
               cutOffTailIfNeeded(type, !0),
               null === type.tail &&
                 "hidden" === type.tailMode &&
-                !cache$147.alternate &&
+                !cache$149.alternate &&
                 !isHydrating)
             )
               return bubbleProperties(workInProgress), null;
@@ -10024,13 +10930,13 @@ function completeWork(current, workInProgress, renderLanes) {
               cutOffTailIfNeeded(type, !1),
               (workInProgress.lanes = 4194304));
         type.isBackwards
-          ? ((cache$147.sibling = workInProgress.child),
-            (workInProgress.child = cache$147))
+          ? ((cache$149.sibling = workInProgress.child),
+            (workInProgress.child = cache$149))
           : ((current = type.last),
             null !== current
-              ? (current.sibling = cache$147)
-              : (workInProgress.child = cache$147),
-            (type.last = cache$147));
+              ? (current.sibling = cache$149)
+              : (workInProgress.child = cache$149),
+            (type.last = cache$149));
       }
       if (null !== type.tail)
         return (
@@ -10053,7 +10959,8 @@ function completeWork(current, workInProgress, renderLanes) {
         (newProps = null !== workInProgress.memoizedState),
         null !== current
           ? (null !== current.memoizedState) !== newProps &&
-            (workInProgress.flags |= 8192)
+            ((workInProgress.flags |= 8192),
+            newProps || trackReappearingViewTransitions(workInProgress))
           : newProps && (workInProgress.flags |= 8192),
         newProps
           ? 0 !== (renderLanes & 536870912) &&
@@ -10090,7 +10997,11 @@ function completeWork(current, workInProgress, renderLanes) {
     case 25:
       return null;
     case 30:
-      return null;
+      return (
+        (workInProgress.flags |= 33554432),
+        bubbleProperties(workInProgress),
+        null
+      );
   }
   throw Error(formatProdErrorMessage(156, workInProgress.tag));
 }
@@ -10230,6 +11141,7 @@ var DefaultAsyncDispatcher = {
   pendingEffectsRemainingLanes = 0,
   pendingPassiveTransitions = null,
   pendingRecoverableErrors = null,
+  pendingViewTransitionEvents = null,
   nestedUpdateCount = 0,
   rootWithNestedUpdates = null;
 function requestUpdateLane() {
@@ -10251,6 +11163,19 @@ function requestDeferredLane() {
   null !== suspenseHandler && (suspenseHandler.flags |= 32);
   return workInProgressDeferredLane;
 }
+function scheduleViewTransitionEvent(fiber, callback) {
+  if (null != callback) {
+    var state = fiber.stateNode,
+      instance = state.ref;
+    null === instance &&
+      (instance = state.ref =
+        createViewTransitionInstance(
+          getViewTransitionName(fiber.memoizedProps, state)
+        ));
+    null === pendingViewTransitionEvents && (pendingViewTransitionEvents = []);
+    pendingViewTransitionEvents.push(callback.bind(null, instance));
+  }
+}
 function scheduleUpdateOnFiber(root, fiber, lane) {
   if (
     (root === workInProgressRoot &&
@@ -10465,18 +11390,29 @@ function commitRootWhenReady(
   completedRenderEndTime
 ) {
   root.timeoutHandle = -1;
-  suspendedCommitReason = finishedWork.subtreeFlags;
-  if (
-    (suspendedCommitReason =
-      suspendedCommitReason & 8192 ||
-      16785408 === (suspendedCommitReason & 16785408))
-  )
-    if (
-      ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),
-      suspendedCommitReason && accumulateSuspenseyCommitOnFiber(finishedWork),
-      (suspendedCommitReason = waitForCommitToBeReady()),
-      null !== suspendedCommitReason)
-    ) {
+  var subtreeFlags = finishedWork.subtreeFlags;
+  suspendedCommitReason = (lanes & 335544192) === lanes;
+  subtreeFlags = subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408);
+  if (suspendedCommitReason || subtreeFlags) {
+    suspendedState = { stylesheets: null, count: 0, unsuspend: noop };
+    subtreeFlags && accumulateSuspenseyCommitOnFiber(finishedWork);
+    if (suspendedCommitReason) {
+      subtreeFlags = root.containerInfo;
+      if (null === suspendedState) throw Error(formatProdErrorMessage(475));
+      suspendedCommitReason = suspendedState;
+      subtreeFlags = (
+        9 === subtreeFlags.nodeType ? subtreeFlags : subtreeFlags.ownerDocument
+      ).__reactViewTransition;
+      null != subtreeFlags &&
+        (suspendedCommitReason.count++,
+        (suspendedCommitReason = onUnsuspend.bind(suspendedCommitReason)),
+        subtreeFlags.finished.then(
+          suspendedCommitReason,
+          suspendedCommitReason
+        ));
+    }
+    suspendedCommitReason = waitForCommitToBeReady();
+    if (null !== suspendedCommitReason) {
       root.cancelPendingCommit = suspendedCommitReason(
         commitRoot.bind(
           null,
@@ -10499,6 +11435,7 @@ function commitRootWhenReady(
       markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
       return;
     }
+  }
   commitRoot(
     root,
     finishedWork,
@@ -10685,6 +11622,23 @@ function renderDidSuspendDelayIfPossible() {
       !1
     );
 }
+function queueConcurrentError(error) {
+  null === workInProgressRootConcurrentErrors
+    ? (workInProgressRootConcurrentErrors = [error])
+    : workInProgressRootConcurrentErrors.push(error);
+}
+function trackAppearingViewTransition(instance, name) {
+  if (null === workInProgressAppearingViewTransitions) {
+    if (
+      (workInProgressRootRenderLanes & 335544192) !==
+      workInProgressRootRenderLanes
+    )
+      return;
+    workInProgressAppearingViewTransitions = new Map();
+  }
+  instance.paired = null;
+  workInProgressAppearingViewTransitions.set(name, instance);
+}
 function renderRootSync(root, lanes, shouldYieldForPrerendering) {
   var prevExecutionContext = executionContext;
   executionContext |= 2;
@@ -10731,8 +11685,8 @@ function renderRootSync(root, lanes, shouldYieldForPrerendering) {
       workLoopSync();
       exitStatus = workInProgressRootExitStatus;
       break;
-    } catch (thrownValue$166) {
-      handleThrow(root, thrownValue$166);
+    } catch (thrownValue$168) {
+      handleThrow(root, thrownValue$168);
     }
   while (1);
   lanes && root.shellSuspendCounter++;
@@ -10847,8 +11801,8 @@ function renderRootConcurrent(root, lanes) {
       }
       workLoopConcurrentByScheduler();
       break;
-    } catch (thrownValue$168) {
-      handleThrow(root, thrownValue$168);
+    } catch (thrownValue$170) {
+      handleThrow(root, thrownValue$170);
     }
   while (1);
   lastContextDependency = currentlyRenderingFiber$1 = null;
@@ -11055,8 +12009,10 @@ function commitRoot(
     pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
     pendingPassiveTransitions = transitions;
     pendingRecoverableErrors = recoverableErrors;
-    0 !== (finishedWork.subtreeFlags & 10256) ||
-    0 !== (finishedWork.flags & 10256)
+    pendingViewTransitionEvents = null;
+    recoverableErrors = (lanes & 335544192) === lanes ? 10262 : 10256;
+    0 !== (finishedWork.subtreeFlags & recoverableErrors) ||
+    0 !== (finishedWork.flags & recoverableErrors)
       ? ((root.callbackNode = null),
         (root.callbackPriority = 0),
         scheduleCallback$1(NormalPriority$1, function () {
@@ -11086,16 +12042,30 @@ function commitRoot(
       }
     }
     pendingEffectsStatus = 1;
-    flushMutationEffects();
-    flushLayoutEffects();
-    flushSpawnedWork();
+    (shouldStartViewTransition &&
+      startViewTransition(
+        root.containerInfo,
+        flushMutationEffects,
+        flushLayoutEffects,
+        flushAfterMutationEffects,
+        flushSpawnedWork,
+        flushPassiveEffects
+      )) ||
+      (flushMutationEffects(), flushLayoutEffects(), flushSpawnedWork());
   }
 }
+function flushAfterMutationEffects() {
+  3 === pendingEffectsStatus &&
+    ((pendingEffectsStatus = 0),
+    commitAfterMutationEffectsOnFiber(pendingFinishedWork, pendingEffectsRoot),
+    (pendingEffectsStatus = 4));
+}
 function flushMutationEffects() {
   if (1 === pendingEffectsStatus) {
     pendingEffectsStatus = 0;
     var root = pendingEffectsRoot,
       finishedWork = pendingFinishedWork,
+      lanes = pendingEffectsLanes,
       rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
     if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
       rootMutationHasEffect = ReactSharedInternals.T;
@@ -11105,11 +12075,11 @@ function flushMutationEffects() {
       var prevExecutionContext = executionContext;
       executionContext |= 4;
       try {
-        commitMutationEffectsOnFiber(finishedWork, root);
-        var priorSelectionInformation = selectionInformation,
-          curFocusedElem = getActiveElementDeep(root.containerInfo),
-          priorFocusedElem = priorSelectionInformation.focusedElem,
-          priorSelectionRange = priorSelectionInformation.selectionRange;
+        commitMutationEffectsOnFiber(finishedWork, root, lanes);
+        lanes = selectionInformation;
+        var curFocusedElem = getActiveElementDeep(root.containerInfo),
+          priorFocusedElem = lanes.focusedElem,
+          priorSelectionRange = lanes.selectionRange;
         if (
           curFocusedElem !== priorFocusedElem &&
           priorFocusedElem &&
@@ -11244,15 +12214,16 @@ function flushSpawnedWork() {
     var root = pendingEffectsRoot,
       finishedWork = pendingFinishedWork,
       lanes = pendingEffectsLanes,
-      recoverableErrors = pendingRecoverableErrors;
-    0 !== (finishedWork.subtreeFlags & 10256) ||
-    0 !== (finishedWork.flags & 10256)
+      recoverableErrors = pendingRecoverableErrors,
+      passiveSubtreeMask = (lanes & 335544192) === lanes ? 10262 : 10256;
+    0 !== (finishedWork.subtreeFlags & passiveSubtreeMask) ||
+    0 !== (finishedWork.flags & passiveSubtreeMask)
       ? (pendingEffectsStatus = 5)
       : ((pendingEffectsStatus = 0),
         (pendingEffectsRoot = null),
         releaseRootPooledCache(root, root.pendingLanes));
-    var remainingLanes = root.pendingLanes;
-    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
+    passiveSubtreeMask = root.pendingLanes;
+    0 === passiveSubtreeMask && (legacyErrorBoundariesThatAlreadyFailed = null);
     lanesToEventPriority(lanes);
     finishedWork = finishedWork.stateNode;
     if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
@@ -11266,7 +12237,7 @@ function flushSpawnedWork() {
       } catch (err) {}
     if (null !== recoverableErrors) {
       finishedWork = ReactSharedInternals.T;
-      remainingLanes = ReactDOMSharedInternals.p;
+      passiveSubtreeMask = ReactDOMSharedInternals.p;
       ReactDOMSharedInternals.p = 2;
       ReactSharedInternals.T = null;
       try {
@@ -11282,13 +12253,21 @@ function flushSpawnedWork() {
         }
       } finally {
         (ReactSharedInternals.T = finishedWork),
-          (ReactDOMSharedInternals.p = remainingLanes);
+          (ReactDOMSharedInternals.p = passiveSubtreeMask);
       }
     }
+    recoverableErrors = pendingViewTransitionEvents;
+    if (null !== recoverableErrors)
+      for (
+        pendingViewTransitionEvents = null, onRecoverableError = 0;
+        onRecoverableError < recoverableErrors.length;
+        onRecoverableError++
+      )
+        (0, recoverableErrors[onRecoverableError])();
     0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
     ensureRootIsScheduled(root);
-    remainingLanes = root.pendingLanes;
-    0 !== (lanes & 4194218) && 0 !== (remainingLanes & 42)
+    passiveSubtreeMask = root.pendingLanes;
+    0 !== (lanes & 4194218) && 0 !== (passiveSubtreeMask & 42)
       ? root === rootWithNestedUpdates
         ? nestedUpdateCount++
         : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
@@ -11489,14 +12468,14 @@ function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
     isFlushingWork = !0;
     do {
       var didPerformSomeWork = !1;
-      for (var root$173 = firstScheduledRoot; null !== root$173; ) {
+      for (var root$176 = firstScheduledRoot; null !== root$176; ) {
         if (!onlyLegacy)
           if (0 !== syncTransitionLanes) {
-            var pendingLanes = root$173.pendingLanes;
+            var pendingLanes = root$176.pendingLanes;
             if (0 === pendingLanes) var JSCompiler_inline_result = 0;
             else {
-              var suspendedLanes = root$173.suspendedLanes,
-                pingedLanes = root$173.pingedLanes;
+              var suspendedLanes = root$176.suspendedLanes,
+                pingedLanes = root$176.pingedLanes;
               JSCompiler_inline_result =
                 (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
               JSCompiler_inline_result &=
@@ -11510,20 +12489,20 @@ function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
             }
             0 !== JSCompiler_inline_result &&
               ((didPerformSomeWork = !0),
-              performSyncWorkOnRoot(root$173, JSCompiler_inline_result));
+              performSyncWorkOnRoot(root$176, JSCompiler_inline_result));
           } else
             (JSCompiler_inline_result = workInProgressRootRenderLanes),
               (JSCompiler_inline_result = getNextLanes(
-                root$173,
-                root$173 === workInProgressRoot ? JSCompiler_inline_result : 0,
-                null !== root$173.cancelPendingCommit ||
-                  -1 !== root$173.timeoutHandle
+                root$176,
+                root$176 === workInProgressRoot ? JSCompiler_inline_result : 0,
+                null !== root$176.cancelPendingCommit ||
+                  -1 !== root$176.timeoutHandle
               )),
               0 === (JSCompiler_inline_result & 3) ||
-                checkIfRootIsPrerendering(root$173, JSCompiler_inline_result) ||
+                checkIfRootIsPrerendering(root$176, JSCompiler_inline_result) ||
                 ((didPerformSomeWork = !0),
-                performSyncWorkOnRoot(root$173, JSCompiler_inline_result));
-        root$173 = root$173.next;
+                performSyncWorkOnRoot(root$176, JSCompiler_inline_result));
+        root$176 = root$176.next;
       }
     } while (didPerformSomeWork);
     isFlushingWork = !1;
@@ -11763,20 +12742,20 @@ function extractEvents$1(
   }
 }
 for (
-  var i$jscomp$inline_1492 = 0;
-  i$jscomp$inline_1492 < simpleEventPluginEvents.length;
-  i$jscomp$inline_1492++
+  var i$jscomp$inline_1552 = 0;
+  i$jscomp$inline_1552 < simpleEventPluginEvents.length;
+  i$jscomp$inline_1552++
 ) {
-  var eventName$jscomp$inline_1493 =
-      simpleEventPluginEvents[i$jscomp$inline_1492],
-    domEventName$jscomp$inline_1494 =
-      eventName$jscomp$inline_1493.toLowerCase(),
-    capitalizedEvent$jscomp$inline_1495 =
-      eventName$jscomp$inline_1493[0].toUpperCase() +
-      eventName$jscomp$inline_1493.slice(1);
+  var eventName$jscomp$inline_1553 =
+      simpleEventPluginEvents[i$jscomp$inline_1552],
+    domEventName$jscomp$inline_1554 =
+      eventName$jscomp$inline_1553.toLowerCase(),
+    capitalizedEvent$jscomp$inline_1555 =
+      eventName$jscomp$inline_1553[0].toUpperCase() +
+      eventName$jscomp$inline_1553.slice(1);
   registerSimpleEvent(
-    domEventName$jscomp$inline_1494,
-    "on" + capitalizedEvent$jscomp$inline_1495
+    domEventName$jscomp$inline_1554,
+    "on" + capitalizedEvent$jscomp$inline_1555
   );
 }
 registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
@@ -12527,13 +13506,13 @@ function noop$1() {}
 function setProp(domElement, tag, key, value, props, prevValue) {
   switch (key) {
     case "children":
-      "string" === typeof value
-        ? "body" === tag ||
+      if ("string" === typeof value)
+        "body" === tag ||
           ("textarea" === tag && "" === value) ||
-          setTextContent(domElement, value)
-        : ("number" === typeof value || "bigint" === typeof value) &&
-          "body" !== tag &&
-          setTextContent(domElement, "" + value);
+          setTextContent(domElement, value);
+      else if ("number" === typeof value || "bigint" === typeof value)
+        "body" !== tag && setTextContent(domElement, "" + value);
+      else return;
       break;
     case "className":
       setValueForKnownAttribute(domElement, "class", value);
@@ -12550,7 +13529,7 @@ function setProp(domElement, tag, key, value, props, prevValue) {
       break;
     case "style":
       setValueForStyles(domElement, value, prevValue);
-      break;
+      return;
     case "data":
       if ("object" !== tag) {
         setValueForKnownAttribute(domElement, "data", value);
@@ -12627,13 +13606,13 @@ function setProp(domElement, tag, key, value, props, prevValue) {
       break;
     case "onClick":
       null != value && (domElement.onclick = noop$1);
-      break;
+      return;
     case "onScroll":
       null != value && listenToNonDelegatedEvent("scroll", domElement);
-      break;
+      return;
     case "onScrollEnd":
       null != value && listenToNonDelegatedEvent("scrollend", domElement);
-      break;
+      return;
     case "dangerouslySetInnerHTML":
       if (null != value) {
         if ("object" !== typeof value || !("__html" in value))
@@ -12832,7 +13811,7 @@ function setProp(domElement, tag, key, value, props, prevValue) {
       break;
     case "innerText":
     case "textContent":
-      break;
+      return;
     default:
       if (
         !(2 < key.length) ||
@@ -12841,13 +13820,15 @@ function setProp(domElement, tag, key, value, props, prevValue) {
       )
         (key = aliases.get(key) || key),
           setValueForAttribute(domElement, key, value);
+      else return;
   }
+  viewTransitionMutationContext = !0;
 }
 function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
   switch (key) {
     case "style":
       setValueForStyles(domElement, value, prevValue);
-      break;
+      return;
     case "dangerouslySetInnerHTML":
       if (null != value) {
         if ("object" !== typeof value || !("__html" in value))
@@ -12860,28 +13841,28 @@ function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
       }
       break;
     case "children":
-      "string" === typeof value
-        ? setTextContent(domElement, value)
-        : ("number" === typeof value || "bigint" === typeof value) &&
-          setTextContent(domElement, "" + value);
+      if ("string" === typeof value) setTextContent(domElement, value);
+      else if ("number" === typeof value || "bigint" === typeof value)
+        setTextContent(domElement, "" + value);
+      else return;
       break;
     case "onScroll":
       null != value && listenToNonDelegatedEvent("scroll", domElement);
-      break;
+      return;
     case "onScrollEnd":
       null != value && listenToNonDelegatedEvent("scrollend", domElement);
-      break;
+      return;
     case "onClick":
       null != value && (domElement.onclick = noop$1);
-      break;
+      return;
     case "suppressContentEditableWarning":
     case "suppressHydrationWarning":
     case "innerHTML":
     case "ref":
-      break;
+      return;
     case "innerText":
     case "textContent":
-      break;
+      return;
     default:
       if (!registrationNameDependencies.hasOwnProperty(key))
         a: {
@@ -12905,13 +13886,16 @@ function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
             domElement.addEventListener(tag, value, props);
             break a;
           }
+          viewTransitionMutationContext = !0;
           key in domElement
             ? (domElement[key] = value)
             : !0 === value
               ? domElement.setAttribute(key, "")
               : setValueForAttribute(domElement, key, value);
         }
+      return;
   }
+  viewTransitionMutationContext = !0;
 }
 function setInitialProperties(domElement, tag, props) {
   switch (tag) {
@@ -12959,34 +13943,34 @@ function setInitialProperties(domElement, tag, props) {
         defaultChecked = null;
       for (hasSrc in props)
         if (props.hasOwnProperty(hasSrc)) {
-          var propValue$187 = props[hasSrc];
-          if (null != propValue$187)
+          var propValue$190 = props[hasSrc];
+          if (null != propValue$190)
             switch (hasSrc) {
               case "name":
-                hasSrcSet = propValue$187;
+                hasSrcSet = propValue$190;
                 break;
               case "type":
-                propValue = propValue$187;
+                propValue = propValue$190;
                 break;
               case "checked":
-                checked = propValue$187;
+                checked = propValue$190;
                 break;
               case "defaultChecked":
-                defaultChecked = propValue$187;
+                defaultChecked = propValue$190;
                 break;
               case "value":
-                propKey = propValue$187;
+                propKey = propValue$190;
                 break;
               case "defaultValue":
-                defaultValue = propValue$187;
+                defaultValue = propValue$190;
                 break;
               case "children":
               case "dangerouslySetInnerHTML":
-                if (null != propValue$187)
+                if (null != propValue$190)
                   throw Error(formatProdErrorMessage(137, tag));
                 break;
               default:
-                setProp(domElement, tag, hasSrc, propValue$187, props, null);
+                setProp(domElement, tag, hasSrc, propValue$190, props, null);
             }
         }
       initInput(
@@ -13123,14 +14107,14 @@ function setInitialProperties(domElement, tag, props) {
       return;
     default:
       if (isCustomElement(tag)) {
-        for (propValue$187 in props)
-          props.hasOwnProperty(propValue$187) &&
-            ((hasSrc = props[propValue$187]),
+        for (propValue$190 in props)
+          props.hasOwnProperty(propValue$190) &&
+            ((hasSrc = props[propValue$190]),
             void 0 !== hasSrc &&
               setPropOnCustomElement(
                 domElement,
                 tag,
-                propValue$187,
+                propValue$190,
                 hasSrc,
                 props,
                 void 0
@@ -13178,30 +14162,36 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
                 setProp(domElement, tag, propKey, null, nextProps, lastProp);
           }
       }
-      for (var propKey$204 in nextProps) {
-        var propKey = nextProps[propKey$204];
-        lastProp = lastProps[propKey$204];
+      for (var propKey$207 in nextProps) {
+        var propKey = nextProps[propKey$207];
+        lastProp = lastProps[propKey$207];
         if (
-          nextProps.hasOwnProperty(propKey$204) &&
+          nextProps.hasOwnProperty(propKey$207) &&
           (null != propKey || null != lastProp)
         )
-          switch (propKey$204) {
+          switch (propKey$207) {
             case "type":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               type = propKey;
               break;
             case "name":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               name = propKey;
               break;
             case "checked":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               checked = propKey;
               break;
             case "defaultChecked":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               defaultChecked = propKey;
               break;
             case "value":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               value = propKey;
               break;
             case "defaultValue":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               defaultValue = propKey;
               break;
             case "children":
@@ -13214,7 +14204,7 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
                 setProp(
                   domElement,
                   tag,
-                  propKey$204,
+                  propKey$207,
                   propKey,
                   nextProps,
                   lastProp
@@ -13233,7 +14223,7 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
       );
       return;
     case "select":
-      propKey = value = defaultValue = propKey$204 = null;
+      propKey = value = defaultValue = propKey$207 = null;
       for (type in lastProps)
         if (
           ((lastDefaultValue = lastProps[type]),
@@ -13264,13 +14254,16 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
         )
           switch (name) {
             case "value":
-              propKey$204 = type;
+              type !== lastDefaultValue && (viewTransitionMutationContext = !0);
+              propKey$207 = type;
               break;
             case "defaultValue":
+              type !== lastDefaultValue && (viewTransitionMutationContext = !0);
               defaultValue = type;
               break;
             case "multiple":
-              value = type;
+              type !== lastDefaultValue && (viewTransitionMutationContext = !0),
+                (value = type);
             default:
               type !== lastDefaultValue &&
                 setProp(
@@ -13285,15 +14278,15 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
       tag = defaultValue;
       lastProps = value;
       nextProps = propKey;
-      null != propKey$204
-        ? updateOptions(domElement, !!lastProps, propKey$204, !1)
+      null != propKey$207
+        ? updateOptions(domElement, !!lastProps, propKey$207, !1)
         : !!nextProps !== !!lastProps &&
           (null != tag
             ? updateOptions(domElement, !!lastProps, tag, !0)
             : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));
       return;
     case "textarea":
-      propKey = propKey$204 = null;
+      propKey = propKey$207 = null;
       for (defaultValue in lastProps)
         if (
           ((name = lastProps[defaultValue]),
@@ -13317,9 +14310,11 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
         )
           switch (value) {
             case "value":
-              propKey$204 = name;
+              name !== type && (viewTransitionMutationContext = !0);
+              propKey$207 = name;
               break;
             case "defaultValue":
+              name !== type && (viewTransitionMutationContext = !0);
               propKey = name;
               break;
             case "children":
@@ -13331,17 +14326,17 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
               name !== type &&
                 setProp(domElement, tag, value, name, nextProps, type);
           }
-      updateTextarea(domElement, propKey$204, propKey);
+      updateTextarea(domElement, propKey$207, propKey);
       return;
     case "option":
-      for (var propKey$220 in lastProps)
+      for (var propKey$223 in lastProps)
         if (
-          ((propKey$204 = lastProps[propKey$220]),
-          lastProps.hasOwnProperty(propKey$220) &&
-            null != propKey$204 &&
-            !nextProps.hasOwnProperty(propKey$220))
+          ((propKey$207 = lastProps[propKey$223]),
+          lastProps.hasOwnProperty(propKey$223) &&
+            null != propKey$207 &&
+            !nextProps.hasOwnProperty(propKey$223))
         )
-          switch (propKey$220) {
+          switch (propKey$223) {
             case "selected":
               domElement.selected = !1;
               break;
@@ -13349,33 +14344,34 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
               setProp(
                 domElement,
                 tag,
-                propKey$220,
+                propKey$223,
                 null,
                 nextProps,
-                propKey$204
+                propKey$207
               );
           }
       for (lastDefaultValue in nextProps)
         if (
-          ((propKey$204 = nextProps[lastDefaultValue]),
+          ((propKey$207 = nextProps[lastDefaultValue]),
           (propKey = lastProps[lastDefaultValue]),
           nextProps.hasOwnProperty(lastDefaultValue) &&
-            propKey$204 !== propKey &&
-            (null != propKey$204 || null != propKey))
+            propKey$207 !== propKey &&
+            (null != propKey$207 || null != propKey))
         )
           switch (lastDefaultValue) {
             case "selected":
+              propKey$207 !== propKey && (viewTransitionMutationContext = !0);
               domElement.selected =
-                propKey$204 &&
-                "function" !== typeof propKey$204 &&
-                "symbol" !== typeof propKey$204;
+                propKey$207 &&
+                "function" !== typeof propKey$207 &&
+                "symbol" !== typeof propKey$207;
               break;
             default:
               setProp(
                 domElement,
                 tag,
                 lastDefaultValue,
-                propKey$204,
+                propKey$207,
                 nextProps,
                 propKey
               );
@@ -13396,24 +14392,24 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
     case "track":
     case "wbr":
     case "menuitem":
-      for (var propKey$225 in lastProps)
-        (propKey$204 = lastProps[propKey$225]),
-          lastProps.hasOwnProperty(propKey$225) &&
-            null != propKey$204 &&
-            !nextProps.hasOwnProperty(propKey$225) &&
-            setProp(domElement, tag, propKey$225, null, nextProps, propKey$204);
+      for (var propKey$228 in lastProps)
+        (propKey$207 = lastProps[propKey$228]),
+          lastProps.hasOwnProperty(propKey$228) &&
+            null != propKey$207 &&
+            !nextProps.hasOwnProperty(propKey$228) &&
+            setProp(domElement, tag, propKey$228, null, nextProps, propKey$207);
       for (checked in nextProps)
         if (
-          ((propKey$204 = nextProps[checked]),
+          ((propKey$207 = nextProps[checked]),
           (propKey = lastProps[checked]),
           nextProps.hasOwnProperty(checked) &&
-            propKey$204 !== propKey &&
-            (null != propKey$204 || null != propKey))
+            propKey$207 !== propKey &&
+            (null != propKey$207 || null != propKey))
         )
           switch (checked) {
             case "children":
             case "dangerouslySetInnerHTML":
-              if (null != propKey$204)
+              if (null != propKey$207)
                 throw Error(formatProdErrorMessage(137, tag));
               break;
             default:
@@ -13421,7 +14417,7 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
                 domElement,
                 tag,
                 checked,
-                propKey$204,
+                propKey$207,
                 nextProps,
                 propKey
               );
@@ -13429,49 +14425,49 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
       return;
     default:
       if (isCustomElement(tag)) {
-        for (var propKey$230 in lastProps)
-          (propKey$204 = lastProps[propKey$230]),
-            lastProps.hasOwnProperty(propKey$230) &&
-              void 0 !== propKey$204 &&
-              !nextProps.hasOwnProperty(propKey$230) &&
+        for (var propKey$233 in lastProps)
+          (propKey$207 = lastProps[propKey$233]),
+            lastProps.hasOwnProperty(propKey$233) &&
+              void 0 !== propKey$207 &&
+              !nextProps.hasOwnProperty(propKey$233) &&
               setPropOnCustomElement(
                 domElement,
                 tag,
-                propKey$230,
+                propKey$233,
                 void 0,
                 nextProps,
-                propKey$204
+                propKey$207
               );
         for (defaultChecked in nextProps)
-          (propKey$204 = nextProps[defaultChecked]),
+          (propKey$207 = nextProps[defaultChecked]),
             (propKey = lastProps[defaultChecked]),
             !nextProps.hasOwnProperty(defaultChecked) ||
-              propKey$204 === propKey ||
-              (void 0 === propKey$204 && void 0 === propKey) ||
+              propKey$207 === propKey ||
+              (void 0 === propKey$207 && void 0 === propKey) ||
               setPropOnCustomElement(
                 domElement,
                 tag,
                 defaultChecked,
-                propKey$204,
+                propKey$207,
                 nextProps,
                 propKey
               );
         return;
       }
   }
-  for (var propKey$235 in lastProps)
-    (propKey$204 = lastProps[propKey$235]),
-      lastProps.hasOwnProperty(propKey$235) &&
-        null != propKey$204 &&
-        !nextProps.hasOwnProperty(propKey$235) &&
-        setProp(domElement, tag, propKey$235, null, nextProps, propKey$204);
+  for (var propKey$238 in lastProps)
+    (propKey$207 = lastProps[propKey$238]),
+      lastProps.hasOwnProperty(propKey$238) &&
+        null != propKey$207 &&
+        !nextProps.hasOwnProperty(propKey$238) &&
+        setProp(domElement, tag, propKey$238, null, nextProps, propKey$207);
   for (lastProp in nextProps)
-    (propKey$204 = nextProps[lastProp]),
+    (propKey$207 = nextProps[lastProp]),
       (propKey = lastProps[lastProp]),
       !nextProps.hasOwnProperty(lastProp) ||
-        propKey$204 === propKey ||
-        (null == propKey$204 && null == propKey) ||
-        setProp(domElement, tag, lastProp, propKey$204, nextProps, propKey);
+        propKey$207 === propKey ||
+        (null == propKey$207 && null == propKey) ||
+        setProp(domElement, tag, lastProp, propKey$207, nextProps, propKey);
 }
 var eventsEnabled = null,
   selectionInformation = null;
@@ -13565,6 +14561,148 @@ function clearSuspenseBoundary(parentInstance, suspenseInstance) {
   } while (node);
   retryIfBlockedOn(suspenseInstance);
 }
+function restoreViewTransitionName(instance, props) {
+  props = props.style;
+  var viewTransitionName =
+    null != props
+      ? props.hasOwnProperty("viewTransitionName")
+        ? props.viewTransitionName
+        : props.hasOwnProperty("view-transition-name")
+          ? props["view-transition-name"]
+          : null
+      : null;
+  instance.style.viewTransitionName =
+    null == viewTransitionName || "boolean" === typeof viewTransitionName
+      ? ""
+      : ("" + viewTransitionName).trim();
+  props =
+    null != props
+      ? props.hasOwnProperty("viewTransitionClass")
+        ? props.viewTransitionClass
+        : props.hasOwnProperty("view-transition-class")
+          ? props["view-transition-class"]
+          : null
+      : null;
+  instance.style.viewTransitionClass =
+    null == props || "boolean" === typeof props ? "" : ("" + props).trim();
+}
+function measureInstance(instance) {
+  var ownerWindow = instance.ownerDocument.defaultView,
+    rect = instance.getBoundingClientRect();
+  instance = getComputedStyle(instance);
+  return {
+    rect: rect,
+    abs: "absolute" === instance.position || "fixed" === instance.position,
+    clip:
+      "none" !== instance.clipPath ||
+      "visible" !== instance.overflow ||
+      "none" !== instance.filter ||
+      "none" !== instance.mask ||
+      "none" !== instance.mask ||
+      "0px" !== instance.borderRadius,
+    view:
+      0 <= rect.bottom &&
+      0 <= rect.right &&
+      rect.top <= ownerWindow.innerHeight &&
+      rect.left <= ownerWindow.innerWidth
+  };
+}
+function startViewTransition(
+  rootContainer,
+  mutationCallback,
+  layoutCallback,
+  afterMutationCallback,
+  spawnedWorkCallback,
+  passiveCallback
+) {
+  var ownerDocument =
+    9 === rootContainer.nodeType ? rootContainer : rootContainer.ownerDocument;
+  try {
+    var transition = ownerDocument.startViewTransition({
+      update: function () {
+        var ownerWindow = ownerDocument.defaultView;
+        ownerWindow =
+          ownerWindow.navigation && ownerWindow.navigation.transition;
+        var previousFontLoadingStatus = ownerDocument.fonts.status;
+        mutationCallback();
+        if (
+          "loaded" === previousFontLoadingStatus &&
+          (ownerDocument.documentElement.clientHeight,
+          "loading" === ownerDocument.fonts.status)
+        )
+          return (
+            (previousFontLoadingStatus = Promise.race([
+              ownerDocument.fonts.ready,
+              new Promise(function (resolve) {
+                return setTimeout(resolve, 500);
+              })
+            ]).then(layoutCallback, layoutCallback)),
+            (ownerWindow
+              ? Promise.allSettled([
+                  ownerWindow.finished,
+                  previousFontLoadingStatus
+                ])
+              : previousFontLoadingStatus
+            ).then(afterMutationCallback, afterMutationCallback)
+          );
+        layoutCallback();
+        if (ownerWindow)
+          return ownerWindow.finished.then(
+            afterMutationCallback,
+            afterMutationCallback
+          );
+        afterMutationCallback();
+      },
+      types: null
+    });
+    ownerDocument.__reactViewTransition = transition;
+    transition.ready.then(spawnedWorkCallback, spawnedWorkCallback);
+    transition.finished.then(function () {
+      ownerDocument.__reactViewTransition = null;
+      passiveCallback();
+    });
+    return !0;
+  } catch (x) {
+    return !1;
+  }
+}
+function ViewTransitionPseudoElement(pseudo, name) {
+  this._scope = document.documentElement;
+  this._selector = "::view-transition-" + pseudo + "(" + name + ")";
+}
+ViewTransitionPseudoElement.prototype.animate = function (keyframes, options) {
+  options =
+    "number" === typeof options ? { duration: options } : assign({}, options);
+  options.pseudoElement = this._selector;
+  return this._scope.animate(keyframes, options);
+};
+ViewTransitionPseudoElement.prototype.getAnimations = function () {
+  for (
+    var scope = this._scope,
+      selector = this._selector,
+      animations = scope.getAnimations({ subtree: !0 }),
+      result = [],
+      i = 0;
+    i < animations.length;
+    i++
+  ) {
+    var effect = animations[i].effect;
+    null !== effect &&
+      effect.target === scope &&
+      effect.pseudoElement === selector &&
+      result.push(animations[i]);
+  }
+  return result;
+};
+function createViewTransitionInstance(name) {
+  return {
+    name: name,
+    group: new ViewTransitionPseudoElement("group", name),
+    imagePair: new ViewTransitionPseudoElement("image-pair", name),
+    old: new ViewTransitionPseudoElement("old", name),
+    new: new ViewTransitionPseudoElement("new", name)
+  };
+}
 function clearContainerSparingly(container) {
   var nextNode = container.firstChild;
   nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
@@ -13738,11 +14876,6 @@ function resolveSingletonInstance(type, props, rootContainerInstance) {
       throw Error(formatProdErrorMessage(451));
   }
 }
-function releaseSingletonInstance(instance) {
-  for (var attributes = instance.attributes; attributes.length; )
-    instance.removeAttributeNode(attributes[0]);
-  detachDeletedInstance(instance);
-}
 var preloadPropsMap = new Map(),
   preconnectsSet = new Set();
 function getHoistableRoot(container) {
@@ -14042,26 +15175,26 @@ function getResource(type, currentProps, pendingProps, currentResource) {
         "string" === typeof pendingProps.precedence
       ) {
         type = getStyleKey(pendingProps.href);
-        var styles$243 = getResourcesFromRoot(
+        var styles$246 = getResourcesFromRoot(
             JSCompiler_inline_result
           ).hoistableStyles,
-          resource$244 = styles$243.get(type);
-        resource$244 ||
+          resource$247 = styles$246.get(type);
+        resource$247 ||
           ((JSCompiler_inline_result =
             JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
-          (resource$244 = {
+          (resource$247 = {
             type: "stylesheet",
             instance: null,
             count: 0,
             state: { loading: 0, preload: null }
           }),
-          styles$243.set(type, resource$244),
-          (styles$243 = JSCompiler_inline_result.querySelector(
+          styles$246.set(type, resource$247),
+          (styles$246 = JSCompiler_inline_result.querySelector(
             getStylesheetSelectorFromKey(type)
           )) &&
-            !styles$243._p &&
-            ((resource$244.instance = styles$243),
-            (resource$244.state.loading = 5)),
+            !styles$246._p &&
+            ((resource$247.instance = styles$246),
+            (resource$247.state.loading = 5)),
           preloadPropsMap.has(type) ||
             ((pendingProps = {
               rel: "preload",
@@ -14074,16 +15207,16 @@ function getResource(type, currentProps, pendingProps, currentResource) {
               referrerPolicy: pendingProps.referrerPolicy
             }),
             preloadPropsMap.set(type, pendingProps),
-            styles$243 ||
+            styles$246 ||
               preloadStylesheet(
                 JSCompiler_inline_result,
                 type,
                 pendingProps,
-                resource$244.state
+                resource$247.state
               )));
         if (currentProps && null === currentResource)
           throw Error(formatProdErrorMessage(528, ""));
-        return resource$244;
+        return resource$247;
       }
       if (currentProps && null !== currentResource)
         throw Error(formatProdErrorMessage(529, ""));
@@ -14180,37 +15313,37 @@ function acquireResource(hoistableRoot, resource, props) {
         return (resource.instance = instance);
       case "stylesheet":
         styleProps = getStyleKey(props.href);
-        var instance$249 = hoistableRoot.querySelector(
+        var instance$252 = hoistableRoot.querySelector(
           getStylesheetSelectorFromKey(styleProps)
         );
-        if (instance$249)
+        if (instance$252)
           return (
             (resource.state.loading |= 4),
-            (resource.instance = instance$249),
-            markNodeAsHoistable(instance$249),
-            instance$249
+            (resource.instance = instance$252),
+            markNodeAsHoistable(instance$252),
+            instance$252
           );
         instance = stylesheetPropsFromRawProps(props);
         (styleProps = preloadPropsMap.get(styleProps)) &&
           adoptPreloadPropsForStylesheet(instance, styleProps);
-        instance$249 = (
+        instance$252 = (
           hoistableRoot.ownerDocument || hoistableRoot
         ).createElement("link");
-        markNodeAsHoistable(instance$249);
-        var linkInstance = instance$249;
+        markNodeAsHoistable(instance$252);
+        var linkInstance = instance$252;
         linkInstance._p = new Promise(function (resolve, reject) {
           linkInstance.onload = resolve;
           linkInstance.onerror = reject;
         });
-        setInitialProperties(instance$249, "link", instance);
+        setInitialProperties(instance$252, "link", instance);
         resource.state.loading |= 4;
-        insertStylesheet(instance$249, props.precedence, hoistableRoot);
-        return (resource.instance = instance$249);
+        insertStylesheet(instance$252, props.precedence, hoistableRoot);
+        return (resource.instance = instance$252);
       case "script":
-        instance$249 = getScriptKey(props.src);
+        instance$252 = getScriptKey(props.src);
         if (
           (styleProps = hoistableRoot.querySelector(
-            getScriptSelectorFromKey(instance$249)
+            getScriptSelectorFromKey(instance$252)
           ))
         )
           return (
@@ -14219,7 +15352,7 @@ function acquireResource(hoistableRoot, resource, props) {
             styleProps
           );
         instance = props;
-        if ((styleProps = preloadPropsMap.get(instance$249)))
+        if ((styleProps = preloadPropsMap.get(instance$252)))
           (instance = assign({}, props)),
             adoptPreloadPropsForScript(instance, styleProps);
         hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
@@ -15238,16 +16371,16 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
     0 === i && attemptExplicitHydrationTarget(target);
   }
 };
-var isomorphicReactPackageVersion$jscomp$inline_1739 = React.version;
+var isomorphicReactPackageVersion$jscomp$inline_1799 = React.version;
 if (
-  "19.1.0-canary-c492f975-20250128" !==
-  isomorphicReactPackageVersion$jscomp$inline_1739
+  "19.1.0-experimental-b3a95caf-20250113" !==
+  isomorphicReactPackageVersion$jscomp$inline_1799
 )
   throw Error(
     formatProdErrorMessage(
       527,
-      isomorphicReactPackageVersion$jscomp$inline_1739,
-      "19.1.0-canary-c492f975-20250128"
+      isomorphicReactPackageVersion$jscomp$inline_1799,
+      "19.1.0-experimental-b3a95caf-20250113"
     )
   );
 ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
@@ -15267,24 +16400,24 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
     null === componentOrElement ? null : componentOrElement.stateNode;
   return componentOrElement;
 };
-var internals$jscomp$inline_2216 = {
+var internals$jscomp$inline_2330 = {
   bundleType: 0,
-  version: "19.1.0-canary-c492f975-20250128",
+  version: "19.1.0-experimental-b3a95caf-20250113",
   rendererPackageName: "react-dom",
   currentDispatcherRef: ReactSharedInternals,
-  reconcilerVersion: "19.1.0-canary-c492f975-20250128"
+  reconcilerVersion: "19.1.0-experimental-b3a95caf-20250113"
 };
 if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
-  var hook$jscomp$inline_2217 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+  var hook$jscomp$inline_2331 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
   if (
-    !hook$jscomp$inline_2217.isDisabled &&
-    hook$jscomp$inline_2217.supportsFiber
+    !hook$jscomp$inline_2331.isDisabled &&
+    hook$jscomp$inline_2331.supportsFiber
   )
     try {
-      (rendererID = hook$jscomp$inline_2217.inject(
-        internals$jscomp$inline_2216
+      (rendererID = hook$jscomp$inline_2331.inject(
+        internals$jscomp$inline_2330
       )),
-        (injectedHook = hook$jscomp$inline_2217);
+        (injectedHook = hook$jscomp$inline_2331);
     } catch (err) {}
 }
 exports.createRoot = function (container, options) {
@@ -15378,4 +16511,4 @@ exports.hydrateRoot = function (container, initialChildren, options) {
   listenToAllSupportedEvents(container);
   return new ReactDOMHydrationRoot(initialChildren);
 };
-exports.version = "19.1.0-canary-c492f975-20250128";
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
diff --git a/node_modules/react-dom/cjs/react-dom-profiling.development.js b/node_modules/react-dom/cjs/react-dom-profiling.development.js
index 88a98d3..0f4f69a 100644
--- a/node_modules/react-dom/cjs/react-dom-profiling.development.js
+++ b/node_modules/react-dom/cjs/react-dom-profiling.development.js
@@ -264,6 +264,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (
@@ -353,6 +355,8 @@
           return "SuspenseList";
         case 25:
           return "TracingMarker";
+        case 30:
+          return "ViewTransition";
         case 1:
         case 0:
         case 14:
@@ -567,61 +571,10 @@
             ));
         }
     }
-    function injectProfilingHooks(profilingHooks) {
-      injectedProfilingHooks = profilingHooks;
-    }
-    function markCommitStopped() {
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markCommitStopped &&
-        injectedProfilingHooks.markCommitStopped();
-    }
-    function markComponentRenderStarted(fiber) {
-      null !== injectedProfilingHooks &&
-        "function" ===
-          typeof injectedProfilingHooks.markComponentRenderStarted &&
-        injectedProfilingHooks.markComponentRenderStarted(fiber);
-    }
-    function markComponentRenderStopped() {
-      null !== injectedProfilingHooks &&
-        "function" ===
-          typeof injectedProfilingHooks.markComponentRenderStopped &&
-        injectedProfilingHooks.markComponentRenderStopped();
-    }
-    function markRenderStarted(lanes) {
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markRenderStarted &&
-        injectedProfilingHooks.markRenderStarted(lanes);
-    }
-    function markRenderStopped() {
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markRenderStopped &&
-        injectedProfilingHooks.markRenderStopped();
-    }
-    function markStateUpdateScheduled(fiber, lane) {
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markStateUpdateScheduled &&
-        injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
-    }
     function clz32Fallback(x) {
       x >>>= 0;
       return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
     }
-    function getLabelForLane(lane) {
-      if (lane & 1) return "SyncHydrationLane";
-      if (lane & 2) return "Sync";
-      if (lane & 4) return "InputContinuousHydration";
-      if (lane & 8) return "InputContinuous";
-      if (lane & 16) return "DefaultHydration";
-      if (lane & 32) return "Default";
-      if (lane & 64) return "TransitionHydration";
-      if (lane & 4194176) return "Transition";
-      if (lane & 62914560) return "Retry";
-      if (lane & 67108864) return "SelectiveHydration";
-      if (lane & 134217728) return "IdleHydration";
-      if (lane & 268435456) return "Idle";
-      if (lane & 536870912) return "Offscreen";
-      if (lane & 1073741824) return "Deferred";
-    }
     function getHighestPriorityLanes(lanes) {
       var pendingSyncLanes = lanes & 42;
       if (0 !== pendingSyncLanes) return pendingSyncLanes;
@@ -1377,6 +1330,27 @@
       "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
       return sampleLines;
     }
+    function formatOwnerStack(error) {
+      var prevPrepareStackTrace = Error.prepareStackTrace;
+      Error.prepareStackTrace = void 0;
+      error = error.stack;
+      Error.prepareStackTrace = prevPrepareStackTrace;
+      error.startsWith("Error: react-stack-top-frame\n") &&
+        (error = error.slice(29));
+      prevPrepareStackTrace = error.indexOf("\n");
+      -1 !== prevPrepareStackTrace &&
+        (error = error.slice(prevPrepareStackTrace + 1));
+      prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
+      -1 !== prevPrepareStackTrace &&
+        (prevPrepareStackTrace = error.lastIndexOf(
+          "\n",
+          prevPrepareStackTrace
+        ));
+      if (-1 !== prevPrepareStackTrace)
+        error = error.slice(0, prevPrepareStackTrace);
+      else return "";
+      return error;
+    }
     function describeFiber(fiber) {
       switch (fiber.tag) {
         case 26:
@@ -1396,6 +1370,8 @@
           return describeNativeComponentFrame(fiber.type.render, !1);
         case 1:
           return describeNativeComponentFrame(fiber.type, !0);
+        case 30:
+          return describeBuiltInComponentFrame("ViewTransition");
         default:
           return "";
       }
@@ -1425,13 +1401,75 @@
         return "\nError generating stack: " + x.message + "\n" + x.stack;
       }
     }
+    function describeFunctionComponentFrameWithoutLineNumber(fn) {
+      return (fn = fn ? fn.displayName || fn.name : "")
+        ? describeBuiltInComponentFrame(fn)
+        : "";
+    }
     function getCurrentFiberOwnerNameInDevOrNull() {
       if (null === current) return null;
       var owner = current._debugOwner;
       return null != owner ? getComponentNameFromOwner(owner) : null;
     }
     function getCurrentFiberStackInDev() {
-      return null === current ? "" : getStackByFiberInDevAndProd(current);
+      if (null === current) return "";
+      var workInProgress = current;
+      try {
+        var info = "";
+        6 === workInProgress.tag && (workInProgress = workInProgress.return);
+        switch (workInProgress.tag) {
+          case 26:
+          case 27:
+          case 5:
+            info += describeBuiltInComponentFrame(workInProgress.type);
+            break;
+          case 13:
+            info += describeBuiltInComponentFrame("Suspense");
+            break;
+          case 19:
+            info += describeBuiltInComponentFrame("SuspenseList");
+            break;
+          case 30:
+            info += describeBuiltInComponentFrame("SuspenseList");
+            break;
+          case 0:
+          case 15:
+          case 1:
+            workInProgress._debugOwner ||
+              "" !== info ||
+              (info += describeFunctionComponentFrameWithoutLineNumber(
+                workInProgress.type
+              ));
+            break;
+          case 11:
+            workInProgress._debugOwner ||
+              "" !== info ||
+              (info += describeFunctionComponentFrameWithoutLineNumber(
+                workInProgress.type.render
+              ));
+        }
+        for (; workInProgress; )
+          if ("number" === typeof workInProgress.tag) {
+            var fiber = workInProgress;
+            workInProgress = fiber._debugOwner;
+            var debugStack = fiber._debugStack;
+            workInProgress &&
+              debugStack &&
+              ("string" !== typeof debugStack &&
+                (fiber._debugStack = debugStack = formatOwnerStack(debugStack)),
+              "" !== debugStack && (info += "\n" + debugStack));
+          } else if (null != workInProgress.debugStack) {
+            var ownerStack = workInProgress.debugStack;
+            (workInProgress = workInProgress.owner) &&
+              ownerStack &&
+              (info += "\n" + formatOwnerStack(ownerStack));
+          } else break;
+        var JSCompiler_inline_result = info;
+      } catch (x) {
+        JSCompiler_inline_result =
+          "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+      return JSCompiler_inline_result;
     }
     function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
       var previousFiber = current;
@@ -1440,7 +1478,11 @@
       isRendering = !1;
       current = fiber;
       try {
-        return callback(arg0, arg1, arg2, arg3, arg4);
+        return null !== fiber && fiber._debugTask
+          ? fiber._debugTask.run(
+              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
+            )
+          : callback(arg0, arg1, arg2, arg3, arg4);
       } finally {
         current = previousFiber;
       }
@@ -2480,37 +2522,50 @@
         : findInvalidAncestorForTag(childTag, ancestorInfo);
       ancestorInfo = parentInfo || ancestorInfo;
       if (!ancestorInfo) return !0;
-      ancestorInfo = ancestorInfo.tag;
-      var warnKey = String(!!parentInfo) + "|" + childTag + "|" + ancestorInfo;
-      if (didWarn[warnKey]) return !1;
-      didWarn[warnKey] = !0;
-      var ancestor = (warnKey = current)
-        ? findAncestor(warnKey.return, ancestorInfo)
-        : null;
-      warnKey =
-        null !== warnKey && null !== ancestor
-          ? describeAncestors(ancestor, warnKey, null)
-          : "";
-      ancestor = "<" + childTag + ">";
+      var ancestorTag = ancestorInfo.tag;
+      ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
+      if (didWarn[ancestorInfo]) return !1;
+      didWarn[ancestorInfo] = !0;
+      var ancestor = (ancestorInfo = current)
+          ? findAncestor(ancestorInfo.return, ancestorTag)
+          : null,
+        ancestorDescription =
+          null !== ancestorInfo && null !== ancestor
+            ? describeAncestors(ancestor, ancestorInfo, null)
+            : "",
+        tagDisplayName = "<" + childTag + ">";
       parentInfo
         ? ((parentInfo = ""),
-          "table" === ancestorInfo &&
+          "table" === ancestorTag &&
             "tr" === childTag &&
             (parentInfo +=
               " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."),
           console.error(
             "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
-            ancestor,
-            ancestorInfo,
+            tagDisplayName,
+            ancestorTag,
             parentInfo,
-            warnKey
+            ancestorDescription
           ))
         : console.error(
             "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
-            ancestor,
-            ancestorInfo,
-            warnKey
+            tagDisplayName,
+            ancestorTag,
+            ancestorDescription
           );
+      ancestorInfo &&
+        ((childTag = ancestorInfo.return),
+        null === ancestor ||
+          null === childTag ||
+          (ancestor === childTag &&
+            childTag._debugOwner === ancestorInfo._debugOwner) ||
+          runWithFiberInDEV(ancestor, function () {
+            console.error(
+              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
+              ancestorTag,
+              tagDisplayName
+            );
+          }));
       return !1;
     }
     function validateTextNesting(childText, parentTag) {
@@ -2691,12 +2746,14 @@
               ? node.setProperty(styleName, "")
               : "float" === styleName
                 ? (node.cssFloat = "")
-                : (node[styleName] = ""));
+                : (node[styleName] = ""),
+            (viewTransitionMutationContext = !0));
         for (var _styleName in styles)
           (_key2 = styles[_styleName]),
             styles.hasOwnProperty(_styleName) &&
               prevStyles[_styleName] !== _key2 &&
-              setValueForStyle(node, _styleName, _key2);
+              (setValueForStyle(node, _styleName, _key2),
+              (viewTransitionMutationContext = !0));
       } else
         for (expandedUpdates in styles)
           styles.hasOwnProperty(expandedUpdates) &&
@@ -3878,6 +3935,38 @@
           staleFamilies
         );
     }
+    function startUpdateTimerByLane(lane) {
+      var JSCompiler_temp;
+      (JSCompiler_temp = 0 !== (lane & 3)) ||
+        (JSCompiler_temp = 0 !== (lane & 60));
+      if (JSCompiler_temp)
+        0 > blockingUpdateTime &&
+          ((blockingUpdateTime = now()),
+          (executionContext & (RenderContext | CommitContext)) !== NoContext &&
+            (blockingSpawnedUpdate = !0),
+          (lane = resolveEventTimeStamp()),
+          (JSCompiler_temp = resolveEventType()),
+          lane !== blockingEventTime || JSCompiler_temp !== blockingEventType
+            ? (blockingEventIsRepeat = !1)
+            : null !== JSCompiler_temp && (blockingSpawnedUpdate = !0),
+          (blockingEventTime = lane),
+          (blockingEventType = JSCompiler_temp));
+      else if (
+        0 !== (lane & 4194176) &&
+        0 > transitionUpdateTime &&
+        ((transitionUpdateTime = now()), 0 > transitionStartTime)
+      ) {
+        lane = resolveEventTimeStamp();
+        JSCompiler_temp = resolveEventType();
+        if (
+          lane !== transitionEventTime ||
+          JSCompiler_temp !== transitionEventType
+        )
+          transitionEventIsRepeat = !1;
+        transitionEventTime = lane;
+        transitionEventType = JSCompiler_temp;
+      }
+    }
     function pushNestedEffectDurations() {
       var prevEffectDuration = profilerEffectDuration;
       profilerEffectDuration = 0;
@@ -3893,6 +3982,23 @@
       profilerEffectDuration += prevEffectDuration;
       return elapsedTime;
     }
+    function resetComponentEffectTimers() {
+      componentEffectEndTime = componentEffectStartTime = -1.1;
+    }
+    function pushComponentEffectStart() {
+      var prevEffectStart = componentEffectStartTime;
+      componentEffectStartTime = -1.1;
+      componentEffectDuration = -0;
+      return prevEffectStart;
+    }
+    function popComponentEffectStart(prevEffectStart) {
+      0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
+    }
+    function pushComponentEffectErrors() {
+      var prevErrors = componentEffectErrors;
+      componentEffectErrors = null;
+      return prevErrors;
+    }
     function startProfilerTimer(fiber) {
       profilerStartTime = now();
       0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
@@ -3914,18 +4020,266 @@
     }
     function recordEffectDuration() {
       if (0 <= profilerStartTime) {
-        var elapsedTime = now() - profilerStartTime;
+        var endTime = now(),
+          elapsedTime = endTime - profilerStartTime;
         profilerStartTime = -1;
         profilerEffectDuration += elapsedTime;
+        componentEffectDuration += elapsedTime;
+        componentEffectEndTime = endTime;
       }
     }
+    function recordEffectError(errorInfo) {
+      null === componentEffectErrors && (componentEffectErrors = []);
+      componentEffectErrors.push(errorInfo);
+      null === commitErrors && (commitErrors = []);
+      commitErrors.push(errorInfo);
+    }
     function startEffectTimer() {
       profilerStartTime = now();
+      0 > componentEffectStartTime &&
+        (componentEffectStartTime = profilerStartTime);
     }
     function transferActualDuration(fiber) {
       for (var child = fiber.child; child; )
         (fiber.actualDuration += child.actualDuration), (child = child.sibling);
     }
+    function setCurrentTrackFromLanes(lanes) {
+      reusableLaneDevToolDetails.track =
+        lanes & 63
+          ? "Blocking"
+          : lanes & 4194240
+            ? "Transition"
+            : lanes & 62914560
+              ? "Suspense"
+              : lanes & 2080374784
+                ? "Idle"
+                : "Other";
+    }
+    function logComponentRender(fiber, startTime, endTime, wasHydrated) {
+      var name = getComponentNameFromFiber(fiber);
+      if (null !== name && supportsUserTiming) {
+        var selfTime = fiber.actualDuration;
+        if (null === fiber.alternate || fiber.alternate.child !== fiber.child)
+          for (fiber = fiber.child; null !== fiber; fiber = fiber.sibling)
+            selfTime -= fiber.actualDuration;
+        reusableComponentDevToolDetails.color =
+          0.5 > selfTime
+            ? wasHydrated
+              ? "tertiary-light"
+              : "primary-light"
+            : 10 > selfTime
+              ? wasHydrated
+                ? "tertiary"
+                : "primary"
+              : 100 > selfTime
+                ? wasHydrated
+                  ? "tertiary-dark"
+                  : "primary-dark"
+                : "error";
+        reusableComponentOptions.start = startTime;
+        reusableComponentOptions.end = endTime;
+        performance.measure(name, reusableComponentOptions);
+      }
+    }
+    function logComponentErrored(fiber, startTime, endTime, errors) {
+      if (supportsUserTiming) {
+        var name = getComponentNameFromFiber(fiber);
+        if (null !== name) {
+          for (var properties = [], i = 0; i < errors.length; i++) {
+            var error = errors[i].value;
+            properties.push([
+              "Error",
+              "object" === typeof error &&
+              null !== error &&
+              "string" === typeof error.message
+                ? String(error.message)
+                : String(error)
+            ]);
+          }
+          performance.measure(name, {
+            start: startTime,
+            end: endTime,
+            detail: {
+              devtools: {
+                color: "error",
+                track: COMPONENTS_TRACK,
+                tooltipText:
+                  13 === fiber.tag
+                    ? "Hydration failed"
+                    : "Error boundary caught an error",
+                properties: properties
+              }
+            }
+          });
+        }
+      }
+    }
+    function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
+      if (null !== errors) {
+        if (
+          supportsUserTiming &&
+          ((selfTime = getComponentNameFromFiber(fiber)), null !== selfTime)
+        ) {
+          fiber = [];
+          for (var i = 0; i < errors.length; i++) {
+            var error = errors[i].value;
+            fiber.push([
+              "Error",
+              "object" === typeof error &&
+              null !== error &&
+              "string" === typeof error.message
+                ? String(error.message)
+                : String(error)
+            ]);
+          }
+          performance.measure(selfTime, {
+            start: startTime,
+            end: endTime,
+            detail: {
+              devtools: {
+                color: "error",
+                track: COMPONENTS_TRACK,
+                tooltipText: "A lifecycle or effect errored",
+                properties: fiber
+              }
+            }
+          });
+        }
+      } else
+        (errors = getComponentNameFromFiber(fiber)),
+          null !== errors &&
+            supportsUserTiming &&
+            ((reusableComponentDevToolDetails.color =
+              1 > selfTime
+                ? "secondary-light"
+                : 100 > selfTime
+                  ? "secondary"
+                  : 500 > selfTime
+                    ? "secondary-dark"
+                    : "error"),
+            (reusableComponentOptions.start = startTime),
+            (reusableComponentOptions.end = endTime),
+            performance.measure(errors, reusableComponentOptions));
+    }
+    function logRenderPhase(startTime, endTime, lanes) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color =
+          (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure(
+          (lanes & 536870912) === lanes
+            ? "Prepared"
+            : (lanes & 201326677) === lanes
+              ? "Hydrated"
+              : "Render",
+          reusableLaneOptions
+        ));
+    }
+    function logSuspendedRenderPhase(startTime, endTime, lanes) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color =
+          (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Prewarm", reusableLaneOptions));
+    }
+    function logSuspendedWithDelayPhase(startTime, endTime, lanes) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color =
+          (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Suspended", reusableLaneOptions));
+    }
+    function logRecoveredRenderPhase(
+      startTime,
+      endTime,
+      lanes,
+      recoverableErrors,
+      hydrationFailed
+    ) {
+      if (supportsUserTiming) {
+        lanes = [];
+        for (var i = 0; i < recoverableErrors.length; i++) {
+          var error = recoverableErrors[i].value;
+          lanes.push([
+            "Recoverable Error",
+            "object" === typeof error &&
+            null !== error &&
+            "string" === typeof error.message
+              ? String(error.message)
+              : String(error)
+          ]);
+        }
+        performance.measure("Recovered", {
+          start: startTime,
+          end: endTime,
+          detail: {
+            devtools: {
+              color: "primary-dark",
+              track: reusableLaneDevToolDetails.track,
+              trackGroup: LANES_TRACK_GROUP,
+              tooltipText: hydrationFailed
+                ? "Hydration Failed"
+                : "Recovered after Error",
+              properties: lanes
+            }
+          }
+        });
+      }
+    }
+    function logErroredRenderPhase(startTime, endTime) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color = "error"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Errored", reusableLaneOptions));
+    }
+    function logSuspenseThrottlePhase(startTime, endTime) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color = "secondary-light"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Throttled", reusableLaneOptions));
+    }
+    function logSuspendedCommitPhase(startTime, endTime) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color = "secondary-light"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Suspended", reusableLaneOptions));
+    }
+    function logCommitErrored(startTime, endTime, errors, passive) {
+      if (supportsUserTiming) {
+        for (var properties = [], i = 0; i < errors.length; i++) {
+          var error = errors[i].value;
+          properties.push([
+            "Error",
+            "object" === typeof error &&
+            null !== error &&
+            "string" === typeof error.message
+              ? String(error.message)
+              : String(error)
+          ]);
+        }
+        performance.measure("Errored", {
+          start: startTime,
+          end: endTime,
+          detail: {
+            devtools: {
+              color: "error",
+              track: reusableLaneDevToolDetails.track,
+              trackGroup: LANES_TRACK_GROUP,
+              tooltipText: passive
+                ? "Remaining Effects Errored"
+                : "Commit Errored",
+              properties: properties
+            }
+          }
+        });
+      }
+    }
     function resetContextDependencies() {
       lastContextDependency = currentlyRenderingFiber$1 = null;
       isDisallowedContextReadInDEV = !1;
@@ -4155,7 +4509,8 @@
     function pingEngtangledActionScope() {
       if (
         0 === --currentEntangledPendingCount &&
-        null !== currentEntangledListeners
+        (-1 < transitionUpdateTime || (transitionStartTime = -1.1),
+        null !== currentEntangledListeners)
       ) {
         null !== currentEntangledActionThenable &&
           (currentEntangledActionThenable.status = "fulfilled");
@@ -4643,6 +4998,15 @@
       }
       return newProps;
     }
+    function getTreeId() {
+      var overflow = treeContextOverflow,
+        idWithLeadingBit = treeContextId;
+      return (
+        (
+          idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
+        ).toString(32) + overflow
+      );
+    }
     function pushTreeFork(workInProgress, totalChildren) {
       warnIfNotHydrating();
       forkStack[forkStackIndex++] = treeForkCount;
@@ -5713,7 +6077,7 @@
           ),
           node.isTransition ||
             console.error(
-              "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
+              "An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`"
             ))
         : onActionSuccess(actionQueue, node, returnValue);
     }
@@ -5950,6 +6314,43 @@
         ? mountEffectImpl(276826112, Passive, create, deps)
         : mountEffectImpl(8390656, Passive, create, deps);
     }
+    function useEffectEventImpl(payload) {
+      currentlyRenderingFiber.flags |= 4;
+      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
+      if (null === componentUpdateQueue)
+        (componentUpdateQueue = createFunctionComponentUpdateQueue()),
+          (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
+          (componentUpdateQueue.events = [payload]);
+      else {
+        var events = componentUpdateQueue.events;
+        null === events
+          ? (componentUpdateQueue.events = [payload])
+          : events.push(payload);
+      }
+    }
+    function mountEvent(callback) {
+      var hook = mountWorkInProgressHook(),
+        ref = { impl: callback };
+      hook.memoizedState = ref;
+      return function () {
+        if ((executionContext & RenderContext) !== NoContext)
+          throw Error(
+            "A function wrapped in useEffectEvent can't be called during rendering."
+          );
+        return ref.impl.apply(void 0, arguments);
+      };
+    }
+    function updateEvent(callback) {
+      var ref = updateWorkInProgressHook().memoizedState;
+      useEffectEventImpl({ ref: ref, nextImpl: callback });
+      return function () {
+        if ((executionContext & RenderContext) !== NoContext)
+          throw Error(
+            "A function wrapped in useEffectEvent can't be called during rendering."
+          );
+        return ref.impl.apply(void 0, arguments);
+      };
+    }
     function mountLayoutEffect(create, deps) {
       var fiberFlags = 4194308;
       (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode &&
@@ -6276,18 +6677,13 @@
       var hook = mountWorkInProgressHook(),
         identifierPrefix = workInProgressRoot.identifierPrefix;
       if (isHydrating) {
-        var treeId = treeContextOverflow;
-        var idWithLeadingBit = treeContextId;
-        treeId =
-          (
-            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
-          ).toString(32) + treeId;
+        var treeId = getTreeId();
         identifierPrefix = ":" + identifierPrefix + "R" + treeId;
         treeId = localIdCounter++;
         0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
         identifierPrefix += ":";
       } else
-        (treeId = globalClientIdCounter++),
+        (treeId = globalClientIdCounter$1++),
           (identifierPrefix =
             ":" + identifierPrefix + "r" + treeId.toString(32) + ":");
       return (hook.memoizedState = identifierPrefix);
@@ -6298,7 +6694,7 @@
         currentlyRenderingFiber
       ));
     }
-    function refreshCache(fiber, seedKey) {
+    function refreshCache(fiber, seedKey, seedValue) {
       for (var provider = fiber.return; null !== provider; ) {
         switch (provider.tag) {
           case 24:
@@ -6307,15 +6703,14 @@
             fiber = createUpdate(lane);
             var root = enqueueUpdate(provider, fiber, lane);
             null !== root &&
-              (scheduleUpdateOnFiber(root, provider, lane),
+              (startUpdateTimerByLane(lane),
+              scheduleUpdateOnFiber(root, provider, lane),
               entangleTransitions(root, provider, lane));
             provider = createCache();
             null !== seedKey &&
               void 0 !== seedKey &&
               null !== root &&
-              console.error(
-                "The seed argument is not enabled outside experimental channels."
-              );
+              provider.data.set(seedKey, seedValue);
             fiber.payload = { cache: provider };
             return;
         }
@@ -6341,9 +6736,9 @@
         ? enqueueRenderPhaseUpdate(queue, update)
         : ((update = enqueueConcurrentHookUpdate(fiber, queue, update, args)),
           null !== update &&
-            (scheduleUpdateOnFiber(update, fiber, args),
+            (startUpdateTimerByLane(args),
+            scheduleUpdateOnFiber(update, fiber, args),
             entangleTransitionUpdate(update, queue, args)));
-      markStateUpdateScheduled(fiber, args);
     }
     function dispatchSetState(fiber, queue, action) {
       var args = arguments;
@@ -6352,8 +6747,8 @@
           "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
         );
       args = requestUpdateLane(fiber);
-      dispatchSetStateInternal(fiber, queue, action, args);
-      markStateUpdateScheduled(fiber, args);
+      dispatchSetStateInternal(fiber, queue, action, args) &&
+        startUpdateTimerByLane(args);
     }
     function dispatchSetStateInternal(fiber, queue, action, lane) {
       var update = {
@@ -6432,8 +6827,8 @@
           2
         )),
           null !== throwIfDuringRender &&
-            scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
-      markStateUpdateScheduled(fiber, 2);
+            (startUpdateTimerByLane(2),
+            scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
     }
     function isRenderPhaseUpdate(fiber) {
       var alternate = fiber.alternate;
@@ -6616,6 +7011,7 @@
             )),
             (current.return = returnFiber),
             (current._debugOwner = returnFiber),
+            (current._debugTask = returnFiber._debugTask),
             (current._debugInfo = currentDebugInfo),
             current
           );
@@ -6690,6 +7086,7 @@
             )),
             (current.return = returnFiber),
             (current._debugOwner = returnFiber),
+            (current._debugTask = returnFiber._debugTask),
             (current._debugInfo = currentDebugInfo),
             current
           );
@@ -6712,6 +7109,7 @@
             )),
             (newChild.return = returnFiber),
             (newChild._debugOwner = returnFiber),
+            (newChild._debugTask = returnFiber._debugTask),
             (newChild._debugInfo = currentDebugInfo),
             newChild
           );
@@ -6749,7 +7147,11 @@
               currentDebugInfo = _prevDebugInfo;
               return returnFiber;
           }
-          if (isArrayImpl(newChild) || getIteratorFn(newChild))
+          if (
+            isArrayImpl(newChild) ||
+            getIteratorFn(newChild) ||
+            "function" === typeof newChild[ASYNC_ITERATOR]
+          )
             return (
               (lanes = createFiberFromFragment(
                 newChild,
@@ -6759,6 +7161,7 @@
               )),
               (lanes.return = returnFiber),
               (lanes._debugOwner = returnFiber),
+              (lanes._debugTask = returnFiber._debugTask),
               (returnFiber = pushDebugInfo(newChild._debugInfo)),
               (lanes._debugInfo = currentDebugInfo),
               (currentDebugInfo = returnFiber),
@@ -6830,7 +7233,11 @@
                 returnFiber
               );
           }
-          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
+          if (
+            isArrayImpl(newChild) ||
+            getIteratorFn(newChild) ||
+            "function" === typeof newChild[ASYNC_ITERATOR]
+          ) {
             if (null !== key) return null;
             key = pushDebugInfo(newChild._debugInfo);
             returnFiber = updateFragment(
@@ -6924,7 +7331,11 @@
               currentDebugInfo = _prevDebugInfo7;
               return returnFiber;
           }
-          if (isArrayImpl(newChild) || getIteratorFn(newChild))
+          if (
+            isArrayImpl(newChild) ||
+            getIteratorFn(newChild) ||
+            "function" === typeof newChild[ASYNC_ITERATOR]
+          )
             return (
               (newIdx = existingChildren.get(newIdx) || null),
               (existingChildren = pushDebugInfo(newChild._debugInfo)),
@@ -7110,6 +7521,37 @@
         isHydrating && pushTreeFork(returnFiber, newIdx);
         return resultingFirstChild;
       }
+      function reconcileChildrenAsyncIteratable(
+        returnFiber,
+        currentFirstChild,
+        newChildrenIterable,
+        lanes
+      ) {
+        var newChildren = newChildrenIterable[ASYNC_ITERATOR]();
+        newChildren !== newChildrenIterable ||
+          (0 === returnFiber.tag &&
+            "[object AsyncGeneratorFunction]" ===
+              Object.prototype.toString.call(returnFiber.type) &&
+            "[object AsyncGenerator]" ===
+              Object.prototype.toString.call(newChildren)) ||
+          (didWarnAboutGenerators ||
+            console.error(
+              "Using AsyncIterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You can use an AsyncIterable that can iterate multiple times over the same items."
+            ),
+          (didWarnAboutGenerators = !0));
+        if (null == newChildren)
+          throw Error("An iterable object provided no iterator.");
+        return reconcileChildrenIterator(
+          returnFiber,
+          currentFirstChild,
+          {
+            next: function () {
+              return unwrapThenable(newChildren.next());
+            }
+          },
+          lanes
+        );
+      }
       function reconcileChildrenIterator(
         returnFiber,
         currentFirstChild,
@@ -7296,6 +7738,7 @@
                     )),
                     (lanes.return = returnFiber),
                     (lanes._debugOwner = returnFiber),
+                    (lanes._debugTask = returnFiber._debugTask),
                     (lanes._debugInfo = currentDebugInfo),
                     validateFragmentProps(newChild, lanes, returnFiber),
                     (returnFiber = lanes))
@@ -7418,6 +7861,18 @@
             currentDebugInfo = prevDebugInfo;
             return returnFiber;
           }
+          if ("function" === typeof newChild[ASYNC_ITERATOR])
+            return (
+              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
+              (returnFiber = reconcileChildrenAsyncIteratable(
+                returnFiber,
+                currentFirstChild,
+                newChild,
+                lanes
+              )),
+              (currentDebugInfo = prevDebugInfo),
+              returnFiber
+            );
           if ("function" === typeof newChild.then)
             return (
               (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
@@ -7462,6 +7917,7 @@
                 )),
                 (lanes.return = returnFiber),
                 (lanes._debugOwner = returnFiber),
+                (lanes._debugTask = returnFiber._debugTask),
                 (lanes._debugInfo = currentDebugInfo),
                 (returnFiber = lanes)),
             placeSingleChild(returnFiber)
@@ -7491,10 +7947,12 @@
           fiber.return = returnFiber;
           var debugInfo = (fiber._debugInfo = currentDebugInfo);
           fiber._debugOwner = returnFiber._debugOwner;
+          fiber._debugTask = returnFiber._debugTask;
           if (null != debugInfo)
             for (var i = debugInfo.length - 1; 0 <= i; i--)
               if ("string" === typeof debugInfo[i].stack) {
                 fiber._debugOwner = debugInfo[i];
+                fiber._debugTask = debugInfo[i].debugTask;
                 break;
               }
           return fiber;
@@ -7575,63 +8033,62 @@
       }
       return null;
     }
-    function defaultOnUncaughtError(error, errorInfo) {
+    function defaultOnUncaughtError(error) {
       reportGlobalError(error);
-      error = componentName
-        ? "An error occurred in the <" + componentName + "> component."
-        : "An error occurred in one of your React components.";
-      var prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
-        componentStack =
-          null != errorInfo.componentStack ? errorInfo.componentStack : "";
-      ReactSharedInternals.getCurrentStack = function () {
-        return componentStack;
-      };
-      try {
-        console.warn(
-          "%s\n\n%s\n",
-          error,
-          "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
-        );
-      } finally {
-        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
-      }
+      console.warn(
+        "%s\n\n%s\n",
+        componentName
+          ? "An error occurred in the <" + componentName + "> component."
+          : "An error occurred in one of your React components.",
+        "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
+      );
     }
-    function defaultOnCaughtError(error, errorInfo) {
+    function defaultOnCaughtError(error) {
       var componentNameMessage = componentName
           ? "The above error occurred in the <" + componentName + "> component."
           : "The above error occurred in one of your React components.",
         recreateMessage =
           "React will try to recreate this component tree from scratch using the error boundary you provided, " +
-          ((errorBoundaryName || "Anonymous") + "."),
-        prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
-        componentStack =
-          null != errorInfo.componentStack ? errorInfo.componentStack : "";
-      ReactSharedInternals.getCurrentStack = function () {
-        return componentStack;
-      };
-      try {
+          ((errorBoundaryName || "Anonymous") + ".");
+      if (
         "object" === typeof error &&
         null !== error &&
         "string" === typeof error.environmentName
-          ? bindToConsole(
-              "error",
-              [
-                "%o\n\n%s\n\n%s\n",
-                error,
-                componentNameMessage,
-                recreateMessage
-              ],
-              error.environmentName
-            )()
-          : console.error(
-              "%o\n\n%s\n\n%s\n",
-              error,
-              componentNameMessage,
-              recreateMessage
+      ) {
+        var JSCompiler_inline_result = error.environmentName;
+        error = [
+          "%o\n\n%s\n\n%s\n",
+          error,
+          componentNameMessage,
+          recreateMessage
+        ].slice(0);
+        "string" === typeof error[0]
+          ? error.splice(
+              0,
+              1,
+              badgeFormat + error[0],
+              badgeStyle,
+              pad + JSCompiler_inline_result + pad,
+              resetStyle
+            )
+          : error.splice(
+              0,
+              0,
+              badgeFormat,
+              badgeStyle,
+              pad + JSCompiler_inline_result + pad,
+              resetStyle
             );
-      } finally {
-        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
-      }
+        error.unshift(console);
+        JSCompiler_inline_result = bind.apply(console.error, error);
+        JSCompiler_inline_result();
+      } else
+        console.error(
+          "%o\n\n%s\n\n%s\n",
+          error,
+          componentNameMessage,
+          recreateMessage
+        );
     }
     function defaultOnRecoverableError(error) {
       reportGlobalError(error);
@@ -7729,6 +8186,27 @@
               ));
         });
     }
+    function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
+      var currentSourceFiber = sourceFiber.alternate;
+      null !== currentSourceFiber &&
+        propagateParentContextChanges(
+          currentSourceFiber,
+          sourceFiber,
+          rootRenderLanes,
+          !0
+        );
+    }
+    function markSuspenseBoundaryShouldCapture(
+      suspenseBoundary,
+      returnFiber,
+      sourceFiber,
+      root,
+      rootRenderLanes
+    ) {
+      suspenseBoundary.flags |= 65536;
+      suspenseBoundary.lanes = rootRenderLanes;
+      return suspenseBoundary;
+    }
     function throwException(
       root,
       returnFiber,
@@ -7741,63 +8219,63 @@
       if (
         null !== value &&
         "object" === typeof value &&
-        "function" === typeof value.then
+        (value.$$typeof === REACT_POSTPONE_TYPE &&
+          (value = { then: function () {} }),
+        "function" === typeof value.then)
       ) {
-        returnFiber = sourceFiber.alternate;
-        null !== returnFiber &&
-          propagateParentContextChanges(
-            returnFiber,
-            sourceFiber,
-            rootRenderLanes,
-            !0
-          );
+        resetSuspendedComponent(sourceFiber, rootRenderLanes);
         isHydrating && (didSuspendOrErrorDEV = !0);
-        sourceFiber = suspenseHandlerStackCursor.current;
-        if (null !== sourceFiber) {
-          switch (sourceFiber.tag) {
+        var suspenseBoundary = suspenseHandlerStackCursor.current;
+        if (null !== suspenseBoundary) {
+          switch (suspenseBoundary.tag) {
             case 13:
               return (
                 null === shellBoundary
                   ? renderDidSuspendDelayIfPossible()
-                  : null === sourceFiber.alternate &&
+                  : null === suspenseBoundary.alternate &&
                     workInProgressRootExitStatus === RootInProgress &&
                     (workInProgressRootExitStatus = RootSuspended),
-                (sourceFiber.flags &= -257),
-                (sourceFiber.flags |= 65536),
-                (sourceFiber.lanes = rootRenderLanes),
+                (suspenseBoundary.flags &= -257),
+                markSuspenseBoundaryShouldCapture(
+                  suspenseBoundary,
+                  returnFiber,
+                  sourceFiber,
+                  root,
+                  rootRenderLanes
+                ),
                 value === noopSuspenseyCommitThenable
-                  ? (sourceFiber.flags |= 16384)
-                  : ((returnFiber = sourceFiber.updateQueue),
-                    null === returnFiber
-                      ? (sourceFiber.updateQueue = new Set([value]))
-                      : returnFiber.add(value),
+                  ? (suspenseBoundary.flags |= 16384)
+                  : ((sourceFiber = suspenseBoundary.updateQueue),
+                    null === sourceFiber
+                      ? (suspenseBoundary.updateQueue = new Set([value]))
+                      : sourceFiber.add(value),
                     attachPingListener(root, value, rootRenderLanes)),
                 !1
               );
             case 22:
               return (
-                (sourceFiber.flags |= 65536),
+                (suspenseBoundary.flags |= 65536),
                 value === noopSuspenseyCommitThenable
-                  ? (sourceFiber.flags |= 16384)
-                  : ((returnFiber = sourceFiber.updateQueue),
-                    null === returnFiber
-                      ? ((returnFiber = {
+                  ? (suspenseBoundary.flags |= 16384)
+                  : ((sourceFiber = suspenseBoundary.updateQueue),
+                    null === sourceFiber
+                      ? ((sourceFiber = {
                           transitions: null,
                           markerInstances: null,
                           retryQueue: new Set([value])
                         }),
-                        (sourceFiber.updateQueue = returnFiber))
-                      : ((sourceFiber = returnFiber.retryQueue),
-                        null === sourceFiber
-                          ? (returnFiber.retryQueue = new Set([value]))
-                          : sourceFiber.add(value)),
+                        (suspenseBoundary.updateQueue = sourceFiber))
+                      : ((returnFiber = sourceFiber.retryQueue),
+                        null === returnFiber
+                          ? (sourceFiber.retryQueue = new Set([value]))
+                          : returnFiber.add(value)),
                     attachPingListener(root, value, rootRenderLanes)),
                 !1
               );
           }
           throw Error(
             "Unexpected Suspense handler tag (" +
-              sourceFiber.tag +
+              suspenseBoundary.tag +
               "). This is a bug in React."
           );
         }
@@ -7808,11 +8286,17 @@
       if (isHydrating)
         return (
           (didSuspendOrErrorDEV = !0),
-          (returnFiber = suspenseHandlerStackCursor.current),
-          null !== returnFiber
-            ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
-              (returnFiber.flags |= 65536),
-              (returnFiber.lanes = rootRenderLanes),
+          (suspenseBoundary = suspenseHandlerStackCursor.current),
+          null !== suspenseBoundary
+            ? (0 === (suspenseBoundary.flags & 65536) &&
+                (suspenseBoundary.flags |= 256),
+              markSuspenseBoundaryShouldCapture(
+                suspenseBoundary,
+                returnFiber,
+                sourceFiber,
+                root,
+                rootRenderLanes
+              ),
               value !== HydrationMismatchException &&
                 queueHydrationError(
                   createCapturedValueAtFiber(
@@ -7837,10 +8321,10 @@
               (root.flags |= 65536),
               (rootRenderLanes &= -rootRenderLanes),
               (root.lanes |= rootRenderLanes),
-              (value = createCapturedValueAtFiber(value, sourceFiber)),
+              (sourceFiber = createCapturedValueAtFiber(value, sourceFiber)),
               (rootRenderLanes = createRootErrorUpdate(
                 root.stateNode,
-                value,
+                sourceFiber,
                 rootRenderLanes
               )),
               enqueueCapturedUpdate(root, rootRenderLanes),
@@ -7848,64 +8332,65 @@
                 (workInProgressRootExitStatus = RootErrored)),
           !1
         );
-      var error = createCapturedValueAtFiber(
-        Error(
-          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
-          { cause: value }
-        ),
-        sourceFiber
+      queueConcurrentError(
+        createCapturedValueAtFiber(
+          Error(
+            "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
+            { cause: value }
+          ),
+          sourceFiber
+        )
       );
-      null === workInProgressRootConcurrentErrors
-        ? (workInProgressRootConcurrentErrors = [error])
-        : workInProgressRootConcurrentErrors.push(error);
       workInProgressRootExitStatus !== RootSuspendedWithDelay &&
         (workInProgressRootExitStatus = RootErrored);
       if (null === returnFiber) return !0;
-      value = createCapturedValueAtFiber(value, sourceFiber);
-      sourceFiber = returnFiber;
+      sourceFiber = createCapturedValueAtFiber(value, sourceFiber);
+      value = returnFiber;
       do {
-        switch (sourceFiber.tag) {
+        switch (value.tag) {
           case 3:
             return (
-              (sourceFiber.flags |= 65536),
+              (value.flags |= 65536),
               (root = rootRenderLanes & -rootRenderLanes),
-              (sourceFiber.lanes |= root),
+              (value.lanes |= root),
               (root = createRootErrorUpdate(
-                sourceFiber.stateNode,
-                value,
+                value.stateNode,
+                sourceFiber,
                 root
               )),
-              enqueueCapturedUpdate(sourceFiber, root),
+              enqueueCapturedUpdate(value, root),
               !1
             );
           case 1:
             if (
-              ((returnFiber = sourceFiber.type),
-              (error = sourceFiber.stateNode),
-              0 === (sourceFiber.flags & 128) &&
+              ((returnFiber = value.type),
+              (suspenseBoundary = value.stateNode),
+              0 === (value.flags & 128) &&
                 ("function" === typeof returnFiber.getDerivedStateFromError ||
-                  (null !== error &&
-                    "function" === typeof error.componentDidCatch &&
+                  (null !== suspenseBoundary &&
+                    "function" === typeof suspenseBoundary.componentDidCatch &&
                     (null === legacyErrorBoundariesThatAlreadyFailed ||
-                      !legacyErrorBoundariesThatAlreadyFailed.has(error)))))
+                      !legacyErrorBoundariesThatAlreadyFailed.has(
+                        suspenseBoundary
+                      )))))
             )
               return (
-                (sourceFiber.flags |= 65536),
+                (value.flags |= 65536),
                 (rootRenderLanes &= -rootRenderLanes),
-                (sourceFiber.lanes |= rootRenderLanes),
+                (value.lanes |= rootRenderLanes),
                 (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
                 initializeClassErrorUpdate(
                   rootRenderLanes,
                   root,
-                  sourceFiber,
-                  value
+                  value,
+                  sourceFiber
                 ),
-                enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
+                enqueueCapturedUpdate(value, rootRenderLanes),
                 !1
               );
         }
-        sourceFiber = sourceFiber.return;
-      } while (null !== sourceFiber);
+        value = value.return;
+      } while (null !== value);
       return !1;
     }
     function reconcileChildren(
@@ -7939,7 +8424,6 @@
           "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
       } else propsWithoutRef = nextProps;
       prepareToReadContext(workInProgress);
-      markComponentRenderStarted(workInProgress);
       nextProps = renderWithHooks(
         current,
         workInProgress,
@@ -7949,7 +8433,6 @@
         renderLanes
       );
       key = checkDidRenderIdHook();
-      markComponentRenderStopped();
       if (null !== current && !didReceiveUpdate)
         return (
           bailoutHooks(current, workInProgress, renderLanes),
@@ -8195,7 +8678,6 @@
               componentName
             ))));
       prepareToReadContext(workInProgress);
-      markComponentRenderStarted(workInProgress);
       Component = renderWithHooks(
         current,
         workInProgress,
@@ -8205,7 +8687,6 @@
         renderLanes
       );
       nextProps = checkDidRenderIdHook();
-      markComponentRenderStopped();
       if (null !== current && !didReceiveUpdate)
         return (
           bailoutHooks(current, workInProgress, renderLanes),
@@ -8225,7 +8706,6 @@
       renderLanes
     ) {
       prepareToReadContext(workInProgress);
-      markComponentRenderStarted(workInProgress);
       hookTypesUpdateIndexDev = -1;
       ignorePreviousDependencies =
         null !== current && current.type !== workInProgress.type;
@@ -8238,7 +8718,6 @@
       );
       finishRenderingHooks(current, workInProgress);
       Component = checkDidRenderIdHook();
-      markComponentRenderStopped();
       if (null !== current && !didReceiveUpdate)
         return (
           bailoutHooks(current, workInProgress, renderLanes),
@@ -8754,18 +9233,16 @@
         current = workInProgress;
         if (state && "function" !== typeof Component.getDerivedStateFromError)
           (Component = null), (profilerStartTime = -1);
-        else {
-          markComponentRenderStarted(workInProgress);
-          Component = callRenderInDEV(lane);
-          if (workInProgress.mode & StrictLegacyMode) {
-            setIsStrictModeForDevtools(!0);
-            try {
-              callRenderInDEV(lane);
-            } finally {
-              setIsStrictModeForDevtools(!1);
-            }
+        else if (
+          ((Component = callRenderInDEV(lane)),
+          workInProgress.mode & StrictLegacyMode)
+        ) {
+          setIsStrictModeForDevtools(!0);
+          try {
+            callRenderInDEV(lane);
+          } finally {
+            setIsStrictModeForDevtools(!1);
           }
-          markComponentRenderStopped();
         }
         workInProgress.flags |= 1;
         null !== current$jscomp$0 && state
@@ -8856,32 +9333,33 @@
       return current;
     }
     function updateSuspenseComponent(current, workInProgress, renderLanes) {
-      var JSCompiler_object_inline_digest_2393;
-      var JSCompiler_object_inline_stack_2394 = workInProgress.pendingProps;
+      var JSCompiler_object_inline_componentStack_2557;
+      var JSCompiler_object_inline_stack_2556 = workInProgress.pendingProps;
       shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);
-      var JSCompiler_object_inline_componentStack_2395 = !1;
+      var JSCompiler_object_inline_message_2554 = !1;
       var didSuspend = 0 !== (workInProgress.flags & 128);
-      (JSCompiler_object_inline_digest_2393 = didSuspend) ||
-        (JSCompiler_object_inline_digest_2393 =
+      (JSCompiler_object_inline_componentStack_2557 = didSuspend) ||
+        (JSCompiler_object_inline_componentStack_2557 =
           null !== current && null === current.memoizedState
             ? !1
             : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
-      JSCompiler_object_inline_digest_2393 &&
-        ((JSCompiler_object_inline_componentStack_2395 = !0),
+      JSCompiler_object_inline_componentStack_2557 &&
+        ((JSCompiler_object_inline_message_2554 = !0),
         (workInProgress.flags &= -129));
-      JSCompiler_object_inline_digest_2393 = 0 !== (workInProgress.flags & 32);
+      JSCompiler_object_inline_componentStack_2557 =
+        0 !== (workInProgress.flags & 32);
       workInProgress.flags &= -33;
       if (null === current) {
         if (isHydrating) {
-          JSCompiler_object_inline_componentStack_2395
+          JSCompiler_object_inline_message_2554
             ? pushPrimaryTreeSuspenseHandler(workInProgress)
             : reuseSuspenseHandlerOnStack(workInProgress);
           if (isHydrating) {
-            var JSCompiler_object_inline_message_2392 = nextHydratableInstance;
+            var JSCompiler_object_inline_digest_2555 = nextHydratableInstance;
             var JSCompiler_temp;
-            if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2392)) {
+            if (!(JSCompiler_temp = !JSCompiler_object_inline_digest_2555)) {
               c: {
-                var instance = JSCompiler_object_inline_message_2392;
+                var instance = JSCompiler_object_inline_digest_2555;
                 for (
                   JSCompiler_temp = rootOrSingletonContext;
                   8 !== instance.nodeType;
@@ -8923,77 +9401,87 @@
             JSCompiler_temp &&
               (warnNonHydratedInstance(
                 workInProgress,
-                JSCompiler_object_inline_message_2392
+                JSCompiler_object_inline_digest_2555
               ),
               throwOnHydrationMismatch(workInProgress));
           }
-          JSCompiler_object_inline_message_2392 = workInProgress.memoizedState;
+          JSCompiler_object_inline_digest_2555 = workInProgress.memoizedState;
           if (
-            null !== JSCompiler_object_inline_message_2392 &&
-            ((JSCompiler_object_inline_message_2392 =
-              JSCompiler_object_inline_message_2392.dehydrated),
-            null !== JSCompiler_object_inline_message_2392)
+            null !== JSCompiler_object_inline_digest_2555 &&
+            ((JSCompiler_object_inline_digest_2555 =
+              JSCompiler_object_inline_digest_2555.dehydrated),
+            null !== JSCompiler_object_inline_digest_2555)
           )
             return (
-              isSuspenseInstanceFallback(JSCompiler_object_inline_message_2392)
+              isSuspenseInstanceFallback(JSCompiler_object_inline_digest_2555)
                 ? (workInProgress.lanes = 32)
                 : (workInProgress.lanes = 536870912),
               null
             );
           popSuspenseHandler(workInProgress);
         }
-        JSCompiler_object_inline_message_2392 =
-          JSCompiler_object_inline_stack_2394.children;
-        JSCompiler_object_inline_stack_2394 =
-          JSCompiler_object_inline_stack_2394.fallback;
-        if (JSCompiler_object_inline_componentStack_2395)
+        JSCompiler_object_inline_digest_2555 =
+          JSCompiler_object_inline_stack_2556.children;
+        JSCompiler_temp = JSCompiler_object_inline_stack_2556.fallback;
+        if (JSCompiler_object_inline_message_2554)
           return (
             reuseSuspenseHandlerOnStack(workInProgress),
-            (JSCompiler_object_inline_componentStack_2395 =
-              workInProgress.mode),
-            (JSCompiler_object_inline_message_2392 =
-              mountWorkInProgressOffscreenFiber(
-                {
-                  mode: "hidden",
-                  children: JSCompiler_object_inline_message_2392
-                },
-                JSCompiler_object_inline_componentStack_2395
+            (JSCompiler_object_inline_stack_2556 =
+              mountSuspenseFallbackChildren(
+                workInProgress,
+                JSCompiler_object_inline_digest_2555,
+                JSCompiler_temp,
+                renderLanes
               )),
-            (JSCompiler_object_inline_stack_2394 = createFiberFromFragment(
-              JSCompiler_object_inline_stack_2394,
-              JSCompiler_object_inline_componentStack_2395,
-              renderLanes,
-              null
-            )),
-            (JSCompiler_object_inline_message_2392.return = workInProgress),
-            (JSCompiler_object_inline_stack_2394.return = workInProgress),
-            (JSCompiler_object_inline_message_2392.sibling =
-              JSCompiler_object_inline_stack_2394),
-            (workInProgress.child = JSCompiler_object_inline_message_2392),
-            (JSCompiler_object_inline_componentStack_2395 =
-              workInProgress.child),
-            (JSCompiler_object_inline_componentStack_2395.memoizedState =
+            (JSCompiler_object_inline_message_2554 = workInProgress.child),
+            (JSCompiler_object_inline_message_2554.memoizedState =
+              mountSuspenseOffscreenState(renderLanes)),
+            (JSCompiler_object_inline_message_2554.childLanes =
+              getRemainingWorkInPrimaryTree(
+                current,
+                JSCompiler_object_inline_componentStack_2557,
+                renderLanes
+              )),
+            (workInProgress.memoizedState = SUSPENDED_MARKER),
+            JSCompiler_object_inline_stack_2556
+          );
+        if (
+          "number" ===
+          typeof JSCompiler_object_inline_stack_2556.unstable_expectedLoadTime
+        )
+          return (
+            reuseSuspenseHandlerOnStack(workInProgress),
+            (JSCompiler_object_inline_stack_2556 =
+              mountSuspenseFallbackChildren(
+                workInProgress,
+                JSCompiler_object_inline_digest_2555,
+                JSCompiler_temp,
+                renderLanes
+              )),
+            (JSCompiler_object_inline_message_2554 = workInProgress.child),
+            (JSCompiler_object_inline_message_2554.memoizedState =
               mountSuspenseOffscreenState(renderLanes)),
-            (JSCompiler_object_inline_componentStack_2395.childLanes =
+            (JSCompiler_object_inline_message_2554.childLanes =
               getRemainingWorkInPrimaryTree(
                 current,
-                JSCompiler_object_inline_digest_2393,
+                JSCompiler_object_inline_componentStack_2557,
                 renderLanes
               )),
             (workInProgress.memoizedState = SUSPENDED_MARKER),
-            JSCompiler_object_inline_stack_2394
+            (workInProgress.lanes = 4194304),
+            JSCompiler_object_inline_stack_2556
           );
         pushPrimaryTreeSuspenseHandler(workInProgress);
         return mountSuspensePrimaryChildren(
           workInProgress,
-          JSCompiler_object_inline_message_2392
+          JSCompiler_object_inline_digest_2555
         );
       }
       var prevState = current.memoizedState;
       if (
         null !== prevState &&
-        ((JSCompiler_object_inline_message_2392 = prevState.dehydrated),
-        null !== JSCompiler_object_inline_message_2392)
+        ((JSCompiler_object_inline_digest_2555 = prevState.dehydrated),
+        null !== JSCompiler_object_inline_digest_2555)
       ) {
         if (didSuspend)
           workInProgress.flags & 256
@@ -9010,94 +9498,94 @@
                 (workInProgress.flags |= 128),
                 (workInProgress = null))
               : (reuseSuspenseHandlerOnStack(workInProgress),
-                (JSCompiler_object_inline_componentStack_2395 =
-                  JSCompiler_object_inline_stack_2394.fallback),
-                (JSCompiler_object_inline_message_2392 = workInProgress.mode),
-                (JSCompiler_object_inline_stack_2394 =
+                (JSCompiler_object_inline_message_2554 =
+                  JSCompiler_object_inline_stack_2556.fallback),
+                (JSCompiler_object_inline_digest_2555 = workInProgress.mode),
+                (JSCompiler_object_inline_stack_2556 =
                   mountWorkInProgressOffscreenFiber(
                     {
                       mode: "visible",
-                      children: JSCompiler_object_inline_stack_2394.children
+                      children: JSCompiler_object_inline_stack_2556.children
                     },
-                    JSCompiler_object_inline_message_2392
+                    JSCompiler_object_inline_digest_2555
                   )),
-                (JSCompiler_object_inline_componentStack_2395 =
+                (JSCompiler_object_inline_message_2554 =
                   createFiberFromFragment(
-                    JSCompiler_object_inline_componentStack_2395,
-                    JSCompiler_object_inline_message_2392,
+                    JSCompiler_object_inline_message_2554,
+                    JSCompiler_object_inline_digest_2555,
                     renderLanes,
                     null
                   )),
-                (JSCompiler_object_inline_componentStack_2395.flags |= 2),
-                (JSCompiler_object_inline_stack_2394.return = workInProgress),
-                (JSCompiler_object_inline_componentStack_2395.return =
-                  workInProgress),
-                (JSCompiler_object_inline_stack_2394.sibling =
-                  JSCompiler_object_inline_componentStack_2395),
-                (workInProgress.child = JSCompiler_object_inline_stack_2394),
+                (JSCompiler_object_inline_message_2554.flags |= 2),
+                (JSCompiler_object_inline_stack_2556.return = workInProgress),
+                (JSCompiler_object_inline_message_2554.return = workInProgress),
+                (JSCompiler_object_inline_stack_2556.sibling =
+                  JSCompiler_object_inline_message_2554),
+                (workInProgress.child = JSCompiler_object_inline_stack_2556),
                 reconcileChildFibers(
                   workInProgress,
                   current.child,
                   null,
                   renderLanes
                 ),
-                (JSCompiler_object_inline_stack_2394 = workInProgress.child),
-                (JSCompiler_object_inline_stack_2394.memoizedState =
+                (JSCompiler_object_inline_stack_2556 = workInProgress.child),
+                (JSCompiler_object_inline_stack_2556.memoizedState =
                   mountSuspenseOffscreenState(renderLanes)),
-                (JSCompiler_object_inline_stack_2394.childLanes =
+                (JSCompiler_object_inline_stack_2556.childLanes =
                   getRemainingWorkInPrimaryTree(
                     current,
-                    JSCompiler_object_inline_digest_2393,
+                    JSCompiler_object_inline_componentStack_2557,
                     renderLanes
                   )),
                 (workInProgress.memoizedState = SUSPENDED_MARKER),
-                (workInProgress =
-                  JSCompiler_object_inline_componentStack_2395));
+                (workInProgress = JSCompiler_object_inline_message_2554));
         else if (
           (pushPrimaryTreeSuspenseHandler(workInProgress),
           isHydrating &&
             console.error(
               "We should not be hydrating here. This is a bug in React. Please file a bug."
             ),
-          isSuspenseInstanceFallback(JSCompiler_object_inline_message_2392))
+          isSuspenseInstanceFallback(JSCompiler_object_inline_digest_2555))
         ) {
-          JSCompiler_object_inline_digest_2393 =
-            JSCompiler_object_inline_message_2392.nextSibling &&
-            JSCompiler_object_inline_message_2392.nextSibling.dataset;
-          if (JSCompiler_object_inline_digest_2393) {
-            JSCompiler_temp = JSCompiler_object_inline_digest_2393.dgst;
-            var message = JSCompiler_object_inline_digest_2393.msg;
-            instance = JSCompiler_object_inline_digest_2393.stck;
-            var componentStack = JSCompiler_object_inline_digest_2393.cstck;
+          JSCompiler_object_inline_componentStack_2557 =
+            JSCompiler_object_inline_digest_2555.nextSibling &&
+            JSCompiler_object_inline_digest_2555.nextSibling.dataset;
+          if (JSCompiler_object_inline_componentStack_2557) {
+            JSCompiler_temp = JSCompiler_object_inline_componentStack_2557.dgst;
+            var message = JSCompiler_object_inline_componentStack_2557.msg;
+            instance = JSCompiler_object_inline_componentStack_2557.stck;
+            var componentStack =
+              JSCompiler_object_inline_componentStack_2557.cstck;
           }
-          JSCompiler_object_inline_message_2392 = message;
-          JSCompiler_object_inline_digest_2393 = JSCompiler_temp;
-          JSCompiler_object_inline_stack_2394 = instance;
-          JSCompiler_temp = JSCompiler_object_inline_componentStack_2395 =
+          JSCompiler_object_inline_message_2554 = message;
+          JSCompiler_object_inline_digest_2555 = JSCompiler_temp;
+          JSCompiler_object_inline_stack_2556 = instance;
+          JSCompiler_temp = JSCompiler_object_inline_componentStack_2557 =
             componentStack;
-          JSCompiler_object_inline_componentStack_2395 =
-            JSCompiler_object_inline_message_2392
-              ? Error(JSCompiler_object_inline_message_2392)
-              : Error(
-                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
-                );
-          JSCompiler_object_inline_componentStack_2395.stack =
-            JSCompiler_object_inline_stack_2394 || "";
-          JSCompiler_object_inline_componentStack_2395.digest =
-            JSCompiler_object_inline_digest_2393;
-          JSCompiler_object_inline_digest_2393 =
-            void 0 === JSCompiler_temp ? null : JSCompiler_temp;
-          JSCompiler_object_inline_stack_2394 = {
-            value: JSCompiler_object_inline_componentStack_2395,
-            source: null,
-            stack: JSCompiler_object_inline_digest_2393
-          };
-          "string" === typeof JSCompiler_object_inline_digest_2393 &&
-            CapturedStacks.set(
-              JSCompiler_object_inline_componentStack_2395,
-              JSCompiler_object_inline_stack_2394
-            );
-          queueHydrationError(JSCompiler_object_inline_stack_2394);
+          "POSTPONE" !== JSCompiler_object_inline_digest_2555 &&
+            ((JSCompiler_object_inline_componentStack_2557 =
+              JSCompiler_object_inline_message_2554
+                ? Error(JSCompiler_object_inline_message_2554)
+                : Error(
+                    "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
+                  )),
+            (JSCompiler_object_inline_componentStack_2557.stack =
+              JSCompiler_object_inline_stack_2556 || ""),
+            (JSCompiler_object_inline_componentStack_2557.digest =
+              JSCompiler_object_inline_digest_2555),
+            (JSCompiler_object_inline_stack_2556 =
+              void 0 === JSCompiler_temp ? null : JSCompiler_temp),
+            (JSCompiler_object_inline_message_2554 = {
+              value: JSCompiler_object_inline_componentStack_2557,
+              source: null,
+              stack: JSCompiler_object_inline_stack_2556
+            }),
+            "string" === typeof JSCompiler_object_inline_stack_2556 &&
+              CapturedStacks.set(
+                JSCompiler_object_inline_componentStack_2557,
+                JSCompiler_object_inline_message_2554
+              ),
+            queueHydrationError(JSCompiler_object_inline_message_2554));
           workInProgress = retrySuspenseComponentWithoutHydrating(
             current,
             workInProgress,
@@ -9111,44 +9599,44 @@
               renderLanes,
               !1
             ),
-          (JSCompiler_object_inline_digest_2393 =
+          (JSCompiler_object_inline_componentStack_2557 =
             0 !== (renderLanes & current.childLanes)),
-          didReceiveUpdate || JSCompiler_object_inline_digest_2393)
+          didReceiveUpdate || JSCompiler_object_inline_componentStack_2557)
         ) {
-          JSCompiler_object_inline_digest_2393 = workInProgressRoot;
+          JSCompiler_object_inline_componentStack_2557 = workInProgressRoot;
           if (
-            null !== JSCompiler_object_inline_digest_2393 &&
-            ((JSCompiler_object_inline_stack_2394 = renderLanes & -renderLanes),
-            (JSCompiler_object_inline_stack_2394 =
-              0 !== (JSCompiler_object_inline_stack_2394 & 42)
+            null !== JSCompiler_object_inline_componentStack_2557 &&
+            ((JSCompiler_object_inline_stack_2556 = renderLanes & -renderLanes),
+            (JSCompiler_object_inline_stack_2556 =
+              0 !== (JSCompiler_object_inline_stack_2556 & 42)
                 ? 1
                 : getBumpedLaneForHydrationByLane(
-                    JSCompiler_object_inline_stack_2394
+                    JSCompiler_object_inline_stack_2556
                   )),
-            (JSCompiler_object_inline_stack_2394 =
+            (JSCompiler_object_inline_stack_2556 =
               0 !==
-              (JSCompiler_object_inline_stack_2394 &
-                (JSCompiler_object_inline_digest_2393.suspendedLanes |
+              (JSCompiler_object_inline_stack_2556 &
+                (JSCompiler_object_inline_componentStack_2557.suspendedLanes |
                   renderLanes))
                 ? 0
-                : JSCompiler_object_inline_stack_2394),
-            0 !== JSCompiler_object_inline_stack_2394 &&
-              JSCompiler_object_inline_stack_2394 !== prevState.retryLane)
+                : JSCompiler_object_inline_stack_2556),
+            0 !== JSCompiler_object_inline_stack_2556 &&
+              JSCompiler_object_inline_stack_2556 !== prevState.retryLane)
           )
             throw (
-              ((prevState.retryLane = JSCompiler_object_inline_stack_2394),
+              ((prevState.retryLane = JSCompiler_object_inline_stack_2556),
               enqueueConcurrentRenderForLane(
                 current,
-                JSCompiler_object_inline_stack_2394
+                JSCompiler_object_inline_stack_2556
               ),
               scheduleUpdateOnFiber(
-                JSCompiler_object_inline_digest_2393,
+                JSCompiler_object_inline_componentStack_2557,
                 current,
-                JSCompiler_object_inline_stack_2394
+                JSCompiler_object_inline_stack_2556
               ),
               SelectiveHydrationException)
             );
-          JSCompiler_object_inline_message_2392.data ===
+          JSCompiler_object_inline_digest_2555.data ===
             SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
           workInProgress = retrySuspenseComponentWithoutHydrating(
             current,
@@ -9156,14 +9644,14 @@
             renderLanes
           );
         } else
-          JSCompiler_object_inline_message_2392.data ===
+          JSCompiler_object_inline_digest_2555.data ===
           SUSPENSE_PENDING_START_DATA
             ? ((workInProgress.flags |= 192),
               (workInProgress.child = current.child),
               (workInProgress = null))
             : ((current = prevState.treeContext),
               (nextHydratableInstance = getNextHydratable(
-                JSCompiler_object_inline_message_2392.nextSibling
+                JSCompiler_object_inline_digest_2555.nextSibling
               )),
               (hydrationParentFiber = workInProgress),
               (isHydrating = !0),
@@ -9181,57 +9669,54 @@
                 (treeContextProvider = workInProgress)),
               (workInProgress = mountSuspensePrimaryChildren(
                 workInProgress,
-                JSCompiler_object_inline_stack_2394.children
+                JSCompiler_object_inline_stack_2556.children
               )),
               (workInProgress.flags |= 4096));
         return workInProgress;
       }
-      if (JSCompiler_object_inline_componentStack_2395)
+      if (JSCompiler_object_inline_message_2554)
         return (
           reuseSuspenseHandlerOnStack(workInProgress),
-          (JSCompiler_object_inline_componentStack_2395 =
-            JSCompiler_object_inline_stack_2394.fallback),
-          (JSCompiler_object_inline_message_2392 = workInProgress.mode),
+          (JSCompiler_object_inline_message_2554 =
+            JSCompiler_object_inline_stack_2556.fallback),
+          (JSCompiler_object_inline_digest_2555 = workInProgress.mode),
           (JSCompiler_temp = current.child),
           (instance = JSCompiler_temp.sibling),
-          (JSCompiler_object_inline_stack_2394 = createWorkInProgress(
+          (JSCompiler_object_inline_stack_2556 = createWorkInProgress(
             JSCompiler_temp,
             {
               mode: "hidden",
-              children: JSCompiler_object_inline_stack_2394.children
+              children: JSCompiler_object_inline_stack_2556.children
             }
           )),
-          (JSCompiler_object_inline_stack_2394.subtreeFlags =
+          (JSCompiler_object_inline_stack_2556.subtreeFlags =
             JSCompiler_temp.subtreeFlags & 65011712),
           null !== instance
-            ? (JSCompiler_object_inline_componentStack_2395 =
-                createWorkInProgress(
-                  instance,
-                  JSCompiler_object_inline_componentStack_2395
-                ))
-            : ((JSCompiler_object_inline_componentStack_2395 =
-                createFiberFromFragment(
-                  JSCompiler_object_inline_componentStack_2395,
-                  JSCompiler_object_inline_message_2392,
-                  renderLanes,
-                  null
-                )),
-              (JSCompiler_object_inline_componentStack_2395.flags |= 2)),
-          (JSCompiler_object_inline_componentStack_2395.return =
-            workInProgress),
-          (JSCompiler_object_inline_stack_2394.return = workInProgress),
-          (JSCompiler_object_inline_stack_2394.sibling =
-            JSCompiler_object_inline_componentStack_2395),
-          (workInProgress.child = JSCompiler_object_inline_stack_2394),
-          (JSCompiler_object_inline_stack_2394 =
-            JSCompiler_object_inline_componentStack_2395),
-          (JSCompiler_object_inline_componentStack_2395 = workInProgress.child),
-          (JSCompiler_object_inline_message_2392 = current.child.memoizedState),
-          null === JSCompiler_object_inline_message_2392
-            ? (JSCompiler_object_inline_message_2392 =
+            ? (JSCompiler_object_inline_message_2554 = createWorkInProgress(
+                instance,
+                JSCompiler_object_inline_message_2554
+              ))
+            : ((JSCompiler_object_inline_message_2554 = createFiberFromFragment(
+                JSCompiler_object_inline_message_2554,
+                JSCompiler_object_inline_digest_2555,
+                renderLanes,
+                null
+              )),
+              (JSCompiler_object_inline_message_2554.flags |= 2)),
+          (JSCompiler_object_inline_message_2554.return = workInProgress),
+          (JSCompiler_object_inline_stack_2556.return = workInProgress),
+          (JSCompiler_object_inline_stack_2556.sibling =
+            JSCompiler_object_inline_message_2554),
+          (workInProgress.child = JSCompiler_object_inline_stack_2556),
+          (JSCompiler_object_inline_stack_2556 =
+            JSCompiler_object_inline_message_2554),
+          (JSCompiler_object_inline_message_2554 = workInProgress.child),
+          (JSCompiler_object_inline_digest_2555 = current.child.memoizedState),
+          null === JSCompiler_object_inline_digest_2555
+            ? (JSCompiler_object_inline_digest_2555 =
                 mountSuspenseOffscreenState(renderLanes))
             : ((JSCompiler_temp =
-                JSCompiler_object_inline_message_2392.cachePool),
+                JSCompiler_object_inline_digest_2555.cachePool),
               null !== JSCompiler_temp
                 ? ((instance = CacheContext._currentValue),
                   (JSCompiler_temp =
@@ -9239,37 +9724,38 @@
                       ? { parent: instance, pool: instance }
                       : JSCompiler_temp))
                 : (JSCompiler_temp = getSuspendedCache()),
-              (JSCompiler_object_inline_message_2392 = {
+              (JSCompiler_object_inline_digest_2555 = {
                 baseLanes:
-                  JSCompiler_object_inline_message_2392.baseLanes | renderLanes,
+                  JSCompiler_object_inline_digest_2555.baseLanes | renderLanes,
                 cachePool: JSCompiler_temp
               })),
-          (JSCompiler_object_inline_componentStack_2395.memoizedState =
-            JSCompiler_object_inline_message_2392),
-          (JSCompiler_object_inline_componentStack_2395.childLanes =
+          (JSCompiler_object_inline_message_2554.memoizedState =
+            JSCompiler_object_inline_digest_2555),
+          (JSCompiler_object_inline_message_2554.childLanes =
             getRemainingWorkInPrimaryTree(
               current,
-              JSCompiler_object_inline_digest_2393,
+              JSCompiler_object_inline_componentStack_2557,
               renderLanes
             )),
           (workInProgress.memoizedState = SUSPENDED_MARKER),
-          JSCompiler_object_inline_stack_2394
+          JSCompiler_object_inline_stack_2556
         );
       pushPrimaryTreeSuspenseHandler(workInProgress);
       renderLanes = current.child;
       current = renderLanes.sibling;
       renderLanes = createWorkInProgress(renderLanes, {
         mode: "visible",
-        children: JSCompiler_object_inline_stack_2394.children
+        children: JSCompiler_object_inline_stack_2556.children
       });
       renderLanes.return = workInProgress;
       renderLanes.sibling = null;
       null !== current &&
-        ((JSCompiler_object_inline_digest_2393 = workInProgress.deletions),
-        null === JSCompiler_object_inline_digest_2393
+        ((JSCompiler_object_inline_componentStack_2557 =
+          workInProgress.deletions),
+        null === JSCompiler_object_inline_componentStack_2557
           ? ((workInProgress.deletions = [current]),
             (workInProgress.flags |= 16))
-          : JSCompiler_object_inline_digest_2393.push(current));
+          : JSCompiler_object_inline_componentStack_2557.push(current));
       workInProgress.child = renderLanes;
       workInProgress.memoizedState = null;
       return renderLanes;
@@ -9282,6 +9768,29 @@
       primaryChildren.return = workInProgress;
       return (workInProgress.child = primaryChildren);
     }
+    function mountSuspenseFallbackChildren(
+      workInProgress,
+      primaryChildren,
+      fallbackChildren,
+      renderLanes
+    ) {
+      var mode = workInProgress.mode;
+      primaryChildren = mountWorkInProgressOffscreenFiber(
+        { mode: "hidden", children: primaryChildren },
+        mode
+      );
+      fallbackChildren = createFiberFromFragment(
+        fallbackChildren,
+        mode,
+        renderLanes,
+        null
+      );
+      primaryChildren.return = workInProgress;
+      fallbackChildren.return = workInProgress;
+      primaryChildren.sibling = fallbackChildren;
+      workInProgress.child = primaryChildren;
+      return fallbackChildren;
+    }
     function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
       return createFiberFromOffscreen(offscreenProps, mode, 0, null);
     }
@@ -9682,6 +10191,8 @@
           workInProgress.mode,
           workInProgress.lanes
         );
+        renderLanes._debugStack = workInProgress._debugStack;
+        renderLanes._debugTask = workInProgress._debugTask;
         var returnFiber = workInProgress.return;
         if (null === returnFiber) throw Error("Cannot swap the root fiber.");
         current.alternate = null;
@@ -10008,21 +10519,28 @@
               (nextHydratableInstance = getNextHydratable(
                 prevSibling.firstChild
               ))),
-            reconcileChildren(
-              current,
-              workInProgress,
-              workInProgress.pendingProps.children,
-              renderLanes
-            ),
-            markRef(current, workInProgress),
-            null === current && (workInProgress.flags |= 4194304),
-            workInProgress.child
-          );
-        case 5:
-          return (
-            null === current &&
-              isHydrating &&
-              ((nextProps = getHostContext()),
+            (returnFiber = workInProgress.pendingProps.children),
+            null !== current || isHydrating
+              ? reconcileChildren(
+                  current,
+                  workInProgress,
+                  returnFiber,
+                  renderLanes
+                )
+              : (workInProgress.child = reconcileChildFibers(
+                  workInProgress,
+                  null,
+                  returnFiber,
+                  renderLanes
+                )),
+            markRef(current, workInProgress),
+            workInProgress.child
+          );
+        case 5:
+          return (
+            null === current &&
+              isHydrating &&
+              ((nextProps = getHostContext()),
               (returnFiber = validateDOMNesting(
                 workInProgress.type,
                 nextProps.ancestorInfo
@@ -10215,13 +10733,11 @@
               ),
             prepareToReadContext(workInProgress),
             (prevSibling = readContext(prevSibling)),
-            markComponentRenderStarted(workInProgress),
             (returnFiber = callComponentInDEV(
               returnFiber,
               prevSibling,
               void 0
             )),
-            markComponentRenderStopped(),
             (workInProgress.flags |= 1),
             reconcileChildren(
               current,
@@ -10309,6 +10825,39 @@
             ),
             workInProgress.child
           );
+        case 30:
+          return (
+            (returnFiber = workInProgress.pendingProps),
+            (prevSibling = workInProgress.stateNode),
+            null != returnFiber.name && "auto" !== returnFiber.name
+              ? ((workInProgress.flags |= 2097152),
+                null === current &&
+                  trackAppearingViewTransition(prevSibling, returnFiber.name))
+              : null === prevSibling.autoName &&
+                ((nextProps = workInProgressRoot.identifierPrefix),
+                isHydrating
+                  ? ((nextState = getTreeId()),
+                    (nextProps =
+                      "\u00ab" + nextProps + "T" + nextState + "\u00bb"))
+                  : ((nextState = globalClientIdCounter++),
+                    (nextProps =
+                      "\u00ab" +
+                      nextProps +
+                      "t" +
+                      nextState.toString(32) +
+                      "\u00bb")),
+                (prevSibling.autoName = nextProps)),
+            null !== current && current.memoizedProps.name !== returnFiber.name
+              ? (workInProgress.flags |= 4194816)
+              : markRef(current, workInProgress),
+            reconcileChildren(
+              current,
+              workInProgress,
+              returnFiber.children,
+              renderLanes
+            ),
+            workInProgress.child
+          );
         case 29:
           throw workInProgress.pendingProps;
       }
@@ -10357,21 +10906,7 @@
           do {
             if (
               (updateQueue.tag & flags) === flags &&
-              ((flags & Passive) !== NoFlags
-                ? null !== injectedProfilingHooks &&
-                  "function" ===
-                    typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted &&
-                  injectedProfilingHooks.markComponentPassiveEffectMountStarted(
-                    finishedWork
-                  )
-                : (flags & Layout) !== NoFlags &&
-                  null !== injectedProfilingHooks &&
-                  "function" ===
-                    typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted &&
-                  injectedProfilingHooks.markComponentLayoutEffectMountStarted(
-                    finishedWork
-                  ),
-              (lastEffect = void 0),
+              ((lastEffect = void 0),
               (flags & Insertion) !== NoFlags &&
                 (isRunningInsertionEffect = !0),
               (lastEffect = runWithFiberInDEV(
@@ -10381,16 +10916,6 @@
               )),
               (flags & Insertion) !== NoFlags &&
                 (isRunningInsertionEffect = !1),
-              (flags & Passive) !== NoFlags
-                ? null !== injectedProfilingHooks &&
-                  "function" ===
-                    typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped &&
-                  injectedProfilingHooks.markComponentPassiveEffectMountStopped()
-                : (flags & Layout) !== NoFlags &&
-                  null !== injectedProfilingHooks &&
-                  "function" ===
-                    typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped &&
-                  injectedProfilingHooks.markComponentLayoutEffectMountStopped(),
               void 0 !== lastEffect && "function" !== typeof lastEffect)
             ) {
               var hookName = void 0;
@@ -10448,20 +10973,6 @@
                 destroy = inst.destroy;
               void 0 !== destroy &&
                 ((inst.destroy = void 0),
-                (flags & Passive) !== NoFlags
-                  ? null !== injectedProfilingHooks &&
-                    "function" ===
-                      typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted &&
-                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
-                      finishedWork
-                    )
-                  : (flags & Layout) !== NoFlags &&
-                    null !== injectedProfilingHooks &&
-                    "function" ===
-                      typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted &&
-                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
-                      finishedWork
-                    ),
                 (flags & Insertion) !== NoFlags &&
                   (isRunningInsertionEffect = !0),
                 runWithFiberInDEV(
@@ -10472,17 +10983,7 @@
                   destroy
                 ),
                 (flags & Insertion) !== NoFlags &&
-                  (isRunningInsertionEffect = !1),
-                (flags & Passive) !== NoFlags
-                  ? null !== injectedProfilingHooks &&
-                    "function" ===
-                      typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped &&
-                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped()
-                  : (flags & Layout) !== NoFlags &&
-                    null !== injectedProfilingHooks &&
-                    "function" ===
-                      typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped &&
-                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
+                  (isRunningInsertionEffect = !1));
             }
             updateQueue = updateQueue.next;
           } while (updateQueue !== firstEffect);
@@ -10631,6 +11132,16 @@
           case 5:
             var instanceToUse = finishedWork.stateNode;
             break;
+          case 30:
+            instanceToUse = finishedWork.stateNode;
+            var name = getViewTransitionName(
+              finishedWork.memoizedProps,
+              instanceToUse
+            );
+            if (null === instanceToUse.ref || instanceToUse.ref.name !== name)
+              instanceToUse.ref = createViewTransitionInstance(name);
+            instanceToUse = instanceToUse.ref;
+            break;
           default:
             instanceToUse = finishedWork.stateNode;
         }
@@ -10780,7 +11291,7 @@
         5 === fiber.tag ||
         3 === fiber.tag ||
         26 === fiber.tag ||
-        (27 === fiber.tag && "head" === fiber.type) ||
+        27 === fiber.tag ||
         4 === fiber.tag
       );
     }
@@ -10793,10 +11304,12 @@
         fiber.sibling.return = fiber.return;
         for (
           fiber = fiber.sibling;
-          5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;
+          5 !== fiber.tag &&
+          6 !== fiber.tag &&
+          27 !== fiber.tag &&
+          18 !== fiber.tag;
 
         ) {
-          if (27 === fiber.tag && "head" === fiber.type) continue a;
           if (fiber.flags & 2) continue a;
           if (null === fiber.child || 4 === fiber.tag) continue a;
           else (fiber.child.return = fiber), (fiber = fiber.child);
@@ -10807,47 +11320,21 @@
     function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
       var tag = node.tag;
       if (5 === tag || 6 === tag)
-        if (((node = node.stateNode), before)) {
-          switch (parent.nodeType) {
-            case 8:
-              parent = parent.parentNode;
-              break;
-            case 9:
-              parent = parent.body;
-              break;
-            default:
-              parent =
-                "HTML" === parent.nodeName ? parent.ownerDocument.body : parent;
-          }
-          parent.insertBefore(node, before);
-        } else
-          a: {
-            switch (parent.nodeType) {
-              case 8:
-                before = parent.parentNode;
-                before.insertBefore(node, parent);
-                break a;
-              case 9:
-                before = parent.body;
-                break;
-              default:
-                before =
-                  "HTML" === parent.nodeName
-                    ? parent.ownerDocument.body
-                    : parent;
-            }
-            before.appendChild(node);
-            parent = parent._reactRootContainer;
-            (null !== parent && void 0 !== parent) ||
-              null !== before.onclick ||
-              (before.onclick = noop$2);
-          }
-      else if (
-        4 !== tag &&
-        (27 === tag && "head" === node.type && (parent = node.stateNode),
-        (node = node.child),
-        null !== node)
-      )
+        (node = node.stateNode),
+          before
+            ? 8 === parent.nodeType
+              ? parent.parentNode.insertBefore(node, before)
+              : parent.insertBefore(node, before)
+            : (8 === parent.nodeType
+                ? ((before = parent.parentNode),
+                  before.insertBefore(node, parent))
+                : ((before = parent), before.appendChild(node)),
+              (parent = parent._reactRootContainer),
+              (null !== parent && void 0 !== parent) ||
+                null !== before.onclick ||
+                (before.onclick = noop$2)),
+          (viewTransitionMutationContext = !0);
+      else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
         for (
           insertOrAppendPlacementNodeIntoContainer(node, before, parent),
             node = node.sibling;
@@ -10861,13 +11348,9 @@
       var tag = node.tag;
       if (5 === tag || 6 === tag)
         (node = node.stateNode),
-          before ? parent.insertBefore(node, before) : parent.appendChild(node);
-      else if (
-        4 !== tag &&
-        (27 === tag && "head" === node.type && (parent = node.stateNode),
-        (node = node.child),
-        null !== node)
-      )
+          before ? parent.insertBefore(node, before) : parent.appendChild(node),
+          (viewTransitionMutationContext = !0);
+      else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
         for (
           insertOrAppendPlacementNode(node, before, parent),
             node = node.sibling;
@@ -10878,64 +11361,55 @@
             (node = node.sibling);
     }
     function commitPlacement(finishedWork) {
-      a: {
-        for (var parent = finishedWork.return; null !== parent; ) {
-          if (isHostParent(parent)) {
-            var parentFiber = parent;
-            break a;
+      if (27 !== finishedWork.tag) {
+        a: {
+          for (var parent = finishedWork.return; null !== parent; ) {
+            if (isHostParent(parent)) {
+              var parentFiber = parent;
+              break a;
+            }
+            parent = parent.return;
           }
-          parent = parent.return;
-        }
-        throw Error(
-          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
-        );
-      }
-      switch (parentFiber.tag) {
-        case 27:
-          parent = parentFiber.stateNode;
-          parentFiber = getHostSibling(finishedWork);
-          insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
-          break;
-        case 5:
-          parent = parentFiber.stateNode;
-          parentFiber.flags & 32 &&
-            (resetTextContent(parent), (parentFiber.flags &= -33));
-          parentFiber = getHostSibling(finishedWork);
-          insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
-          break;
-        case 3:
-        case 4:
-          parent = parentFiber.stateNode.containerInfo;
-          parentFiber = getHostSibling(finishedWork);
-          insertOrAppendPlacementNodeIntoContainer(
-            finishedWork,
-            parentFiber,
-            parent
-          );
-          break;
-        default:
           throw Error(
-            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
+            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
           );
+        }
+        switch (parentFiber.tag) {
+          case 27:
+            parent = parentFiber.stateNode;
+            parentFiber = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
+            break;
+          case 5:
+            parent = parentFiber.stateNode;
+            parentFiber.flags & 32 &&
+              (resetTextContent(parent), (parentFiber.flags &= -33));
+            parentFiber = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
+            break;
+          case 3:
+          case 4:
+            parent = parentFiber.stateNode.containerInfo;
+            parentFiber = getHostSibling(finishedWork);
+            insertOrAppendPlacementNodeIntoContainer(
+              finishedWork,
+              parentFiber,
+              parent
+            );
+            break;
+          default:
+            throw Error(
+              "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
+            );
+        }
       }
     }
-    function commitHostSingletonAcquisition(finishedWork) {
-      var singleton = finishedWork.stateNode,
-        props = finishedWork.memoizedProps;
-      try {
-        runWithFiberInDEV(
-          finishedWork,
-          acquireSingletonInstance,
-          finishedWork.type,
-          props,
-          singleton,
-          finishedWork
-        );
-      } catch (error) {
-        captureCommitPhaseError(finishedWork, finishedWork.return, error);
-      }
-    }
-    function commitBeforeMutationEffects(root, firstChild) {
+    function commitBeforeMutationEffects(
+      root,
+      firstChild,
+      committedLanes,
+      appearingViewTransitions
+    ) {
       root = root.containerInfo;
       eventsEnabled = _enabled;
       root = getActiveElementDeep(root);
@@ -11008,73 +11482,583 @@
         focusedElem: root,
         selectionRange: JSCompiler_temp
       };
-      _enabled = !1;
-      for (nextEffect = firstChild; null !== nextEffect; )
+      shouldStartViewTransition = _enabled = !1;
+      committedLanes = (committedLanes & 335544192) === committedLanes;
+      nextEffect = firstChild;
+      for (firstChild = committedLanes ? 9238 : 1028; null !== nextEffect; ) {
+        root = nextEffect;
         if (
-          ((firstChild = nextEffect),
-          (root = firstChild.child),
-          0 !== (firstChild.subtreeFlags & 1024) && null !== root)
+          committedLanes &&
+          ((JSCompiler_temp = root.deletions), null !== JSCompiler_temp)
         )
-          (root.return = firstChild), (nextEffect = root);
-        else
-          for (; null !== nextEffect; ) {
-            root = firstChild = nextEffect;
-            JSCompiler_temp = root.alternate;
-            anchorOffset = root.flags;
-            switch (root.tag) {
-              case 0:
-                break;
-              case 11:
-              case 15:
-                break;
-              case 1:
-                0 !== (anchorOffset & 1024) &&
-                  null !== JSCompiler_temp &&
-                  commitClassSnapshot(root, JSCompiler_temp);
-                break;
-              case 3:
-                if (0 !== (anchorOffset & 1024))
-                  if (
-                    ((root = root.stateNode.containerInfo),
-                    (JSCompiler_temp = root.nodeType),
-                    9 === JSCompiler_temp)
-                  )
-                    clearContainerSparingly(root);
-                  else if (1 === JSCompiler_temp)
-                    switch (root.nodeName) {
-                      case "HEAD":
-                      case "HTML":
-                      case "BODY":
-                        clearContainerSparingly(root);
-                        break;
-                      default:
-                        root.textContent = "";
-                    }
-                break;
-              case 5:
-              case 26:
-              case 27:
-              case 6:
-              case 4:
-              case 17:
-                break;
-              default:
-                if (0 !== (anchorOffset & 1024))
-                  throw Error(
-                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
+          for (
+            anchorOffset = 0;
+            anchorOffset < JSCompiler_temp.length;
+            anchorOffset++
+          )
+            committedLanes &&
+              commitExitViewTransitions(
+                JSCompiler_temp[anchorOffset],
+                appearingViewTransitions
+              );
+        if (null === root.alternate && 0 !== (root.flags & 2))
+          commitBeforeMutationEffects_complete(committedLanes);
+        else {
+          if (22 === root.tag)
+            if (
+              ((JSCompiler_temp = root.alternate), null !== root.memoizedState)
+            ) {
+              null !== JSCompiler_temp &&
+                null === JSCompiler_temp.memoizedState &&
+                committedLanes &&
+                commitExitViewTransitions(
+                  JSCompiler_temp,
+                  appearingViewTransitions
+                );
+              commitBeforeMutationEffects_complete(committedLanes);
+              continue;
+            } else if (
+              null !== JSCompiler_temp &&
+              null !== JSCompiler_temp.memoizedState
+            ) {
+              commitBeforeMutationEffects_complete(committedLanes);
+              continue;
+            }
+          JSCompiler_temp = root.child;
+          0 !== (root.subtreeFlags & firstChild) && null !== JSCompiler_temp
+            ? ((JSCompiler_temp.return = root), (nextEffect = JSCompiler_temp))
+            : (committedLanes && commitNestedViewTransitions(root),
+              commitBeforeMutationEffects_complete(committedLanes));
+        }
+      }
+    }
+    function commitBeforeMutationEffects_complete(
+      isViewTransitionEligible$jscomp$0
+    ) {
+      for (; null !== nextEffect; ) {
+        var fiber = nextEffect,
+          finishedWork = fiber,
+          isViewTransitionEligible = isViewTransitionEligible$jscomp$0,
+          current = finishedWork.alternate,
+          flags = finishedWork.flags;
+        switch (finishedWork.tag) {
+          case 0:
+            if (
+              0 !== (flags & 4) &&
+              ((isViewTransitionEligible = finishedWork.updateQueue),
+              (isViewTransitionEligible =
+                null !== isViewTransitionEligible
+                  ? isViewTransitionEligible.events
+                  : null),
+              null !== isViewTransitionEligible)
+            )
+              for (
+                finishedWork = 0;
+                finishedWork < isViewTransitionEligible.length;
+                finishedWork++
+              )
+                (current = isViewTransitionEligible[finishedWork]),
+                  (current.ref.impl = current.nextImpl);
+            break;
+          case 11:
+          case 15:
+            break;
+          case 1:
+            0 !== (flags & 1024) &&
+              null !== current &&
+              commitClassSnapshot(finishedWork, current);
+            break;
+          case 3:
+            if (0 !== (flags & 1024))
+              if (
+                ((isViewTransitionEligible =
+                  finishedWork.stateNode.containerInfo),
+                (finishedWork = isViewTransitionEligible.nodeType),
+                9 === finishedWork)
+              )
+                clearContainerSparingly(isViewTransitionEligible);
+              else if (1 === finishedWork)
+                switch (isViewTransitionEligible.nodeName) {
+                  case "HEAD":
+                  case "HTML":
+                  case "BODY":
+                    clearContainerSparingly(isViewTransitionEligible);
+                    break;
+                  default:
+                    isViewTransitionEligible.textContent = "";
+                }
+            break;
+          case 5:
+          case 26:
+          case 27:
+          case 6:
+          case 4:
+          case 17:
+            break;
+          case 30:
+            if (
+              isViewTransitionEligible &&
+              null !== current &&
+              0 !== (finishedWork.subtreeFlags & 8246)
+            )
+              a: {
+                isViewTransitionEligible = current;
+                current = finishedWork;
+                finishedWork = getViewTransitionName(
+                  isViewTransitionEligible.memoizedProps,
+                  isViewTransitionEligible.stateNode
+                );
+                current = current.memoizedProps;
+                flags = getViewTransitionClassName(
+                  current.className,
+                  current.update
+                );
+                if (
+                  "none" === flags &&
+                  ((flags = getViewTransitionClassName(
+                    current.className,
+                    current.layout
+                  )),
+                  "none" === flags)
+                )
+                  break a;
+                viewTransitionHostInstanceIdx = 0;
+                applyViewTransitionToHostInstances(
+                  isViewTransitionEligible.child,
+                  finishedWork,
+                  flags,
+                  (isViewTransitionEligible.memoizedState = []),
+                  !0
+                );
+              }
+            break;
+          default:
+            if (0 !== (flags & 1024))
+              throw Error(
+                "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
+              );
+        }
+        isViewTransitionEligible = fiber.sibling;
+        if (null !== isViewTransitionEligible) {
+          isViewTransitionEligible.return = fiber.return;
+          nextEffect = isViewTransitionEligible;
+          break;
+        }
+        nextEffect = fiber.return;
+      }
+    }
+    function applyViewTransitionToHostInstances(
+      child,
+      name,
+      className,
+      collectMeasurements,
+      stopAtNestedViewTransitions
+    ) {
+      for (var inViewport = !1; null !== child; ) {
+        if (5 === child.tag) {
+          shouldStartViewTransition = !0;
+          var instance = child.stateNode;
+          if (null !== collectMeasurements) {
+            var measurement = measureInstance(instance);
+            collectMeasurements.push(measurement);
+            measurement.view && (inViewport = !0);
+          } else
+            inViewport || (measureInstance(instance).view && (inViewport = !0));
+          measurement = className;
+          instance.style.viewTransitionName =
+            0 === viewTransitionHostInstanceIdx
+              ? name
+              : name + "_" + viewTransitionHostInstanceIdx;
+          null != measurement &&
+            (instance.style.viewTransitionClass = measurement);
+          viewTransitionHostInstanceIdx++;
+        } else if (22 !== child.tag || null === child.memoizedState)
+          (30 === child.tag && stopAtNestedViewTransitions) ||
+            (applyViewTransitionToHostInstances(
+              child.child,
+              name,
+              className,
+              collectMeasurements,
+              stopAtNestedViewTransitions
+            ) &&
+              (inViewport = !0));
+        child = child.sibling;
+      }
+      return inViewport;
+    }
+    function restoreViewTransitionOnHostInstances(
+      child,
+      stopAtNestedViewTransitions
+    ) {
+      for (; null !== child; ) {
+        if (5 === child.tag)
+          restoreViewTransitionName(child.stateNode, child.memoizedProps);
+        else if (22 !== child.tag || null === child.memoizedState)
+          (30 === child.tag && stopAtNestedViewTransitions) ||
+            restoreViewTransitionOnHostInstances(
+              child.child,
+              stopAtNestedViewTransitions
+            );
+        child = child.sibling;
+      }
+    }
+    function commitAppearingPairViewTransitions(placement) {
+      if (0 !== (placement.subtreeFlags & 2097152))
+        for (placement = placement.child; null !== placement; ) {
+          if (22 !== placement.tag || null !== placement.memoizedState)
+            if (
+              (commitAppearingPairViewTransitions(placement),
+              30 === placement.tag &&
+                0 !== (placement.flags & 2097152) &&
+                placement.stateNode.paired)
+            ) {
+              var props = placement.memoizedProps;
+              if (null == props.name || "auto" === props.name)
+                throw Error(
+                  "Found a pair with an auto name. This is a bug in React."
+                );
+              var name = props.name;
+              props = getViewTransitionClassName(props.className, props.share);
+              "none" !== props &&
+                ((viewTransitionHostInstanceIdx = 0),
+                applyViewTransitionToHostInstances(
+                  placement.child,
+                  name,
+                  props,
+                  null,
+                  !1
+                ) || restoreViewTransitionOnHostInstances(placement.child, !1));
+            }
+          placement = placement.sibling;
+        }
+    }
+    function commitEnterViewTransitions(placement) {
+      if (30 === placement.tag) {
+        var state = placement.stateNode,
+          props = placement.memoizedProps,
+          name = getViewTransitionName(props, state),
+          className = getViewTransitionClassName(
+            props.className,
+            state.paired ? props.share : props.enter
+          );
+        "none" !== className
+          ? ((viewTransitionHostInstanceIdx = 0),
+            applyViewTransitionToHostInstances(
+              placement.child,
+              name,
+              className,
+              null,
+              !1
+            )
+              ? (commitAppearingPairViewTransitions(placement),
+                state.paired ||
+                  scheduleViewTransitionEvent(placement, props.onEnter))
+              : restoreViewTransitionOnHostInstances(placement.child, !1))
+          : commitAppearingPairViewTransitions(placement);
+      } else if (0 !== (placement.subtreeFlags & 33554432))
+        for (placement = placement.child; null !== placement; )
+          commitEnterViewTransitions(placement),
+            (placement = placement.sibling);
+      else commitAppearingPairViewTransitions(placement);
+    }
+    function commitDeletedPairViewTransitions(
+      deletion,
+      appearingViewTransitions
+    ) {
+      if (
+        0 !== appearingViewTransitions.size &&
+        0 !== (deletion.subtreeFlags & 2097152)
+      )
+        for (deletion = deletion.child; null !== deletion; ) {
+          if (22 !== deletion.tag || null !== deletion.memoizedState) {
+            if (30 === deletion.tag && 0 !== (deletion.flags & 2097152)) {
+              var props = deletion.memoizedProps,
+                name = props.name;
+              if (null != name && "auto" !== name) {
+                var pair = appearingViewTransitions.get(name);
+                if (void 0 !== pair) {
+                  var className = getViewTransitionClassName(
+                    props.className,
+                    props.share
                   );
+                  "none" !== className &&
+                    ((viewTransitionHostInstanceIdx = 0),
+                    applyViewTransitionToHostInstances(
+                      deletion.child,
+                      name,
+                      className,
+                      null,
+                      !1
+                    )
+                      ? ((pair.paired = deletion.stateNode),
+                        scheduleViewTransitionEvent(deletion, props.onShare))
+                      : restoreViewTransitionOnHostInstances(
+                          deletion.child,
+                          !1
+                        ));
+                  appearingViewTransitions.delete(name);
+                  if (0 === appearingViewTransitions.size) break;
+                }
+              }
             }
-            root = firstChild.sibling;
-            if (null !== root) {
-              root.return = firstChild.return;
-              nextEffect = root;
-              break;
+            commitDeletedPairViewTransitions(
+              deletion,
+              appearingViewTransitions
+            );
+          }
+          deletion = deletion.sibling;
+        }
+    }
+    function commitExitViewTransitions(deletion, appearingViewTransitions) {
+      if (30 === deletion.tag) {
+        var props = deletion.memoizedProps,
+          name = getViewTransitionName(props, deletion.stateNode),
+          pair =
+            null !== appearingViewTransitions
+              ? appearingViewTransitions.get(name)
+              : void 0,
+          className = getViewTransitionClassName(
+            props.className,
+            void 0 !== pair ? props.share : props.exit
+          );
+        "none" !== className &&
+          ((viewTransitionHostInstanceIdx = 0),
+          applyViewTransitionToHostInstances(
+            deletion.child,
+            name,
+            className,
+            null,
+            !1
+          )
+            ? void 0 !== pair
+              ? ((pair.paired = deletion.stateNode),
+                appearingViewTransitions.delete(name),
+                scheduleViewTransitionEvent(deletion, props.onShare))
+              : scheduleViewTransitionEvent(deletion, props.onExit)
+            : restoreViewTransitionOnHostInstances(deletion.child, !1));
+        null !== appearingViewTransitions &&
+          commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+      } else if (0 !== (deletion.subtreeFlags & 33554432))
+        for (deletion = deletion.child; null !== deletion; )
+          commitExitViewTransitions(deletion, appearingViewTransitions),
+            (deletion = deletion.sibling);
+      else
+        null !== appearingViewTransitions &&
+          commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+    }
+    function commitNestedViewTransitions(changedParent) {
+      for (changedParent = changedParent.child; null !== changedParent; ) {
+        if (30 === changedParent.tag) {
+          var props = changedParent.memoizedProps,
+            name = getViewTransitionName(props, changedParent.stateNode);
+          props = getViewTransitionClassName(props.className, props.layout);
+          "none" !== props &&
+            ((viewTransitionHostInstanceIdx = 0),
+            applyViewTransitionToHostInstances(
+              changedParent.child,
+              name,
+              props,
+              (changedParent.memoizedState = []),
+              !1
+            ));
+        } else
+          0 !== (changedParent.subtreeFlags & 33554432) &&
+            commitNestedViewTransitions(changedParent);
+        changedParent = changedParent.sibling;
+      }
+    }
+    function restorePairedViewTransitions(parent) {
+      if (0 !== (parent.subtreeFlags & 2097152))
+        for (parent = parent.child; null !== parent; ) {
+          if (22 !== parent.tag || null !== parent.memoizedState) {
+            if (30 === parent.tag && 0 !== (parent.flags & 2097152)) {
+              var instance = parent.stateNode;
+              null !== instance.paired &&
+                ((instance.paired = null),
+                restoreViewTransitionOnHostInstances(parent.child, !1));
             }
-            nextEffect = firstChild.return;
+            restorePairedViewTransitions(parent);
           }
+          parent = parent.sibling;
+        }
+    }
+    function restoreEnterViewTransitions(placement) {
+      if (30 === placement.tag)
+        (placement.stateNode.paired = null),
+          restoreViewTransitionOnHostInstances(placement.child, !1),
+          restorePairedViewTransitions(placement);
+      else if (0 !== (placement.subtreeFlags & 33554432))
+        for (placement = placement.child; null !== placement; )
+          restoreEnterViewTransitions(placement),
+            (placement = placement.sibling);
+      else restorePairedViewTransitions(placement);
+    }
+    function restoreExitViewTransitions(deletion) {
+      if (30 === deletion.tag)
+        (deletion.stateNode.paired = null),
+          restoreViewTransitionOnHostInstances(deletion.child, !1),
+          restorePairedViewTransitions(deletion);
+      else if (0 !== (deletion.subtreeFlags & 33554432))
+        for (deletion = deletion.child; null !== deletion; )
+          restoreExitViewTransitions(deletion), (deletion = deletion.sibling);
+      else restorePairedViewTransitions(deletion);
+    }
+    function restoreNestedViewTransitions(changedParent) {
+      for (changedParent = changedParent.child; null !== changedParent; )
+        30 === changedParent.tag
+          ? ((changedParent.memoizedState = null),
+            restoreViewTransitionOnHostInstances(changedParent.child, !1))
+          : 0 !== (changedParent.subtreeFlags & 33554432) &&
+            restoreNestedViewTransitions(changedParent),
+          (changedParent = changedParent.sibling);
+    }
+    function cancelViewTransitionHostInstances(
+      currentViewTransition,
+      child,
+      stopAtNestedViewTransitions
+    ) {
+      for (; null !== child; ) {
+        if (5 === child.tag) {
+          var instance = child.stateNode,
+            oldName = getViewTransitionName(
+              currentViewTransition.memoizedProps,
+              currentViewTransition.stateNode
+            );
+          null === viewTransitionCancelableChildren &&
+            (viewTransitionCancelableChildren = []);
+          viewTransitionCancelableChildren.push(
+            instance,
+            oldName,
+            child.memoizedProps
+          );
+          viewTransitionHostInstanceIdx++;
+        } else if (22 !== child.tag || null === child.memoizedState)
+          (30 === child.tag && stopAtNestedViewTransitions) ||
+            cancelViewTransitionHostInstances(
+              currentViewTransition,
+              child.child,
+              stopAtNestedViewTransitions
+            );
+        child = child.sibling;
+      }
+    }
+    function measureViewTransitionHostInstances(
+      currentViewTransition,
+      parentViewTransition,
+      child,
+      name,
+      className,
+      previousMeasurements,
+      stopAtNestedViewTransitions
+    ) {
+      for (var inViewport = !1; null !== child; ) {
+        if (5 === child.tag) {
+          var instance = child.stateNode;
+          if (
+            null !== previousMeasurements &&
+            viewTransitionHostInstanceIdx < previousMeasurements.length
+          ) {
+            var previousMeasurement =
+                previousMeasurements[viewTransitionHostInstanceIdx],
+              nextMeasurement = measureInstance(instance);
+            if (previousMeasurement.view || nextMeasurement.view)
+              inViewport = !0;
+            var JSCompiler_temp;
+            if ((JSCompiler_temp = 0 === (parentViewTransition.flags & 4)))
+              if (nextMeasurement.clip) JSCompiler_temp = !0;
+              else {
+                JSCompiler_temp = previousMeasurement.rect;
+                var newRect = nextMeasurement.rect;
+                JSCompiler_temp =
+                  JSCompiler_temp.y !== newRect.y ||
+                  JSCompiler_temp.x !== newRect.x ||
+                  JSCompiler_temp.height !== newRect.height ||
+                  JSCompiler_temp.width !== newRect.width;
+              }
+            JSCompiler_temp && (parentViewTransition.flags |= 4);
+            nextMeasurement.abs
+              ? (nextMeasurement = !previousMeasurement.abs)
+              : ((previousMeasurement = previousMeasurement.rect),
+                (nextMeasurement = nextMeasurement.rect),
+                (nextMeasurement =
+                  previousMeasurement.height !== nextMeasurement.height ||
+                  previousMeasurement.width !== nextMeasurement.width));
+            nextMeasurement && (parentViewTransition.flags |= 32);
+          } else parentViewTransition.flags |= 32;
+          0 !== (parentViewTransition.flags & 4) &&
+            ((nextMeasurement = instance),
+            (previousMeasurement = className),
+            (nextMeasurement.style.viewTransitionName =
+              0 === viewTransitionHostInstanceIdx
+                ? name
+                : name + "_" + viewTransitionHostInstanceIdx),
+            null != previousMeasurement &&
+              (nextMeasurement.style.viewTransitionClass =
+                previousMeasurement));
+          (inViewport && 0 !== (parentViewTransition.flags & 4)) ||
+            ((nextMeasurement = getViewTransitionName(
+              currentViewTransition.memoizedProps,
+              currentViewTransition.stateNode
+            )),
+            null === viewTransitionCancelableChildren &&
+              (viewTransitionCancelableChildren = []),
+            viewTransitionCancelableChildren.push(
+              instance,
+              nextMeasurement,
+              child.memoizedProps
+            ));
+          viewTransitionHostInstanceIdx++;
+        } else if (22 !== child.tag || null === child.memoizedState)
+          30 === child.tag && stopAtNestedViewTransitions
+            ? (parentViewTransition.flags |= child.flags & 32)
+            : measureViewTransitionHostInstances(
+                currentViewTransition,
+                parentViewTransition,
+                child.child,
+                name,
+                className,
+                previousMeasurements,
+                stopAtNestedViewTransitions
+              ) && (inViewport = !0);
+        child = child.sibling;
+      }
+      return inViewport;
+    }
+    function measureNestedViewTransitions(changedParent) {
+      for (changedParent = changedParent.child; null !== changedParent; ) {
+        if (30 === changedParent.tag) {
+          var current = changedParent.alternate;
+          if (null !== current) {
+            var props = changedParent.memoizedProps,
+              name = getViewTransitionName(props, changedParent.stateNode),
+              className = getViewTransitionClassName(
+                props.className,
+                props.layout
+              );
+            viewTransitionHostInstanceIdx = 0;
+            current = measureViewTransitionHostInstances(
+              current,
+              changedParent,
+              changedParent.child,
+              name,
+              className,
+              changedParent.memoizedState,
+              !1
+            );
+            0 !== (changedParent.flags & 4) &&
+              current &&
+              scheduleViewTransitionEvent(changedParent, props.onLayout);
+          }
+        } else
+          0 !== (changedParent.subtreeFlags & 33554432) &&
+            measureNestedViewTransitions(changedParent);
+        changedParent = changedParent.sibling;
+      }
     }
     function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
-      var flags = finishedWork.flags;
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors(),
+        flags = finishedWork.flags;
       switch (finishedWork.tag) {
         case 0:
         case 11:
@@ -11189,11 +12173,11 @@
           }
           finishedRoot.effectDuration += popNestedEffectDurations(current);
           break;
-        case 27:
-          null === current &&
-            flags & 4 &&
-            commitHostSingletonAcquisition(finishedWork);
         case 26:
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+          break;
+        case 27:
         case 5:
           recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
           null === current && flags & 4 && commitHostMount(finishedWork);
@@ -11228,11 +12212,11 @@
             null !== finishedRoot &&
               ((finishedRoot = finishedRoot.dehydrated),
               null !== finishedRoot &&
-                ((finishedWork = retryDehydratedSuspenseBoundary.bind(
+                ((flags = retryDehydratedSuspenseBoundary.bind(
                   null,
                   finishedWork
                 )),
-                registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
+                registerSuspenseInstanceRetry(finishedRoot, flags))));
           break;
         case 22:
           prevProps =
@@ -11260,9 +12244,26 @@
               ? safelyAttachRef(finishedWork, finishedWork.return)
               : safelyDetachRef(finishedWork, finishedWork.return));
           break;
+        case 30:
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+          break;
         default:
           recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function detachFiberAfterEffects(fiber) {
       var alternate = fiber.alternate;
@@ -11336,19 +12337,16 @@
             safelyDetachRef(deletedFiber, nearestMountedAncestor);
           var prevHostParent = hostParent,
             prevHostParentIsContainer = hostParentIsContainer;
-          "head" === deletedFiber.type &&
-            ((hostParent = deletedFiber.stateNode),
-            (hostParentIsContainer = !1));
+          hostParent = deletedFiber.stateNode;
           recursivelyTraverseDeletionEffects(
             finishedRoot,
             nearestMountedAncestor,
             deletedFiber
           );
-          runWithFiberInDEV(
-            deletedFiber,
-            releaseSingletonInstance,
-            deletedFiber.stateNode
-          );
+          deletedFiber = deletedFiber.stateNode;
+          for (finishedRoot = deletedFiber.attributes; finishedRoot.length; )
+            deletedFiber.removeAttributeNode(finishedRoot[0]);
+          detachDeletedInstance(deletedFiber);
           hostParent = prevHostParent;
           hostParentIsContainer = prevHostParentIsContainer;
           break;
@@ -11374,7 +12372,8 @@
                   removeChildFromContainer,
                   hostParent,
                   deletedFiber.stateNode
-                );
+                ),
+                  (viewTransitionMutationContext = !0);
               } catch (error) {
                 captureCommitPhaseError(
                   deletedFiber,
@@ -11389,7 +12388,8 @@
                   removeChild,
                   hostParent,
                   deletedFiber.stateNode
-                );
+                ),
+                  (viewTransitionMutationContext = !0);
               } catch (error) {
                 captureCommitPhaseError(
                   deletedFiber,
@@ -11405,14 +12405,8 @@
                 (deletedFiber = deletedFiber.stateNode),
                 8 === finishedRoot.nodeType
                   ? clearSuspenseBoundary(finishedRoot.parentNode, deletedFiber)
-                  : 9 === finishedRoot.nodeType
-                    ? clearSuspenseBoundary(finishedRoot.body, deletedFiber)
-                    : "HTML" === finishedRoot.nodeName
-                      ? clearSuspenseBoundary(
-                          finishedRoot.ownerDocument.body,
-                          deletedFiber
-                        )
-                      : clearSuspenseBoundary(finishedRoot, deletedFiber),
+                  : 1 === finishedRoot.nodeType &&
+                    clearSuspenseBoundary(finishedRoot, deletedFiber),
                 retryIfBlockedOn(finishedRoot))
               : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
           break;
@@ -11555,7 +12549,11 @@
         }
       });
     }
-    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
+    function recursivelyTraverseMutationEffects(
+      root$jscomp$0,
+      parentFiber,
+      lanes
+    ) {
       var deletions = parentFiber.deletions;
       if (null !== deletions)
         for (var i = 0; i < deletions.length; i++) {
@@ -11566,12 +12564,6 @@
           a: for (; null !== parent; ) {
             switch (parent.tag) {
               case 27:
-                if ("head" === parent.type) {
-                  hostParent = parent.stateNode;
-                  hostParentIsContainer = !1;
-                  break a;
-                }
-                break;
               case 5:
                 hostParent = parent.stateNode;
                 hostParentIsContainer = !1;
@@ -11601,18 +12593,20 @@
         }
       if (parentFiber.subtreeFlags & 13878)
         for (parentFiber = parentFiber.child; null !== parentFiber; )
-          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
+          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0, lanes),
             (parentFiber = parentFiber.sibling);
     }
-    function commitMutationEffectsOnFiber(finishedWork, root) {
-      var current = finishedWork.alternate,
+    function commitMutationEffectsOnFiber(finishedWork, root, lanes) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors(),
+        current = finishedWork.alternate,
         flags = finishedWork.flags;
       switch (finishedWork.tag) {
         case 0:
         case 11:
         case 14:
         case 15:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           flags & 4 &&
             (commitHookEffectListUnmount(
@@ -11628,7 +12622,7 @@
             ));
           break;
         case 1:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           flags & 512 &&
             (offscreenSubtreeWasHidden ||
@@ -11636,17 +12630,17 @@
               safelyDetachRef(current, current.return));
           flags & 64 &&
             offscreenSubtreeIsHidden &&
-            ((finishedWork = finishedWork.updateQueue),
-            null !== finishedWork &&
-              ((flags = finishedWork.callbacks),
+            ((current = finishedWork.updateQueue),
+            null !== current &&
+              ((flags = current.callbacks),
               null !== flags &&
-                ((current = finishedWork.shared.hiddenCallbacks),
-                (finishedWork.shared.hiddenCallbacks =
-                  null === current ? flags : current.concat(flags)))));
+                ((root = current.shared.hiddenCallbacks),
+                (current.shared.hiddenCallbacks =
+                  null === root ? flags : root.concat(flags)))));
           break;
         case 26:
           var hoistableRoot = currentHoistableRoot;
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           flags & 512 &&
             (offscreenSubtreeWasHidden ||
@@ -11661,116 +12655,113 @@
               if (null === flags)
                 if (null === finishedWork.stateNode) {
                   a: {
-                    flags = finishedWork.type;
-                    current = finishedWork.memoizedProps;
+                    current = finishedWork.type;
+                    flags = finishedWork.memoizedProps;
                     root = hoistableRoot.ownerDocument || hoistableRoot;
-                    b: switch (flags) {
+                    b: switch (current) {
                       case "title":
-                        hoistableRoot = root.getElementsByTagName("title")[0];
+                        lanes = root.getElementsByTagName("title")[0];
                         if (
-                          !hoistableRoot ||
-                          hoistableRoot[internalHoistableMarker] ||
-                          hoistableRoot[internalInstanceKey] ||
-                          hoistableRoot.namespaceURI === SVG_NAMESPACE ||
-                          hoistableRoot.hasAttribute("itemprop")
+                          !lanes ||
+                          lanes[internalHoistableMarker] ||
+                          lanes[internalInstanceKey] ||
+                          lanes.namespaceURI === SVG_NAMESPACE ||
+                          lanes.hasAttribute("itemprop")
                         )
-                          (hoistableRoot = root.createElement(flags)),
+                          (lanes = root.createElement(current)),
                             root.head.insertBefore(
-                              hoistableRoot,
+                              lanes,
                               root.querySelector("head > title")
                             );
-                        setInitialProperties(hoistableRoot, flags, current);
-                        hoistableRoot[internalInstanceKey] = finishedWork;
-                        markNodeAsHoistable(hoistableRoot);
-                        flags = hoistableRoot;
+                        setInitialProperties(lanes, current, flags);
+                        lanes[internalInstanceKey] = finishedWork;
+                        markNodeAsHoistable(lanes);
+                        current = lanes;
                         break a;
                       case "link":
-                        var maybeNodes = getHydratableHoistableCache(
-                          "link",
-                          "href",
-                          root
-                        ).get(flags + (current.href || ""));
-                        if (maybeNodes)
-                          for (var i = 0; i < maybeNodes.length; i++)
+                        if (
+                          (hoistableRoot = getHydratableHoistableCache(
+                            "link",
+                            "href",
+                            root
+                          ).get(current + (flags.href || "")))
+                        )
+                          for (var i = 0; i < hoistableRoot.length; i++)
                             if (
-                              ((hoistableRoot = maybeNodes[i]),
-                              hoistableRoot.getAttribute("href") ===
-                                (null == current.href || "" === current.href
+                              ((lanes = hoistableRoot[i]),
+                              lanes.getAttribute("href") ===
+                                (null == flags.href || "" === flags.href
                                   ? null
-                                  : current.href) &&
-                                hoistableRoot.getAttribute("rel") ===
-                                  (null == current.rel ? null : current.rel) &&
-                                hoistableRoot.getAttribute("title") ===
-                                  (null == current.title
+                                  : flags.href) &&
+                                lanes.getAttribute("rel") ===
+                                  (null == flags.rel ? null : flags.rel) &&
+                                lanes.getAttribute("title") ===
+                                  (null == flags.title ? null : flags.title) &&
+                                lanes.getAttribute("crossorigin") ===
+                                  (null == flags.crossOrigin
                                     ? null
-                                    : current.title) &&
-                                hoistableRoot.getAttribute("crossorigin") ===
-                                  (null == current.crossOrigin
-                                    ? null
-                                    : current.crossOrigin))
+                                    : flags.crossOrigin))
                             ) {
-                              maybeNodes.splice(i, 1);
+                              hoistableRoot.splice(i, 1);
                               break b;
                             }
-                        hoistableRoot = root.createElement(flags);
-                        setInitialProperties(hoistableRoot, flags, current);
-                        root.head.appendChild(hoistableRoot);
+                        lanes = root.createElement(current);
+                        setInitialProperties(lanes, current, flags);
+                        root.head.appendChild(lanes);
                         break;
                       case "meta":
                         if (
-                          (maybeNodes = getHydratableHoistableCache(
+                          (hoistableRoot = getHydratableHoistableCache(
                             "meta",
                             "content",
                             root
-                          ).get(flags + (current.content || "")))
+                          ).get(current + (flags.content || "")))
                         )
-                          for (i = 0; i < maybeNodes.length; i++)
+                          for (i = 0; i < hoistableRoot.length; i++)
                             if (
-                              ((hoistableRoot = maybeNodes[i]),
+                              ((lanes = hoistableRoot[i]),
                               checkAttributeStringCoercion(
-                                current.content,
+                                flags.content,
                                 "content"
                               ),
-                              hoistableRoot.getAttribute("content") ===
-                                (null == current.content
+                              lanes.getAttribute("content") ===
+                                (null == flags.content
                                   ? null
-                                  : "" + current.content) &&
-                                hoistableRoot.getAttribute("name") ===
-                                  (null == current.name
-                                    ? null
-                                    : current.name) &&
-                                hoistableRoot.getAttribute("property") ===
-                                  (null == current.property
+                                  : "" + flags.content) &&
+                                lanes.getAttribute("name") ===
+                                  (null == flags.name ? null : flags.name) &&
+                                lanes.getAttribute("property") ===
+                                  (null == flags.property
                                     ? null
-                                    : current.property) &&
-                                hoistableRoot.getAttribute("http-equiv") ===
-                                  (null == current.httpEquiv
+                                    : flags.property) &&
+                                lanes.getAttribute("http-equiv") ===
+                                  (null == flags.httpEquiv
                                     ? null
-                                    : current.httpEquiv) &&
-                                hoistableRoot.getAttribute("charset") ===
-                                  (null == current.charSet
+                                    : flags.httpEquiv) &&
+                                lanes.getAttribute("charset") ===
+                                  (null == flags.charSet
                                     ? null
-                                    : current.charSet))
+                                    : flags.charSet))
                             ) {
-                              maybeNodes.splice(i, 1);
+                              hoistableRoot.splice(i, 1);
                               break b;
                             }
-                        hoistableRoot = root.createElement(flags);
-                        setInitialProperties(hoistableRoot, flags, current);
-                        root.head.appendChild(hoistableRoot);
+                        lanes = root.createElement(current);
+                        setInitialProperties(lanes, current, flags);
+                        root.head.appendChild(lanes);
                         break;
                       default:
                         throw Error(
                           'getNodesForType encountered a type it did not expect: "' +
-                            flags +
+                            current +
                             '". This is a bug in React.'
                         );
                     }
-                    hoistableRoot[internalInstanceKey] = finishedWork;
-                    markNodeAsHoistable(hoistableRoot);
-                    flags = hoistableRoot;
+                    lanes[internalInstanceKey] = finishedWork;
+                    markNodeAsHoistable(lanes);
+                    current = lanes;
                   }
-                  finishedWork.stateNode = flags;
+                  finishedWork.stateNode = current;
                 } else
                   mountHoistable(
                     hoistableRoot,
@@ -11810,22 +12801,37 @@
                   );
           break;
         case 27:
-          recursivelyTraverseMutationEffects(root, finishedWork);
-          commitReconciliationEffects(finishedWork);
-          flags & 512 &&
-            (offscreenSubtreeWasHidden ||
-              null === current ||
-              safelyDetachRef(current, current.return));
-          null !== current &&
-            flags & 4 &&
-            commitHostUpdate(
-              finishedWork,
-              finishedWork.memoizedProps,
-              current.memoizedProps
-            );
-          break;
+          if (flags & 4 && null === finishedWork.alternate) {
+            hoistableRoot = finishedWork.stateNode;
+            i = finishedWork.memoizedProps;
+            try {
+              for (var node = hoistableRoot.firstChild; node; ) {
+                var nextNode = node.nextSibling,
+                  nodeName = node.nodeName;
+                node[internalHoistableMarker] ||
+                  "HEAD" === nodeName ||
+                  "BODY" === nodeName ||
+                  "SCRIPT" === nodeName ||
+                  "STYLE" === nodeName ||
+                  ("LINK" === nodeName &&
+                    "stylesheet" === node.rel.toLowerCase()) ||
+                  hoistableRoot.removeChild(node);
+                node = nextNode;
+              }
+              runWithFiberInDEV(
+                finishedWork,
+                acquireSingletonInstance,
+                finishedWork.type,
+                i,
+                hoistableRoot,
+                finishedWork
+              );
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+          }
         case 5:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           flags & 512 &&
             (offscreenSubtreeWasHidden ||
@@ -11834,7 +12840,8 @@
           if (finishedWork.flags & 32) {
             root = finishedWork.stateNode;
             try {
-              runWithFiberInDEV(finishedWork, resetTextContent, root);
+              runWithFiberInDEV(finishedWork, resetTextContent, root),
+                (viewTransitionMutationContext = !0);
             } catch (error) {
               captureCommitPhaseError(finishedWork, finishedWork.return, error);
             }
@@ -11855,7 +12862,7 @@
               ));
           break;
         case 6:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           if (flags & 4) {
             if (null === finishedWork.stateNode)
@@ -11872,7 +12879,8 @@
                 root,
                 current,
                 flags
-              );
+              ),
+                (viewTransitionMutationContext = !0);
             } catch (error) {
               captureCommitPhaseError(finishedWork, finishedWork.return, error);
             }
@@ -11881,10 +12889,10 @@
         case 3:
           hoistableRoot = pushNestedEffectDurations();
           tagCaches = null;
-          maybeNodes = currentHoistableRoot;
+          i = currentHoistableRoot;
           currentHoistableRoot = getHoistableRoot(root.containerInfo);
-          recursivelyTraverseMutationEffects(root, finishedWork);
-          currentHoistableRoot = maybeNodes;
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          currentHoistableRoot = i;
           commitReconciliationEffects(finishedWork);
           if (
             flags & 4 &&
@@ -11905,50 +12913,48 @@
           root.effectDuration += popNestedEffectDurations(hoistableRoot);
           break;
         case 4:
-          flags = currentHoistableRoot;
+          current = currentHoistableRoot;
           currentHoistableRoot = getHoistableRoot(
             finishedWork.stateNode.containerInfo
           );
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
-          currentHoistableRoot = flags;
+          currentHoistableRoot = current;
           break;
         case 12:
-          flags = pushNestedEffectDurations();
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          current = pushNestedEffectDurations();
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           finishedWork.stateNode.effectDuration +=
-            bubbleNestedEffectDurations(flags);
+            bubbleNestedEffectDurations(current);
           break;
         case 13:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           finishedWork.child.flags & 8192 &&
             (null !== finishedWork.memoizedState) !==
               (null !== current && null !== current.memoizedState) &&
             (globalMostRecentFallbackTime = now$1());
           flags & 4 &&
-            ((flags = finishedWork.updateQueue),
-            null !== flags &&
+            ((current = finishedWork.updateQueue),
+            null !== current &&
               ((finishedWork.updateQueue = null),
-              attachSuspenseRetryListeners(finishedWork, flags)));
+              attachSuspenseRetryListeners(finishedWork, current)));
           break;
         case 22:
           flags & 512 &&
             (offscreenSubtreeWasHidden ||
               null === current ||
               safelyDetachRef(current, current.return));
-          hoistableRoot = null !== finishedWork.memoizedState;
-          var wasHidden = null !== current && null !== current.memoizedState,
-            prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-          offscreenSubtreeIsHidden =
-            prevOffscreenSubtreeIsHidden || hoistableRoot;
-          offscreenSubtreeWasHidden =
-            prevOffscreenSubtreeWasHidden || wasHidden;
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          node = null !== finishedWork.memoizedState;
+          nextNode = null !== current && null !== current.memoizedState;
+          nodeName = offscreenSubtreeIsHidden;
+          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+          offscreenSubtreeIsHidden = nodeName || node;
+          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || nextNode;
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
-          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+          offscreenSubtreeIsHidden = nodeName;
           commitReconciliationEffects(finishedWork);
           root = finishedWork.stateNode;
           root._current = finishedWork;
@@ -11956,51 +12962,51 @@
           root._visibility |= root._pendingVisibility & OffscreenDetached;
           if (
             flags & 8192 &&
-            ((root._visibility = hoistableRoot
+            ((root._visibility = node
               ? root._visibility & ~OffscreenVisible
               : root._visibility | OffscreenVisible),
-            hoistableRoot &&
-              (null === current ||
-                wasHidden ||
-                offscreenSubtreeIsHidden ||
-                offscreenSubtreeWasHidden ||
+            node &&
+              ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
+              null === current ||
+                nextNode ||
+                root ||
                 recursivelyTraverseDisappearLayoutEffects(finishedWork)),
             null === finishedWork.memoizedProps ||
               "manual" !== finishedWork.memoizedProps.mode)
           )
             a: for (current = null, root = finishedWork; ; ) {
-              if (5 === root.tag || 26 === root.tag) {
+              if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
                 if (null === current) {
-                  wasHidden = current = root;
+                  lanes = current = root;
                   try {
-                    (maybeNodes = wasHidden.stateNode),
-                      hoistableRoot
-                        ? runWithFiberInDEV(wasHidden, hideInstance, maybeNodes)
+                    (hoistableRoot = lanes.stateNode),
+                      node
+                        ? runWithFiberInDEV(lanes, hideInstance, hoistableRoot)
                         : runWithFiberInDEV(
-                            wasHidden,
+                            lanes,
                             unhideInstance,
-                            wasHidden.stateNode,
-                            wasHidden.memoizedProps
+                            lanes.stateNode,
+                            lanes.memoizedProps
                           );
                   } catch (error) {
-                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
+                    captureCommitPhaseError(lanes, lanes.return, error);
                   }
                 }
               } else if (6 === root.tag) {
                 if (null === current) {
-                  wasHidden = root;
+                  lanes = root;
                   try {
-                    (i = wasHidden.stateNode),
-                      hoistableRoot
-                        ? runWithFiberInDEV(wasHidden, hideTextInstance, i)
+                    (i = lanes.stateNode),
+                      node
+                        ? runWithFiberInDEV(lanes, hideTextInstance, i)
                         : runWithFiberInDEV(
-                            wasHidden,
+                            lanes,
                             unhideTextInstance,
                             i,
-                            wasHidden.memoizedProps
+                            lanes.memoizedProps
                           );
                   } catch (error) {
-                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
+                    captureCommitPhaseError(lanes, lanes.return, error);
                   }
                 }
               } else if (
@@ -12025,29 +13031,56 @@
               root = root.sibling;
             }
           flags & 4 &&
-            ((flags = finishedWork.updateQueue),
-            null !== flags &&
-              ((current = flags.retryQueue),
-              null !== current &&
-                ((flags.retryQueue = null),
-                attachSuspenseRetryListeners(finishedWork, current))));
+            ((current = finishedWork.updateQueue),
+            null !== current &&
+              ((flags = current.retryQueue),
+              null !== flags &&
+                ((current.retryQueue = null),
+                attachSuspenseRetryListeners(finishedWork, flags))));
           break;
         case 19:
-          recursivelyTraverseMutationEffects(root, finishedWork);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
           commitReconciliationEffects(finishedWork);
           flags & 4 &&
-            ((flags = finishedWork.updateQueue),
-            null !== flags &&
+            ((current = finishedWork.updateQueue),
+            null !== current &&
               ((finishedWork.updateQueue = null),
-              attachSuspenseRetryListeners(finishedWork, flags)));
+              attachSuspenseRetryListeners(finishedWork, current)));
           break;
         case 30:
+          flags & 512 &&
+            (offscreenSubtreeWasHidden ||
+              null === current ||
+              safelyDetachRef(current, current.return));
+          flags = viewTransitionMutationContext;
+          viewTransitionMutationContext = !1;
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          (lanes & 335544192) === lanes &&
+            null !== current &&
+            viewTransitionMutationContext &&
+            (finishedWork.flags |= 4);
+          viewTransitionMutationContext = flags;
+          break;
         case 21:
           break;
         default:
-          recursivelyTraverseMutationEffects(root, finishedWork),
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes),
             commitReconciliationEffects(finishedWork);
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function commitReconciliationEffects(finishedWork) {
       var flags = finishedWork.flags;
@@ -12070,6 +13103,158 @@
           parentFiber = parentFiber.sibling;
         }
     }
+    function recursivelyTraverseAfterMutationEffects(root, parentFiber) {
+      if (parentFiber.subtreeFlags & 9238)
+        for (parentFiber = parentFiber.child; null !== parentFiber; )
+          commitAfterMutationEffectsOnFiber(parentFiber, root),
+            (parentFiber = parentFiber.sibling);
+      else measureNestedViewTransitions(parentFiber);
+    }
+    function commitAfterMutationEffectsOnFiber(finishedWork, root) {
+      var current = finishedWork.alternate;
+      if (null === current) commitEnterViewTransitions(finishedWork);
+      else
+        switch (finishedWork.tag) {
+          case 3:
+            viewTransitionContextChanged = !1;
+            viewTransitionCancelableChildren = null;
+            recursivelyTraverseAfterMutationEffects(root, finishedWork);
+            if (!viewTransitionContextChanged) {
+              finishedWork = viewTransitionCancelableChildren;
+              viewTransitionCancelableChildren = null;
+              if (null !== finishedWork)
+                for (var i = 0; i < finishedWork.length; i += 3) {
+                  var instance = finishedWork[i],
+                    oldName = finishedWork[i + 1];
+                  restoreViewTransitionName(instance, finishedWork[i + 2]);
+                  instance = instance.ownerDocument.documentElement;
+                  null !== instance &&
+                    instance.animate(
+                      { opacity: [0, 0], pointerEvents: ["none", "none"] },
+                      {
+                        duration: 0,
+                        fill: "forwards",
+                        pseudoElement:
+                          "::view-transition-group(" + oldName + ")"
+                      }
+                    );
+                }
+              finishedWork = root.containerInfo;
+              finishedWork =
+                9 === finishedWork.nodeType
+                  ? finishedWork.documentElement
+                  : finishedWork.ownerDocument.documentElement;
+              null !== finishedWork &&
+                "" === finishedWork.style.viewTransitionName &&
+                ((finishedWork.style.viewTransitionName = "none"),
+                finishedWork.animate(
+                  { opacity: [0, 0], pointerEvents: ["none", "none"] },
+                  {
+                    duration: 0,
+                    fill: "forwards",
+                    pseudoElement: "::view-transition-group(root)"
+                  }
+                ),
+                finishedWork.animate(
+                  { width: [0, 0], height: [0, 0] },
+                  {
+                    duration: 0,
+                    fill: "forwards",
+                    pseudoElement: "::view-transition"
+                  }
+                ));
+            }
+            break;
+          case 5:
+            recursivelyTraverseAfterMutationEffects(root, finishedWork);
+            break;
+          case 22:
+            null === finishedWork.memoizedState &&
+              (null !== current.memoizedState
+                ? commitEnterViewTransitions(finishedWork)
+                : recursivelyTraverseAfterMutationEffects(root, finishedWork));
+            break;
+          case 30:
+            if (0 !== (finishedWork.subtreeFlags & 8246)) {
+              i = 0 !== (finishedWork.flags & 4);
+              oldName = viewTransitionContextChanged;
+              instance = viewTransitionCancelableChildren;
+              viewTransitionContextChanged = !1;
+              viewTransitionCancelableChildren = null;
+              recursivelyTraverseAfterMutationEffects(root, finishedWork);
+              viewTransitionContextChanged && (finishedWork.flags |= 4);
+              a: {
+                root = finishedWork.memoizedProps;
+                var updateClassName = getViewTransitionClassName(
+                    root.className,
+                    root.update
+                  ),
+                  layoutClassName = getViewTransitionClassName(
+                    root.className,
+                    root.update
+                  );
+                if ("none" === updateClassName) {
+                  if ("none" === layoutClassName) {
+                    current = !1;
+                    break a;
+                  }
+                  finishedWork.flags &= -5;
+                  updateClassName = layoutClassName;
+                } else if (0 === (finishedWork.flags & 4)) {
+                  if ("none" === layoutClassName) {
+                    viewTransitionHostInstanceIdx = 0;
+                    cancelViewTransitionHostInstances(
+                      current,
+                      finishedWork.child,
+                      !0
+                    );
+                    current = !1;
+                    break a;
+                  }
+                  updateClassName = layoutClassName;
+                }
+                layoutClassName = getViewTransitionName(
+                  root,
+                  finishedWork.stateNode
+                );
+                viewTransitionHostInstanceIdx = 0;
+                root = current.memoizedState;
+                current = measureViewTransitionHostInstances(
+                  current,
+                  finishedWork,
+                  finishedWork.child,
+                  layoutClassName,
+                  updateClassName,
+                  root,
+                  !0
+                );
+                viewTransitionHostInstanceIdx !==
+                  (null === root ? 0 : root.length) &&
+                  (finishedWork.flags |= 32);
+              }
+              0 !== (finishedWork.flags & 4) && current
+                ? ((current = finishedWork.memoizedProps),
+                  scheduleViewTransitionEvent(
+                    finishedWork,
+                    i || viewTransitionContextChanged
+                      ? current.onUpdate
+                      : current.onLayout
+                  ),
+                  (viewTransitionCancelableChildren = instance))
+                : null !== instance &&
+                  (instance.push.apply(
+                    instance,
+                    viewTransitionCancelableChildren
+                  ),
+                  (viewTransitionCancelableChildren = instance));
+              viewTransitionContextChanged =
+                0 !== (finishedWork.flags & 32) ? !0 : oldName;
+            }
+            break;
+          default:
+            recursivelyTraverseAfterMutationEffects(root, finishedWork);
+        }
+    }
     function recursivelyTraverseLayoutEffects(root, parentFiber) {
       if (parentFiber.subtreeFlags & 8772)
         for (parentFiber = parentFiber.child; null !== parentFiber; )
@@ -12077,6 +13262,8 @@
             (parentFiber = parentFiber.sibling);
     }
     function disappearLayoutEffects(finishedWork) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
       switch (finishedWork.tag) {
         case 0:
         case 11:
@@ -12100,13 +13287,8 @@
             );
           recursivelyTraverseDisappearLayoutEffects(finishedWork);
           break;
-        case 27:
-          runWithFiberInDEV(
-            finishedWork,
-            releaseSingletonInstance,
-            finishedWork.stateNode
-          );
         case 26:
+        case 27:
         case 5:
           safelyDetachRef(finishedWork, finishedWork.return);
           recursivelyTraverseDisappearLayoutEffects(finishedWork);
@@ -12116,9 +13298,24 @@
           null === finishedWork.memoizedState &&
             recursivelyTraverseDisappearLayoutEffects(finishedWork);
           break;
+        case 30:
+          safelyDetachRef(finishedWork, finishedWork.return);
         default:
           recursivelyTraverseDisappearLayoutEffects(finishedWork);
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
       for (parentFiber = parentFiber.child; null !== parentFiber; )
@@ -12131,7 +13328,9 @@
       finishedWork,
       includeWorkInProgressEffects
     ) {
-      var flags = finishedWork.flags;
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors(),
+        flags = finishedWork.flags;
       switch (finishedWork.tag) {
         case 0:
         case 11:
@@ -12176,9 +13375,8 @@
             commitClassCallbacks(finishedWork);
           safelyAttachRef(finishedWork, finishedWork.return);
           break;
-        case 27:
-          commitHostSingletonAcquisition(finishedWork);
         case 26:
+        case 27:
         case 5:
           recursivelyTraverseReappearLayoutEffects(
             finishedRoot,
@@ -12240,6 +13438,14 @@
             );
           safelyAttachRef(finishedWork, finishedWork.return);
           break;
+        case 30:
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+          safelyAttachRef(finishedWork, finishedWork.return);
+          break;
         default:
           recursivelyTraverseReappearLayoutEffects(
             finishedRoot,
@@ -12247,6 +13453,19 @@
             includeWorkInProgressEffects
           );
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function recursivelyTraverseReappearLayoutEffects(
       finishedRoot,
@@ -12290,61 +13509,137 @@
       root,
       parentFiber,
       committedLanes,
-      committedTransitions
+      committedTransitions,
+      endTime
     ) {
-      if (parentFiber.subtreeFlags & 10256)
+      var isViewTransitionEligible =
+        (committedLanes & 335544192) === committedLanes;
+      if (
+        parentFiber.subtreeFlags & (isViewTransitionEligible ? 10262 : 10256) ||
+        (0 !== parentFiber.actualDuration &&
+          (null === parentFiber.alternate ||
+            parentFiber.alternate.child !== parentFiber.child))
+      )
         for (parentFiber = parentFiber.child; null !== parentFiber; )
-          commitPassiveMountOnFiber(
-            root,
-            parentFiber,
-            committedLanes,
-            committedTransitions
-          ),
-            (parentFiber = parentFiber.sibling);
+          (isViewTransitionEligible = parentFiber.sibling),
+            commitPassiveMountOnFiber(
+              root,
+              parentFiber,
+              committedLanes,
+              committedTransitions,
+              null !== isViewTransitionEligible
+                ? isViewTransitionEligible.actualStartTime
+                : endTime
+            ),
+            (parentFiber = isViewTransitionEligible);
+      else
+        isViewTransitionEligible && restoreNestedViewTransitions(parentFiber);
     }
     function commitPassiveMountOnFiber(
       finishedRoot,
       finishedWork,
       committedLanes,
-      committedTransitions
+      committedTransitions,
+      endTime
     ) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 < finishedWork.actualStartTime &&
+        0 !== (finishedWork.flags & 1) &&
+        logComponentRender(
+          finishedWork,
+          finishedWork.actualStartTime,
+          endTime,
+          inHydratedSubtree
+        );
+      var isViewTransitionEligible =
+        (committedLanes & 335544192) === committedLanes;
+      isViewTransitionEligible &&
+        null === finishedWork.alternate &&
+        null !== finishedWork.return &&
+        null !== finishedWork.return.alternate &&
+        restoreEnterViewTransitions(finishedWork);
       var flags = finishedWork.flags;
       switch (finishedWork.tag) {
         case 0:
         case 11:
         case 15:
+          (finishedWork.mode & ProfileMode) !== NoMode &&
+            0 < finishedWork.actualStartTime &&
+            0 !== (finishedWork.flags & 1) &&
+            logComponentRender(
+              finishedWork,
+              finishedWork.actualStartTime,
+              endTime,
+              inHydratedSubtree
+            );
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
           flags & 2048 &&
             commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
           break;
         case 1:
+          (finishedWork.mode & ProfileMode) !== NoMode &&
+            0 < finishedWork.actualStartTime &&
+            (0 !== (finishedWork.flags & 128)
+              ? logComponentErrored(
+                  finishedWork,
+                  finishedWork.actualStartTime,
+                  endTime,
+                  []
+                )
+              : 0 !== (finishedWork.flags & 1) &&
+                logComponentRender(
+                  finishedWork,
+                  finishedWork.actualStartTime,
+                  endTime,
+                  inHydratedSubtree
+                ));
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
           break;
         case 3:
-          var prevEffectDuration = pushNestedEffectDurations();
+          var prevEffectDuration = pushNestedEffectDurations(),
+            wasInHydratedSubtree = inHydratedSubtree;
+          inHydratedSubtree =
+            null !== finishedWork.alternate &&
+            finishedWork.alternate.memoizedState.isDehydrated &&
+            0 === (finishedWork.flags & 256);
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
+          inHydratedSubtree = wasInHydratedSubtree;
+          isViewTransitionEligible &&
+            ((committedLanes = finishedRoot.containerInfo),
+            (committedLanes =
+              9 === committedLanes.nodeType
+                ? committedLanes.documentElement
+                : committedLanes.ownerDocument.documentElement),
+            null !== committedLanes &&
+              "none" === committedLanes.style.viewTransitionName &&
+              (committedLanes.style.viewTransitionName = ""));
           flags & 2048 &&
             ((committedLanes = null),
             null !== finishedWork.alternate &&
               (committedLanes = finishedWork.alternate.memoizedState.cache),
-            (finishedWork = finishedWork.memoizedState.cache),
-            finishedWork !== committedLanes &&
-              (retainCache(finishedWork),
+            (committedTransitions = finishedWork.memoizedState.cache),
+            committedTransitions !== committedLanes &&
+              (retainCache(committedTransitions),
               null != committedLanes && releaseCache(committedLanes)));
           finishedRoot.passiveEffectDuration +=
             popNestedEffectDurations(prevEffectDuration);
@@ -12356,7 +13651,8 @@
               finishedRoot,
               finishedWork,
               committedLanes,
-              committedTransitions
+              committedTransitions,
+              endTime
             );
             finishedRoot = finishedWork.stateNode;
             finishedRoot.passiveEffectDuration +=
@@ -12378,99 +13674,191 @@
               finishedRoot,
               finishedWork,
               committedLanes,
-              committedTransitions
+              committedTransitions,
+              endTime
             );
           break;
         case 13:
+          flags = inHydratedSubtree;
+          prevEffectDuration =
+            null !== finishedWork.alternate
+              ? finishedWork.alternate.memoizedState
+              : null;
+          isViewTransitionEligible = finishedWork.memoizedState;
+          null === prevEffectDuration ||
+          null === prevEffectDuration.dehydrated ||
+          (null !== isViewTransitionEligible &&
+            null !== isViewTransitionEligible.dehydrated)
+            ? (inHydratedSubtree = !1)
+            : ((isViewTransitionEligible = finishedWork.deletions),
+              null !== isViewTransitionEligible &&
+              0 < isViewTransitionEligible.length &&
+              18 === isViewTransitionEligible[0].tag
+                ? ((inHydratedSubtree = !1),
+                  (prevEffectDuration = prevEffectDuration.hydrationErrors),
+                  null !== prevEffectDuration &&
+                    logComponentErrored(
+                      finishedWork,
+                      finishedWork.actualStartTime,
+                      endTime,
+                      prevEffectDuration
+                    ))
+                : (inHydratedSubtree = !0));
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
+          inHydratedSubtree = flags;
           break;
         case 23:
           break;
         case 22:
           prevEffectDuration = finishedWork.stateNode;
-          var _current = finishedWork.alternate;
+          wasInHydratedSubtree = finishedWork.alternate;
           null !== finishedWork.memoizedState
-            ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
-              ? recursivelyTraversePassiveMountEffects(
-                  finishedRoot,
-                  finishedWork,
-                  committedLanes,
-                  committedTransitions
-                )
-              : recursivelyTraverseAtomicPassiveEffects(
-                  finishedRoot,
-                  finishedWork
-                )
-            : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
-              ? recursivelyTraversePassiveMountEffects(
-                  finishedRoot,
-                  finishedWork,
-                  committedLanes,
-                  committedTransitions
-                )
-              : ((prevEffectDuration._visibility |=
-                  OffscreenPassiveEffectsConnected),
-                recursivelyTraverseReconnectPassiveEffects(
-                  finishedRoot,
-                  finishedWork,
-                  committedLanes,
-                  committedTransitions,
-                  0 !== (finishedWork.subtreeFlags & 10256)
-                ));
+            ? (isViewTransitionEligible &&
+                null !== wasInHydratedSubtree &&
+                null === wasInHydratedSubtree.memoizedState &&
+                restoreExitViewTransitions(wasInHydratedSubtree),
+              prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
+                ? recursivelyTraversePassiveMountEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    endTime
+                  )
+                : recursivelyTraverseAtomicPassiveEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    endTime
+                  ))
+            : (isViewTransitionEligible &&
+                null !== wasInHydratedSubtree &&
+                null !== wasInHydratedSubtree.memoizedState &&
+                restoreEnterViewTransitions(finishedWork),
+              prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
+                ? recursivelyTraversePassiveMountEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    endTime
+                  )
+                : ((prevEffectDuration._visibility |=
+                    OffscreenPassiveEffectsConnected),
+                  recursivelyTraverseReconnectPassiveEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    0 !== (finishedWork.subtreeFlags & 10256),
+                    endTime
+                  )));
           flags & 2048 &&
-            commitOffscreenPassiveMountEffects(_current, finishedWork);
+            commitOffscreenPassiveMountEffects(
+              wasInHydratedSubtree,
+              finishedWork
+            );
           break;
         case 24:
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
           flags & 2048 &&
             commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
           break;
+        case 30:
+          isViewTransitionEligible &&
+            ((flags = finishedWork.alternate),
+            null !== flags &&
+              0 !== (finishedWork.subtreeFlags & 8246) &&
+              ((finishedWork.memoizedState = null),
+              restoreViewTransitionOnHostInstances(flags.child, !0),
+              restoreViewTransitionOnHostInstances(finishedWork.child, !0)));
+          recursivelyTraversePassiveMountEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
+          break;
         default:
           recursivelyTraversePassiveMountEffects(
             finishedRoot,
             finishedWork,
             committedLanes,
-            committedTransitions
+            committedTransitions,
+            endTime
           );
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function recursivelyTraverseReconnectPassiveEffects(
       finishedRoot,
       parentFiber,
       committedLanes,
       committedTransitions,
-      includeWorkInProgressEffects
+      includeWorkInProgressEffects,
+      endTime
     ) {
       includeWorkInProgressEffects =
         includeWorkInProgressEffects &&
         0 !== (parentFiber.subtreeFlags & 10256);
-      for (parentFiber = parentFiber.child; null !== parentFiber; )
+      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+        var nextSibling = parentFiber.sibling;
         reconnectPassiveEffects(
           finishedRoot,
           parentFiber,
           committedLanes,
           committedTransitions,
-          includeWorkInProgressEffects
-        ),
-          (parentFiber = parentFiber.sibling);
+          includeWorkInProgressEffects,
+          null !== nextSibling ? nextSibling.actualStartTime : endTime
+        );
+        parentFiber = nextSibling;
+      }
     }
     function reconnectPassiveEffects(
       finishedRoot,
       finishedWork,
       committedLanes,
       committedTransitions,
-      includeWorkInProgressEffects
+      includeWorkInProgressEffects,
+      endTime
     ) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 < finishedWork.actualStartTime &&
+        0 !== (finishedWork.flags & 1) &&
+        logComponentRender(
+          finishedWork,
+          finishedWork.actualStartTime,
+          endTime,
+          inHydratedSubtree
+        );
       var flags = finishedWork.flags;
       switch (finishedWork.tag) {
         case 0:
@@ -12481,7 +13869,8 @@
             finishedWork,
             committedLanes,
             committedTransitions,
-            includeWorkInProgressEffects
+            includeWorkInProgressEffects,
+            endTime
           );
           commitHookPassiveMountEffects(finishedWork, Passive);
           break;
@@ -12496,11 +13885,15 @@
                   finishedWork,
                   committedLanes,
                   committedTransitions,
-                  includeWorkInProgressEffects
+                  includeWorkInProgressEffects,
+                  endTime
                 )
               : recursivelyTraverseAtomicPassiveEffects(
                   finishedRoot,
-                  finishedWork
+                  finishedWork,
+                  committedLanes,
+                  committedTransitions,
+                  endTime
                 )
             : ((_instance2._visibility |= OffscreenPassiveEffectsConnected),
               recursivelyTraverseReconnectPassiveEffects(
@@ -12508,7 +13901,8 @@
                 finishedWork,
                 committedLanes,
                 committedTransitions,
-                includeWorkInProgressEffects
+                includeWorkInProgressEffects,
+                endTime
               ));
           includeWorkInProgressEffects &&
             flags & 2048 &&
@@ -12523,7 +13917,8 @@
             finishedWork,
             committedLanes,
             committedTransitions,
-            includeWorkInProgressEffects
+            includeWorkInProgressEffects,
+            endTime
           );
           includeWorkInProgressEffects &&
             flags & 2048 &&
@@ -12535,49 +13930,84 @@
             finishedWork,
             committedLanes,
             committedTransitions,
-            includeWorkInProgressEffects
+            includeWorkInProgressEffects,
+            endTime
           );
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function recursivelyTraverseAtomicPassiveEffects(
       finishedRoot$jscomp$0,
-      parentFiber
+      parentFiber,
+      committedLanes$jscomp$0,
+      committedTransitions$jscomp$0,
+      endTime$jscomp$0
     ) {
       if (parentFiber.subtreeFlags & 10256)
-        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+        for (var child = parentFiber.child; null !== child; ) {
+          parentFiber = child.sibling;
           var finishedRoot = finishedRoot$jscomp$0,
-            finishedWork = parentFiber,
-            flags = finishedWork.flags;
-          switch (finishedWork.tag) {
+            committedLanes = committedLanes$jscomp$0,
+            committedTransitions = committedTransitions$jscomp$0,
+            endTime =
+              null !== parentFiber
+                ? parentFiber.actualStartTime
+                : endTime$jscomp$0;
+          (child.mode & ProfileMode) !== NoMode &&
+            0 < child.actualStartTime &&
+            0 !== (child.flags & 1) &&
+            logComponentRender(
+              child,
+              child.actualStartTime,
+              endTime,
+              inHydratedSubtree
+            );
+          var flags = child.flags;
+          switch (child.tag) {
             case 22:
               recursivelyTraverseAtomicPassiveEffects(
                 finishedRoot,
-                finishedWork
+                child,
+                committedLanes,
+                committedTransitions,
+                endTime
               );
               flags & 2048 &&
-                commitOffscreenPassiveMountEffects(
-                  finishedWork.alternate,
-                  finishedWork
-                );
+                commitOffscreenPassiveMountEffects(child.alternate, child);
               break;
             case 24:
               recursivelyTraverseAtomicPassiveEffects(
                 finishedRoot,
-                finishedWork
+                child,
+                committedLanes,
+                committedTransitions,
+                endTime
               );
               flags & 2048 &&
-                commitCachePassiveMountEffect(
-                  finishedWork.alternate,
-                  finishedWork
-                );
+                commitCachePassiveMountEffect(child.alternate, child);
               break;
             default:
               recursivelyTraverseAtomicPassiveEffects(
                 finishedRoot,
-                finishedWork
+                child,
+                committedLanes,
+                committedTransitions,
+                endTime
               );
           }
-          parentFiber = parentFiber.sibling;
+          child = parentFiber;
         }
     }
     function recursivelyAccumulateSuspenseyCommit(parentFiber) {
@@ -12659,6 +14089,8 @@
             (parentFiber = parentFiber.sibling);
     }
     function commitPassiveUnmountOnFiber(finishedWork) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
       switch (finishedWork.tag) {
         case 0:
         case 11:
@@ -12696,6 +14128,19 @@
         default:
           recursivelyTraversePassiveUnmountEffects(finishedWork);
       }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
     }
     function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
       var deletions = parentFiber.deletions;
@@ -12739,11 +14184,14 @@
     }
     function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
       deletedSubtreeRoot,
-      nearestMountedAncestor
+      nearestMountedAncestor$jscomp$0
     ) {
       for (; null !== nextEffect; ) {
         var fiber = nextEffect,
-          current = fiber;
+          current = fiber,
+          nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
+          prevEffectStart = pushComponentEffectStart(),
+          prevEffectErrors = pushComponentEffectErrors();
         switch (current.tag) {
           case 0:
           case 11:
@@ -12758,30 +14206,44 @@
           case 22:
             null !== current.memoizedState &&
               null !== current.memoizedState.cachePool &&
-              ((current = current.memoizedState.cachePool.pool),
-              null != current && retainCache(current));
+              ((nearestMountedAncestor = current.memoizedState.cachePool.pool),
+              null != nearestMountedAncestor &&
+                retainCache(nearestMountedAncestor));
             break;
           case 24:
             releaseCache(current.memoizedState.cache);
         }
+        (current.mode & ProfileMode) !== NoMode &&
+          0 <= componentEffectStartTime &&
+          0 <= componentEffectEndTime &&
+          0.05 < componentEffectDuration &&
+          logComponentEffect(
+            current,
+            componentEffectStartTime,
+            componentEffectEndTime,
+            componentEffectDuration,
+            componentEffectErrors
+          );
+        popComponentEffectStart(prevEffectStart);
+        componentEffectErrors = prevEffectErrors;
         current = fiber.child;
         if (null !== current) (current.return = fiber), (nextEffect = current);
         else
           a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
             current = nextEffect;
-            var sibling = current.sibling,
-              returnFiber = current.return;
+            prevEffectStart = current.sibling;
+            prevEffectErrors = current.return;
             detachFiberAfterEffects(current);
             if (current === fiber) {
               nextEffect = null;
               break a;
             }
-            if (null !== sibling) {
-              sibling.return = returnFiber;
-              nextEffect = sibling;
+            if (null !== prevEffectStart) {
+              prevEffectStart.return = prevEffectErrors;
+              nextEffect = prevEffectStart;
               break a;
             }
-            nextEffect = returnFiber;
+            nextEffect = prevEffectErrors;
           }
       }
     }
@@ -12811,7 +14273,11 @@
       this.actualDuration = -0;
       this.actualStartTime = -1.1;
       this.treeBaseDuration = this.selfBaseDuration = -0;
-      this._debugOwner = this._debugInfo = null;
+      this._debugTask =
+        this._debugStack =
+        this._debugOwner =
+        this._debugInfo =
+          null;
       this._debugNeedsRemount = !1;
       this._debugHookTypes = null;
       hasBadMapPolyfill ||
@@ -12835,6 +14301,8 @@
           (workInProgress.type = current.type),
           (workInProgress.stateNode = current.stateNode),
           (workInProgress._debugOwner = current._debugOwner),
+          (workInProgress._debugStack = current._debugStack),
+          (workInProgress._debugTask = current._debugTask),
           (workInProgress._debugHookTypes = current._debugHookTypes),
           (workInProgress.alternate = current),
           (current.alternate = workInProgress))
@@ -12984,6 +14452,15 @@
             );
           case REACT_OFFSCREEN_TYPE:
             return createFiberFromOffscreen(pendingProps, mode, lanes, key);
+          case REACT_LEGACY_HIDDEN_TYPE:
+          case REACT_VIEW_TRANSITION_TYPE:
+            return (
+              (key = createFiber(30, pendingProps, key, mode)),
+              (key.elementType = REACT_VIEW_TRANSITION_TYPE),
+              (key.lanes = lanes),
+              (key.stateNode = { autoName: null, paired: null, ref: null }),
+              key
+            );
           default:
             if ("object" === typeof type && null !== type)
               switch (type.$$typeof) {
@@ -13054,6 +14531,8 @@
         lanes
       );
       mode._debugOwner = element._owner;
+      mode._debugStack = element._debugStack;
+      mode._debugTask = element._debugTask;
       return mode;
     }
     function createFiberFromFragment(elements, mode, lanes, key) {
@@ -13370,6 +14849,20 @@
           diffRoot
         ));
     }
+    function getViewTransitionName(props, instance) {
+      return null != props.name && "auto" !== props.name
+        ? props.name
+        : instance.autoName;
+    }
+    function getViewTransitionClassName(className, eventClassName) {
+      return null == eventClassName
+        ? className
+        : "none" === eventClassName
+          ? eventClassName
+          : null != className
+            ? className + " " + eventClassName
+            : eventClassName;
+    }
     function markUpdate(workInProgress) {
       workInProgress.flags |= 4;
     }
@@ -13493,6 +14986,30 @@
       completedWork.childLanes = newChildLanes;
       return didBailout;
     }
+    function trackReappearingViewTransitions(workInProgress) {
+      if (0 !== (workInProgress.subtreeFlags & 2097152))
+        for (workInProgress = workInProgress.child; null !== workInProgress; ) {
+          if (
+            22 !== workInProgress.tag ||
+            null !== workInProgress.memoizedState
+          ) {
+            if (
+              30 === workInProgress.tag &&
+              0 !== (workInProgress.flags & 2097152)
+            ) {
+              var props = workInProgress.memoizedProps;
+              null != props.name &&
+                "auto" !== props.name &&
+                trackAppearingViewTransition(
+                  workInProgress.stateNode,
+                  props.name
+                );
+            }
+            trackReappearingViewTransitions(workInProgress);
+          }
+          workInProgress = workInProgress.sibling;
+        }
+    }
     function completeWork(current, workInProgress, renderLanes) {
       var newProps = workInProgress.pendingProps;
       popTreeContext(workInProgress);
@@ -13572,6 +15089,7 @@
                   "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                 );
               bubbleProperties(workInProgress);
+              workInProgress.subtreeFlags &= -33554433;
               return null;
             }
             current = getHostContext();
@@ -13588,6 +15106,7 @@
                 markUpdate(workInProgress));
           }
           bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
           return null;
         case 5:
           popHostContext(workInProgress);
@@ -13601,6 +15120,7 @@
                   "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                 );
               bubbleProperties(workInProgress);
+              workInProgress.subtreeFlags &= -33554433;
               return null;
             }
             _type = getHostContext();
@@ -13719,6 +15239,7 @@
             }
           }
           bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
           workInProgress.flags &= -16777217;
           return null;
         case 6:
@@ -14002,7 +15523,8 @@
             (newProps = null !== workInProgress.memoizedState),
             null !== current
               ? (null !== current.memoizedState) !== newProps &&
-                (workInProgress.flags |= 8192)
+                ((workInProgress.flags |= 8192),
+                newProps || trackReappearingViewTransitions(workInProgress))
               : newProps && (workInProgress.flags |= 8192),
             newProps
               ? 0 !== (renderLanes & 536870912) &&
@@ -14040,7 +15562,11 @@
         case 25:
           return null;
         case 30:
-          return null;
+          return (
+            (workInProgress.flags |= 33554432),
+            bubbleProperties(workInProgress),
+            null
+          );
       }
       throw Error(
         "Unknown unit of work tag (" +
@@ -14195,6 +15721,20 @@
       null !== suspenseHandler && (suspenseHandler.flags |= 32);
       return workInProgressDeferredLane;
     }
+    function scheduleViewTransitionEvent(fiber, callback) {
+      if (null != callback) {
+        var state = fiber.stateNode,
+          instance = state.ref;
+        null === instance &&
+          (instance = state.ref =
+            createViewTransitionInstance(
+              getViewTransitionName(fiber.memoizedProps, state)
+            ));
+        null === pendingViewTransitionEvents &&
+          (pendingViewTransitionEvents = []);
+        pendingViewTransitionEvents.push(callback.bind(null, instance));
+      }
+    }
     function scheduleUpdateOnFiber(root, fiber, lane) {
       isRunningInsertionEffect &&
         console.error("useInsertionEffect must not schedule updates.");
@@ -14260,32 +15800,82 @@
     function performWorkOnRoot(root, lanes, forceSync) {
       if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
         throw Error("Should not already be working.");
-      var shouldTimeSlice =
-          (!forceSync &&
-            0 === (lanes & 60) &&
-            0 === (lanes & root.expiredLanes)) ||
-          checkIfRootIsPrerendering(root, lanes),
-        exitStatus = shouldTimeSlice
-          ? renderRootConcurrent(root, lanes)
-          : renderRootSync(root, lanes, !0),
-        renderWasConcurrent = shouldTimeSlice;
+      if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {
+        var yieldEndTime = now$1();
+        switch (yieldReason) {
+          case SuspendedOnImmediate:
+          case SuspendedOnData:
+            var startTime = yieldStartTime;
+            supportsUserTiming &&
+              ((reusableComponentDevToolDetails.color = "primary-light"),
+              (reusableComponentOptions.start = startTime),
+              (reusableComponentOptions.end = yieldEndTime),
+              performance.measure("Suspended", reusableComponentOptions));
+            break;
+          case SuspendedOnAction:
+            startTime = yieldStartTime;
+            supportsUserTiming &&
+              ((reusableComponentDevToolDetails.color = "primary-light"),
+              (reusableComponentOptions.start = startTime),
+              (reusableComponentOptions.end = yieldEndTime),
+              performance.measure("Action", reusableComponentOptions));
+            break;
+          default:
+            if (((startTime = yieldStartTime), supportsUserTiming)) {
+              var yieldDuration = yieldEndTime - startTime;
+              1 > yieldDuration ||
+                ((reusableComponentDevToolDetails.color =
+                  5 > yieldDuration
+                    ? "primary-light"
+                    : 10 > yieldDuration
+                      ? "primary"
+                      : 100 > yieldDuration
+                        ? "primary-dark"
+                        : "error"),
+                (reusableComponentOptions.start = startTime),
+                (reusableComponentOptions.end = yieldEndTime),
+                performance.measure("Blocked", reusableComponentOptions));
+            }
+        }
+      }
+      yieldDuration = (forceSync =
+        (!forceSync &&
+          0 === (lanes & 60) &&
+          0 === (lanes & root.expiredLanes)) ||
+        checkIfRootIsPrerendering(root, lanes))
+        ? renderRootConcurrent(root, lanes)
+        : renderRootSync(root, lanes, !0);
+      var renderWasConcurrent = forceSync;
       do {
-        if (exitStatus === RootInProgress) {
+        if (yieldDuration === RootInProgress) {
           workInProgressRootIsPrerendering &&
-            !shouldTimeSlice &&
+            !forceSync &&
             markRootSuspended(root, lanes, 0, !1);
+          lanes = workInProgressSuspendedReason;
+          yieldStartTime = now();
+          yieldReason = lanes;
           break;
         } else {
-          forceSync = root.current.alternate;
+          startTime = now$1();
+          yieldEndTime = root.current.alternate;
           if (
             renderWasConcurrent &&
-            !isRenderConsistentWithExternalStores(forceSync)
+            !isRenderConsistentWithExternalStores(yieldEndTime)
           ) {
-            exitStatus = renderRootSync(root, lanes, !1);
+            setCurrentTrackFromLanes(lanes);
+            yieldEndTime = renderStartTime;
+            yieldDuration = startTime;
+            supportsUserTiming &&
+              ((reusableLaneDevToolDetails.color = "error"),
+              (reusableLaneOptions.start = yieldEndTime),
+              (reusableLaneOptions.end = yieldDuration),
+              performance.measure("Teared Render", reusableLaneOptions));
+            finalizeRender(lanes, startTime);
+            yieldDuration = renderRootSync(root, lanes, !1);
             renderWasConcurrent = !1;
             continue;
           }
-          if (exitStatus === RootErrored) {
+          if (yieldDuration === RootErrored) {
             renderWasConcurrent = lanes;
             if (root.errorRecoveryDisabledLanes & renderWasConcurrent)
               var errorRetryLanes = 0;
@@ -14298,67 +15888,77 @@
                       ? 536870912
                       : 0);
             if (0 !== errorRetryLanes) {
+              setCurrentTrackFromLanes(lanes);
+              logErroredRenderPhase(renderStartTime, startTime);
+              finalizeRender(lanes, startTime);
               lanes = errorRetryLanes;
               a: {
-                exitStatus = root;
-                var errorRetryLanes$jscomp$0 = errorRetryLanes;
-                errorRetryLanes = workInProgressRootConcurrentErrors;
+                startTime = root;
+                yieldDuration = renderWasConcurrent;
+                renderWasConcurrent = workInProgressRootConcurrentErrors;
                 var wasRootDehydrated =
-                  exitStatus.current.memoizedState.isDehydrated;
+                  startTime.current.memoizedState.isDehydrated;
                 wasRootDehydrated &&
-                  (prepareFreshStack(
-                    exitStatus,
-                    errorRetryLanes$jscomp$0
-                  ).flags |= 256);
-                errorRetryLanes$jscomp$0 = renderRootSync(
-                  exitStatus,
-                  errorRetryLanes$jscomp$0,
+                  (prepareFreshStack(startTime, errorRetryLanes).flags |= 256);
+                errorRetryLanes = renderRootSync(
+                  startTime,
+                  errorRetryLanes,
                   !1
                 );
-                if (errorRetryLanes$jscomp$0 !== RootErrored) {
+                if (errorRetryLanes !== RootErrored) {
                   if (
                     workInProgressRootDidAttachPingListener &&
                     !wasRootDehydrated
                   ) {
-                    exitStatus.errorRecoveryDisabledLanes |=
-                      renderWasConcurrent;
-                    workInProgressRootInterleavedUpdatedLanes |=
-                      renderWasConcurrent;
-                    exitStatus = RootSuspendedWithDelay;
+                    startTime.errorRecoveryDisabledLanes |= yieldDuration;
+                    workInProgressRootInterleavedUpdatedLanes |= yieldDuration;
+                    yieldDuration = RootSuspendedWithDelay;
                     break a;
                   }
-                  exitStatus = workInProgressRootRecoverableErrors;
-                  workInProgressRootRecoverableErrors = errorRetryLanes;
-                  null !== exitStatus &&
+                  startTime = workInProgressRootRecoverableErrors;
+                  workInProgressRootRecoverableErrors = renderWasConcurrent;
+                  null !== startTime &&
                     (null === workInProgressRootRecoverableErrors
-                      ? (workInProgressRootRecoverableErrors = exitStatus)
+                      ? (workInProgressRootRecoverableErrors = startTime)
                       : workInProgressRootRecoverableErrors.push.apply(
                           workInProgressRootRecoverableErrors,
-                          exitStatus
+                          startTime
                         ));
                 }
-                exitStatus = errorRetryLanes$jscomp$0;
+                yieldDuration = errorRetryLanes;
               }
               renderWasConcurrent = !1;
-              if (exitStatus !== RootErrored) continue;
+              if (yieldDuration !== RootErrored) continue;
+              else startTime = now$1();
             }
           }
-          if (exitStatus === RootFatalErrored) {
+          if (yieldDuration === RootFatalErrored) {
+            setCurrentTrackFromLanes(lanes);
+            logErroredRenderPhase(renderStartTime, startTime);
+            finalizeRender(lanes, startTime);
             prepareFreshStack(root, 0);
             markRootSuspended(root, lanes, 0, !0);
             break;
           }
           a: {
-            shouldTimeSlice = root;
-            switch (exitStatus) {
+            forceSync = root;
+            switch (yieldDuration) {
               case RootInProgress:
               case RootFatalErrored:
                 throw Error("Root did not complete. This is a bug in React.");
               case RootSuspendedWithDelay:
                 if ((lanes & 4194176) !== lanes) break;
               case RootSuspendedAtTheShell:
+                setCurrentTrackFromLanes(lanes);
+                logSuspendedRenderPhase(renderStartTime, startTime, lanes);
+                finalizeRender(lanes, startTime);
+                yieldEndTime = lanes;
+                0 !== (yieldEndTime & 3) || 0 !== (yieldEndTime & 60)
+                  ? (blockingSuspendedTime = startTime)
+                  : 0 !== (yieldEndTime & 4194176) &&
+                    (transitionSuspendedTime = startTime);
                 markRootSuspended(
-                  shouldTimeSlice,
+                  forceSync,
                   lanes,
                   workInProgressDeferredLane,
                   !workInProgressRootDidSkipSuspendedSiblings
@@ -14375,8 +15975,8 @@
             }
             if (null !== ReactSharedInternals.actQueue)
               commitRoot(
-                shouldTimeSlice,
                 forceSync,
+                yieldEndTime,
                 lanes,
                 workInProgressRootRecoverableErrors,
                 workInProgressTransitions,
@@ -14384,7 +15984,11 @@
                 workInProgressRootDidIncludeRecursiveRenderUpdate,
                 workInProgressDeferredLane,
                 workInProgressRootInterleavedUpdatedLanes,
-                workInProgressSuspendedRetryLanes
+                workInProgressSuspendedRetryLanes,
+                yieldDuration,
+                IMMEDIATE_COMMIT,
+                renderStartTime,
+                startTime
               );
             else {
               if (
@@ -14396,17 +16000,17 @@
                 10 < renderWasConcurrent)
               ) {
                 markRootSuspended(
-                  shouldTimeSlice,
+                  forceSync,
                   lanes,
                   workInProgressDeferredLane,
                   !workInProgressRootDidSkipSuspendedSiblings
                 );
-                if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
-                shouldTimeSlice.timeoutHandle = scheduleTimeout(
+                if (0 !== getNextLanes(forceSync, 0, !0)) break a;
+                forceSync.timeoutHandle = scheduleTimeout(
                   commitRootWhenReady.bind(
                     null,
-                    shouldTimeSlice,
                     forceSync,
+                    yieldEndTime,
                     workInProgressRootRecoverableErrors,
                     workInProgressTransitions,
                     workInProgressAppearingViewTransitions,
@@ -14416,18 +16020,18 @@
                     workInProgressRootInterleavedUpdatedLanes,
                     workInProgressSuspendedRetryLanes,
                     workInProgressRootDidSkipSuspendedSiblings,
-                    exitStatus,
+                    yieldDuration,
                     THROTTLED_COMMIT,
                     renderStartTime,
-                    0
+                    startTime
                   ),
                   renderWasConcurrent
                 );
                 break a;
               }
               commitRootWhenReady(
-                shouldTimeSlice,
                 forceSync,
+                yieldEndTime,
                 workInProgressRootRecoverableErrors,
                 workInProgressTransitions,
                 workInProgressAppearingViewTransitions,
@@ -14437,10 +16041,10 @@
                 workInProgressRootInterleavedUpdatedLanes,
                 workInProgressSuspendedRetryLanes,
                 workInProgressRootDidSkipSuspendedSiblings,
-                exitStatus,
+                yieldDuration,
                 IMMEDIATE_COMMIT,
                 renderStartTime,
-                0
+                startTime
               );
             }
           }
@@ -14467,24 +16071,38 @@
       completedRenderEndTime
     ) {
       root.timeoutHandle = noTimeout;
-      suspendedCommitReason = finishedWork.subtreeFlags;
-      if (
-        (suspendedCommitReason =
-          suspendedCommitReason & 8192 ||
-          16785408 === (suspendedCommitReason & 16785408))
-      )
-        if (
-          ((suspendedState = {
-            stylesheets: null,
-            count: 0,
-            unsuspend: noop$1
-          }),
-          suspendedCommitReason &&
-            accumulateSuspenseyCommitOnFiber(finishedWork),
-          (suspendedCommitReason = waitForCommitToBeReady()),
-          null !== suspendedCommitReason)
-        ) {
-          root.cancelPendingCommit = suspendedCommitReason(
+      var subtreeFlags = finishedWork.subtreeFlags,
+        isViewTransitionEligible = (lanes & 335544192) === lanes;
+      subtreeFlags =
+        subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408);
+      if (isViewTransitionEligible || subtreeFlags) {
+        suspendedState = { stylesheets: null, count: 0, unsuspend: noop$1 };
+        subtreeFlags && accumulateSuspenseyCommitOnFiber(finishedWork);
+        if (isViewTransitionEligible) {
+          subtreeFlags = root.containerInfo;
+          if (null === suspendedState)
+            throw Error(
+              "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
+            );
+          isViewTransitionEligible = suspendedState;
+          subtreeFlags = (
+            9 === subtreeFlags.nodeType
+              ? subtreeFlags
+              : subtreeFlags.ownerDocument
+          ).__reactViewTransition;
+          null != subtreeFlags &&
+            (isViewTransitionEligible.count++,
+            (isViewTransitionEligible = onUnsuspend.bind(
+              isViewTransitionEligible
+            )),
+            subtreeFlags.finished.then(
+              isViewTransitionEligible,
+              isViewTransitionEligible
+            ));
+        }
+        isViewTransitionEligible = waitForCommitToBeReady();
+        if (null !== isViewTransitionEligible) {
+          root.cancelPendingCommit = isViewTransitionEligible(
             commitRoot.bind(
               null,
               root,
@@ -14511,6 +16129,7 @@
           );
           return;
         }
+      }
       commitRoot(
         root,
         finishedWork,
@@ -14521,7 +16140,11 @@
         didIncludeRenderPhaseUpdate,
         spawnedLane,
         updatedLanes,
-        suspendedRetryLanes
+        suspendedRetryLanes,
+        exitStatus,
+        suspendedCommitReason,
+        completedRenderStartTime,
+        completedRenderEndTime
       );
     }
     function isRenderConsistentWithExternalStores(finishedWork) {
@@ -14601,16 +16224,179 @@
         workInProgress = null;
       }
     }
+    function finalizeRender(lanes, finalizationTime) {
+      if (0 !== (lanes & 3) || 0 !== (lanes & 60))
+        blockingClampTime = finalizationTime;
+      0 !== (lanes & 4194176) && (transitionClampTime = finalizationTime);
+    }
     function prepareFreshStack(root, lanes) {
-      var timeoutHandle = root.timeoutHandle;
-      timeoutHandle !== noTimeout &&
-        ((root.timeoutHandle = noTimeout), cancelTimeout(timeoutHandle));
-      timeoutHandle = root.cancelPendingCommit;
-      null !== timeoutHandle &&
-        ((root.cancelPendingCommit = null), timeoutHandle());
+      supportsUserTiming &&
+        (performance.mark("Blocking Track", blockingLaneMarker),
+        performance.mark("Transition Track", transitionLaneMarker),
+        performance.mark("Suspense Track", suspenseLaneMarker),
+        performance.mark("Idle Track", idleLaneMarker));
+      var previousRenderStartTime = renderStartTime;
+      renderStartTime = now();
+      if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {
+        setCurrentTrackFromLanes(workInProgressRootRenderLanes);
+        if (
+          workInProgressRootExitStatus === RootSuspended ||
+          workInProgressRootExitStatus === RootSuspendedWithDelay
+        )
+          logSuspendedRenderPhase(
+            previousRenderStartTime,
+            renderStartTime,
+            lanes
+          );
+        else {
+          var endTime = renderStartTime;
+          supportsUserTiming &&
+            ((reusableLaneDevToolDetails.color =
+              (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+            (reusableLaneOptions.start = previousRenderStartTime),
+            (reusableLaneOptions.end = endTime),
+            performance.measure(
+              (lanes & 536870912) === lanes
+                ? "Prewarm"
+                : (lanes & 201326677) === lanes
+                  ? "Interrupted Hydration"
+                  : "Interrupted Render",
+              reusableLaneOptions
+            ));
+        }
+        finalizeRender(workInProgressRootRenderLanes, renderStartTime);
+      }
+      if (0 !== (lanes & 3) || 0 !== (lanes & 60)) {
+        previousRenderStartTime =
+          0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime
+            ? blockingClampTime
+            : blockingUpdateTime;
+        endTime =
+          0 <= blockingEventTime && blockingEventTime < blockingClampTime
+            ? blockingClampTime
+            : blockingEventTime;
+        0 <= blockingSuspendedTime &&
+          (setCurrentTrackFromLanes(lanes),
+          logSuspendedWithDelayPhase(
+            blockingSuspendedTime,
+            0 <= endTime
+              ? endTime
+              : 0 <= previousRenderStartTime
+                ? previousRenderStartTime
+                : renderStartTime,
+            lanes
+          ));
+        var eventType = blockingEventType,
+          eventIsRepeat = blockingEventIsRepeat,
+          isSpawnedUpdate = blockingSpawnedUpdate,
+          renderStartTime$jscomp$0 = renderStartTime;
+        supportsUserTiming &&
+          ((reusableLaneDevToolDetails.track = "Blocking"),
+          0 < endTime &&
+            null !== eventType &&
+            ((reusableLaneDevToolDetails.color = eventIsRepeat
+              ? "secondary-light"
+              : "warning"),
+            (reusableLaneOptions.start = endTime),
+            (reusableLaneOptions.end =
+              0 < previousRenderStartTime
+                ? previousRenderStartTime
+                : renderStartTime$jscomp$0),
+            performance.measure(
+              eventIsRepeat ? "" : "Event: " + eventType,
+              reusableLaneOptions
+            )),
+          0 < previousRenderStartTime &&
+            ((reusableLaneDevToolDetails.color = isSpawnedUpdate
+              ? "error"
+              : (lanes & 738197589) === lanes
+                ? "tertiary-light"
+                : "primary-light"),
+            (reusableLaneOptions.start = previousRenderStartTime),
+            (reusableLaneOptions.end = renderStartTime$jscomp$0),
+            performance.measure(
+              isSpawnedUpdate ? "Cascade" : "Blocked",
+              reusableLaneOptions
+            )));
+        blockingSuspendedTime = blockingUpdateTime = -1.1;
+        blockingEventIsRepeat = !0;
+        blockingSpawnedUpdate = !1;
+      }
+      0 !== (lanes & 4194176) &&
+        ((previousRenderStartTime =
+          0 <= transitionStartTime && transitionStartTime < transitionClampTime
+            ? transitionClampTime
+            : transitionStartTime),
+        (endTime =
+          0 <= transitionUpdateTime &&
+          transitionUpdateTime < transitionClampTime
+            ? transitionClampTime
+            : transitionUpdateTime),
+        (eventType =
+          0 <= transitionEventTime && transitionEventTime < transitionClampTime
+            ? transitionClampTime
+            : transitionEventTime),
+        0 <= transitionSuspendedTime &&
+          (setCurrentTrackFromLanes(lanes),
+          logSuspendedWithDelayPhase(
+            transitionSuspendedTime,
+            0 <= eventType
+              ? eventType
+              : 0 <= endTime
+                ? endTime
+                : renderStartTime,
+            lanes
+          )),
+        (eventIsRepeat = transitionEventType),
+        (isSpawnedUpdate = transitionEventIsRepeat),
+        (renderStartTime$jscomp$0 = renderStartTime),
+        supportsUserTiming &&
+          ((reusableLaneDevToolDetails.track = "Transition"),
+          0 < eventType &&
+            null !== eventIsRepeat &&
+            ((reusableLaneDevToolDetails.color = isSpawnedUpdate
+              ? "secondary-light"
+              : "warning"),
+            (reusableLaneOptions.start = eventType),
+            (reusableLaneOptions.end =
+              0 < previousRenderStartTime
+                ? previousRenderStartTime
+                : 0 < endTime
+                  ? endTime
+                  : renderStartTime$jscomp$0),
+            performance.measure(
+              isSpawnedUpdate ? "" : "Event: " + eventIsRepeat,
+              reusableLaneOptions
+            )),
+          0 < previousRenderStartTime &&
+            ((reusableLaneDevToolDetails.color = "primary-dark"),
+            (reusableLaneOptions.start = previousRenderStartTime),
+            (reusableLaneOptions.end =
+              0 < endTime ? endTime : renderStartTime$jscomp$0),
+            performance.measure("Action", reusableLaneOptions)),
+          0 < endTime &&
+            ((reusableLaneDevToolDetails.color = "primary-light"),
+            (reusableLaneOptions.start = endTime),
+            (reusableLaneOptions.end = renderStartTime$jscomp$0),
+            performance.measure("Blocked", reusableLaneOptions))),
+        (transitionSuspendedTime =
+          transitionUpdateTime =
+          transitionStartTime =
+            -1.1),
+        (transitionEventIsRepeat = !0));
+      previousRenderStartTime = root.timeoutHandle;
+      previousRenderStartTime !== noTimeout &&
+        ((root.timeoutHandle = noTimeout),
+        cancelTimeout(previousRenderStartTime));
+      previousRenderStartTime = root.cancelPendingCommit;
+      null !== previousRenderStartTime &&
+        ((root.cancelPendingCommit = null), previousRenderStartTime());
       resetWorkInProgressStack();
       workInProgressRoot = root;
-      workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
+      workInProgress = previousRenderStartTime = createWorkInProgress(
+        root.current,
+        null
+      );
       workInProgressRootRenderLanes = lanes;
       workInProgressSuspendedReason = NotSuspended;
       workInProgressThrownValue = null;
@@ -14629,22 +16415,17 @@
       workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
       workInProgressAppearingViewTransitions = null;
       0 !== (lanes & 8) && (lanes |= lanes & 32);
-      var allEntangledLanes = root.entangledLanes;
-      if (0 !== allEntangledLanes)
-        for (
-          root = root.entanglements, allEntangledLanes &= lanes;
-          0 < allEntangledLanes;
-
-        ) {
-          var index = 31 - clz32(allEntangledLanes),
-            lane = 1 << index;
-          lanes |= root[index];
-          allEntangledLanes &= ~lane;
-        }
+      endTime = root.entangledLanes;
+      if (0 !== endTime)
+        for (root = root.entanglements, endTime &= lanes; 0 < endTime; )
+          (eventType = 31 - clz32(endTime)),
+            (eventIsRepeat = 1 << eventType),
+            (lanes |= root[eventType]),
+            (endTime &= ~eventIsRepeat);
       entangledRenderLanes = lanes;
       finishQueueingConcurrentUpdates();
       ReactStrictModeWarnings.discardPendingWarnings();
-      return timeoutHandle;
+      return previousRenderStartTime;
     }
     function handleThrow(root, thrownValue) {
       currentlyRenderingFiber = null;
@@ -14669,43 +16450,14 @@
                   : SuspendedOnError);
       workInProgressThrownValue = thrownValue;
       var erroredWork = workInProgress;
-      if (null === erroredWork)
-        (workInProgressRootExitStatus = RootFatalErrored),
+      null === erroredWork
+        ? ((workInProgressRootExitStatus = RootFatalErrored),
           logUncaughtError(
             root,
             createCapturedValueAtFiber(thrownValue, root.current)
-          );
-      else
-        switch (
-          (erroredWork.mode & ProfileMode &&
-            stopProfilerTimerIfRunningAndRecordDuration(erroredWork),
-          markComponentRenderStopped(),
-          workInProgressSuspendedReason)
-        ) {
-          case SuspendedOnError:
-            null !== injectedProfilingHooks &&
-              "function" ===
-                typeof injectedProfilingHooks.markComponentErrored &&
-              injectedProfilingHooks.markComponentErrored(
-                erroredWork,
-                thrownValue,
-                workInProgressRootRenderLanes
-              );
-            break;
-          case SuspendedOnData:
-          case SuspendedOnAction:
-          case SuspendedOnImmediate:
-          case SuspendedOnDeprecatedThrowPromise:
-          case SuspendedAndReadyToContinue:
-            null !== injectedProfilingHooks &&
-              "function" ===
-                typeof injectedProfilingHooks.markComponentSuspended &&
-              injectedProfilingHooks.markComponentSuspended(
-                erroredWork,
-                thrownValue,
-                workInProgressRootRenderLanes
-              );
-        }
+          ))
+        : erroredWork.mode & ProfileMode &&
+          stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
     }
     function pushDispatcher() {
       var prevDispatcher = ReactSharedInternals.H;
@@ -14734,6 +16486,23 @@
           !1
         );
     }
+    function queueConcurrentError(error) {
+      null === workInProgressRootConcurrentErrors
+        ? (workInProgressRootConcurrentErrors = [error])
+        : workInProgressRootConcurrentErrors.push(error);
+    }
+    function trackAppearingViewTransition(instance, name) {
+      if (null === workInProgressAppearingViewTransitions) {
+        if (
+          (workInProgressRootRenderLanes & 335544192) !==
+          workInProgressRootRenderLanes
+        )
+          return;
+        workInProgressAppearingViewTransitions = new Map();
+      }
+      instance.paired = null;
+      workInProgressAppearingViewTransitions.set(name, instance);
+    }
     function renderRootSync(root, lanes, shouldYieldForPrerendering) {
       var prevExecutionContext = executionContext;
       executionContext |= RenderContext;
@@ -14753,7 +16522,6 @@
         workInProgressTransitions = null;
         prepareFreshStack(root, lanes);
       }
-      markRenderStarted(lanes);
       lanes = !1;
       memoizedUpdaters = workInProgressRootExitStatus;
       a: do
@@ -14805,7 +16573,6 @@
       executionContext = prevExecutionContext;
       ReactSharedInternals.H = prevDispatcher;
       ReactSharedInternals.A = prevAsyncDispatcher;
-      markRenderStopped();
       null === workInProgress &&
         ((workInProgressRoot = null),
         (workInProgressRootRenderLanes = 0),
@@ -14839,7 +16606,6 @@
           root,
           lanes
         );
-      markRenderStarted(lanes);
       a: do
         try {
           if (
@@ -14968,14 +16734,7 @@
       ReactSharedInternals.H = prevDispatcher;
       ReactSharedInternals.A = prevAsyncDispatcher;
       executionContext = prevExecutionContext;
-      if (null !== workInProgress)
-        return (
-          null !== injectedProfilingHooks &&
-            "function" === typeof injectedProfilingHooks.markRenderYielded &&
-            injectedProfilingHooks.markRenderYielded(),
-          RootInProgress
-        );
-      markRenderStopped();
+      if (null !== workInProgress) return RootInProgress;
       workInProgressRoot = null;
       workInProgressRootRenderLanes = 0;
       finishQueueingConcurrentUpdates();
@@ -15190,7 +16949,11 @@
       didIncludeRenderPhaseUpdate,
       spawnedLane,
       updatedLanes,
-      suspendedRetryLanes
+      suspendedRetryLanes,
+      exitStatus,
+      suspendedCommitReason,
+      completedRenderStartTime,
+      completedRenderEndTime
     ) {
       root.cancelPendingCommit = null;
       do flushPendingEffects();
@@ -15199,11 +16962,29 @@
       ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
       if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
         throw Error("Should not already be working.");
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markCommitStarted &&
-        injectedProfilingHooks.markCommitStarted(lanes);
-      if (null === finishedWork) markCommitStopped();
-      else {
+      setCurrentTrackFromLanes(lanes);
+      exitStatus === RootErrored
+        ? logErroredRenderPhase(
+            completedRenderStartTime,
+            completedRenderEndTime
+          )
+        : null !== recoverableErrors
+          ? logRecoveredRenderPhase(
+              completedRenderStartTime,
+              completedRenderEndTime,
+              lanes,
+              recoverableErrors,
+              null !== finishedWork &&
+                null !== finishedWork.alternate &&
+                finishedWork.alternate.memoizedState.isDehydrated &&
+                0 !== (finishedWork.flags & 256)
+            )
+          : logRenderPhase(
+              completedRenderStartTime,
+              completedRenderEndTime,
+              lanes
+            );
+      if (null !== finishedWork) {
         0 === lanes &&
           console.error(
             "finishedLanes should not be empty during a commit. This is a bug in React."
@@ -15232,23 +17013,37 @@
         pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
         pendingPassiveTransitions = transitions;
         pendingRecoverableErrors = recoverableErrors;
-        0 !== (finishedWork.subtreeFlags & 10256) ||
-        0 !== (finishedWork.flags & 10256)
+        pendingViewTransitionEvents = null;
+        pendingEffectsRenderEndTime = completedRenderEndTime;
+        pendingSuspendedCommitReason = suspendedCommitReason;
+        recoverableErrors = (lanes & 335544192) === lanes ? 10262 : 10256;
+        0 !== finishedWork.actualDuration ||
+        0 !== (finishedWork.subtreeFlags & recoverableErrors) ||
+        0 !== (finishedWork.flags & recoverableErrors)
           ? ((root.callbackNode = null),
             (root.callbackPriority = 0),
             scheduleCallback$1(NormalPriority$1, function () {
+              schedulerEvent = window.event;
               flushPassiveEffects(!0);
               return null;
             }))
           : ((root.callbackNode = null), (root.callbackPriority = 0));
+        commitErrors = null;
         commitStartTime = now();
-        recoverableErrors = 0 !== (finishedWork.flags & 13878);
-        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
-          recoverableErrors = ReactSharedInternals.T;
+        suspendedCommitReason === SUSPENDED_COMMIT
+          ? logSuspendedCommitPhase(completedRenderEndTime, commitStartTime)
+          : suspendedCommitReason === THROTTLED_COMMIT &&
+            logSuspenseThrottlePhase(completedRenderEndTime, commitStartTime);
+        suspendedCommitReason = 0 !== (finishedWork.flags & 13878);
+        if (
+          0 !== (finishedWork.subtreeFlags & 13878) ||
+          suspendedCommitReason
+        ) {
+          suspendedCommitReason = ReactSharedInternals.T;
           ReactSharedInternals.T = null;
-          transitions = ReactDOMSharedInternals.p;
+          completedRenderEndTime = ReactDOMSharedInternals.p;
           ReactDOMSharedInternals.p = DiscreteEventPriority;
-          spawnedLane = executionContext;
+          recoverableErrors = executionContext;
           executionContext |= CommitContext;
           try {
             commitBeforeMutationEffects(
@@ -15258,16 +17053,32 @@
               appearingViewTransitions
             );
           } finally {
-            (executionContext = spawnedLane),
-              (ReactDOMSharedInternals.p = transitions),
-              (ReactSharedInternals.T = recoverableErrors);
+            (executionContext = recoverableErrors),
+              (ReactDOMSharedInternals.p = completedRenderEndTime),
+              (ReactSharedInternals.T = suspendedCommitReason);
           }
         }
         pendingEffectsStatus = PENDING_MUTATION_PHASE;
-        flushMutationEffects();
-        flushLayoutEffects();
-        flushSpawnedWork();
-      }
+        (shouldStartViewTransition &&
+          startViewTransition(
+            root.containerInfo,
+            flushMutationEffects,
+            flushLayoutEffects,
+            flushAfterMutationEffects,
+            flushSpawnedWork,
+            flushPassiveEffects
+          )) ||
+          (flushMutationEffects(), flushLayoutEffects(), flushSpawnedWork());
+      }
+    }
+    function flushAfterMutationEffects() {
+      pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE &&
+        ((pendingEffectsStatus = NO_PENDING_EFFECTS),
+        commitAfterMutationEffectsOnFiber(
+          pendingFinishedWork,
+          pendingEffectsRoot
+        ),
+        (pendingEffectsStatus = PENDING_SPAWNED_WORK));
     }
     function flushMutationEffects() {
       if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
@@ -15289,7 +17100,8 @@
           try {
             inProgressLanes = lanes;
             inProgressRoot = root;
-            commitMutationEffectsOnFiber(finishedWork, root);
+            resetComponentEffectTimers();
+            commitMutationEffectsOnFiber(finishedWork, root, lanes);
             inProgressRoot = inProgressLanes = null;
             lanes = selectionInformation;
             var curFocusedElem = getActiveElementDeep(root.containerInfo),
@@ -15416,22 +17228,15 @@
           var prevExecutionContext = executionContext;
           executionContext |= CommitContext;
           try {
-            null !== injectedProfilingHooks &&
-              "function" ===
-                typeof injectedProfilingHooks.markLayoutEffectsStarted &&
-              injectedProfilingHooks.markLayoutEffectsStarted(lanes),
-              (inProgressLanes = lanes),
+            (inProgressLanes = lanes),
               (inProgressRoot = root),
+              resetComponentEffectTimers(),
               commitLayoutEffectOnFiber(
                 root,
                 finishedWork.alternate,
                 finishedWork
               ),
-              (inProgressRoot = inProgressLanes = null),
-              null !== injectedProfilingHooks &&
-                "function" ===
-                  typeof injectedProfilingHooks.markLayoutEffectsStopped &&
-                injectedProfilingHooks.markLayoutEffectsStopped();
+              (inProgressRoot = inProgressLanes = null);
           } finally {
             (executionContext = prevExecutionContext),
               (ReactDOMSharedInternals.p = previousPriority),
@@ -15451,21 +17256,43 @@
         var root = pendingEffectsRoot,
           finishedWork = pendingFinishedWork,
           lanes = pendingEffectsLanes,
+          completedRenderEndTime = pendingEffectsRenderEndTime,
           recoverableErrors = pendingRecoverableErrors,
-          rootDidHavePassiveEffects =
-            0 !== (finishedWork.subtreeFlags & 10256) ||
-            0 !== (finishedWork.flags & 10256);
-        rootDidHavePassiveEffects
+          suspendedCommitReason = pendingSuspendedCommitReason;
+        commitEndTime = now();
+        completedRenderEndTime =
+          suspendedCommitReason === IMMEDIATE_COMMIT
+            ? completedRenderEndTime
+            : commitStartTime;
+        suspendedCommitReason = commitEndTime;
+        null !== commitErrors
+          ? logCommitErrored(
+              completedRenderEndTime,
+              suspendedCommitReason,
+              commitErrors,
+              !1
+            )
+          : supportsUserTiming &&
+            ((reusableLaneDevToolDetails.color = "secondary-dark"),
+            (reusableLaneOptions.start = completedRenderEndTime),
+            (reusableLaneOptions.end = suspendedCommitReason),
+            performance.measure("Commit", reusableLaneOptions));
+        completedRenderEndTime = (lanes & 335544192) === lanes ? 10262 : 10256;
+        (completedRenderEndTime =
+          0 !== finishedWork.actualDuration ||
+          0 !== (finishedWork.subtreeFlags & completedRenderEndTime) ||
+          0 !== (finishedWork.flags & completedRenderEndTime))
           ? (pendingEffectsStatus = PENDING_PASSIVE_PHASE)
           : ((pendingEffectsStatus = NO_PENDING_EFFECTS),
             (pendingEffectsRoot = null),
             releaseRootPooledCache(root, root.pendingLanes),
             (nestedPassiveUpdateCount = 0),
             (rootWithPassiveNestedUpdates = null));
-        var remainingLanes = root.pendingLanes;
-        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
-        rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root);
-        rootDidHavePassiveEffects = lanesToEventPriority(lanes);
+        suspendedCommitReason = root.pendingLanes;
+        0 === suspendedCommitReason &&
+          (legacyErrorBoundariesThatAlreadyFailed = null);
+        completedRenderEndTime || commitDoubleInvokeEffectsInDEV(root);
+        suspendedCommitReason = lanesToEventPriority(lanes);
         finishedWork = finishedWork.stateNode;
         if (
           injectedHook &&
@@ -15473,7 +17300,7 @@
         )
           try {
             var didError = 128 === (finishedWork.current.flags & 128);
-            switch (rootDidHavePassiveEffects) {
+            switch (suspendedCommitReason) {
               case DiscreteEventPriority:
                 var schedulerPriority = ImmediatePriority;
                 break;
@@ -15531,17 +17358,25 @@
               (ReactDOMSharedInternals.p = schedulerPriority);
           }
         }
+        recoverableErrors = pendingViewTransitionEvents;
+        if (null !== recoverableErrors)
+          for (
+            pendingViewTransitionEvents = null, onRecoverableError = 0;
+            onRecoverableError < recoverableErrors.length;
+            onRecoverableError++
+          )
+            (0, recoverableErrors[onRecoverableError])();
         0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
         ensureRootIsScheduled(root);
-        remainingLanes = root.pendingLanes;
-        0 !== (lanes & 4194218) && 0 !== (remainingLanes & 42)
+        suspendedCommitReason = root.pendingLanes;
+        0 !== (lanes & 4194218) && 0 !== (suspendedCommitReason & 42)
           ? ((nestedUpdateScheduled = !0),
             root === rootWithNestedUpdates
               ? nestedUpdateCount++
               : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)))
           : (nestedUpdateCount = 0);
+        completedRenderEndTime || finalizeRender(lanes, commitEndTime);
         flushSyncWorkAcrossRoots_impl(0, !1);
-        markCommitStopped();
       }
     }
     function makeErrorInfo(componentStack) {
@@ -15567,7 +17402,7 @@
       flushSpawnedWork();
       return flushPassiveEffects(wasDelayedCommit);
     }
-    function flushPassiveEffects() {
+    function flushPassiveEffects(wasDelayedCommit) {
       if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return !1;
       var root = pendingEffectsRoot,
         remainingLanes = pendingEffectsRemainingLanes;
@@ -15582,42 +17417,70 @@
       try {
         ReactDOMSharedInternals.p = priority;
         ReactSharedInternals.T = null;
-        priority = pendingPassiveTransitions;
+        var transitions = pendingPassiveTransitions;
         pendingPassiveTransitions = null;
-        var root$jscomp$0 = pendingEffectsRoot,
-          lanes = pendingEffectsLanes;
+        priority = pendingEffectsRoot;
+        var lanes = pendingEffectsLanes;
         pendingEffectsStatus = NO_PENDING_EFFECTS;
         pendingEffectsRoot = null;
         pendingEffectsLanes = 0;
         if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
           throw Error("Cannot flush passive effects while already rendering.");
+        setCurrentTrackFromLanes(lanes);
         isFlushingPassiveEffects = !0;
         didScheduleUpdateDuringPassiveEffects = !1;
-        null !== injectedProfilingHooks &&
-          "function" ===
-            typeof injectedProfilingHooks.markPassiveEffectsStarted &&
-          injectedProfilingHooks.markPassiveEffectsStarted(lanes);
-        var prevExecutionContext = executionContext;
+        var passiveEffectStartTime = 0;
+        commitErrors = null;
+        passiveEffectStartTime = now$1();
+        var startTime = commitEndTime,
+          endTime = passiveEffectStartTime;
+        wasDelayedCommit = !!wasDelayedCommit;
+        supportsUserTiming &&
+          ((reusableLaneDevToolDetails.color = "secondary-light"),
+          (reusableLaneOptions.start = startTime),
+          (reusableLaneOptions.end = endTime),
+          performance.measure(
+            wasDelayedCommit ? "Waiting for Paint" : "",
+            reusableLaneOptions
+          ));
+        wasDelayedCommit = executionContext;
         executionContext |= CommitContext;
-        commitPassiveUnmountOnFiber(root$jscomp$0.current);
+        var finishedWork = priority.current;
+        resetComponentEffectTimers();
+        commitPassiveUnmountOnFiber(finishedWork);
+        var finishedWork$jscomp$0 = priority.current;
+        finishedWork = pendingEffectsRenderEndTime;
+        resetComponentEffectTimers();
         commitPassiveMountOnFiber(
-          root$jscomp$0,
-          root$jscomp$0.current,
+          priority,
+          finishedWork$jscomp$0,
           lanes,
-          priority
+          transitions,
+          finishedWork
         );
-        null !== injectedProfilingHooks &&
-          "function" ===
-            typeof injectedProfilingHooks.markPassiveEffectsStopped &&
-          injectedProfilingHooks.markPassiveEffectsStopped();
-        commitDoubleInvokeEffectsInDEV(root$jscomp$0);
-        executionContext = prevExecutionContext;
+        commitDoubleInvokeEffectsInDEV(priority);
+        executionContext = wasDelayedCommit;
+        var passiveEffectsEndTime = now$1();
+        finishedWork$jscomp$0 = passiveEffectStartTime;
+        null !== commitErrors
+          ? logCommitErrored(
+              finishedWork$jscomp$0,
+              passiveEffectsEndTime,
+              commitErrors,
+              !0
+            )
+          : supportsUserTiming &&
+            ((reusableLaneDevToolDetails.color = "secondary-dark"),
+            (reusableLaneOptions.start = finishedWork$jscomp$0),
+            (reusableLaneOptions.end = passiveEffectsEndTime),
+            performance.measure("Remaining Effects", reusableLaneOptions));
+        finalizeRender(lanes, passiveEffectsEndTime);
         flushSyncWorkAcrossRoots_impl(0, !1);
         didScheduleUpdateDuringPassiveEffects
-          ? root$jscomp$0 === rootWithPassiveNestedUpdates
+          ? priority === rootWithPassiveNestedUpdates
             ? nestedPassiveUpdateCount++
             : ((nestedPassiveUpdateCount = 0),
-              (rootWithPassiveNestedUpdates = root$jscomp$0))
+              (rootWithPassiveNestedUpdates = priority))
           : (nestedPassiveUpdateCount = 0);
         didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;
         if (
@@ -15625,7 +17488,7 @@
           "function" === typeof injectedHook.onPostCommitFiberRoot
         )
           try {
-            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
+            injectedHook.onPostCommitFiberRoot(rendererID, priority);
           } catch (err) {
             hasLoggedError ||
               ((hasLoggedError = !0),
@@ -15634,7 +17497,7 @@
                 err
               ));
           }
-        var stateNode = root$jscomp$0.current.stateNode;
+        var stateNode = priority.current.stateNode;
         stateNode.effectDuration = 0;
         stateNode.passiveEffectDuration = 0;
         return !0;
@@ -15646,6 +17509,7 @@
     }
     function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
       sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+      recordEffectError(sourceFiber);
       sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
       rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
       null !== rootFiber &&
@@ -15679,6 +17543,7 @@
                   !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
             ) {
               sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+              recordEffectError(sourceFiber);
               error = createClassErrorUpdate(2);
               instance = enqueueUpdate(nearestMountedAncestor, error, 2);
               null !== instance &&
@@ -15723,6 +17588,12 @@
       null !== pingCache && pingCache.delete(wakeable);
       root.pingedLanes |= root.suspendedLanes & pingedLanes;
       root.warmLanes &= ~pingedLanes;
+      0 !== (pingedLanes & 3) || 0 !== (pingedLanes & 60)
+        ? 0 > blockingUpdateTime &&
+          (blockingClampTime = blockingUpdateTime = now())
+        : 0 !== (pingedLanes & 4194176) &&
+          0 > transitionUpdateTime &&
+          (transitionClampTime = transitionUpdateTime = now());
       isConcurrentActEnvironment() &&
         null === ReactSharedInternals.actQueue &&
         console.error(
@@ -15950,6 +17821,7 @@
       }
     }
     function processRootScheduleInImmediateTask() {
+      schedulerEvent = window.event;
       processRootScheduleInMicrotask();
     }
     function processRootScheduleInMicrotask() {
@@ -16020,47 +17892,49 @@
           (root.callbackPriority = 0)
         );
       if (
-        0 === (suspendedLanes & 3) ||
-        checkIfRootIsPrerendering(root, suspendedLanes)
-      ) {
-        currentTime = suspendedLanes & -suspendedLanes;
-        if (
-          currentTime !== root.callbackPriority ||
-          (null !== ReactSharedInternals.actQueue &&
-            pingedLanes !== fakeActCallbackNode)
-        )
-          cancelCallback(pingedLanes);
-        else return currentTime;
-        switch (lanesToEventPriority(suspendedLanes)) {
-          case DiscreteEventPriority:
-          case ContinuousEventPriority:
-            suspendedLanes = UserBlockingPriority;
-            break;
-          case DefaultEventPriority:
-            suspendedLanes = NormalPriority$1;
-            break;
-          case IdleEventPriority:
-            suspendedLanes = IdlePriority;
-            break;
-          default:
-            suspendedLanes = NormalPriority$1;
-        }
-        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
-        null !== ReactSharedInternals.actQueue
-          ? (ReactSharedInternals.actQueue.push(pingedLanes),
-            (suspendedLanes = fakeActCallbackNode))
-          : (suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes));
-        root.callbackPriority = currentTime;
-        root.callbackNode = suspendedLanes;
-        return currentTime;
-      }
-      null !== pingedLanes && cancelCallback(pingedLanes);
-      root.callbackPriority = 2;
-      root.callbackNode = null;
-      return 2;
+        0 !== (suspendedLanes & 3) &&
+        !checkIfRootIsPrerendering(root, suspendedLanes)
+      )
+        return (
+          null !== pingedLanes && cancelCallback(pingedLanes),
+          (root.callbackPriority = 2),
+          (root.callbackNode = null),
+          2
+        );
+      currentTime = suspendedLanes & -suspendedLanes;
+      if (
+        currentTime !== root.callbackPriority ||
+        (null !== ReactSharedInternals.actQueue &&
+          pingedLanes !== fakeActCallbackNode)
+      )
+        cancelCallback(pingedLanes);
+      else return currentTime;
+      switch (lanesToEventPriority(suspendedLanes)) {
+        case DiscreteEventPriority:
+        case ContinuousEventPriority:
+          suspendedLanes = UserBlockingPriority;
+          break;
+        case DefaultEventPriority:
+          suspendedLanes = NormalPriority$1;
+          break;
+        case IdleEventPriority:
+          suspendedLanes = IdlePriority;
+          break;
+        default:
+          suspendedLanes = NormalPriority$1;
+      }
+      pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
+      null !== ReactSharedInternals.actQueue
+        ? (ReactSharedInternals.actQueue.push(pingedLanes),
+          (suspendedLanes = fakeActCallbackNode))
+        : (suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes));
+      root.callbackPriority = currentTime;
+      root.callbackNode = suspendedLanes;
+      return currentTime;
     }
     function performWorkOnRootViaSchedulerTask(root, didTimeout) {
       nestedUpdateScheduled = currentUpdateIsNested = !1;
+      schedulerEvent = window.event;
       if (
         pendingEffectsStatus !== NO_PENDING_EFFECTS &&
         pendingEffectsStatus !== PENDING_PASSIVE_PHASE
@@ -16228,6 +18102,15 @@
         });
       }
     }
+    function executeDispatch(event, listener, currentTarget) {
+      event.currentTarget = currentTarget;
+      try {
+        listener(event);
+      } catch (error) {
+        reportGlobalError(error);
+      }
+      event.currentTarget = null;
+    }
     function processDispatchQueue(dispatchQueue, eventSystemFlags) {
       eventSystemFlags = 0 !== (eventSystemFlags & 4);
       for (var i = 0; i < dispatchQueue.length; i++) {
@@ -16248,14 +18131,15 @@
               _dispatchListeners$i = _dispatchListeners$i.listener;
               if (instance !== previousInstance && event.isPropagationStopped())
                 break a;
-              previousInstance = event;
-              previousInstance.currentTarget = currentTarget;
-              try {
-                _dispatchListeners$i(previousInstance);
-              } catch (error) {
-                reportGlobalError(error);
-              }
-              previousInstance.currentTarget = null;
+              null !== instance
+                ? runWithFiberInDEV(
+                    instance,
+                    executeDispatch,
+                    event,
+                    _dispatchListeners$i,
+                    currentTarget
+                  )
+                : executeDispatch(event, _dispatchListeners$i, currentTarget);
               previousInstance = instance;
             }
           else
@@ -16270,14 +18154,15 @@
               _dispatchListeners$i = _dispatchListeners$i.listener;
               if (instance !== previousInstance && event.isPropagationStopped())
                 break a;
-              previousInstance = event;
-              previousInstance.currentTarget = currentTarget;
-              try {
-                _dispatchListeners$i(previousInstance);
-              } catch (error) {
-                reportGlobalError(error);
-              }
-              previousInstance.currentTarget = null;
+              null !== instance
+                ? runWithFiberInDEV(
+                    instance,
+                    executeDispatch,
+                    event,
+                    _dispatchListeners$i,
+                    currentTarget
+                  )
+                : executeDispatch(event, _dispatchListeners$i, currentTarget);
               previousInstance = instance;
             }
         }
@@ -17062,6 +18947,7 @@
           else if ("number" === typeof value || "bigint" === typeof value)
             validateTextNesting("" + value, tag),
               "body" !== tag && setTextContent(domElement, "" + value);
+          else return;
           break;
         case "className":
           setValueForKnownAttribute(domElement, "class", value);
@@ -17078,7 +18964,7 @@
           break;
         case "style":
           setValueForStyles(domElement, value, prevValue);
-          break;
+          return;
         case "data":
           if ("object" !== tag) {
             setValueForKnownAttribute(domElement, "data", value);
@@ -17252,19 +19138,19 @@
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             (domElement.onclick = noop$2));
-          break;
+          return;
         case "onScroll":
           null != value &&
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             listenToNonDelegatedEvent("scroll", domElement));
-          break;
+          return;
         case "onScrollEnd":
           null != value &&
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             listenToNonDelegatedEvent("scrollend", domElement));
-          break;
+          return;
         case "dangerouslySetInnerHTML":
           if (null != value) {
             if ("object" !== typeof value || !("__html" in value))
@@ -17482,7 +19368,7 @@
           break;
         case "innerText":
         case "textContent":
-          break;
+          return;
         case "popoverTarget":
           didWarnPopoverTargetObject ||
             null == value ||
@@ -17493,16 +19379,22 @@
               value
             ));
         default:
-          !(2 < key.length) ||
-          ("o" !== key[0] && "O" !== key[0]) ||
-          ("n" !== key[1] && "N" !== key[1])
-            ? ((key = getAttributeAlias(key)),
-              setValueForAttribute(domElement, key, value))
-            : registrationNameDependencies.hasOwnProperty(key) &&
+          if (
+            !(2 < key.length) ||
+            ("o" !== key[0] && "O" !== key[0]) ||
+            ("n" !== key[1] && "N" !== key[1])
+          )
+            (key = getAttributeAlias(key)),
+              setValueForAttribute(domElement, key, value);
+          else {
+            registrationNameDependencies.hasOwnProperty(key) &&
               null != value &&
               "function" !== typeof value &&
               warnForInvalidEventListener(key, value);
+            return;
+          }
       }
+      viewTransitionMutationContext = !0;
     }
     function setPropOnCustomElement(
       domElement,
@@ -17515,7 +19407,7 @@
       switch (key) {
         case "style":
           setValueForStyles(domElement, value, prevValue);
-          break;
+          return;
         case "dangerouslySetInnerHTML":
           if (null != value) {
             if ("object" !== typeof value || !("__html" in value))
@@ -17533,37 +19425,37 @@
           }
           break;
         case "children":
-          "string" === typeof value
-            ? setTextContent(domElement, value)
-            : ("number" === typeof value || "bigint" === typeof value) &&
-              setTextContent(domElement, "" + value);
+          if ("string" === typeof value) setTextContent(domElement, value);
+          else if ("number" === typeof value || "bigint" === typeof value)
+            setTextContent(domElement, "" + value);
+          else return;
           break;
         case "onScroll":
           null != value &&
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             listenToNonDelegatedEvent("scroll", domElement));
-          break;
+          return;
         case "onScrollEnd":
           null != value &&
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             listenToNonDelegatedEvent("scrollend", domElement));
-          break;
+          return;
         case "onClick":
           null != value &&
             ("function" !== typeof value &&
               warnForInvalidEventListener(key, value),
             (domElement.onclick = noop$2));
-          break;
+          return;
         case "suppressContentEditableWarning":
         case "suppressHydrationWarning":
         case "innerHTML":
         case "ref":
-          break;
+          return;
         case "innerText":
         case "textContent":
-          break;
+          return;
         default:
           if (registrationNameDependencies.hasOwnProperty(key))
             null != value &&
@@ -17591,13 +19483,16 @@
                 domElement.addEventListener(tag, value, props);
                 break a;
               }
+              viewTransitionMutationContext = !0;
               key in domElement
                 ? (domElement[key] = value)
                 : !0 === value
                   ? domElement.setAttribute(key, "")
                   : setValueForAttribute(domElement, key, value);
             }
+          return;
       }
+      viewTransitionMutationContext = !0;
     }
     function setInitialProperties(domElement, tag, props) {
       validatePropertiesInDevelopment(tag, props);
@@ -17915,21 +19810,27 @@
             )
               switch (_propKey8) {
                 case "type":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   type = propKey;
                   break;
                 case "name":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   name = propKey;
                   break;
                 case "checked":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   checked = propKey;
                   break;
                 case "defaultChecked":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   defaultChecked = propKey;
                   break;
                 case "value":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   value = propKey;
                   break;
                 case "defaultValue":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
                   defaultValue = propKey;
                   break;
                 case "children":
@@ -18017,13 +19918,19 @@
             )
               switch (name) {
                 case "value":
+                  type !== lastDefaultValue &&
+                    (viewTransitionMutationContext = !0);
                   _propKey8 = type;
                   break;
                 case "defaultValue":
+                  type !== lastDefaultValue &&
+                    (viewTransitionMutationContext = !0);
                   defaultValue = type;
                   break;
                 case "multiple":
-                  value = type;
+                  type !== lastDefaultValue &&
+                    (viewTransitionMutationContext = !0),
+                    (value = type);
                 default:
                   type !== lastDefaultValue &&
                     setProp(
@@ -18070,9 +19977,11 @@
             )
               switch (value) {
                 case "value":
+                  name !== type && (viewTransitionMutationContext = !0);
                   _propKey8 = name;
                   break;
                 case "defaultValue":
+                  name !== type && (viewTransitionMutationContext = !0);
                   propKey = name;
                   break;
                 case "children":
@@ -18121,6 +20030,7 @@
             )
               switch (lastDefaultValue) {
                 case "selected":
+                  _propKey8 !== propKey && (viewTransitionMutationContext = !0);
                   domElement.selected =
                     _propKey8 &&
                     "function" !== typeof _propKey8 &&
@@ -19183,6 +21093,14 @@
       currentPopstateTransitionEvent = null;
       return !1;
     }
+    function resolveEventType() {
+      var event = window.event;
+      return event && event !== schedulerEvent ? event.type : null;
+    }
+    function resolveEventTimeStamp() {
+      var event = window.event;
+      return event && event !== schedulerEvent ? event.timeStamp : -1.1;
+    }
     function handleErrorInNextTick(error) {
       setTimeout(function () {
         throw error;
@@ -19216,20 +21134,9 @@
       parentInstance.removeChild(child);
     }
     function removeChildFromContainer(container, child) {
-      switch (container.nodeType) {
-        case 8:
-          container = container.parentNode;
-          break;
-        case 9:
-          container = container.body;
-          break;
-        default:
-          container =
-            "HTML" === container.nodeName
-              ? container.ownerDocument.body
-              : container;
-      }
-      container.removeChild(child);
+      8 === container.nodeType
+        ? container.parentNode.removeChild(child)
+        : container.removeChild(child);
     }
     function clearSuspenseBoundary(parentInstance, suspenseInstance) {
       var node = suspenseInstance,
@@ -19275,6 +21182,134 @@
     function unhideTextInstance(textInstance, text) {
       textInstance.nodeValue = text;
     }
+    function restoreViewTransitionName(instance, props) {
+      props = props[STYLE];
+      var viewTransitionName =
+        null != props
+          ? props.hasOwnProperty("viewTransitionName")
+            ? props.viewTransitionName
+            : props.hasOwnProperty("view-transition-name")
+              ? props["view-transition-name"]
+              : null
+          : null;
+      instance.style.viewTransitionName =
+        null == viewTransitionName || "boolean" === typeof viewTransitionName
+          ? ""
+          : ("" + viewTransitionName).trim();
+      props =
+        null != props
+          ? props.hasOwnProperty("viewTransitionClass")
+            ? props.viewTransitionClass
+            : props.hasOwnProperty("view-transition-class")
+              ? props["view-transition-class"]
+              : null
+          : null;
+      instance.style.viewTransitionClass =
+        null == props || "boolean" === typeof props ? "" : ("" + props).trim();
+    }
+    function measureInstance(instance) {
+      var ownerWindow = instance.ownerDocument.defaultView,
+        rect = instance.getBoundingClientRect();
+      instance = getComputedStyle(instance);
+      return {
+        rect: rect,
+        abs: "absolute" === instance.position || "fixed" === instance.position,
+        clip:
+          "none" !== instance.clipPath ||
+          "visible" !== instance.overflow ||
+          "none" !== instance.filter ||
+          "none" !== instance.mask ||
+          "none" !== instance.mask ||
+          "0px" !== instance.borderRadius,
+        view:
+          0 <= rect.bottom &&
+          0 <= rect.right &&
+          rect.top <= ownerWindow.innerHeight &&
+          rect.left <= ownerWindow.innerWidth
+      };
+    }
+    function startViewTransition(
+      rootContainer,
+      mutationCallback,
+      layoutCallback,
+      afterMutationCallback,
+      spawnedWorkCallback,
+      passiveCallback
+    ) {
+      var ownerDocument =
+        9 === rootContainer.nodeType
+          ? rootContainer
+          : rootContainer.ownerDocument;
+      try {
+        var transition = ownerDocument.startViewTransition({
+          update: function () {
+            var ownerWindow = ownerDocument.defaultView;
+            ownerWindow =
+              ownerWindow.navigation && ownerWindow.navigation.transition;
+            var previousFontLoadingStatus = ownerDocument.fonts.status;
+            mutationCallback();
+            if (
+              "loaded" === previousFontLoadingStatus &&
+              (ownerDocument.documentElement.clientHeight,
+              "loading" === ownerDocument.fonts.status)
+            )
+              return (
+                (previousFontLoadingStatus = Promise.race([
+                  ownerDocument.fonts.ready,
+                  new Promise(function (resolve) {
+                    return setTimeout(resolve, SUSPENSEY_FONT_TIMEOUT);
+                  })
+                ]).then(layoutCallback, layoutCallback)),
+                (ownerWindow
+                  ? Promise.allSettled([
+                      ownerWindow.finished,
+                      previousFontLoadingStatus
+                    ])
+                  : previousFontLoadingStatus
+                ).then(afterMutationCallback, afterMutationCallback)
+              );
+            layoutCallback();
+            if (ownerWindow)
+              return ownerWindow.finished.then(
+                afterMutationCallback,
+                afterMutationCallback
+              );
+            afterMutationCallback();
+          },
+          types: null
+        });
+        ownerDocument.__reactViewTransition = transition;
+        transition.ready.then(void 0, function (reason) {
+          "object" === typeof reason &&
+            null !== reason &&
+            "TimeoutError" === reason.name &&
+            console.error(
+              "A ViewTransition timed out because a Navigation stalled. This can happen if a Navigation is blocked on React itself. Such as if it's resolved inside useEffect. This can be solved by moving the resolution to useLayoutEffect."
+            );
+        });
+        transition.ready.then(spawnedWorkCallback, spawnedWorkCallback);
+        transition.finished.then(function () {
+          ownerDocument.__reactViewTransition = null;
+          passiveCallback();
+        });
+        return !0;
+      } catch (x) {
+        return !1;
+      }
+    }
+    function ViewTransitionPseudoElement(pseudo, name) {
+      this._scope = document.documentElement;
+      this._selector = "::view-transition-" + pseudo + "(" + name + ")";
+    }
+    function createViewTransitionInstance(name) {
+      return {
+        name: name,
+        group: new ViewTransitionPseudoElement("group", name),
+        imagePair: new ViewTransitionPseudoElement("image-pair", name),
+        old: new ViewTransitionPseudoElement("old", name),
+        new: new ViewTransitionPseudoElement("new", name)
+      };
+    }
     function clearContainerSparingly(container) {
       var nextNode = container.firstChild;
       nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
@@ -19575,11 +21610,6 @@
       instance[internalInstanceKey] = internalInstanceHandle;
       instance[internalPropsKey] = props;
     }
-    function releaseSingletonInstance(instance) {
-      for (var attributes = instance.attributes; attributes.length; )
-        instance.removeAttributeNode(attributes[0]);
-      detachDeletedInstance(instance);
-    }
     function getHoistableRoot(container) {
       return "function" === typeof container.getRootNode
         ? container.getRootNode()
@@ -20265,38 +22295,6 @@
         resource.state.loading |= Inserted;
       }
     }
-    function bindToConsole(methodName, args, badgeName) {
-      var offset = 0;
-      switch (methodName) {
-        case "dir":
-        case "dirxml":
-        case "groupEnd":
-        case "table":
-          return bind.apply(console[methodName], [console].concat(args));
-        case "assert":
-          offset = 1;
-      }
-      args = args.slice(0);
-      "string" === typeof args[offset]
-        ? args.splice(
-            offset,
-            1,
-            badgeFormat + args[offset],
-            badgeStyle,
-            pad + badgeName + pad,
-            resetStyle
-          )
-        : args.splice(
-            offset,
-            0,
-            badgeFormat,
-            badgeStyle,
-            pad + badgeName + pad,
-            resetStyle
-          );
-      args.unshift(console);
-      return bind.apply(console[methodName], args);
-    }
     function FiberRootNode(
       containerInfo,
       tag,
@@ -20430,9 +22428,6 @@
               err
             ));
         }
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markRenderScheduled &&
-        injectedProfilingHooks.markRenderScheduled(lane);
       parentComponent = getContextForSubtree(parentComponent);
       null === container.context
         ? (container.context = parentComponent)
@@ -20457,7 +22452,8 @@
         (container.callback = callback));
       element = enqueueUpdate(rootFiber, container, lane);
       null !== element &&
-        (scheduleUpdateOnFiber(element, rootFiber, lane),
+        (startUpdateTimerByLane(lane),
+        scheduleUpdateOnFiber(element, rootFiber, lane),
         entangleTransitions(element, rootFiber, lane));
     }
     function markRetryLaneImpl(fiber, retryLane) {
@@ -20481,14 +22477,6 @@
     function getCurrentFiberForDevTools() {
       return current;
     }
-    function getLaneLabelMap() {
-      for (var map = new Map(), lane = 1, index = 0; 31 > index; index++) {
-        var label = getLabelForLane(lane);
-        map.set(lane, label);
-        lane *= 2;
-      }
-      return map;
-    }
     function dispatchDiscreteEvent(
       domEventName,
       eventSystemFlags,
@@ -21125,12 +23113,14 @@
       REACT_MEMO_TYPE = Symbol.for("react.memo"),
       REACT_LAZY_TYPE = Symbol.for("react.lazy");
     Symbol.for("react.scope");
-    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
-    Symbol.for("react.legacy_hidden");
+    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
+      REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
     Symbol.for("react.tracing_marker");
-    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-    Symbol.for("react.view_transition");
-    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+      REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+      REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
+      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+      ASYNC_ITERATOR = Symbol.asyncIterator,
       REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
       isArrayImpl = Array.isArray,
       ReactSharedInternals =
@@ -21166,7 +23156,6 @@
       unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
       rendererID = null,
       injectedHook = null,
-      injectedProfilingHooks = null,
       hasLoggedError = !1,
       isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__,
       clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
@@ -21204,6 +23193,7 @@
       ),
       illegalAttributeNameCache = {},
       validatedAttributeNameCache = {},
+      viewTransitionMutationContext = !1,
       disabledDepth = 0,
       prevLog,
       prevInfo,
@@ -22402,10 +24392,96 @@
       now = Scheduler.unstable_now,
       renderStartTime = -0,
       commitStartTime = -0,
+      commitEndTime = -0,
+      commitErrors = null,
       profilerStartTime = -1.1,
       profilerEffectDuration = -0,
+      componentEffectDuration = -0,
+      componentEffectStartTime = -1.1,
+      componentEffectEndTime = -1.1,
+      componentEffectErrors = null,
+      blockingClampTime = -0,
+      blockingUpdateTime = -1.1,
+      blockingEventTime = -1.1,
+      blockingEventType = null,
+      blockingEventIsRepeat = !1,
+      blockingSpawnedUpdate = !1,
+      blockingSuspendedTime = -1.1,
+      transitionClampTime = -0,
+      transitionStartTime = -1.1,
+      transitionUpdateTime = -1.1,
+      transitionEventTime = -1.1,
+      transitionEventType = null,
+      transitionEventIsRepeat = !1,
+      transitionSuspendedTime = -1.1,
+      yieldReason = 0,
+      yieldStartTime = -1.1,
       currentUpdateIsNested = !1,
       nestedUpdateScheduled = !1,
+      supportsUserTiming =
+        "undefined" !== typeof performance &&
+        "function" === typeof performance.measure,
+      COMPONENTS_TRACK = "Components \u269b",
+      reusableComponentDevToolDetails = {
+        color: "primary",
+        track: COMPONENTS_TRACK
+      },
+      reusableComponentOptions = {
+        start: -0,
+        end: -0,
+        detail: { devtools: reusableComponentDevToolDetails }
+      },
+      LANES_TRACK_GROUP = "Scheduler \u269b",
+      reusableLaneDevToolDetails = {
+        color: "primary",
+        track: "Blocking",
+        trackGroup: LANES_TRACK_GROUP
+      },
+      reusableLaneOptions = {
+        start: -0,
+        end: -0,
+        detail: { devtools: reusableLaneDevToolDetails }
+      },
+      blockingLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Blocking",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
+      transitionLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Transition",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
+      suspenseLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Suspense",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
+      idleLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Idle",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
       valueCursor = createCursor(null);
     var rendererCursorDEV = createCursor(null);
     var rendererSigil = {};
@@ -22676,9 +24752,9 @@
             (warnOnInvalidCallback(callback), (update.callback = callback));
           payload = enqueueUpdate(inst, update, lane);
           null !== payload &&
-            (scheduleUpdateOnFiber(payload, inst, lane),
+            (startUpdateTimerByLane(lane),
+            scheduleUpdateOnFiber(payload, inst, lane),
             entangleTransitions(payload, inst, lane));
-          markStateUpdateScheduled(inst, lane);
         },
         enqueueReplaceState: function (inst, payload, callback) {
           inst = inst._reactInternals;
@@ -22691,9 +24767,9 @@
             (warnOnInvalidCallback(callback), (update.callback = callback));
           payload = enqueueUpdate(inst, update, lane);
           null !== payload &&
-            (scheduleUpdateOnFiber(payload, inst, lane),
+            (startUpdateTimerByLane(lane),
+            scheduleUpdateOnFiber(payload, inst, lane),
             entangleTransitions(payload, inst, lane));
-          markStateUpdateScheduled(inst, lane);
         },
         enqueueForceUpdate: function (inst, callback) {
           inst = inst._reactInternals;
@@ -22705,12 +24781,9 @@
             (warnOnInvalidCallback(callback), (update.callback = callback));
           callback = enqueueUpdate(inst, update, lane);
           null !== callback &&
-            (scheduleUpdateOnFiber(callback, inst, lane),
+            (startUpdateTimerByLane(lane),
+            scheduleUpdateOnFiber(callback, inst, lane),
             entangleTransitions(callback, inst, lane));
-          null !== injectedProfilingHooks &&
-            "function" ===
-              typeof injectedProfilingHooks.markForceUpdateScheduled &&
-            injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
         }
       },
       forkStack = [],
@@ -22744,10 +24817,25 @@
       prevEntangledRenderLanesCursor = createCursor(0),
       prevOnStartTransitionFinish = ReactSharedInternals.S;
     ReactSharedInternals.S = function (transition, returnValue) {
-      "object" === typeof returnValue &&
+      if (
+        "object" === typeof returnValue &&
         null !== returnValue &&
-        "function" === typeof returnValue.then &&
+        "function" === typeof returnValue.then
+      ) {
+        if (0 > transitionStartTime && 0 > transitionUpdateTime) {
+          transitionStartTime = now();
+          var newEventTime = resolveEventTimeStamp(),
+            newEventType = resolveEventType();
+          if (
+            newEventTime !== transitionEventTime ||
+            newEventType !== transitionEventType
+          )
+            transitionEventIsRepeat = !1;
+          transitionEventTime = newEventTime;
+          transitionEventType = newEventType;
+        }
         entangleAsyncAction(transition, returnValue);
+      }
       null !== prevOnStartTransitionFinish &&
         prevOnStartTransitionFinish(transition, returnValue);
     };
@@ -22767,7 +24855,7 @@
       localIdCounter = 0,
       thenableIndexCounter$1 = 0,
       thenableState$1 = null,
-      globalClientIdCounter = 0,
+      globalClientIdCounter$1 = 0,
       RE_RENDER_LIMIT = 25,
       currentHookNameInDev = null,
       hookTypesDev = null,
@@ -22797,8 +24885,9 @@
         useOptimistic: throwInvalidHookError,
         useMemoCache: throwInvalidHookError,
         useCacheRefresh: throwInvalidHookError
-      },
-      HooksDispatcherOnMountInDEV = null,
+      };
+    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
+    var HooksDispatcherOnMountInDEV = null,
       HooksDispatcherOnMountWithHookTypesInDEV = null,
       HooksDispatcherOnUpdateInDEV = null,
       HooksDispatcherOnRerenderInDEV = null,
@@ -22938,6 +25027,11 @@
         currentHookNameInDev = "useCacheRefresh";
         mountHookTypesDev();
         return mountRefresh();
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        mountHookTypesDev();
+        return mountEvent(callback);
       }
     };
     HooksDispatcherOnMountWithHookTypesInDEV = {
@@ -23067,6 +25161,11 @@
         currentHookNameInDev = "useCacheRefresh";
         updateHookTypesDev();
         return mountRefresh();
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        updateHookTypesDev();
+        return mountEvent(callback);
       }
     };
     HooksDispatcherOnUpdateInDEV = {
@@ -23196,6 +25295,11 @@
         currentHookNameInDev = "useCacheRefresh";
         updateHookTypesDev();
         return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        updateHookTypesDev();
+        return updateEvent(callback);
       }
     };
     HooksDispatcherOnRerenderInDEV = {
@@ -23325,6 +25429,11 @@
         currentHookNameInDev = "useCacheRefresh";
         updateHookTypesDev();
         return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        updateHookTypesDev();
+        return updateEvent(callback);
       }
     };
     InvalidNestedHooksDispatcherOnMountInDEV = {
@@ -23478,6 +25587,12 @@
         currentHookNameInDev = "useCacheRefresh";
         mountHookTypesDev();
         return mountRefresh();
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountEvent(callback);
       }
     };
     InvalidNestedHooksDispatcherOnUpdateInDEV = {
@@ -23631,6 +25746,12 @@
         currentHookNameInDev = "useCacheRefresh";
         updateHookTypesDev();
         return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateEvent(callback);
       }
     };
     InvalidNestedHooksDispatcherOnRerenderInDEV = {
@@ -23784,6 +25905,12 @@
         currentHookNameInDev = "useCacheRefresh";
         updateHookTypesDev();
         return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateEvent(callback);
       }
     };
     var callComponent = {
@@ -24029,9 +26156,14 @@
       nextEffect = null,
       inProgressLanes = null,
       inProgressRoot = null,
+      shouldStartViewTransition = !1,
+      viewTransitionContextChanged = !1,
+      viewTransitionCancelableChildren = null,
+      viewTransitionHostInstanceIdx = 0,
       hostParent = null,
       hostParentIsContainer = !1,
       currentHoistableRoot = null,
+      inHydratedSubtree = !1,
       suspenseyCommitFlag = 8192;
     var hasBadMapPolyfill = !1;
     try {
@@ -24051,6 +26183,7 @@
       HydrationMismatchException = Error(
         "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
       ),
+      globalClientIdCounter = 0,
       DefaultAsyncDispatcher = {
         getCacheForType: function (resourceType) {
           var cache = readContext(CacheContext),
@@ -24134,8 +26267,11 @@
       pendingFinishedWork = null,
       pendingEffectsLanes = 0,
       pendingEffectsRemainingLanes = 0,
+      pendingEffectsRenderEndTime = -0,
       pendingPassiveTransitions = null,
       pendingRecoverableErrors = null,
+      pendingViewTransitionEvents = null,
+      pendingSuspendedCommitReason = IMMEDIATE_COMMIT,
       NESTED_UPDATE_LIMIT = 50,
       nestedUpdateCount = 0,
       rootWithNestedUpdates = null,
@@ -24249,6 +26385,7 @@
       selectionInformation = null,
       warnedUnknownTags = { dialog: !0, webview: !0 },
       currentPopstateTransitionEvent = null,
+      schedulerEvent = void 0,
       scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
       cancelTimeout =
         "function" === typeof clearTimeout ? clearTimeout : void 0,
@@ -24265,7 +26402,37 @@
                   .catch(handleErrorInNextTick);
               }
             : scheduleTimeout,
-      NotLoaded = 0,
+      SUSPENSEY_FONT_TIMEOUT = 500;
+    ViewTransitionPseudoElement.prototype.animate = function (
+      keyframes,
+      options
+    ) {
+      options =
+        "number" === typeof options
+          ? { duration: options }
+          : assign({}, options);
+      options.pseudoElement = this._selector;
+      return this._scope.animate(keyframes, options);
+    };
+    ViewTransitionPseudoElement.prototype.getAnimations = function () {
+      for (
+        var scope = this._scope,
+          selector = this._selector,
+          animations = scope.getAnimations({ subtree: !0 }),
+          result = [],
+          i = 0;
+        i < animations.length;
+        i++
+      ) {
+        var effect = animations[i].effect;
+        null !== effect &&
+          effect.target === scope &&
+          effect.pseudoElement === selector &&
+          result.push(animations[i]);
+      }
+      return result;
+    };
+    var NotLoaded = 0,
       Loaded = 1,
       Errored = 2,
       Settled = 3,
@@ -24680,11 +26847,11 @@
     };
     (function () {
       var isomorphicReactPackageVersion = React.version;
-      if ("19.1.0-canary-c492f975-20250128" !== isomorphicReactPackageVersion)
+      if ("19.1.0-experimental-b3a95caf-20250113" !== isomorphicReactPackageVersion)
         throw Error(
           'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
             (isomorphicReactPackageVersion +
-              "\n  - react-dom:  19.1.0-canary-c492f975-20250128\nLearn more: https://react.dev/warnings/version-mismatch")
+              "\n  - react-dom:  19.1.0-experimental-b3a95caf-20250113\nLearn more: https://react.dev/warnings/version-mismatch")
         );
     })();
     ("function" === typeof Map &&
@@ -24721,10 +26888,10 @@
       !(function () {
         var internals = {
           bundleType: 1,
-          version: "19.1.0-canary-c492f975-20250128",
+          version: "19.1.0-experimental-b3a95caf-20250113",
           rendererPackageName: "react-dom",
           currentDispatcherRef: ReactSharedInternals,
-          reconcilerVersion: "19.1.0-canary-c492f975-20250128"
+          reconcilerVersion: "19.1.0-experimental-b3a95caf-20250113"
         };
         internals.overrideHookState = overrideHookState;
         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
@@ -24739,8 +26906,6 @@
         internals.scheduleRoot = scheduleRoot;
         internals.setRefreshHandler = setRefreshHandler;
         internals.getCurrentFiber = getCurrentFiberForDevTools;
-        internals.getLaneLabelMap = getLaneLabelMap;
-        internals.injectProfilingHooks = injectProfilingHooks;
         return injectInternals(internals);
       })() &&
       canUseDOM &&
@@ -25200,7 +27365,7 @@
     exports.useFormStatus = function () {
       return resolveDispatcher().useHostTransitionStatus();
     };
-    exports.version = "19.1.0-canary-c492f975-20250128";
+    exports.version = "19.1.0-experimental-b3a95caf-20250113";
     "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
       "function" ===
         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
diff --git a/node_modules/react-dom/cjs/react-dom-profiling.profiling.js b/node_modules/react-dom/cjs/react-dom-profiling.profiling.js
index 31f748b..4c639a6 100644
--- a/node_modules/react-dom/cjs/react-dom-profiling.profiling.js
+++ b/node_modules/react-dom/cjs/react-dom-profiling.profiling.js
@@ -162,12 +162,13 @@ var assign = Object.assign,
   REACT_MEMO_TYPE = Symbol.for("react.memo"),
   REACT_LAZY_TYPE = Symbol.for("react.lazy");
 Symbol.for("react.scope");
-var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
-Symbol.for("react.legacy_hidden");
+var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
+  REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
 Symbol.for("react.tracing_marker");
-var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
-Symbol.for("react.view_transition");
-var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+  REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
+  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
 function getIteratorFn(maybeIterable) {
   if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
   maybeIterable =
@@ -175,7 +176,8 @@ function getIteratorFn(maybeIterable) {
     maybeIterable["@@iterator"];
   return "function" === typeof maybeIterable ? maybeIterable : null;
 }
-var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
+var ASYNC_ITERATOR = Symbol.asyncIterator,
+  REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
 function getComponentNameFromType(type) {
   if (null == type) return null;
   if ("function" === typeof type)
@@ -196,6 +198,8 @@ function getComponentNameFromType(type) {
       return "Suspense";
     case REACT_SUSPENSE_LIST_TYPE:
       return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
   }
   if ("object" === typeof type)
     switch (type.$$typeof) {
@@ -226,6 +230,64 @@ function getComponentNameFromType(type) {
     }
   return null;
 }
+function getComponentNameFromFiber(fiber) {
+  var type = fiber.type;
+  switch (fiber.tag) {
+    case 24:
+      return "Cache";
+    case 9:
+      return (type._context.displayName || "Context") + ".Consumer";
+    case 10:
+      return (type.displayName || "Context") + ".Provider";
+    case 18:
+      return "DehydratedFragment";
+    case 11:
+      return (
+        (fiber = type.render),
+        (fiber = fiber.displayName || fiber.name || ""),
+        type.displayName ||
+          ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef")
+      );
+    case 7:
+      return "Fragment";
+    case 26:
+    case 27:
+    case 5:
+      return type;
+    case 4:
+      return "Portal";
+    case 3:
+      return "Root";
+    case 6:
+      return "Text";
+    case 16:
+      return getComponentNameFromType(type);
+    case 8:
+      return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
+    case 22:
+      return "Offscreen";
+    case 12:
+      return "Profiler";
+    case 21:
+      return "Scope";
+    case 13:
+      return "Suspense";
+    case 19:
+      return "SuspenseList";
+    case 25:
+      return "TracingMarker";
+    case 30:
+      return "ViewTransition";
+    case 1:
+    case 0:
+    case 14:
+    case 15:
+      if ("function" === typeof type)
+        return type.displayName || type.name || null;
+      if ("string" === typeof type) return type;
+  }
+  return null;
+}
 var isArrayImpl = Array.isArray,
   ReactSharedInternals =
     React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
@@ -328,7 +390,6 @@ var hasOwnProperty = Object.prototype.hasOwnProperty,
   unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
   rendererID = null,
   injectedHook = null,
-  injectedProfilingHooks = null,
   isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__;
 function setIsStrictModeForDevtools(newIsStrictMode) {
   "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
@@ -337,36 +398,6 @@ function setIsStrictModeForDevtools(newIsStrictMode) {
       injectedHook.setStrictMode(rendererID, newIsStrictMode);
     } catch (err) {}
 }
-function markCommitStopped() {
-  null !== injectedProfilingHooks &&
-    "function" === typeof injectedProfilingHooks.markCommitStopped &&
-    injectedProfilingHooks.markCommitStopped();
-}
-function markComponentRenderStarted(fiber) {
-  null !== injectedProfilingHooks &&
-    "function" === typeof injectedProfilingHooks.markComponentRenderStarted &&
-    injectedProfilingHooks.markComponentRenderStarted(fiber);
-}
-function markComponentRenderStopped() {
-  null !== injectedProfilingHooks &&
-    "function" === typeof injectedProfilingHooks.markComponentRenderStopped &&
-    injectedProfilingHooks.markComponentRenderStopped();
-}
-function markRenderStarted(lanes) {
-  null !== injectedProfilingHooks &&
-    "function" === typeof injectedProfilingHooks.markRenderStarted &&
-    injectedProfilingHooks.markRenderStarted(lanes);
-}
-function markRenderStopped() {
-  null !== injectedProfilingHooks &&
-    "function" === typeof injectedProfilingHooks.markRenderStopped &&
-    injectedProfilingHooks.markRenderStopped();
-}
-function markStateUpdateScheduled(fiber, lane) {
-  null !== injectedProfilingHooks &&
-    "function" === typeof injectedProfilingHooks.markStateUpdateScheduled &&
-    injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
-}
 var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
   log = Math.log,
   LN2 = Math.LN2;
@@ -374,22 +405,6 @@ function clz32Fallback(x) {
   x >>>= 0;
   return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
 }
-function getLabelForLane(lane) {
-  if (lane & 1) return "SyncHydrationLane";
-  if (lane & 2) return "Sync";
-  if (lane & 4) return "InputContinuousHydration";
-  if (lane & 8) return "InputContinuous";
-  if (lane & 16) return "DefaultHydration";
-  if (lane & 32) return "Default";
-  if (lane & 64) return "TransitionHydration";
-  if (lane & 4194176) return "Transition";
-  if (lane & 62914560) return "Retry";
-  if (lane & 67108864) return "SelectiveHydration";
-  if (lane & 134217728) return "IdleHydration";
-  if (lane & 268435456) return "Idle";
-  if (lane & 536870912) return "Offscreen";
-  if (lane & 1073741824) return "Deferred";
-}
 var nextTransitionLane = 128,
   nextRetryLane = 4194304;
 function getHighestPriorityLanes(lanes) {
@@ -823,6 +838,7 @@ function isAttributeNameSafe(attributeName) {
   illegalAttributeNameCache[attributeName] = !0;
   return !1;
 }
+var viewTransitionMutationContext = !1;
 function setValueForAttribute(node, name, value) {
   if (isAttributeNameSafe(name))
     if (null === value) node.removeAttribute(name);
@@ -1041,6 +1057,8 @@ function describeFiber(fiber) {
       return describeNativeComponentFrame(fiber.type.render, !1);
     case 1:
       return describeNativeComponentFrame(fiber.type, !0);
+    case 30:
+      return describeBuiltInComponentFrame("ViewTransition");
     default:
       return "";
   }
@@ -1353,12 +1371,14 @@ function setValueForStyles(node, styles, prevStyles) {
           ? node.setProperty(styleName, "")
           : "float" === styleName
             ? (node.cssFloat = "")
-            : (node[styleName] = ""));
+            : (node[styleName] = ""),
+        (viewTransitionMutationContext = !0));
     for (var styleName$18 in styles)
       (styleName = styles[styleName$18]),
         styles.hasOwnProperty(styleName$18) &&
           prevStyles[styleName$18] !== styleName &&
-          setValueForStyle(node, styleName$18, styleName);
+          (setValueForStyle(node, styleName$18, styleName),
+          (viewTransitionMutationContext = !0));
   } else
     for (var styleName$19 in styles)
       styles.hasOwnProperty(styleName$19) &&
@@ -2096,19 +2116,19 @@ function getTargetInstForChangeEvent(domEventName, targetInst) {
 }
 var isInputEventSupported = !1;
 if (canUseDOM) {
-  var JSCompiler_inline_result$jscomp$297;
+  var JSCompiler_inline_result$jscomp$308;
   if (canUseDOM) {
-    var isSupported$jscomp$inline_433 = "oninput" in document;
-    if (!isSupported$jscomp$inline_433) {
-      var element$jscomp$inline_434 = document.createElement("div");
-      element$jscomp$inline_434.setAttribute("oninput", "return;");
-      isSupported$jscomp$inline_433 =
-        "function" === typeof element$jscomp$inline_434.oninput;
-    }
-    JSCompiler_inline_result$jscomp$297 = isSupported$jscomp$inline_433;
-  } else JSCompiler_inline_result$jscomp$297 = !1;
+    var isSupported$jscomp$inline_447 = "oninput" in document;
+    if (!isSupported$jscomp$inline_447) {
+      var element$jscomp$inline_448 = document.createElement("div");
+      element$jscomp$inline_448.setAttribute("oninput", "return;");
+      isSupported$jscomp$inline_447 =
+        "function" === typeof element$jscomp$inline_448.oninput;
+    }
+    JSCompiler_inline_result$jscomp$308 = isSupported$jscomp$inline_447;
+  } else JSCompiler_inline_result$jscomp$308 = !1;
   isInputEventSupported =
-    JSCompiler_inline_result$jscomp$297 &&
+    JSCompiler_inline_result$jscomp$308 &&
     (!document.documentMode || 9 < document.documentMode);
 }
 function stopWatchingForValueChange() {
@@ -2458,9 +2478,59 @@ function getRootForUpdatedFiber(sourceFiber) {
 }
 var emptyContextObject = {},
   now = Scheduler.unstable_now,
+  renderStartTime = -0,
   commitStartTime = -0,
+  commitEndTime = -0,
+  commitErrors = null,
   profilerStartTime = -1.1,
-  profilerEffectDuration = -0;
+  profilerEffectDuration = -0,
+  componentEffectDuration = -0,
+  componentEffectStartTime = -1.1,
+  componentEffectEndTime = -1.1,
+  componentEffectErrors = null,
+  blockingClampTime = -0,
+  blockingUpdateTime = -1.1,
+  blockingEventTime = -1.1,
+  blockingEventType = null,
+  blockingEventIsRepeat = !1,
+  blockingSpawnedUpdate = !1,
+  blockingSuspendedTime = -1.1,
+  transitionClampTime = -0,
+  transitionStartTime = -1.1,
+  transitionUpdateTime = -1.1,
+  transitionEventTime = -1.1,
+  transitionEventType = null,
+  transitionEventIsRepeat = !1,
+  transitionSuspendedTime = -1.1,
+  yieldReason = 0,
+  yieldStartTime = -1.1;
+function startUpdateTimerByLane(lane) {
+  var JSCompiler_temp;
+  (JSCompiler_temp = 0 !== (lane & 3)) || (JSCompiler_temp = 0 !== (lane & 60));
+  if (JSCompiler_temp)
+    0 > blockingUpdateTime &&
+      ((blockingUpdateTime = now()),
+      0 !== (executionContext & 6) && (blockingSpawnedUpdate = !0),
+      (lane = resolveEventTimeStamp()),
+      (JSCompiler_temp = resolveEventType()),
+      lane !== blockingEventTime || JSCompiler_temp !== blockingEventType
+        ? (blockingEventIsRepeat = !1)
+        : null !== JSCompiler_temp && (blockingSpawnedUpdate = !0),
+      (blockingEventTime = lane),
+      (blockingEventType = JSCompiler_temp));
+  else if (
+    0 !== (lane & 4194176) &&
+    0 > transitionUpdateTime &&
+    ((transitionUpdateTime = now()), 0 > transitionStartTime)
+  ) {
+    lane = resolveEventTimeStamp();
+    JSCompiler_temp = resolveEventType();
+    if (lane !== transitionEventTime || JSCompiler_temp !== transitionEventType)
+      transitionEventIsRepeat = !1;
+    transitionEventTime = lane;
+    transitionEventType = JSCompiler_temp;
+  }
+}
 function pushNestedEffectDurations() {
   var prevEffectDuration = profilerEffectDuration;
   profilerEffectDuration = 0;
@@ -2476,6 +2546,23 @@ function bubbleNestedEffectDurations(prevEffectDuration) {
   profilerEffectDuration += prevEffectDuration;
   return elapsedTime;
 }
+function resetComponentEffectTimers() {
+  componentEffectEndTime = componentEffectStartTime = -1.1;
+}
+function pushComponentEffectStart() {
+  var prevEffectStart = componentEffectStartTime;
+  componentEffectStartTime = -1.1;
+  componentEffectDuration = -0;
+  return prevEffectStart;
+}
+function popComponentEffectStart(prevEffectStart) {
+  0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
+}
+function pushComponentEffectErrors() {
+  var prevErrors = componentEffectErrors;
+  componentEffectErrors = null;
+  return prevErrors;
+}
 var currentUpdateIsNested = !1,
   nestedUpdateScheduled = !1;
 function startProfilerTimer(fiber) {
@@ -2499,18 +2586,250 @@ function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
 }
 function recordEffectDuration() {
   if (0 <= profilerStartTime) {
-    var elapsedTime = now() - profilerStartTime;
+    var endTime = now(),
+      elapsedTime = endTime - profilerStartTime;
     profilerStartTime = -1;
     profilerEffectDuration += elapsedTime;
+    componentEffectDuration += elapsedTime;
+    componentEffectEndTime = endTime;
   }
 }
+function recordEffectError(errorInfo) {
+  null === componentEffectErrors && (componentEffectErrors = []);
+  componentEffectErrors.push(errorInfo);
+  null === commitErrors && (commitErrors = []);
+  commitErrors.push(errorInfo);
+}
 function startEffectTimer() {
   profilerStartTime = now();
+  0 > componentEffectStartTime &&
+    (componentEffectStartTime = profilerStartTime);
 }
 function transferActualDuration(fiber) {
   for (var child = fiber.child; child; )
     (fiber.actualDuration += child.actualDuration), (child = child.sibling);
 }
+var supportsUserTiming =
+    "undefined" !== typeof performance &&
+    "function" === typeof performance.measure,
+  reusableComponentDevToolDetails = {
+    color: "primary",
+    track: "Components \u269b"
+  },
+  reusableComponentOptions = {
+    start: -0,
+    end: -0,
+    detail: { devtools: reusableComponentDevToolDetails }
+  },
+  reusableLaneDevToolDetails = {
+    color: "primary",
+    track: "Blocking",
+    trackGroup: "Scheduler \u269b"
+  },
+  reusableLaneOptions = {
+    start: -0,
+    end: -0,
+    detail: { devtools: reusableLaneDevToolDetails }
+  };
+function setCurrentTrackFromLanes(lanes) {
+  reusableLaneDevToolDetails.track =
+    lanes & 63
+      ? "Blocking"
+      : lanes & 4194240
+        ? "Transition"
+        : lanes & 62914560
+          ? "Suspense"
+          : lanes & 2080374784
+            ? "Idle"
+            : "Other";
+}
+var blockingLaneMarker = {
+    startTime: 0.003,
+    detail: {
+      devtools: {
+        color: "primary-light",
+        track: "Blocking",
+        trackGroup: "Scheduler \u269b"
+      }
+    }
+  },
+  transitionLaneMarker = {
+    startTime: 0.003,
+    detail: {
+      devtools: {
+        color: "primary-light",
+        track: "Transition",
+        trackGroup: "Scheduler \u269b"
+      }
+    }
+  },
+  suspenseLaneMarker = {
+    startTime: 0.003,
+    detail: {
+      devtools: {
+        color: "primary-light",
+        track: "Suspense",
+        trackGroup: "Scheduler \u269b"
+      }
+    }
+  },
+  idleLaneMarker = {
+    startTime: 0.003,
+    detail: {
+      devtools: {
+        color: "primary-light",
+        track: "Idle",
+        trackGroup: "Scheduler \u269b"
+      }
+    }
+  };
+function logComponentRender(fiber, startTime, endTime, wasHydrated) {
+  var name = getComponentNameFromFiber(fiber);
+  if (null !== name && supportsUserTiming) {
+    var selfTime = fiber.actualDuration;
+    if (null === fiber.alternate || fiber.alternate.child !== fiber.child)
+      for (fiber = fiber.child; null !== fiber; fiber = fiber.sibling)
+        selfTime -= fiber.actualDuration;
+    reusableComponentDevToolDetails.color =
+      0.5 > selfTime
+        ? wasHydrated
+          ? "tertiary-light"
+          : "primary-light"
+        : 10 > selfTime
+          ? wasHydrated
+            ? "tertiary"
+            : "primary"
+          : 100 > selfTime
+            ? wasHydrated
+              ? "tertiary-dark"
+              : "primary-dark"
+            : "error";
+    reusableComponentOptions.start = startTime;
+    reusableComponentOptions.end = endTime;
+    performance.measure(name, reusableComponentOptions);
+  }
+}
+function logComponentErrored(fiber, startTime, endTime) {
+  if (supportsUserTiming) {
+    var name = getComponentNameFromFiber(fiber);
+    null !== name &&
+      performance.measure(name, {
+        start: startTime,
+        end: endTime,
+        detail: {
+          devtools: {
+            color: "error",
+            track: "Components \u269b",
+            tooltipText:
+              13 === fiber.tag
+                ? "Hydration failed"
+                : "Error boundary caught an error",
+            properties: []
+          }
+        }
+      });
+  }
+}
+function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
+  null !== errors
+    ? supportsUserTiming &&
+      ((selfTime = getComponentNameFromFiber(fiber)),
+      null !== selfTime &&
+        performance.measure(selfTime, {
+          start: startTime,
+          end: endTime,
+          detail: {
+            devtools: {
+              color: "error",
+              track: "Components \u269b",
+              tooltipText: "A lifecycle or effect errored",
+              properties: []
+            }
+          }
+        }))
+    : ((fiber = getComponentNameFromFiber(fiber)),
+      null !== fiber &&
+        supportsUserTiming &&
+        ((reusableComponentDevToolDetails.color =
+          1 > selfTime
+            ? "secondary-light"
+            : 100 > selfTime
+              ? "secondary"
+              : 500 > selfTime
+                ? "secondary-dark"
+                : "error"),
+        (reusableComponentOptions.start = startTime),
+        (reusableComponentOptions.end = endTime),
+        performance.measure(fiber, reusableComponentOptions)));
+}
+function logRenderPhase(startTime, endTime, lanes) {
+  supportsUserTiming &&
+    ((reusableLaneDevToolDetails.color =
+      (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+    (reusableLaneOptions.start = startTime),
+    (reusableLaneOptions.end = endTime),
+    performance.measure(
+      (lanes & 536870912) === lanes
+        ? "Prepared"
+        : (lanes & 201326677) === lanes
+          ? "Hydrated"
+          : "Render",
+      reusableLaneOptions
+    ));
+}
+function logSuspendedRenderPhase(startTime, endTime, lanes) {
+  supportsUserTiming &&
+    ((reusableLaneDevToolDetails.color =
+      (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+    (reusableLaneOptions.start = startTime),
+    (reusableLaneOptions.end = endTime),
+    performance.measure("Prewarm", reusableLaneOptions));
+}
+function logSuspendedWithDelayPhase(startTime, endTime, lanes) {
+  supportsUserTiming &&
+    ((reusableLaneDevToolDetails.color =
+      (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+    (reusableLaneOptions.start = startTime),
+    (reusableLaneOptions.end = endTime),
+    performance.measure("Suspended", reusableLaneOptions));
+}
+function logErroredRenderPhase(startTime, endTime) {
+  supportsUserTiming &&
+    ((reusableLaneDevToolDetails.color = "error"),
+    (reusableLaneOptions.start = startTime),
+    (reusableLaneOptions.end = endTime),
+    performance.measure("Errored", reusableLaneOptions));
+}
+function logSuspenseThrottlePhase(startTime, endTime) {
+  supportsUserTiming &&
+    ((reusableLaneDevToolDetails.color = "secondary-light"),
+    (reusableLaneOptions.start = startTime),
+    (reusableLaneOptions.end = endTime),
+    performance.measure("Throttled", reusableLaneOptions));
+}
+function logSuspendedCommitPhase(startTime, endTime) {
+  supportsUserTiming &&
+    ((reusableLaneDevToolDetails.color = "secondary-light"),
+    (reusableLaneOptions.start = startTime),
+    (reusableLaneOptions.end = endTime),
+    performance.measure("Suspended", reusableLaneOptions));
+}
+function logCommitErrored(startTime, endTime, errors, passive) {
+  supportsUserTiming &&
+    performance.measure("Errored", {
+      start: startTime,
+      end: endTime,
+      detail: {
+        devtools: {
+          color: "error",
+          track: reusableLaneDevToolDetails.track,
+          trackGroup: "Scheduler \u269b",
+          tooltipText: passive ? "Remaining Effects Errored" : "Commit Errored",
+          properties: []
+        }
+      }
+    });
+}
 var valueCursor = createCursor(null),
   currentlyRenderingFiber$1 = null,
   lastContextDependency = null;
@@ -2702,7 +3021,8 @@ function entangleAsyncAction(transition, thenable) {
 function pingEngtangledActionScope() {
   if (
     0 === --currentEntangledPendingCount &&
-    null !== currentEntangledListeners
+    (-1 < transitionUpdateTime || (transitionStartTime = -1.1),
+    null !== currentEntangledListeners)
   ) {
     null !== currentEntangledActionThenable &&
       (currentEntangledActionThenable.status = "fulfilled");
@@ -3049,9 +3369,9 @@ var classComponentUpdater = {
     void 0 !== callback && null !== callback && (update.callback = callback);
     payload = enqueueUpdate(inst, update, lane);
     null !== payload &&
-      (scheduleUpdateOnFiber(payload, inst, lane),
+      (startUpdateTimerByLane(lane),
+      scheduleUpdateOnFiber(payload, inst, lane),
       entangleTransitions(payload, inst, lane));
-    markStateUpdateScheduled(inst, lane);
   },
   enqueueReplaceState: function (inst, payload, callback) {
     inst = inst._reactInternals;
@@ -3062,9 +3382,9 @@ var classComponentUpdater = {
     void 0 !== callback && null !== callback && (update.callback = callback);
     payload = enqueueUpdate(inst, update, lane);
     null !== payload &&
-      (scheduleUpdateOnFiber(payload, inst, lane),
+      (startUpdateTimerByLane(lane),
+      scheduleUpdateOnFiber(payload, inst, lane),
       entangleTransitions(payload, inst, lane));
-    markStateUpdateScheduled(inst, lane);
   },
   enqueueForceUpdate: function (inst, callback) {
     inst = inst._reactInternals;
@@ -3074,11 +3394,9 @@ var classComponentUpdater = {
     void 0 !== callback && null !== callback && (update.callback = callback);
     callback = enqueueUpdate(inst, update, lane);
     null !== callback &&
-      (scheduleUpdateOnFiber(callback, inst, lane),
+      (startUpdateTimerByLane(lane),
+      scheduleUpdateOnFiber(callback, inst, lane),
       entangleTransitions(callback, inst, lane));
-    null !== injectedProfilingHooks &&
-      "function" === typeof injectedProfilingHooks.markForceUpdateScheduled &&
-      injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
   }
 };
 function checkShouldComponentUpdate(
@@ -3120,9 +3438,9 @@ function resolveClassComponentProps(Component, baseProps) {
   }
   if ((Component = Component.defaultProps)) {
     newProps === baseProps && (newProps = assign({}, newProps));
-    for (var propName$30 in Component)
-      void 0 === newProps[propName$30] &&
-        (newProps[propName$30] = Component[propName$30]);
+    for (var propName$32 in Component)
+      void 0 === newProps[propName$32] &&
+        (newProps[propName$32] = Component[propName$32]);
   }
   return newProps;
 }
@@ -3135,6 +3453,15 @@ var forkStack = [],
   treeContextProvider = null,
   treeContextId = 1,
   treeContextOverflow = "";
+function getTreeId() {
+  var overflow = treeContextOverflow,
+    idWithLeadingBit = treeContextId;
+  return (
+    (idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))).toString(
+      32
+    ) + overflow
+  );
+}
 function pushTreeFork(workInProgress, totalChildren) {
   forkStack[forkStackIndex++] = treeForkCount;
   forkStack[forkStackIndex++] = treeForkProvider;
@@ -3283,10 +3610,25 @@ function popHiddenContext() {
 }
 var prevOnStartTransitionFinish = ReactSharedInternals.S;
 ReactSharedInternals.S = function (transition, returnValue) {
-  "object" === typeof returnValue &&
+  if (
+    "object" === typeof returnValue &&
     null !== returnValue &&
-    "function" === typeof returnValue.then &&
+    "function" === typeof returnValue.then
+  ) {
+    if (0 > transitionStartTime && 0 > transitionUpdateTime) {
+      transitionStartTime = now();
+      var newEventTime = resolveEventTimeStamp(),
+        newEventType = resolveEventType();
+      if (
+        newEventTime !== transitionEventTime ||
+        newEventType !== transitionEventType
+      )
+        transitionEventIsRepeat = !1;
+      transitionEventTime = newEventTime;
+      transitionEventType = newEventType;
+    }
     entangleAsyncAction(transition, returnValue);
+  }
   null !== prevOnStartTransitionFinish &&
     prevOnStartTransitionFinish(transition, returnValue);
 };
@@ -3318,7 +3660,7 @@ var renderLanes = 0,
   localIdCounter = 0,
   thenableIndexCounter$1 = 0,
   thenableState$1 = null,
-  globalClientIdCounter = 0;
+  globalClientIdCounter$1 = 0;
 function throwInvalidHookError() {
   throw Error(formatProdErrorMessage(321));
 }
@@ -3574,7 +3916,7 @@ function updateReducerImpl(hook, current, reducer) {
     var newBaseQueueFirst = (baseFirst = null),
       newBaseQueueLast = null,
       update = current,
-      didReadFromEntangledAsyncAction$35 = !1;
+      didReadFromEntangledAsyncAction$37 = !1;
     do {
       var updateLane = update.lane & -536870913;
       if (
@@ -3595,11 +3937,11 @@ function updateReducerImpl(hook, current, reducer) {
                 next: null
               }),
             updateLane === currentEntangledLane &&
-              (didReadFromEntangledAsyncAction$35 = !0);
+              (didReadFromEntangledAsyncAction$37 = !0);
         else if ((renderLanes & revertLane) === revertLane) {
           update = update.next;
           revertLane === currentEntangledLane &&
-            (didReadFromEntangledAsyncAction$35 = !0);
+            (didReadFromEntangledAsyncAction$37 = !0);
           continue;
         } else
           (updateLane = {
@@ -3645,7 +3987,7 @@ function updateReducerImpl(hook, current, reducer) {
     if (
       !objectIs(pendingQueue, hook.memoizedState) &&
       ((didReceiveUpdate = !0),
-      didReadFromEntangledAsyncAction$35 &&
+      didReadFromEntangledAsyncAction$37 &&
         ((reducer = currentEntangledActionThenable), null !== reducer))
     )
       throw reducer;
@@ -3847,8 +4189,8 @@ function runActionStateAction(actionQueue, node) {
     try {
       (prevTransition = action(prevState, payload)),
         handleActionReturnValue(actionQueue, node, prevTransition);
-    } catch (error$41) {
-      onActionError(actionQueue, node, error$41);
+    } catch (error$43) {
+      onActionError(actionQueue, node, error$43);
     }
 }
 function handleActionReturnValue(actionQueue, node, returnValue) {
@@ -4096,6 +4438,28 @@ function mountEffect(create, deps) {
 function updateEffect(create, deps) {
   updateEffectImpl(2048, 8, create, deps);
 }
+function useEffectEventImpl(payload) {
+  currentlyRenderingFiber.flags |= 4;
+  var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
+  if (null === componentUpdateQueue)
+    (componentUpdateQueue = createFunctionComponentUpdateQueue()),
+      (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
+      (componentUpdateQueue.events = [payload]);
+  else {
+    var events = componentUpdateQueue.events;
+    null === events
+      ? (componentUpdateQueue.events = [payload])
+      : events.push(payload);
+  }
+}
+function updateEvent(callback) {
+  var ref = updateWorkInProgressHook().memoizedState;
+  useEffectEventImpl({ ref: ref, nextImpl: callback });
+  return function () {
+    if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
+    return ref.impl.apply(void 0, arguments);
+  };
+}
 function updateInsertionEffect(create, deps) {
   return updateEffectImpl(4, 2, create, deps);
 }
@@ -4287,19 +4651,24 @@ function updateId() {
 function updateRefresh() {
   return updateWorkInProgressHook().memoizedState;
 }
-function refreshCache(fiber) {
+function refreshCache(fiber, seedKey, seedValue) {
   for (var provider = fiber.return; null !== provider; ) {
     switch (provider.tag) {
       case 24:
       case 3:
         var lane = requestUpdateLane();
         fiber = createUpdate(lane);
-        var root$44 = enqueueUpdate(provider, fiber, lane);
-        null !== root$44 &&
-          (scheduleUpdateOnFiber(root$44, provider, lane),
-          entangleTransitions(root$44, provider, lane));
-        provider = { cache: createCache() };
-        fiber.payload = provider;
+        var root$46 = enqueueUpdate(provider, fiber, lane);
+        null !== root$46 &&
+          (startUpdateTimerByLane(lane),
+          scheduleUpdateOnFiber(root$46, provider, lane),
+          entangleTransitions(root$46, provider, lane));
+        provider = createCache();
+        null !== seedKey &&
+          void 0 !== seedKey &&
+          null !== root$46 &&
+          provider.data.set(seedKey, seedValue);
+        fiber.payload = { cache: provider };
         return;
     }
     provider = provider.return;
@@ -4319,14 +4688,14 @@ function dispatchReducerAction(fiber, queue, action) {
     ? enqueueRenderPhaseUpdate(queue, action)
     : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
       null !== action &&
-        (scheduleUpdateOnFiber(action, fiber, lane),
+        (startUpdateTimerByLane(lane),
+        scheduleUpdateOnFiber(action, fiber, lane),
         entangleTransitionUpdate(action, queue, lane)));
-  markStateUpdateScheduled(fiber, lane);
 }
 function dispatchSetState(fiber, queue, action) {
   var lane = requestUpdateLane();
-  dispatchSetStateInternal(fiber, queue, action, lane);
-  markStateUpdateScheduled(fiber, lane);
+  dispatchSetStateInternal(fiber, queue, action, lane) &&
+    startUpdateTimerByLane(lane);
 }
 function dispatchSetStateInternal(fiber, queue, action, lane) {
   var update = {
@@ -4388,8 +4757,8 @@ function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
       2
     )),
       null !== throwIfDuringRender &&
-        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
-  markStateUpdateScheduled(fiber, 2);
+        (startUpdateTimerByLane(2),
+        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
 }
 function isRenderPhaseUpdate(fiber) {
   var alternate = fiber.alternate;
@@ -4417,31 +4786,32 @@ function entangleTransitionUpdate(root, queue, lane) {
   }
 }
 var ContextOnlyDispatcher = {
-    readContext: readContext,
-    use: use,
-    useCallback: throwInvalidHookError,
-    useContext: throwInvalidHookError,
-    useEffect: throwInvalidHookError,
-    useImperativeHandle: throwInvalidHookError,
-    useLayoutEffect: throwInvalidHookError,
-    useInsertionEffect: throwInvalidHookError,
-    useMemo: throwInvalidHookError,
-    useReducer: throwInvalidHookError,
-    useRef: throwInvalidHookError,
-    useState: throwInvalidHookError,
-    useDebugValue: throwInvalidHookError,
-    useDeferredValue: throwInvalidHookError,
-    useTransition: throwInvalidHookError,
-    useSyncExternalStore: throwInvalidHookError,
-    useId: throwInvalidHookError,
-    useHostTransitionStatus: throwInvalidHookError,
-    useFormState: throwInvalidHookError,
-    useActionState: throwInvalidHookError,
-    useOptimistic: throwInvalidHookError,
-    useMemoCache: throwInvalidHookError,
-    useCacheRefresh: throwInvalidHookError
-  },
-  HooksDispatcherOnMount = {
+  readContext: readContext,
+  use: use,
+  useCallback: throwInvalidHookError,
+  useContext: throwInvalidHookError,
+  useEffect: throwInvalidHookError,
+  useImperativeHandle: throwInvalidHookError,
+  useLayoutEffect: throwInvalidHookError,
+  useInsertionEffect: throwInvalidHookError,
+  useMemo: throwInvalidHookError,
+  useReducer: throwInvalidHookError,
+  useRef: throwInvalidHookError,
+  useState: throwInvalidHookError,
+  useDebugValue: throwInvalidHookError,
+  useDeferredValue: throwInvalidHookError,
+  useTransition: throwInvalidHookError,
+  useSyncExternalStore: throwInvalidHookError,
+  useId: throwInvalidHookError,
+  useHostTransitionStatus: throwInvalidHookError,
+  useFormState: throwInvalidHookError,
+  useActionState: throwInvalidHookError,
+  useOptimistic: throwInvalidHookError,
+  useMemoCache: throwInvalidHookError,
+  useCacheRefresh: throwInvalidHookError
+};
+ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
+var HooksDispatcherOnMount = {
     readContext: readContext,
     use: use,
     useCallback: function (callback, deps) {
@@ -4580,26 +4950,15 @@ var ContextOnlyDispatcher = {
       var hook = mountWorkInProgressHook(),
         identifierPrefix = workInProgressRoot.identifierPrefix;
       if (isHydrating) {
-        var JSCompiler_inline_result = treeContextOverflow;
-        var idWithLeadingBit = treeContextId;
-        JSCompiler_inline_result =
-          (
-            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
-          ).toString(32) + JSCompiler_inline_result;
-        identifierPrefix =
-          ":" + identifierPrefix + "R" + JSCompiler_inline_result;
-        JSCompiler_inline_result = localIdCounter++;
-        0 < JSCompiler_inline_result &&
-          (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
+        var treeId = getTreeId();
+        identifierPrefix = ":" + identifierPrefix + "R" + treeId;
+        treeId = localIdCounter++;
+        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
         identifierPrefix += ":";
       } else
-        (JSCompiler_inline_result = globalClientIdCounter++),
+        (treeId = globalClientIdCounter$1++),
           (identifierPrefix =
-            ":" +
-            identifierPrefix +
-            "r" +
-            JSCompiler_inline_result.toString(32) +
-            ":");
+            ":" + identifierPrefix + "r" + treeId.toString(32) + ":");
       return (hook.memoizedState = identifierPrefix);
     },
     useHostTransitionStatus: useHostTransitionStatus,
@@ -4631,6 +4990,16 @@ var ContextOnlyDispatcher = {
         null,
         currentlyRenderingFiber
       ));
+    },
+    useEffectEvent: function (callback) {
+      var hook = mountWorkInProgressHook(),
+        ref = { impl: callback };
+      hook.memoizedState = ref;
+      return function () {
+        if (0 !== (executionContext & 2))
+          throw Error(formatProdErrorMessage(440));
+        return ref.impl.apply(void 0, arguments);
+      };
     }
   },
   HooksDispatcherOnUpdate = {
@@ -4679,60 +5048,62 @@ var ContextOnlyDispatcher = {
     },
     useMemoCache: useMemoCache,
     useCacheRefresh: updateRefresh
+  };
+HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
+var HooksDispatcherOnRerender = {
+  readContext: readContext,
+  use: use,
+  useCallback: updateCallback,
+  useContext: readContext,
+  useEffect: updateEffect,
+  useImperativeHandle: updateImperativeHandle,
+  useInsertionEffect: updateInsertionEffect,
+  useLayoutEffect: updateLayoutEffect,
+  useMemo: updateMemo,
+  useReducer: rerenderReducer,
+  useRef: updateRef,
+  useState: function () {
+    return rerenderReducer(basicStateReducer);
   },
-  HooksDispatcherOnRerender = {
-    readContext: readContext,
-    use: use,
-    useCallback: updateCallback,
-    useContext: readContext,
-    useEffect: updateEffect,
-    useImperativeHandle: updateImperativeHandle,
-    useInsertionEffect: updateInsertionEffect,
-    useLayoutEffect: updateLayoutEffect,
-    useMemo: updateMemo,
-    useReducer: rerenderReducer,
-    useRef: updateRef,
-    useState: function () {
-      return rerenderReducer(basicStateReducer);
-    },
-    useDebugValue: mountDebugValue,
-    useDeferredValue: function (value, initialValue) {
-      var hook = updateWorkInProgressHook();
-      return null === currentHook
-        ? mountDeferredValueImpl(hook, value, initialValue)
-        : updateDeferredValueImpl(
-            hook,
-            currentHook.memoizedState,
-            value,
-            initialValue
-          );
-    },
-    useTransition: function () {
-      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
-        start = updateWorkInProgressHook().memoizedState;
-      return [
-        "boolean" === typeof booleanOrThenable
-          ? booleanOrThenable
-          : useThenable(booleanOrThenable),
-        start
-      ];
-    },
-    useSyncExternalStore: updateSyncExternalStore,
-    useId: updateId,
-    useHostTransitionStatus: useHostTransitionStatus,
-    useFormState: rerenderActionState,
-    useActionState: rerenderActionState,
-    useOptimistic: function (passthrough, reducer) {
-      var hook = updateWorkInProgressHook();
-      if (null !== currentHook)
-        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
-      hook.baseState = passthrough;
-      return [passthrough, hook.queue.dispatch];
-    },
-    useMemoCache: useMemoCache,
-    useCacheRefresh: updateRefresh
+  useDebugValue: mountDebugValue,
+  useDeferredValue: function (value, initialValue) {
+    var hook = updateWorkInProgressHook();
+    return null === currentHook
+      ? mountDeferredValueImpl(hook, value, initialValue)
+      : updateDeferredValueImpl(
+          hook,
+          currentHook.memoizedState,
+          value,
+          initialValue
+        );
+  },
+  useTransition: function () {
+    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
+      start = updateWorkInProgressHook().memoizedState;
+    return [
+      "boolean" === typeof booleanOrThenable
+        ? booleanOrThenable
+        : useThenable(booleanOrThenable),
+      start
+    ];
   },
-  thenableState = null,
+  useSyncExternalStore: updateSyncExternalStore,
+  useId: updateId,
+  useHostTransitionStatus: useHostTransitionStatus,
+  useFormState: rerenderActionState,
+  useActionState: rerenderActionState,
+  useOptimistic: function (passthrough, reducer) {
+    var hook = updateWorkInProgressHook();
+    if (null !== currentHook)
+      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
+    hook.baseState = passthrough;
+    return [passthrough, hook.queue.dispatch];
+  },
+  useMemoCache: useMemoCache,
+  useCacheRefresh: updateRefresh
+};
+HooksDispatcherOnRerender.useEffectEvent = updateEvent;
+var thenableState = null,
   thenableIndexCounter = 0;
 function unwrapThenable(thenable) {
   var index = thenableIndexCounter;
@@ -4937,7 +5308,11 @@ function createChildReconciler(shouldTrackSideEffects) {
           newChild = init(newChild._payload);
           return createChild(returnFiber, newChild, lanes);
       }
-      if (isArrayImpl(newChild) || getIteratorFn(newChild))
+      if (
+        isArrayImpl(newChild) ||
+        getIteratorFn(newChild) ||
+        "function" === typeof newChild[ASYNC_ITERATOR]
+      )
         return (
           (newChild = createFiberFromFragment(
             newChild,
@@ -4987,7 +5362,11 @@ function createChildReconciler(shouldTrackSideEffects) {
             updateSlot(returnFiber, oldFiber, newChild, lanes)
           );
       }
-      if (isArrayImpl(newChild) || getIteratorFn(newChild))
+      if (
+        isArrayImpl(newChild) ||
+        getIteratorFn(newChild) ||
+        "function" === typeof newChild[ASYNC_ITERATOR]
+      )
         return null !== key
           ? null
           : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
@@ -5054,7 +5433,11 @@ function createChildReconciler(shouldTrackSideEffects) {
             lanes
           );
       }
-      if (isArrayImpl(newChild) || getIteratorFn(newChild))
+      if (
+        isArrayImpl(newChild) ||
+        getIteratorFn(newChild) ||
+        "function" === typeof newChild[ASYNC_ITERATOR]
+      )
         return (
           (existingChildren = existingChildren.get(newIdx) || null),
           updateFragment(returnFiber, existingChildren, newChild, lanes, null)
@@ -5174,6 +5557,25 @@ function createChildReconciler(shouldTrackSideEffects) {
     isHydrating && pushTreeFork(returnFiber, newIdx);
     return resultingFirstChild;
   }
+  function reconcileChildrenAsyncIteratable(
+    returnFiber,
+    currentFirstChild,
+    newChildrenIterable,
+    lanes
+  ) {
+    var newChildren = newChildrenIterable[ASYNC_ITERATOR]();
+    if (null == newChildren) throw Error(formatProdErrorMessage(151));
+    return reconcileChildrenIterator(
+      returnFiber,
+      currentFirstChild,
+      {
+        next: function () {
+          return unwrapThenable(newChildren.next());
+        }
+      },
+      lanes
+    );
+  }
   function reconcileChildrenIterator(
     returnFiber,
     currentFirstChild,
@@ -5387,6 +5789,13 @@ function createChildReconciler(shouldTrackSideEffects) {
           lanes
         );
       }
+      if ("function" === typeof newChild[ASYNC_ITERATOR])
+        return reconcileChildrenAsyncIteratable(
+          returnFiber,
+          currentFirstChild,
+          newChild,
+          lanes
+        );
       if ("function" === typeof newChild.then)
         return reconcileChildFibersImpl(
           returnFiber,
@@ -5548,9 +5957,9 @@ function logUncaughtError(root, errorInfo) {
   try {
     var onUncaughtError = root.onUncaughtError;
     onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
-  } catch (e$76) {
+  } catch (e$79) {
     setTimeout(function () {
-      throw e$76;
+      throw e$79;
     });
   }
 }
@@ -5561,9 +5970,9 @@ function logCaughtError(root, boundary, errorInfo) {
       componentStack: errorInfo.stack,
       errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
     });
-  } catch (e$77) {
+  } catch (e$80) {
     setTimeout(function () {
-      throw e$77;
+      throw e$80;
     });
   }
 }
@@ -5607,6 +6016,27 @@ function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
       });
     });
 }
+function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
+  var currentSourceFiber = sourceFiber.alternate;
+  null !== currentSourceFiber &&
+    propagateParentContextChanges(
+      currentSourceFiber,
+      sourceFiber,
+      rootRenderLanes,
+      !0
+    );
+}
+function markSuspenseBoundaryShouldCapture(
+  suspenseBoundary,
+  returnFiber,
+  sourceFiber,
+  root,
+  rootRenderLanes
+) {
+  suspenseBoundary.flags |= 65536;
+  suspenseBoundary.lanes = rootRenderLanes;
+  return suspenseBoundary;
+}
 function throwException(
   root,
   returnFiber,
@@ -5619,60 +6049,60 @@ function throwException(
   if (
     null !== value &&
     "object" === typeof value &&
-    "function" === typeof value.then
+    (value.$$typeof === REACT_POSTPONE_TYPE &&
+      (value = { then: function () {} }),
+    "function" === typeof value.then)
   ) {
-    returnFiber = sourceFiber.alternate;
-    null !== returnFiber &&
-      propagateParentContextChanges(
-        returnFiber,
-        sourceFiber,
-        rootRenderLanes,
-        !0
-      );
-    sourceFiber = suspenseHandlerStackCursor.current;
-    if (null !== sourceFiber) {
-      switch (sourceFiber.tag) {
+    resetSuspendedComponent(sourceFiber, rootRenderLanes);
+    var suspenseBoundary = suspenseHandlerStackCursor.current;
+    if (null !== suspenseBoundary) {
+      switch (suspenseBoundary.tag) {
         case 13:
           return (
             null === shellBoundary
               ? renderDidSuspendDelayIfPossible()
-              : null === sourceFiber.alternate &&
+              : null === suspenseBoundary.alternate &&
                 0 === workInProgressRootExitStatus &&
                 (workInProgressRootExitStatus = 3),
-            (sourceFiber.flags &= -257),
-            (sourceFiber.flags |= 65536),
-            (sourceFiber.lanes = rootRenderLanes),
+            (suspenseBoundary.flags &= -257),
+            markSuspenseBoundaryShouldCapture(
+              suspenseBoundary,
+              returnFiber,
+              sourceFiber,
+              root,
+              rootRenderLanes
+            ),
             value === noopSuspenseyCommitThenable
-              ? (sourceFiber.flags |= 16384)
-              : ((returnFiber = sourceFiber.updateQueue),
-                null === returnFiber
-                  ? (sourceFiber.updateQueue = new Set([value]))
-                  : returnFiber.add(value),
+              ? (suspenseBoundary.flags |= 16384)
+              : ((sourceFiber = suspenseBoundary.updateQueue),
+                null === sourceFiber
+                  ? (suspenseBoundary.updateQueue = new Set([value]))
+                  : sourceFiber.add(value),
                 attachPingListener(root, value, rootRenderLanes)),
             !1
           );
         case 22:
           return (
-            (sourceFiber.flags |= 65536),
+            (suspenseBoundary.flags |= 65536),
             value === noopSuspenseyCommitThenable
-              ? (sourceFiber.flags |= 16384)
-              : ((returnFiber = sourceFiber.updateQueue),
-                null === returnFiber
-                  ? ((returnFiber = {
+              ? (suspenseBoundary.flags |= 16384)
+              : ((sourceFiber = suspenseBoundary.updateQueue),
+                null === sourceFiber
+                  ? ((sourceFiber = {
                       transitions: null,
                       markerInstances: null,
                       retryQueue: new Set([value])
                     }),
-                    (sourceFiber.updateQueue = returnFiber))
-                  : ((sourceFiber = returnFiber.retryQueue),
-                    null === sourceFiber
-                      ? (returnFiber.retryQueue = new Set([value]))
-                      : sourceFiber.add(value)),
+                    (suspenseBoundary.updateQueue = sourceFiber))
+                  : ((returnFiber = sourceFiber.retryQueue),
+                    null === returnFiber
+                      ? (sourceFiber.retryQueue = new Set([value]))
+                      : returnFiber.add(value)),
                 attachPingListener(root, value, rootRenderLanes)),
             !1
           );
       }
-      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
+      throw Error(formatProdErrorMessage(435, suspenseBoundary.tag));
     }
     attachPingListener(root, value, rootRenderLanes);
     renderDidSuspendDelayIfPossible();
@@ -5680,11 +6110,17 @@ function throwException(
   }
   if (isHydrating)
     return (
-      (returnFiber = suspenseHandlerStackCursor.current),
-      null !== returnFiber
-        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
-          (returnFiber.flags |= 65536),
-          (returnFiber.lanes = rootRenderLanes),
+      (suspenseBoundary = suspenseHandlerStackCursor.current),
+      null !== suspenseBoundary
+        ? (0 === (suspenseBoundary.flags & 65536) &&
+            (suspenseBoundary.flags |= 256),
+          markSuspenseBoundaryShouldCapture(
+            suspenseBoundary,
+            returnFiber,
+            sourceFiber,
+            root,
+            rootRenderLanes
+          ),
           value !== HydrationMismatchException &&
             ((root = Error(formatProdErrorMessage(422), { cause: value })),
             queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
@@ -5699,10 +6135,10 @@ function throwException(
           (root.flags |= 65536),
           (rootRenderLanes &= -rootRenderLanes),
           (root.lanes |= rootRenderLanes),
-          (value = createCapturedValueAtFiber(value, sourceFiber)),
+          (sourceFiber = createCapturedValueAtFiber(value, sourceFiber)),
           (rootRenderLanes = createRootErrorUpdate(
             root.stateNode,
-            value,
+            sourceFiber,
             rootRenderLanes
           )),
           enqueueCapturedUpdate(root, rootRenderLanes),
@@ -5710,54 +6146,58 @@ function throwException(
             (workInProgressRootExitStatus = 2)),
       !1
     );
-  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
-  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
-  null === workInProgressRootConcurrentErrors
-    ? (workInProgressRootConcurrentErrors = [wrapperError])
-    : workInProgressRootConcurrentErrors.push(wrapperError);
+  suspenseBoundary = Error(formatProdErrorMessage(520), { cause: value });
+  queueConcurrentError(
+    createCapturedValueAtFiber(suspenseBoundary, sourceFiber)
+  );
   4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
   if (null === returnFiber) return !0;
-  value = createCapturedValueAtFiber(value, sourceFiber);
-  sourceFiber = returnFiber;
+  sourceFiber = createCapturedValueAtFiber(value, sourceFiber);
   do {
-    switch (sourceFiber.tag) {
+    switch (returnFiber.tag) {
       case 3:
         return (
-          (sourceFiber.flags |= 65536),
+          (returnFiber.flags |= 65536),
           (root = rootRenderLanes & -rootRenderLanes),
-          (sourceFiber.lanes |= root),
-          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
-          enqueueCapturedUpdate(sourceFiber, root),
+          (returnFiber.lanes |= root),
+          (root = createRootErrorUpdate(
+            returnFiber.stateNode,
+            sourceFiber,
+            root
+          )),
+          enqueueCapturedUpdate(returnFiber, root),
           !1
         );
       case 1:
         if (
-          ((returnFiber = sourceFiber.type),
-          (wrapperError = sourceFiber.stateNode),
-          0 === (sourceFiber.flags & 128) &&
-            ("function" === typeof returnFiber.getDerivedStateFromError ||
-              (null !== wrapperError &&
-                "function" === typeof wrapperError.componentDidCatch &&
+          ((value = returnFiber.type),
+          (suspenseBoundary = returnFiber.stateNode),
+          0 === (returnFiber.flags & 128) &&
+            ("function" === typeof value.getDerivedStateFromError ||
+              (null !== suspenseBoundary &&
+                "function" === typeof suspenseBoundary.componentDidCatch &&
                 (null === legacyErrorBoundariesThatAlreadyFailed ||
-                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))
+                  !legacyErrorBoundariesThatAlreadyFailed.has(
+                    suspenseBoundary
+                  )))))
         )
           return (
-            (sourceFiber.flags |= 65536),
+            (returnFiber.flags |= 65536),
             (rootRenderLanes &= -rootRenderLanes),
-            (sourceFiber.lanes |= rootRenderLanes),
+            (returnFiber.lanes |= rootRenderLanes),
             (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
             initializeClassErrorUpdate(
               rootRenderLanes,
               root,
-              sourceFiber,
-              value
+              returnFiber,
+              sourceFiber
             ),
-            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
+            enqueueCapturedUpdate(returnFiber, rootRenderLanes),
             !1
           );
     }
-    sourceFiber = sourceFiber.return;
-  } while (null !== sourceFiber);
+    returnFiber = returnFiber.return;
+  } while (null !== returnFiber);
   return !1;
 }
 var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
@@ -5788,7 +6228,6 @@ function updateForwardRef(
       "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
   } else propsWithoutRef = nextProps;
   prepareToReadContext(workInProgress);
-  markComponentRenderStarted(workInProgress);
   nextProps = renderWithHooks(
     current,
     workInProgress,
@@ -5798,7 +6237,6 @@ function updateForwardRef(
     renderLanes
   );
   key = checkDidRenderIdHook();
-  markComponentRenderStopped();
   if (null !== current && !didReceiveUpdate)
     return (
       bailoutHooks(current, workInProgress, renderLanes),
@@ -5995,7 +6433,6 @@ function updateFunctionComponent(
   renderLanes
 ) {
   prepareToReadContext(workInProgress);
-  markComponentRenderStarted(workInProgress);
   Component = renderWithHooks(
     current,
     workInProgress,
@@ -6005,7 +6442,6 @@ function updateFunctionComponent(
     renderLanes
   );
   nextProps = checkDidRenderIdHook();
-  markComponentRenderStopped();
   if (null !== current && !didReceiveUpdate)
     return (
       bailoutHooks(current, workInProgress, renderLanes),
@@ -6025,7 +6461,6 @@ function replayFunctionComponent(
   renderLanes
 ) {
   prepareToReadContext(workInProgress);
-  markComponentRenderStarted(workInProgress);
   workInProgress.updateQueue = null;
   nextProps = renderWithHooksAgain(
     workInProgress,
@@ -6035,7 +6470,6 @@ function replayFunctionComponent(
   );
   finishRenderingHooks(current);
   Component = checkDidRenderIdHook();
-  markComponentRenderStopped();
   if (null !== current && !didReceiveUpdate)
     return (
       bailoutHooks(current, workInProgress, renderLanes),
@@ -6281,9 +6715,7 @@ function updateClassComponent(
     ? ((context = workInProgress.stateNode),
       nextProps && "function" !== typeof Component.getDerivedStateFromError
         ? ((Component = null), (profilerStartTime = -1))
-        : (markComponentRenderStarted(workInProgress),
-          (Component = context.render()),
-          markComponentRenderStopped()),
+        : (Component = context.render()),
       (workInProgress.flags |= 1),
       null !== current && nextProps
         ? ((workInProgress.child = reconcileChildFibers(
@@ -6420,25 +6852,35 @@ function updateSuspenseComponent(current, workInProgress, renderLanes) {
       popSuspenseHandler(workInProgress);
     }
     nextInstance = nextProps.children;
-    nextProps = nextProps.fallback;
+    JSCompiler_temp$jscomp$0 = nextProps.fallback;
     if (showFallback)
       return (
         reuseSuspenseHandlerOnStack(workInProgress),
-        (showFallback = workInProgress.mode),
-        (nextInstance = mountWorkInProgressOffscreenFiber(
-          { mode: "hidden", children: nextInstance },
-          showFallback
+        (nextProps = mountSuspenseFallbackChildren(
+          workInProgress,
+          nextInstance,
+          JSCompiler_temp$jscomp$0,
+          renderLanes
         )),
-        (nextProps = createFiberFromFragment(
-          nextProps,
-          showFallback,
-          renderLanes,
-          null
+        (showFallback = workInProgress.child),
+        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
+        (showFallback.childLanes = getRemainingWorkInPrimaryTree(
+          current,
+          JSCompiler_temp,
+          renderLanes
+        )),
+        (workInProgress.memoizedState = SUSPENDED_MARKER),
+        nextProps
+      );
+    if ("number" === typeof nextProps.unstable_expectedLoadTime)
+      return (
+        reuseSuspenseHandlerOnStack(workInProgress),
+        (nextProps = mountSuspenseFallbackChildren(
+          workInProgress,
+          nextInstance,
+          JSCompiler_temp$jscomp$0,
+          renderLanes
         )),
-        (nextInstance.return = workInProgress),
-        (nextProps.return = workInProgress),
-        (nextInstance.sibling = nextProps),
-        (workInProgress.child = nextInstance),
         (showFallback = workInProgress.child),
         (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
         (showFallback.childLanes = getRemainingWorkInPrimaryTree(
@@ -6447,6 +6889,7 @@ function updateSuspenseComponent(current, workInProgress, renderLanes) {
           renderLanes
         )),
         (workInProgress.memoizedState = SUSPENDED_MARKER),
+        (workInProgress.lanes = 4194304),
         nextProps
       );
     pushPrimaryTreeSuspenseHandler(workInProgress);
@@ -6514,10 +6957,11 @@ function updateSuspenseComponent(current, workInProgress, renderLanes) {
         nextInstance.nextSibling && nextInstance.nextSibling.dataset;
       if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
       JSCompiler_temp = digest;
-      nextProps = Error(formatProdErrorMessage(419));
-      nextProps.stack = "";
-      nextProps.digest = JSCompiler_temp;
-      queueHydrationError({ value: nextProps, source: null, stack: null });
+      "POSTPONE" !== JSCompiler_temp &&
+        ((nextProps = Error(formatProdErrorMessage(419))),
+        (nextProps.stack = ""),
+        (nextProps.digest = JSCompiler_temp),
+        queueHydrationError({ value: nextProps, source: null, stack: null }));
       workInProgress = retrySuspenseComponentWithoutHydrating(
         current,
         workInProgress,
@@ -6660,6 +7104,29 @@ function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
   primaryChildren.return = workInProgress;
   return (workInProgress.child = primaryChildren);
 }
+function mountSuspenseFallbackChildren(
+  workInProgress,
+  primaryChildren,
+  fallbackChildren,
+  renderLanes
+) {
+  var mode = workInProgress.mode;
+  primaryChildren = mountWorkInProgressOffscreenFiber(
+    { mode: "hidden", children: primaryChildren },
+    mode
+  );
+  fallbackChildren = createFiberFromFragment(
+    fallbackChildren,
+    mode,
+    renderLanes,
+    null
+  );
+  primaryChildren.return = workInProgress;
+  fallbackChildren.return = workInProgress;
+  primaryChildren.sibling = fallbackChildren;
+  workInProgress.child = primaryChildren;
+  return fallbackChildren;
+}
 function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
   return createFiberFromOffscreen(offscreenProps, mode, 0, null);
 }
@@ -7164,14 +7631,21 @@ function beginWork(current, workInProgress, renderLanes) {
           (nextHydratableInstance = getNextHydratable(
             lazyComponent.firstChild
           ))),
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps.children,
-          renderLanes
-        ),
+        (lazyComponent = workInProgress.pendingProps.children),
+        null !== current || isHydrating
+          ? reconcileChildren(
+              current,
+              workInProgress,
+              lazyComponent,
+              renderLanes
+            )
+          : (workInProgress.child = reconcileChildFibers(
+              workInProgress,
+              null,
+              lazyComponent,
+              renderLanes
+            )),
         markRef(current, workInProgress),
-        null === current && (workInProgress.flags |= 4194304),
         workInProgress.child
       );
     case 5:
@@ -7327,9 +7801,7 @@ function beginWork(current, workInProgress, renderLanes) {
         (lazyComponent = workInProgress.pendingProps.children),
         prepareToReadContext(workInProgress),
         (init = readContext(init)),
-        markComponentRenderStarted(workInProgress),
         (lazyComponent = lazyComponent(init)),
-        markComponentRenderStopped(),
         (workInProgress.flags |= 1),
         reconcileChildren(current, workInProgress, lazyComponent, renderLanes),
         workInProgress.child
@@ -7404,6 +7876,38 @@ function beginWork(current, workInProgress, renderLanes) {
         ),
         workInProgress.child
       );
+    case 30:
+      return (
+        (lazyComponent = workInProgress.pendingProps),
+        (init = workInProgress.stateNode),
+        null != lazyComponent.name && "auto" !== lazyComponent.name
+          ? ((workInProgress.flags |= 2097152),
+            null === current &&
+              trackAppearingViewTransition(init, lazyComponent.name))
+          : null === init.autoName &&
+            ((nextProps = workInProgressRoot.identifierPrefix),
+            isHydrating
+              ? ((nextState = getTreeId()),
+                (nextProps = "\u00ab" + nextProps + "T" + nextState + "\u00bb"))
+              : ((nextState = globalClientIdCounter++),
+                (nextProps =
+                  "\u00ab" +
+                  nextProps +
+                  "t" +
+                  nextState.toString(32) +
+                  "\u00bb")),
+            (init.autoName = nextProps)),
+        null !== current && current.memoizedProps.name !== lazyComponent.name
+          ? (workInProgress.flags |= 4194816)
+          : markRef(current, workInProgress),
+        reconcileChildren(
+          current,
+          workInProgress,
+          lazyComponent.children,
+          renderLanes
+        ),
+        workInProgress.child
+      );
     case 29:
       throw workInProgress.pendingProps;
   }
@@ -7447,35 +7951,11 @@ function commitHookEffectListMount(flags, finishedWork) {
       updateQueue = firstEffect;
       do {
         if ((updateQueue.tag & flags) === flags) {
-          0 !== (flags & 8)
-            ? null !== injectedProfilingHooks &&
-              "function" ===
-                typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted &&
-              injectedProfilingHooks.markComponentPassiveEffectMountStarted(
-                finishedWork
-              )
-            : 0 !== (flags & 4) &&
-              null !== injectedProfilingHooks &&
-              "function" ===
-                typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted &&
-              injectedProfilingHooks.markComponentLayoutEffectMountStarted(
-                finishedWork
-              );
           lastEffect = void 0;
           var create = updateQueue.create,
             inst = updateQueue.inst;
           lastEffect = create();
           inst.destroy = lastEffect;
-          0 !== (flags & 8)
-            ? null !== injectedProfilingHooks &&
-              "function" ===
-                typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped &&
-              injectedProfilingHooks.markComponentPassiveEffectMountStopped()
-            : 0 !== (flags & 4) &&
-              null !== injectedProfilingHooks &&
-              "function" ===
-                typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped &&
-              injectedProfilingHooks.markComponentLayoutEffectMountStopped();
         }
         updateQueue = updateQueue.next;
       } while (updateQueue !== firstEffect);
@@ -7501,20 +7981,6 @@ function commitHookEffectListUnmount(
             destroy = inst.destroy;
           if (void 0 !== destroy) {
             inst.destroy = void 0;
-            0 !== (flags & 8)
-              ? null !== injectedProfilingHooks &&
-                "function" ===
-                  typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted &&
-                injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
-                  finishedWork
-                )
-              : 0 !== (flags & 4) &&
-                null !== injectedProfilingHooks &&
-                "function" ===
-                  typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted &&
-                injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
-                  finishedWork
-                );
             lastEffect = finishedWork;
             var nearestMountedAncestor = nearestMountedAncestor$jscomp$0;
             try {
@@ -7526,16 +7992,6 @@ function commitHookEffectListUnmount(
                 error
               );
             }
-            0 !== (flags & 8)
-              ? null !== injectedProfilingHooks &&
-                "function" ===
-                  typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped &&
-                injectedProfilingHooks.markComponentPassiveEffectUnmountStopped()
-              : 0 !== (flags & 4) &&
-                null !== injectedProfilingHooks &&
-                "function" ===
-                  typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped &&
-                injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
           }
         }
         updateQueue = updateQueue.next;
@@ -7603,8 +8059,8 @@ function safelyCallComponentWillUnmount(
   } else
     try {
       instance.componentWillUnmount();
-    } catch (error$117) {
-      captureCommitPhaseError(current, nearestMountedAncestor, error$117);
+    } catch (error$122) {
+      captureCommitPhaseError(current, nearestMountedAncestor, error$122);
     }
 }
 function safelyAttachRef(current, nearestMountedAncestor) {
@@ -7617,6 +8073,13 @@ function safelyAttachRef(current, nearestMountedAncestor) {
         case 5:
           var instanceToUse = current.stateNode;
           break;
+        case 30:
+          var instance = current.stateNode,
+            name = getViewTransitionName(current.memoizedProps, instance);
+          if (null === instance.ref || instance.ref.name !== name)
+            instance.ref = createViewTransitionInstance(name);
+          instanceToUse = instance.ref;
+          break;
         default:
           instanceToUse = current.stateNode;
       }
@@ -7663,8 +8126,8 @@ function safelyDetachRef(current, nearestMountedAncestor) {
             recordEffectDuration(current);
           }
         else ref(null);
-      } catch (error$118) {
-        captureCommitPhaseError(current, nearestMountedAncestor, error$118);
+      } catch (error$123) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error$123);
       }
     else ref.current = null;
 }
@@ -7736,7 +8199,7 @@ function isHostParent(fiber) {
     5 === fiber.tag ||
     3 === fiber.tag ||
     26 === fiber.tag ||
-    (27 === fiber.tag && "head" === fiber.type) ||
+    27 === fiber.tag ||
     4 === fiber.tag
   );
 }
@@ -7749,10 +8212,12 @@ function getHostSibling(fiber) {
     fiber.sibling.return = fiber.return;
     for (
       fiber = fiber.sibling;
-      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;
+      5 !== fiber.tag &&
+      6 !== fiber.tag &&
+      27 !== fiber.tag &&
+      18 !== fiber.tag;
 
     ) {
-      if (27 === fiber.tag && "head" === fiber.type) continue a;
       if (fiber.flags & 2) continue a;
       if (null === fiber.child || 4 === fiber.tag) continue a;
       else (fiber.child.return = fiber), (fiber = fiber.child);
@@ -7763,45 +8228,20 @@ function getHostSibling(fiber) {
 function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
   var tag = node.tag;
   if (5 === tag || 6 === tag)
-    if (((node = node.stateNode), before)) {
-      switch (parent.nodeType) {
-        case 8:
-          parent = parent.parentNode;
-          break;
-        case 9:
-          parent = parent.body;
-          break;
-        default:
-          parent =
-            "HTML" === parent.nodeName ? parent.ownerDocument.body : parent;
-      }
-      parent.insertBefore(node, before);
-    } else
-      a: {
-        switch (parent.nodeType) {
-          case 8:
-            before = parent.parentNode;
-            before.insertBefore(node, parent);
-            break a;
-          case 9:
-            before = parent.body;
-            break;
-          default:
-            before =
-              "HTML" === parent.nodeName ? parent.ownerDocument.body : parent;
-        }
-        before.appendChild(node);
-        parent = parent._reactRootContainer;
-        (null !== parent && void 0 !== parent) ||
-          null !== before.onclick ||
-          (before.onclick = noop$2);
-      }
-  else if (
-    4 !== tag &&
-    (27 === tag && "head" === node.type && (parent = node.stateNode),
-    (node = node.child),
-    null !== node)
-  )
+    (node = node.stateNode),
+      before
+        ? 8 === parent.nodeType
+          ? parent.parentNode.insertBefore(node, before)
+          : parent.insertBefore(node, before)
+        : (8 === parent.nodeType
+            ? ((before = parent.parentNode), before.insertBefore(node, parent))
+            : ((before = parent), before.appendChild(node)),
+          (parent = parent._reactRootContainer),
+          (null !== parent && void 0 !== parent) ||
+            null !== before.onclick ||
+            (before.onclick = noop$2)),
+      (viewTransitionMutationContext = !0);
+  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
     for (
       insertOrAppendPlacementNodeIntoContainer(node, before, parent),
         node = node.sibling;
@@ -7815,13 +8255,9 @@ function insertOrAppendPlacementNode(node, before, parent) {
   var tag = node.tag;
   if (5 === tag || 6 === tag)
     (node = node.stateNode),
-      before ? parent.insertBefore(node, before) : parent.appendChild(node);
-  else if (
-    4 !== tag &&
-    (27 === tag && "head" === node.type && (parent = node.stateNode),
-    (node = node.child),
-    null !== node)
-  )
+      before ? parent.insertBefore(node, before) : parent.appendChild(node),
+      (viewTransitionMutationContext = !0);
+  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
     for (
       insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
       null !== node;
@@ -7829,31 +8265,22 @@ function insertOrAppendPlacementNode(node, before, parent) {
     )
       insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
 }
-function commitHostSingletonAcquisition(finishedWork) {
-  var singleton = finishedWork.stateNode,
-    props = finishedWork.memoizedProps;
-  try {
-    for (
-      var type = finishedWork.type, attributes = singleton.attributes;
-      attributes.length;
-
-    )
-      singleton.removeAttributeNode(attributes[0]);
-    setInitialProperties(singleton, type, props);
-    singleton[internalInstanceKey] = finishedWork;
-    singleton[internalPropsKey] = props;
-  } catch (error) {
-    captureCommitPhaseError(finishedWork, finishedWork.return, error);
-  }
-}
 var offscreenSubtreeIsHidden = !1,
   offscreenSubtreeWasHidden = !1,
   needsFormReset = !1,
   PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
   nextEffect = null,
   inProgressLanes = null,
-  inProgressRoot = null;
-function commitBeforeMutationEffects(root, firstChild) {
+  inProgressRoot = null,
+  shouldStartViewTransition = !1,
+  viewTransitionContextChanged = !1,
+  viewTransitionCancelableChildren = null;
+function commitBeforeMutationEffects(
+  root,
+  firstChild,
+  committedLanes,
+  appearingViewTransitions
+) {
   root = root.containerInfo;
   eventsEnabled = _enabled;
   root = getActiveElementDeep(root);
@@ -7923,92 +8350,571 @@ function commitBeforeMutationEffects(root, firstChild) {
     JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
   } else JSCompiler_temp = null;
   selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
-  _enabled = !1;
-  for (nextEffect = firstChild; null !== nextEffect; )
+  shouldStartViewTransition = _enabled = !1;
+  committedLanes = (committedLanes & 335544192) === committedLanes;
+  nextEffect = firstChild;
+  for (firstChild = committedLanes ? 9238 : 1028; null !== nextEffect; ) {
+    root = nextEffect;
     if (
-      ((firstChild = nextEffect),
-      (root = firstChild.child),
-      0 !== (firstChild.subtreeFlags & 1024) && null !== root)
+      committedLanes &&
+      ((JSCompiler_temp = root.deletions), null !== JSCompiler_temp)
     )
-      (root.return = firstChild), (nextEffect = root);
-    else
-      for (; null !== nextEffect; ) {
-        firstChild = nextEffect;
-        focusNode = firstChild.alternate;
-        root = firstChild.flags;
-        switch (firstChild.tag) {
-          case 0:
-            break;
-          case 11:
-          case 15:
-            break;
-          case 1:
-            if (0 !== (root & 1024) && null !== focusNode) {
-              root = void 0;
-              JSCompiler_temp = firstChild;
-              anchorOffset = focusNode.memoizedProps;
-              focusNode = focusNode.memoizedState;
-              selection = JSCompiler_temp.stateNode;
-              try {
-                var resolvedPrevProps = resolveClassComponentProps(
-                  JSCompiler_temp.type,
-                  anchorOffset,
-                  JSCompiler_temp.elementType === JSCompiler_temp.type
-                );
-                root = selection.getSnapshotBeforeUpdate(
-                  resolvedPrevProps,
-                  focusNode
-                );
-                selection.__reactInternalSnapshotBeforeUpdate = root;
-              } catch (error) {
-                captureCommitPhaseError(
-                  JSCompiler_temp,
-                  JSCompiler_temp.return,
-                  error
-                );
-              }
+      for (
+        anchorOffset = 0;
+        anchorOffset < JSCompiler_temp.length;
+        anchorOffset++
+      )
+        committedLanes &&
+          commitExitViewTransitions(
+            JSCompiler_temp[anchorOffset],
+            appearingViewTransitions
+          );
+    if (null === root.alternate && 0 !== (root.flags & 2))
+      commitBeforeMutationEffects_complete(committedLanes);
+    else {
+      if (22 === root.tag)
+        if (((JSCompiler_temp = root.alternate), null !== root.memoizedState)) {
+          null !== JSCompiler_temp &&
+            null === JSCompiler_temp.memoizedState &&
+            committedLanes &&
+            commitExitViewTransitions(
+              JSCompiler_temp,
+              appearingViewTransitions
+            );
+          commitBeforeMutationEffects_complete(committedLanes);
+          continue;
+        } else if (
+          null !== JSCompiler_temp &&
+          null !== JSCompiler_temp.memoizedState
+        ) {
+          commitBeforeMutationEffects_complete(committedLanes);
+          continue;
+        }
+      JSCompiler_temp = root.child;
+      0 !== (root.subtreeFlags & firstChild) && null !== JSCompiler_temp
+        ? ((JSCompiler_temp.return = root), (nextEffect = JSCompiler_temp))
+        : (committedLanes && commitNestedViewTransitions(root),
+          commitBeforeMutationEffects_complete(committedLanes));
+    }
+  }
+}
+function commitBeforeMutationEffects_complete(
+  isViewTransitionEligible$jscomp$0
+) {
+  for (; null !== nextEffect; ) {
+    var fiber = nextEffect,
+      isViewTransitionEligible = isViewTransitionEligible$jscomp$0,
+      current = fiber.alternate,
+      flags = fiber.flags;
+    switch (fiber.tag) {
+      case 0:
+        if (
+          0 !== (flags & 4) &&
+          ((current = fiber.updateQueue),
+          (current = null !== current ? current.events : null),
+          null !== current)
+        )
+          for (
+            isViewTransitionEligible = 0;
+            isViewTransitionEligible < current.length;
+            isViewTransitionEligible++
+          )
+            (flags = current[isViewTransitionEligible]),
+              (flags.ref.impl = flags.nextImpl);
+        break;
+      case 11:
+      case 15:
+        break;
+      case 1:
+        if (0 !== (flags & 1024) && null !== current) {
+          isViewTransitionEligible = void 0;
+          flags = current.memoizedProps;
+          current = current.memoizedState;
+          var instance = fiber.stateNode;
+          try {
+            var resolvedPrevProps = resolveClassComponentProps(
+              fiber.type,
+              flags,
+              fiber.elementType === fiber.type
+            );
+            isViewTransitionEligible = instance.getSnapshotBeforeUpdate(
+              resolvedPrevProps,
+              current
+            );
+            instance.__reactInternalSnapshotBeforeUpdate =
+              isViewTransitionEligible;
+          } catch (error) {
+            captureCommitPhaseError(fiber, fiber.return, error);
+          }
+        }
+        break;
+      case 3:
+        if (0 !== (flags & 1024))
+          if (
+            ((current = fiber.stateNode.containerInfo),
+            (isViewTransitionEligible = current.nodeType),
+            9 === isViewTransitionEligible)
+          )
+            clearContainerSparingly(current);
+          else if (1 === isViewTransitionEligible)
+            switch (current.nodeName) {
+              case "HEAD":
+              case "HTML":
+              case "BODY":
+                clearContainerSparingly(current);
+                break;
+              default:
+                current.textContent = "";
             }
-            break;
-          case 3:
-            if (0 !== (root & 1024))
-              if (
-                ((root = firstChild.stateNode.containerInfo),
-                (JSCompiler_temp = root.nodeType),
-                9 === JSCompiler_temp)
-              )
-                clearContainerSparingly(root);
-              else if (1 === JSCompiler_temp)
-                switch (root.nodeName) {
-                  case "HEAD":
-                  case "HTML":
-                  case "BODY":
-                    clearContainerSparingly(root);
-                    break;
-                  default:
-                    root.textContent = "";
-                }
-            break;
-          case 5:
-          case 26:
-          case 27:
-          case 6:
-          case 4:
-          case 17:
-            break;
-          default:
-            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
+        break;
+      case 5:
+      case 26:
+      case 27:
+      case 6:
+      case 4:
+      case 17:
+        break;
+      case 30:
+        if (
+          isViewTransitionEligible &&
+          null !== current &&
+          0 !== (fiber.subtreeFlags & 8246)
+        )
+          a: {
+            isViewTransitionEligible = getViewTransitionName(
+              current.memoizedProps,
+              current.stateNode
+            );
+            flags = fiber.memoizedProps;
+            instance = getViewTransitionClassName(
+              flags.className,
+              flags.update
+            );
+            if (
+              "none" === instance &&
+              ((instance = getViewTransitionClassName(
+                flags.className,
+                flags.layout
+              )),
+              "none" === instance)
+            )
+              break a;
+            viewTransitionHostInstanceIdx = 0;
+            applyViewTransitionToHostInstances(
+              current.child,
+              isViewTransitionEligible,
+              instance,
+              (current.memoizedState = []),
+              !0
+            );
+          }
+        break;
+      default:
+        if (0 !== (flags & 1024)) throw Error(formatProdErrorMessage(163));
+    }
+    current = fiber.sibling;
+    if (null !== current) {
+      current.return = fiber.return;
+      nextEffect = current;
+      break;
+    }
+    nextEffect = fiber.return;
+  }
+}
+var viewTransitionHostInstanceIdx = 0;
+function applyViewTransitionToHostInstances(
+  child,
+  name,
+  className,
+  collectMeasurements,
+  stopAtNestedViewTransitions
+) {
+  for (var inViewport = !1; null !== child; ) {
+    if (5 === child.tag) {
+      shouldStartViewTransition = !0;
+      var instance = child.stateNode;
+      if (null !== collectMeasurements) {
+        var measurement = measureInstance(instance);
+        collectMeasurements.push(measurement);
+        measurement.view && (inViewport = !0);
+      } else
+        inViewport || (measureInstance(instance).view && (inViewport = !0));
+      measurement = className;
+      instance.style.viewTransitionName =
+        0 === viewTransitionHostInstanceIdx
+          ? name
+          : name + "_" + viewTransitionHostInstanceIdx;
+      null != measurement && (instance.style.viewTransitionClass = measurement);
+      viewTransitionHostInstanceIdx++;
+    } else if (22 !== child.tag || null === child.memoizedState)
+      (30 === child.tag && stopAtNestedViewTransitions) ||
+        (applyViewTransitionToHostInstances(
+          child.child,
+          name,
+          className,
+          collectMeasurements,
+          stopAtNestedViewTransitions
+        ) &&
+          (inViewport = !0));
+    child = child.sibling;
+  }
+  return inViewport;
+}
+function restoreViewTransitionOnHostInstances(
+  child,
+  stopAtNestedViewTransitions
+) {
+  for (; null !== child; ) {
+    if (5 === child.tag)
+      restoreViewTransitionName(child.stateNode, child.memoizedProps);
+    else if (22 !== child.tag || null === child.memoizedState)
+      (30 === child.tag && stopAtNestedViewTransitions) ||
+        restoreViewTransitionOnHostInstances(
+          child.child,
+          stopAtNestedViewTransitions
+        );
+    child = child.sibling;
+  }
+}
+function commitAppearingPairViewTransitions(placement) {
+  if (0 !== (placement.subtreeFlags & 2097152))
+    for (placement = placement.child; null !== placement; ) {
+      if (22 !== placement.tag || null !== placement.memoizedState)
+        if (
+          (commitAppearingPairViewTransitions(placement),
+          30 === placement.tag &&
+            0 !== (placement.flags & 2097152) &&
+            placement.stateNode.paired)
+        ) {
+          var props = placement.memoizedProps;
+          if (null == props.name || "auto" === props.name)
+            throw Error(formatProdErrorMessage(544));
+          var name = props.name;
+          props = getViewTransitionClassName(props.className, props.share);
+          "none" !== props &&
+            ((viewTransitionHostInstanceIdx = 0),
+            applyViewTransitionToHostInstances(
+              placement.child,
+              name,
+              props,
+              null,
+              !1
+            ) || restoreViewTransitionOnHostInstances(placement.child, !1));
         }
-        root = firstChild.sibling;
-        if (null !== root) {
-          root.return = firstChild.return;
-          nextEffect = root;
-          break;
+      placement = placement.sibling;
+    }
+}
+function commitEnterViewTransitions(placement) {
+  if (30 === placement.tag) {
+    var state = placement.stateNode,
+      props = placement.memoizedProps,
+      name = getViewTransitionName(props, state),
+      className = getViewTransitionClassName(
+        props.className,
+        state.paired ? props.share : props.enter
+      );
+    "none" !== className
+      ? ((viewTransitionHostInstanceIdx = 0),
+        applyViewTransitionToHostInstances(
+          placement.child,
+          name,
+          className,
+          null,
+          !1
+        )
+          ? (commitAppearingPairViewTransitions(placement),
+            state.paired ||
+              scheduleViewTransitionEvent(placement, props.onEnter))
+          : restoreViewTransitionOnHostInstances(placement.child, !1))
+      : commitAppearingPairViewTransitions(placement);
+  } else if (0 !== (placement.subtreeFlags & 33554432))
+    for (placement = placement.child; null !== placement; )
+      commitEnterViewTransitions(placement), (placement = placement.sibling);
+  else commitAppearingPairViewTransitions(placement);
+}
+function commitDeletedPairViewTransitions(deletion, appearingViewTransitions) {
+  if (
+    0 !== appearingViewTransitions.size &&
+    0 !== (deletion.subtreeFlags & 2097152)
+  )
+    for (deletion = deletion.child; null !== deletion; ) {
+      if (22 !== deletion.tag || null !== deletion.memoizedState) {
+        if (30 === deletion.tag && 0 !== (deletion.flags & 2097152)) {
+          var props = deletion.memoizedProps,
+            name = props.name;
+          if (null != name && "auto" !== name) {
+            var pair = appearingViewTransitions.get(name);
+            if (void 0 !== pair) {
+              var className = getViewTransitionClassName(
+                props.className,
+                props.share
+              );
+              "none" !== className &&
+                ((viewTransitionHostInstanceIdx = 0),
+                applyViewTransitionToHostInstances(
+                  deletion.child,
+                  name,
+                  className,
+                  null,
+                  !1
+                )
+                  ? ((pair.paired = deletion.stateNode),
+                    scheduleViewTransitionEvent(deletion, props.onShare))
+                  : restoreViewTransitionOnHostInstances(deletion.child, !1));
+              appearingViewTransitions.delete(name);
+              if (0 === appearingViewTransitions.size) break;
+            }
+          }
         }
-        nextEffect = firstChild.return;
+        commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+      }
+      deletion = deletion.sibling;
+    }
+}
+function commitExitViewTransitions(deletion, appearingViewTransitions) {
+  if (30 === deletion.tag) {
+    var props = deletion.memoizedProps,
+      name = getViewTransitionName(props, deletion.stateNode),
+      pair =
+        null !== appearingViewTransitions
+          ? appearingViewTransitions.get(name)
+          : void 0,
+      className = getViewTransitionClassName(
+        props.className,
+        void 0 !== pair ? props.share : props.exit
+      );
+    "none" !== className &&
+      ((viewTransitionHostInstanceIdx = 0),
+      applyViewTransitionToHostInstances(
+        deletion.child,
+        name,
+        className,
+        null,
+        !1
+      )
+        ? void 0 !== pair
+          ? ((pair.paired = deletion.stateNode),
+            appearingViewTransitions.delete(name),
+            scheduleViewTransitionEvent(deletion, props.onShare))
+          : scheduleViewTransitionEvent(deletion, props.onExit)
+        : restoreViewTransitionOnHostInstances(deletion.child, !1));
+    null !== appearingViewTransitions &&
+      commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+  } else if (0 !== (deletion.subtreeFlags & 33554432))
+    for (deletion = deletion.child; null !== deletion; )
+      commitExitViewTransitions(deletion, appearingViewTransitions),
+        (deletion = deletion.sibling);
+  else
+    null !== appearingViewTransitions &&
+      commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+}
+function commitNestedViewTransitions(changedParent) {
+  for (changedParent = changedParent.child; null !== changedParent; ) {
+    if (30 === changedParent.tag) {
+      var props = changedParent.memoizedProps,
+        name = getViewTransitionName(props, changedParent.stateNode);
+      props = getViewTransitionClassName(props.className, props.layout);
+      "none" !== props &&
+        ((viewTransitionHostInstanceIdx = 0),
+        applyViewTransitionToHostInstances(
+          changedParent.child,
+          name,
+          props,
+          (changedParent.memoizedState = []),
+          !1
+        ));
+    } else
+      0 !== (changedParent.subtreeFlags & 33554432) &&
+        commitNestedViewTransitions(changedParent);
+    changedParent = changedParent.sibling;
+  }
+}
+function restorePairedViewTransitions(parent) {
+  if (0 !== (parent.subtreeFlags & 2097152))
+    for (parent = parent.child; null !== parent; ) {
+      if (22 !== parent.tag || null !== parent.memoizedState) {
+        if (30 === parent.tag && 0 !== (parent.flags & 2097152)) {
+          var instance = parent.stateNode;
+          null !== instance.paired &&
+            ((instance.paired = null),
+            restoreViewTransitionOnHostInstances(parent.child, !1));
+        }
+        restorePairedViewTransitions(parent);
+      }
+      parent = parent.sibling;
+    }
+}
+function restoreEnterViewTransitions(placement) {
+  if (30 === placement.tag)
+    (placement.stateNode.paired = null),
+      restoreViewTransitionOnHostInstances(placement.child, !1),
+      restorePairedViewTransitions(placement);
+  else if (0 !== (placement.subtreeFlags & 33554432))
+    for (placement = placement.child; null !== placement; )
+      restoreEnterViewTransitions(placement), (placement = placement.sibling);
+  else restorePairedViewTransitions(placement);
+}
+function restoreExitViewTransitions(deletion) {
+  if (30 === deletion.tag)
+    (deletion.stateNode.paired = null),
+      restoreViewTransitionOnHostInstances(deletion.child, !1),
+      restorePairedViewTransitions(deletion);
+  else if (0 !== (deletion.subtreeFlags & 33554432))
+    for (deletion = deletion.child; null !== deletion; )
+      restoreExitViewTransitions(deletion), (deletion = deletion.sibling);
+  else restorePairedViewTransitions(deletion);
+}
+function restoreNestedViewTransitions(changedParent) {
+  for (changedParent = changedParent.child; null !== changedParent; )
+    30 === changedParent.tag
+      ? ((changedParent.memoizedState = null),
+        restoreViewTransitionOnHostInstances(changedParent.child, !1))
+      : 0 !== (changedParent.subtreeFlags & 33554432) &&
+        restoreNestedViewTransitions(changedParent),
+      (changedParent = changedParent.sibling);
+}
+function cancelViewTransitionHostInstances(
+  currentViewTransition,
+  child,
+  stopAtNestedViewTransitions
+) {
+  for (; null !== child; ) {
+    if (5 === child.tag) {
+      var instance = child.stateNode,
+        oldName = getViewTransitionName(
+          currentViewTransition.memoizedProps,
+          currentViewTransition.stateNode
+        );
+      null === viewTransitionCancelableChildren &&
+        (viewTransitionCancelableChildren = []);
+      viewTransitionCancelableChildren.push(
+        instance,
+        oldName,
+        child.memoizedProps
+      );
+      viewTransitionHostInstanceIdx++;
+    } else if (22 !== child.tag || null === child.memoizedState)
+      (30 === child.tag && stopAtNestedViewTransitions) ||
+        cancelViewTransitionHostInstances(
+          currentViewTransition,
+          child.child,
+          stopAtNestedViewTransitions
+        );
+    child = child.sibling;
+  }
+}
+function measureViewTransitionHostInstances(
+  currentViewTransition,
+  parentViewTransition,
+  child,
+  name,
+  className,
+  previousMeasurements,
+  stopAtNestedViewTransitions
+) {
+  for (var inViewport = !1; null !== child; ) {
+    if (5 === child.tag) {
+      var instance = child.stateNode;
+      if (
+        null !== previousMeasurements &&
+        viewTransitionHostInstanceIdx < previousMeasurements.length
+      ) {
+        var previousMeasurement =
+            previousMeasurements[viewTransitionHostInstanceIdx],
+          nextMeasurement = measureInstance(instance);
+        if (previousMeasurement.view || nextMeasurement.view) inViewport = !0;
+        var JSCompiler_temp;
+        if ((JSCompiler_temp = 0 === (parentViewTransition.flags & 4)))
+          if (nextMeasurement.clip) JSCompiler_temp = !0;
+          else {
+            JSCompiler_temp = previousMeasurement.rect;
+            var newRect = nextMeasurement.rect;
+            JSCompiler_temp =
+              JSCompiler_temp.y !== newRect.y ||
+              JSCompiler_temp.x !== newRect.x ||
+              JSCompiler_temp.height !== newRect.height ||
+              JSCompiler_temp.width !== newRect.width;
+          }
+        JSCompiler_temp && (parentViewTransition.flags |= 4);
+        nextMeasurement.abs
+          ? (nextMeasurement = !previousMeasurement.abs)
+          : ((previousMeasurement = previousMeasurement.rect),
+            (nextMeasurement = nextMeasurement.rect),
+            (nextMeasurement =
+              previousMeasurement.height !== nextMeasurement.height ||
+              previousMeasurement.width !== nextMeasurement.width));
+        nextMeasurement && (parentViewTransition.flags |= 32);
+      } else parentViewTransition.flags |= 32;
+      0 !== (parentViewTransition.flags & 4) &&
+        ((nextMeasurement = instance),
+        (previousMeasurement = className),
+        (nextMeasurement.style.viewTransitionName =
+          0 === viewTransitionHostInstanceIdx
+            ? name
+            : name + "_" + viewTransitionHostInstanceIdx),
+        null != previousMeasurement &&
+          (nextMeasurement.style.viewTransitionClass = previousMeasurement));
+      (inViewport && 0 !== (parentViewTransition.flags & 4)) ||
+        ((nextMeasurement = getViewTransitionName(
+          currentViewTransition.memoizedProps,
+          currentViewTransition.stateNode
+        )),
+        null === viewTransitionCancelableChildren &&
+          (viewTransitionCancelableChildren = []),
+        viewTransitionCancelableChildren.push(
+          instance,
+          nextMeasurement,
+          child.memoizedProps
+        ));
+      viewTransitionHostInstanceIdx++;
+    } else if (22 !== child.tag || null === child.memoizedState)
+      30 === child.tag && stopAtNestedViewTransitions
+        ? (parentViewTransition.flags |= child.flags & 32)
+        : measureViewTransitionHostInstances(
+            currentViewTransition,
+            parentViewTransition,
+            child.child,
+            name,
+            className,
+            previousMeasurements,
+            stopAtNestedViewTransitions
+          ) && (inViewport = !0);
+    child = child.sibling;
+  }
+  return inViewport;
+}
+function measureNestedViewTransitions(changedParent) {
+  for (changedParent = changedParent.child; null !== changedParent; ) {
+    if (30 === changedParent.tag) {
+      var current = changedParent.alternate;
+      if (null !== current) {
+        var props = changedParent.memoizedProps,
+          name = getViewTransitionName(props, changedParent.stateNode),
+          className = getViewTransitionClassName(props.className, props.layout);
+        viewTransitionHostInstanceIdx = 0;
+        current = measureViewTransitionHostInstances(
+          current,
+          changedParent,
+          changedParent.child,
+          name,
+          className,
+          changedParent.memoizedState,
+          !1
+        );
+        0 !== (changedParent.flags & 4) &&
+          current &&
+          scheduleViewTransitionEvent(changedParent, props.onLayout);
       }
+    } else
+      0 !== (changedParent.subtreeFlags & 33554432) &&
+        measureNestedViewTransitions(changedParent);
+    changedParent = changedParent.sibling;
+  }
 }
 function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
-  var flags = finishedWork.flags;
+  var prevEffectStart = pushComponentEffectStart(),
+    prevEffectErrors = pushComponentEffectErrors(),
+    flags = finishedWork.flags;
   switch (finishedWork.tag) {
     case 0:
     case 11:
@@ -8031,11 +8937,11 @@ function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
           } else
             try {
               finishedRoot.componentDidMount();
-            } catch (error$114) {
+            } catch (error$119) {
               captureCommitPhaseError(
                 finishedWork,
                 finishedWork.return,
-                error$114
+                error$119
               );
             }
         else {
@@ -8052,11 +8958,11 @@ function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
                 current,
                 finishedRoot.__reactInternalSnapshotBeforeUpdate
               );
-            } catch (error$115) {
+            } catch (error$120) {
               captureCommitPhaseError(
                 finishedWork,
                 finishedWork.return,
-                error$115
+                error$120
               );
             }
             recordEffectDuration();
@@ -8067,11 +8973,11 @@ function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
                 current,
                 finishedRoot.__reactInternalSnapshotBeforeUpdate
               );
-            } catch (error$116) {
+            } catch (error$121) {
               captureCommitPhaseError(
                 finishedWork,
                 finishedWork.return,
-                error$116
+                error$121
               );
             }
         }
@@ -8100,11 +9006,11 @@ function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
       }
       finishedRoot.effectDuration += popNestedEffectDurations(current);
       break;
-    case 27:
-      null === current &&
-        flags & 4 &&
-        commitHostSingletonAcquisition(finishedWork);
     case 26:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+      break;
+    case 27:
     case 5:
       recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
       null === current && flags & 4 && commitHostMount(finishedWork);
@@ -8132,11 +9038,8 @@ function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
         null !== finishedRoot &&
           ((finishedRoot = finishedRoot.dehydrated),
           null !== finishedRoot &&
-            ((finishedWork = retryDehydratedSuspenseBoundary.bind(
-              null,
-              finishedWork
-            )),
-            registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
+            ((flags = retryDehydratedSuspenseBoundary.bind(null, finishedWork)),
+            registerSuspenseInstanceRetry(finishedRoot, flags))));
       break;
     case 22:
       prevProps =
@@ -8163,9 +9066,26 @@ function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
           ? safelyAttachRef(finishedWork, finishedWork.return)
           : safelyDetachRef(finishedWork, finishedWork.return));
       break;
+    case 30:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+      break;
     default:
       recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
   }
+  0 !== (finishedWork.mode & 2) &&
+    0 <= componentEffectStartTime &&
+    0 <= componentEffectEndTime &&
+    0.05 < componentEffectDuration &&
+    logComponentEffect(
+      finishedWork,
+      componentEffectStartTime,
+      componentEffectEndTime,
+      componentEffectDuration,
+      componentEffectErrors
+    );
+  popComponentEffectStart(prevEffectStart);
+  componentEffectErrors = prevEffectErrors;
 }
 function detachFiberAfterEffects(fiber) {
   var alternate = fiber.alternate;
@@ -8226,14 +9146,20 @@ function commitDeletionEffectsOnFiber(
         safelyDetachRef(deletedFiber, nearestMountedAncestor);
       var prevHostParent = hostParent,
         prevHostParentIsContainer = hostParentIsContainer;
-      "head" === deletedFiber.type &&
-        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !1));
+      hostParent = deletedFiber.stateNode;
       recursivelyTraverseDeletionEffects(
         finishedRoot,
         nearestMountedAncestor,
         deletedFiber
       );
-      releaseSingletonInstance(deletedFiber.stateNode);
+      deletedFiber = deletedFiber.stateNode;
+      for (
+        nearestMountedAncestor = deletedFiber.attributes;
+        nearestMountedAncestor.length;
+
+      )
+        deletedFiber.removeAttributeNode(nearestMountedAncestor[0]);
+      detachDeletedInstance(deletedFiber);
       hostParent = prevHostParent;
       hostParentIsContainer = prevHostParentIsContainer;
       break;
@@ -8241,33 +9167,25 @@ function commitDeletionEffectsOnFiber(
       offscreenSubtreeWasHidden ||
         safelyDetachRef(deletedFiber, nearestMountedAncestor);
     case 6:
-      prevHostParent = hostParent;
-      prevHostParentIsContainer = hostParentIsContainer;
+      prevHostParentIsContainer = hostParent;
+      var prevHostParentIsContainer$131 = hostParentIsContainer;
       hostParent = null;
       recursivelyTraverseDeletionEffects(
         finishedRoot,
         nearestMountedAncestor,
         deletedFiber
       );
-      hostParent = prevHostParent;
-      hostParentIsContainer = prevHostParentIsContainer;
+      hostParent = prevHostParentIsContainer;
+      hostParentIsContainer = prevHostParentIsContainer$131;
       if (null !== hostParent)
         if (hostParentIsContainer)
           try {
-            switch (hostParent.nodeType) {
-              case 8:
-                var parentNode = hostParent.parentNode;
-                break;
-              case 9:
-                parentNode = hostParent.body;
-                break;
-              default:
-                parentNode =
-                  "HTML" === hostParent.nodeName
-                    ? hostParent.ownerDocument.body
-                    : hostParent;
-            }
-            parentNode.removeChild(deletedFiber.stateNode);
+            (finishedRoot = hostParent),
+              (prevHostParent = deletedFiber.stateNode),
+              8 === finishedRoot.nodeType
+                ? finishedRoot.parentNode.removeChild(prevHostParent)
+                : finishedRoot.removeChild(prevHostParent),
+              (viewTransitionMutationContext = !0);
           } catch (error) {
             captureCommitPhaseError(
               deletedFiber,
@@ -8277,7 +9195,8 @@ function commitDeletionEffectsOnFiber(
           }
         else
           try {
-            hostParent.removeChild(deletedFiber.stateNode);
+            hostParent.removeChild(deletedFiber.stateNode),
+              (viewTransitionMutationContext = !0);
           } catch (error) {
             captureCommitPhaseError(
               deletedFiber,
@@ -8289,19 +9208,16 @@ function commitDeletionEffectsOnFiber(
     case 18:
       null !== hostParent &&
         (hostParentIsContainer
-          ? ((finishedRoot = hostParent),
+          ? ((nearestMountedAncestor = hostParent),
             (deletedFiber = deletedFiber.stateNode),
-            8 === finishedRoot.nodeType
-              ? clearSuspenseBoundary(finishedRoot.parentNode, deletedFiber)
-              : 9 === finishedRoot.nodeType
-                ? clearSuspenseBoundary(finishedRoot.body, deletedFiber)
-                : "HTML" === finishedRoot.nodeName
-                  ? clearSuspenseBoundary(
-                      finishedRoot.ownerDocument.body,
-                      deletedFiber
-                    )
-                  : clearSuspenseBoundary(finishedRoot, deletedFiber),
-            retryIfBlockedOn(finishedRoot))
+            8 === nearestMountedAncestor.nodeType
+              ? clearSuspenseBoundary(
+                  nearestMountedAncestor.parentNode,
+                  deletedFiber
+                )
+              : 1 === nearestMountedAncestor.nodeType &&
+                clearSuspenseBoundary(nearestMountedAncestor, deletedFiber),
+            retryIfBlockedOn(nearestMountedAncestor))
           : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
       break;
     case 4:
@@ -8424,7 +9340,7 @@ function attachSuspenseRetryListeners(finishedWork, wakeables) {
     }
   });
 }
-function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
+function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber, lanes) {
   var deletions = parentFiber.deletions;
   if (null !== deletions)
     for (var i = 0; i < deletions.length; i++) {
@@ -8435,12 +9351,6 @@ function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
       a: for (; null !== parent; ) {
         switch (parent.tag) {
           case 27:
-            if ("head" === parent.type) {
-              hostParent = parent.stateNode;
-              hostParentIsContainer = !1;
-              break a;
-            }
-            break;
           case 5:
             hostParent = parent.stateNode;
             hostParentIsContainer = !1;
@@ -8466,19 +9376,21 @@ function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
     }
   if (parentFiber.subtreeFlags & 13878)
     for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
+      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0, lanes),
         (parentFiber = parentFiber.sibling);
 }
 var currentHoistableRoot = null;
-function commitMutationEffectsOnFiber(finishedWork, root) {
-  var current = finishedWork.alternate,
+function commitMutationEffectsOnFiber(finishedWork, root, lanes) {
+  var prevEffectStart = pushComponentEffectStart(),
+    prevEffectErrors = pushComponentEffectErrors(),
+    current = finishedWork.alternate,
     flags = finishedWork.flags;
   switch (finishedWork.tag) {
     case 0:
     case 11:
     case 14:
     case 15:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       flags & 4 &&
         (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
@@ -8486,7 +9398,7 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
         commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, 5));
       break;
     case 1:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       flags & 512 &&
         (offscreenSubtreeWasHidden ||
@@ -8494,17 +9406,17 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
           safelyDetachRef(current, current.return));
       flags & 64 &&
         offscreenSubtreeIsHidden &&
-        ((finishedWork = finishedWork.updateQueue),
-        null !== finishedWork &&
-          ((flags = finishedWork.callbacks),
-          null !== flags &&
-            ((current = finishedWork.shared.hiddenCallbacks),
-            (finishedWork.shared.hiddenCallbacks =
-              null === current ? flags : current.concat(flags)))));
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((current = flags.callbacks),
+          null !== current &&
+            ((root = flags.shared.hiddenCallbacks),
+            (flags.shared.hiddenCallbacks =
+              null === root ? current : root.concat(current)))));
       break;
     case 26:
       var hoistableRoot = currentHoistableRoot;
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       flags & 512 &&
         (offscreenSubtreeWasHidden ||
@@ -8524,98 +9436,98 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
                 root = hoistableRoot.ownerDocument || hoistableRoot;
                 b: switch (flags) {
                   case "title":
-                    hoistableRoot = root.getElementsByTagName("title")[0];
+                    lanes = root.getElementsByTagName("title")[0];
                     if (
-                      !hoistableRoot ||
-                      hoistableRoot[internalHoistableMarker] ||
-                      hoistableRoot[internalInstanceKey] ||
-                      "http://www.w3.org/2000/svg" ===
-                        hoistableRoot.namespaceURI ||
-                      hoistableRoot.hasAttribute("itemprop")
+                      !lanes ||
+                      lanes[internalHoistableMarker] ||
+                      lanes[internalInstanceKey] ||
+                      "http://www.w3.org/2000/svg" === lanes.namespaceURI ||
+                      lanes.hasAttribute("itemprop")
                     )
-                      (hoistableRoot = root.createElement(flags)),
+                      (lanes = root.createElement(flags)),
                         root.head.insertBefore(
-                          hoistableRoot,
+                          lanes,
                           root.querySelector("head > title")
                         );
-                    setInitialProperties(hoistableRoot, flags, current);
-                    hoistableRoot[internalInstanceKey] = finishedWork;
-                    markNodeAsHoistable(hoistableRoot);
-                    flags = hoistableRoot;
+                    setInitialProperties(lanes, flags, current);
+                    lanes[internalInstanceKey] = finishedWork;
+                    markNodeAsHoistable(lanes);
+                    flags = lanes;
                     break a;
                   case "link":
-                    var maybeNodes = getHydratableHoistableCache(
-                      "link",
-                      "href",
-                      root
-                    ).get(flags + (current.href || ""));
-                    if (maybeNodes)
-                      for (var i = 0; i < maybeNodes.length; i++)
+                    if (
+                      (hoistableRoot = getHydratableHoistableCache(
+                        "link",
+                        "href",
+                        root
+                      ).get(flags + (current.href || "")))
+                    )
+                      for (var i = 0; i < hoistableRoot.length; i++)
                         if (
-                          ((hoistableRoot = maybeNodes[i]),
-                          hoistableRoot.getAttribute("href") ===
+                          ((lanes = hoistableRoot[i]),
+                          lanes.getAttribute("href") ===
                             (null == current.href || "" === current.href
                               ? null
                               : current.href) &&
-                            hoistableRoot.getAttribute("rel") ===
+                            lanes.getAttribute("rel") ===
                               (null == current.rel ? null : current.rel) &&
-                            hoistableRoot.getAttribute("title") ===
+                            lanes.getAttribute("title") ===
                               (null == current.title ? null : current.title) &&
-                            hoistableRoot.getAttribute("crossorigin") ===
+                            lanes.getAttribute("crossorigin") ===
                               (null == current.crossOrigin
                                 ? null
                                 : current.crossOrigin))
                         ) {
-                          maybeNodes.splice(i, 1);
+                          hoistableRoot.splice(i, 1);
                           break b;
                         }
-                    hoistableRoot = root.createElement(flags);
-                    setInitialProperties(hoistableRoot, flags, current);
-                    root.head.appendChild(hoistableRoot);
+                    lanes = root.createElement(flags);
+                    setInitialProperties(lanes, flags, current);
+                    root.head.appendChild(lanes);
                     break;
                   case "meta":
                     if (
-                      (maybeNodes = getHydratableHoistableCache(
+                      (hoistableRoot = getHydratableHoistableCache(
                         "meta",
                         "content",
                         root
                       ).get(flags + (current.content || "")))
                     )
-                      for (i = 0; i < maybeNodes.length; i++)
+                      for (i = 0; i < hoistableRoot.length; i++)
                         if (
-                          ((hoistableRoot = maybeNodes[i]),
-                          hoistableRoot.getAttribute("content") ===
+                          ((lanes = hoistableRoot[i]),
+                          lanes.getAttribute("content") ===
                             (null == current.content
                               ? null
                               : "" + current.content) &&
-                            hoistableRoot.getAttribute("name") ===
+                            lanes.getAttribute("name") ===
                               (null == current.name ? null : current.name) &&
-                            hoistableRoot.getAttribute("property") ===
+                            lanes.getAttribute("property") ===
                               (null == current.property
                                 ? null
                                 : current.property) &&
-                            hoistableRoot.getAttribute("http-equiv") ===
+                            lanes.getAttribute("http-equiv") ===
                               (null == current.httpEquiv
                                 ? null
                                 : current.httpEquiv) &&
-                            hoistableRoot.getAttribute("charset") ===
+                            lanes.getAttribute("charset") ===
                               (null == current.charSet
                                 ? null
                                 : current.charSet))
                         ) {
-                          maybeNodes.splice(i, 1);
+                          hoistableRoot.splice(i, 1);
                           break b;
                         }
-                    hoistableRoot = root.createElement(flags);
-                    setInitialProperties(hoistableRoot, flags, current);
-                    root.head.appendChild(hoistableRoot);
+                    lanes = root.createElement(flags);
+                    setInitialProperties(lanes, flags, current);
+                    root.head.appendChild(lanes);
                     break;
                   default:
                     throw Error(formatProdErrorMessage(468, flags));
                 }
-                hoistableRoot[internalInstanceKey] = finishedWork;
-                markNodeAsHoistable(hoistableRoot);
-                flags = hoistableRoot;
+                lanes[internalInstanceKey] = finishedWork;
+                markNodeAsHoistable(lanes);
+                flags = lanes;
               }
               finishedWork.stateNode = flags;
             } else
@@ -8657,22 +9569,38 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
               );
       break;
     case 27:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 512 &&
-        (offscreenSubtreeWasHidden ||
-          null === current ||
-          safelyDetachRef(current, current.return));
-      null !== current &&
-        flags & 4 &&
-        commitHostUpdate(
-          finishedWork,
-          finishedWork.memoizedProps,
-          current.memoizedProps
-        );
-      break;
+      if (flags & 4 && null === finishedWork.alternate) {
+        hoistableRoot = finishedWork.stateNode;
+        i = finishedWork.memoizedProps;
+        try {
+          for (var node = hoistableRoot.firstChild; node; ) {
+            var nextNode = node.nextSibling,
+              nodeName = node.nodeName;
+            node[internalHoistableMarker] ||
+              "HEAD" === nodeName ||
+              "BODY" === nodeName ||
+              "SCRIPT" === nodeName ||
+              "STYLE" === nodeName ||
+              ("LINK" === nodeName &&
+                "stylesheet" === node.rel.toLowerCase()) ||
+              hoistableRoot.removeChild(node);
+            node = nextNode;
+          }
+          for (
+            var type = finishedWork.type, attributes = hoistableRoot.attributes;
+            attributes.length;
+
+          )
+            hoistableRoot.removeAttributeNode(attributes[0]);
+          setInitialProperties(hoistableRoot, type, i);
+          hoistableRoot[internalInstanceKey] = finishedWork;
+          hoistableRoot[internalPropsKey] = i;
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      }
     case 5:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       flags & 512 &&
         (offscreenSubtreeWasHidden ||
@@ -8681,7 +9609,7 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
       if (finishedWork.flags & 32) {
         root = finishedWork.stateNode;
         try {
-          setTextContent(root, "");
+          setTextContent(root, ""), (viewTransitionMutationContext = !0);
         } catch (error) {
           captureCommitPhaseError(finishedWork, finishedWork.return, error);
         }
@@ -8697,7 +9625,7 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
       flags & 1024 && (needsFormReset = !0);
       break;
     case 6:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       if (flags & 4) {
         if (null === finishedWork.stateNode)
@@ -8705,7 +9633,7 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
         flags = finishedWork.memoizedProps;
         current = finishedWork.stateNode;
         try {
-          current.nodeValue = flags;
+          (current.nodeValue = flags), (viewTransitionMutationContext = !0);
         } catch (error) {
           captureCommitPhaseError(finishedWork, finishedWork.return, error);
         }
@@ -8714,10 +9642,10 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
     case 3:
       hoistableRoot = pushNestedEffectDurations();
       tagCaches = null;
-      maybeNodes = currentHoistableRoot;
+      i = currentHoistableRoot;
       currentHoistableRoot = getHoistableRoot(root.containerInfo);
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      currentHoistableRoot = maybeNodes;
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      currentHoistableRoot = i;
       commitReconciliationEffects(finishedWork);
       if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
         try {
@@ -8734,19 +9662,19 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
       currentHoistableRoot = getHoistableRoot(
         finishedWork.stateNode.containerInfo
       );
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       currentHoistableRoot = flags;
       break;
     case 12:
       flags = pushNestedEffectDurations();
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       finishedWork.stateNode.effectDuration +=
         bubbleNestedEffectDurations(flags);
       break;
     case 13:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       finishedWork.child.flags & 8192 &&
         (null !== finishedWork.memoizedState) !==
@@ -8763,15 +9691,15 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
         (offscreenSubtreeWasHidden ||
           null === current ||
           safelyDetachRef(current, current.return));
-      hoistableRoot = null !== finishedWork.memoizedState;
-      var wasHidden = null !== current && null !== current.memoizedState,
-        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
-      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
-      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+      node = null !== finishedWork.memoizedState;
+      nextNode = null !== current && null !== current.memoizedState;
+      nodeName = offscreenSubtreeIsHidden;
+      type = offscreenSubtreeWasHidden;
+      offscreenSubtreeIsHidden = nodeName || node;
+      offscreenSubtreeWasHidden = type || nextNode;
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      offscreenSubtreeWasHidden = type;
+      offscreenSubtreeIsHidden = nodeName;
       commitReconciliationEffects(finishedWork);
       root = finishedWork.stateNode;
       root._current = finishedWork;
@@ -8779,31 +9707,31 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
       root._visibility |= root._pendingVisibility & 2;
       if (
         flags & 8192 &&
-        ((root._visibility = hoistableRoot
+        ((root._visibility = node
           ? root._visibility & -2
           : root._visibility | 1),
-        hoistableRoot &&
-          (null === current ||
-            wasHidden ||
-            offscreenSubtreeIsHidden ||
-            offscreenSubtreeWasHidden ||
+        node &&
+          ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
+          null === current ||
+            nextNode ||
+            root ||
             recursivelyTraverseDisappearLayoutEffects(finishedWork)),
         null === finishedWork.memoizedProps ||
           "manual" !== finishedWork.memoizedProps.mode)
       )
         a: for (current = null, root = finishedWork; ; ) {
-          if (5 === root.tag || 26 === root.tag) {
+          if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
             if (null === current) {
-              wasHidden = current = root;
+              lanes = current = root;
               try {
-                if (((maybeNodes = wasHidden.stateNode), hoistableRoot))
-                  (i = maybeNodes.style),
+                if (((hoistableRoot = lanes.stateNode), node))
+                  (i = hoistableRoot.style),
                     "function" === typeof i.setProperty
                       ? i.setProperty("display", "none", "important")
                       : (i.display = "none");
                 else {
-                  var instance = wasHidden.stateNode,
-                    styleProp = wasHidden.memoizedProps.style,
+                  var instance = lanes.stateNode,
+                    styleProp = lanes.memoizedProps.style,
                     display =
                       void 0 !== styleProp &&
                       null !== styleProp &&
@@ -8816,18 +9744,16 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
                       : ("" + display).trim();
                 }
               } catch (error) {
-                captureCommitPhaseError(wasHidden, wasHidden.return, error);
+                captureCommitPhaseError(lanes, lanes.return, error);
               }
             }
           } else if (6 === root.tag) {
             if (null === current) {
-              wasHidden = root;
+              lanes = root;
               try {
-                wasHidden.stateNode.nodeValue = hoistableRoot
-                  ? ""
-                  : wasHidden.memoizedProps;
+                lanes.stateNode.nodeValue = node ? "" : lanes.memoizedProps;
               } catch (error) {
-                captureCommitPhaseError(wasHidden, wasHidden.return, error);
+                captureCommitPhaseError(lanes, lanes.return, error);
               }
             }
           } else if (
@@ -8859,7 +9785,7 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
             attachSuspenseRetryListeners(finishedWork, current))));
       break;
     case 19:
-      recursivelyTraverseMutationEffects(root, finishedWork);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
       commitReconciliationEffects(finishedWork);
       flags & 4 &&
         ((flags = finishedWork.updateQueue),
@@ -8868,53 +9794,82 @@ function commitMutationEffectsOnFiber(finishedWork, root) {
           attachSuspenseRetryListeners(finishedWork, flags)));
       break;
     case 30:
+      flags & 512 &&
+        (offscreenSubtreeWasHidden ||
+          null === current ||
+          safelyDetachRef(current, current.return));
+      flags = viewTransitionMutationContext;
+      viewTransitionMutationContext = !1;
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      (lanes & 335544192) === lanes &&
+        null !== current &&
+        viewTransitionMutationContext &&
+        (finishedWork.flags |= 4);
+      viewTransitionMutationContext = flags;
+      break;
     case 21:
       break;
     default:
-      recursivelyTraverseMutationEffects(root, finishedWork),
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes),
         commitReconciliationEffects(finishedWork);
   }
+  0 !== (finishedWork.mode & 2) &&
+    0 <= componentEffectStartTime &&
+    0 <= componentEffectEndTime &&
+    0.05 < componentEffectDuration &&
+    logComponentEffect(
+      finishedWork,
+      componentEffectStartTime,
+      componentEffectEndTime,
+      componentEffectDuration,
+      componentEffectErrors
+    );
+  popComponentEffectStart(prevEffectStart);
+  componentEffectErrors = prevEffectErrors;
 }
 function commitReconciliationEffects(finishedWork) {
   var flags = finishedWork.flags;
   if (flags & 2) {
     try {
-      a: {
-        for (var parent = finishedWork.return; null !== parent; ) {
-          if (isHostParent(parent)) {
-            var JSCompiler_inline_result = parent;
-            break a;
+      if (27 !== finishedWork.tag) {
+        a: {
+          for (var parent = finishedWork.return; null !== parent; ) {
+            if (isHostParent(parent)) {
+              var JSCompiler_inline_result = parent;
+              break a;
+            }
+            parent = parent.return;
           }
-          parent = parent.return;
+          throw Error(formatProdErrorMessage(160));
+        }
+        switch (JSCompiler_inline_result.tag) {
+          case 27:
+            var parent$jscomp$0 = JSCompiler_inline_result.stateNode,
+              before = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
+            break;
+          case 5:
+            var parent$124 = JSCompiler_inline_result.stateNode;
+            JSCompiler_inline_result.flags & 32 &&
+              (setTextContent(parent$124, ""),
+              (JSCompiler_inline_result.flags &= -33));
+            var before$125 = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, before$125, parent$124);
+            break;
+          case 3:
+          case 4:
+            var parent$126 = JSCompiler_inline_result.stateNode.containerInfo,
+              before$127 = getHostSibling(finishedWork);
+            insertOrAppendPlacementNodeIntoContainer(
+              finishedWork,
+              before$127,
+              parent$126
+            );
+            break;
+          default:
+            throw Error(formatProdErrorMessage(161));
         }
-        throw Error(formatProdErrorMessage(160));
-      }
-      switch (JSCompiler_inline_result.tag) {
-        case 27:
-          var parent$jscomp$0 = JSCompiler_inline_result.stateNode,
-            before = getHostSibling(finishedWork);
-          insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
-          break;
-        case 5:
-          var parent$119 = JSCompiler_inline_result.stateNode;
-          JSCompiler_inline_result.flags & 32 &&
-            (setTextContent(parent$119, ""),
-            (JSCompiler_inline_result.flags &= -33));
-          var before$120 = getHostSibling(finishedWork);
-          insertOrAppendPlacementNode(finishedWork, before$120, parent$119);
-          break;
-        case 3:
-        case 4:
-          var parent$121 = JSCompiler_inline_result.stateNode.containerInfo,
-            before$122 = getHostSibling(finishedWork);
-          insertOrAppendPlacementNodeIntoContainer(
-            finishedWork,
-            before$122,
-            parent$121
-          );
-          break;
-        default:
-          throw Error(formatProdErrorMessage(161));
       }
     } catch (error) {
       captureCommitPhaseError(finishedWork, finishedWork.return, error);
@@ -8932,6 +9887,153 @@ function recursivelyResetForms(parentFiber) {
       parentFiber = parentFiber.sibling;
     }
 }
+function recursivelyTraverseAfterMutationEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 9238)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitAfterMutationEffectsOnFiber(parentFiber, root),
+        (parentFiber = parentFiber.sibling);
+  else measureNestedViewTransitions(parentFiber);
+}
+function commitAfterMutationEffectsOnFiber(finishedWork, root) {
+  var current = finishedWork.alternate;
+  if (null === current) commitEnterViewTransitions(finishedWork);
+  else
+    switch (finishedWork.tag) {
+      case 3:
+        viewTransitionContextChanged = !1;
+        viewTransitionCancelableChildren = null;
+        recursivelyTraverseAfterMutationEffects(root, finishedWork);
+        if (!viewTransitionContextChanged) {
+          finishedWork = viewTransitionCancelableChildren;
+          viewTransitionCancelableChildren = null;
+          if (null !== finishedWork)
+            for (var i = 0; i < finishedWork.length; i += 3) {
+              var instance = finishedWork[i],
+                oldName = finishedWork[i + 1];
+              restoreViewTransitionName(instance, finishedWork[i + 2]);
+              instance = instance.ownerDocument.documentElement;
+              null !== instance &&
+                instance.animate(
+                  { opacity: [0, 0], pointerEvents: ["none", "none"] },
+                  {
+                    duration: 0,
+                    fill: "forwards",
+                    pseudoElement: "::view-transition-group(" + oldName + ")"
+                  }
+                );
+            }
+          finishedWork = root.containerInfo;
+          finishedWork =
+            9 === finishedWork.nodeType
+              ? finishedWork.documentElement
+              : finishedWork.ownerDocument.documentElement;
+          null !== finishedWork &&
+            "" === finishedWork.style.viewTransitionName &&
+            ((finishedWork.style.viewTransitionName = "none"),
+            finishedWork.animate(
+              { opacity: [0, 0], pointerEvents: ["none", "none"] },
+              {
+                duration: 0,
+                fill: "forwards",
+                pseudoElement: "::view-transition-group(root)"
+              }
+            ),
+            finishedWork.animate(
+              { width: [0, 0], height: [0, 0] },
+              {
+                duration: 0,
+                fill: "forwards",
+                pseudoElement: "::view-transition"
+              }
+            ));
+        }
+        break;
+      case 5:
+        recursivelyTraverseAfterMutationEffects(root, finishedWork);
+        break;
+      case 22:
+        null === finishedWork.memoizedState &&
+          (null !== current.memoizedState
+            ? commitEnterViewTransitions(finishedWork)
+            : recursivelyTraverseAfterMutationEffects(root, finishedWork));
+        break;
+      case 30:
+        if (0 !== (finishedWork.subtreeFlags & 8246)) {
+          i = 0 !== (finishedWork.flags & 4);
+          oldName = viewTransitionContextChanged;
+          instance = viewTransitionCancelableChildren;
+          viewTransitionContextChanged = !1;
+          viewTransitionCancelableChildren = null;
+          recursivelyTraverseAfterMutationEffects(root, finishedWork);
+          viewTransitionContextChanged && (finishedWork.flags |= 4);
+          a: {
+            root = finishedWork.memoizedProps;
+            var updateClassName = getViewTransitionClassName(
+                root.className,
+                root.update
+              ),
+              layoutClassName = getViewTransitionClassName(
+                root.className,
+                root.update
+              );
+            if ("none" === updateClassName) {
+              if ("none" === layoutClassName) {
+                current = !1;
+                break a;
+              }
+              finishedWork.flags &= -5;
+              updateClassName = layoutClassName;
+            } else if (0 === (finishedWork.flags & 4)) {
+              if ("none" === layoutClassName) {
+                viewTransitionHostInstanceIdx = 0;
+                cancelViewTransitionHostInstances(
+                  current,
+                  finishedWork.child,
+                  !0
+                );
+                current = !1;
+                break a;
+              }
+              updateClassName = layoutClassName;
+            }
+            layoutClassName = getViewTransitionName(
+              root,
+              finishedWork.stateNode
+            );
+            viewTransitionHostInstanceIdx = 0;
+            root = current.memoizedState;
+            current = measureViewTransitionHostInstances(
+              current,
+              finishedWork,
+              finishedWork.child,
+              layoutClassName,
+              updateClassName,
+              root,
+              !0
+            );
+            viewTransitionHostInstanceIdx !==
+              (null === root ? 0 : root.length) && (finishedWork.flags |= 32);
+          }
+          0 !== (finishedWork.flags & 4) && current
+            ? ((current = finishedWork.memoizedProps),
+              scheduleViewTransitionEvent(
+                finishedWork,
+                i || viewTransitionContextChanged
+                  ? current.onUpdate
+                  : current.onLayout
+              ),
+              (viewTransitionCancelableChildren = instance))
+            : null !== instance &&
+              (instance.push.apply(instance, viewTransitionCancelableChildren),
+              (viewTransitionCancelableChildren = instance));
+          viewTransitionContextChanged =
+            0 !== (finishedWork.flags & 32) ? !0 : oldName;
+        }
+        break;
+      default:
+        recursivelyTraverseAfterMutationEffects(root, finishedWork);
+    }
+}
 function recursivelyTraverseLayoutEffects(root, parentFiber) {
   if (parentFiber.subtreeFlags & 8772)
     for (parentFiber = parentFiber.child; null !== parentFiber; )
@@ -8940,7 +10042,9 @@ function recursivelyTraverseLayoutEffects(root, parentFiber) {
 }
 function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
   for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var finishedWork = parentFiber;
+    var finishedWork = parentFiber,
+      prevEffectStart = pushComponentEffectStart(),
+      prevEffectErrors = pushComponentEffectErrors();
     switch (finishedWork.tag) {
       case 0:
       case 11:
@@ -8960,9 +10064,8 @@ function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
           );
         recursivelyTraverseDisappearLayoutEffects(finishedWork);
         break;
-      case 27:
-        releaseSingletonInstance(finishedWork.stateNode);
       case 26:
+      case 27:
       case 5:
         safelyDetachRef(finishedWork, finishedWork.return);
         recursivelyTraverseDisappearLayoutEffects(finishedWork);
@@ -8972,9 +10075,24 @@ function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
         null === finishedWork.memoizedState &&
           recursivelyTraverseDisappearLayoutEffects(finishedWork);
         break;
+      case 30:
+        safelyDetachRef(finishedWork, finishedWork.return);
       default:
         recursivelyTraverseDisappearLayoutEffects(finishedWork);
     }
+    0 !== (finishedWork.mode & 2) &&
+      0 <= componentEffectStartTime &&
+      0 <= componentEffectEndTime &&
+      0.05 < componentEffectDuration &&
+      logComponentEffect(
+        finishedWork,
+        componentEffectStartTime,
+        componentEffectEndTime,
+        componentEffectDuration,
+        componentEffectErrors
+      );
+    popComponentEffectStart(prevEffectStart);
+    componentEffectErrors = prevEffectErrors;
     parentFiber = parentFiber.sibling;
   }
 }
@@ -8989,6 +10107,8 @@ function recursivelyTraverseReappearLayoutEffects(
     var current = parentFiber.alternate,
       finishedRoot = finishedRoot$jscomp$0,
       finishedWork = parentFiber,
+      prevEffectStart = pushComponentEffectStart(),
+      prevEffectErrors = pushComponentEffectErrors(),
       flags = finishedWork.flags;
     switch (finishedWork.tag) {
       case 0:
@@ -9037,9 +10157,8 @@ function recursivelyTraverseReappearLayoutEffects(
           commitClassCallbacks(finishedWork);
         safelyAttachRef(finishedWork, finishedWork.return);
         break;
-      case 27:
-        commitHostSingletonAcquisition(finishedWork);
       case 26:
+      case 27:
       case 5:
         recursivelyTraverseReappearLayoutEffects(
           finishedRoot,
@@ -9093,6 +10212,14 @@ function recursivelyTraverseReappearLayoutEffects(
           );
         safelyAttachRef(finishedWork, finishedWork.return);
         break;
+      case 30:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
       default:
         recursivelyTraverseReappearLayoutEffects(
           finishedRoot,
@@ -9100,6 +10227,19 @@ function recursivelyTraverseReappearLayoutEffects(
           includeWorkInProgressEffects
         );
     }
+    0 !== (finishedWork.mode & 2) &&
+      0 <= componentEffectStartTime &&
+      0 <= componentEffectEndTime &&
+      0.05 < componentEffectDuration &&
+      logComponentEffect(
+        finishedWork,
+        componentEffectStartTime,
+        componentEffectEndTime,
+        componentEffectDuration,
+        componentEffectErrors
+      );
+    popComponentEffectStart(prevEffectStart);
+    componentEffectErrors = prevEffectErrors;
     parentFiber = parentFiber.sibling;
   }
 }
@@ -9129,60 +10269,135 @@ function recursivelyTraversePassiveMountEffects(
   root,
   parentFiber,
   committedLanes,
-  committedTransitions
+  committedTransitions,
+  endTime
 ) {
-  if (parentFiber.subtreeFlags & 10256)
+  var isViewTransitionEligible =
+    (committedLanes & 335544192) === committedLanes;
+  if (
+    parentFiber.subtreeFlags & (isViewTransitionEligible ? 10262 : 10256) ||
+    (0 !== parentFiber.actualDuration &&
+      (null === parentFiber.alternate ||
+        parentFiber.alternate.child !== parentFiber.child))
+  )
     for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitPassiveMountOnFiber(
-        root,
-        parentFiber,
-        committedLanes,
-        committedTransitions
-      ),
-        (parentFiber = parentFiber.sibling);
+      (isViewTransitionEligible = parentFiber.sibling),
+        commitPassiveMountOnFiber(
+          root,
+          parentFiber,
+          committedLanes,
+          committedTransitions,
+          null !== isViewTransitionEligible
+            ? isViewTransitionEligible.actualStartTime
+            : endTime
+        ),
+        (parentFiber = isViewTransitionEligible);
+  else isViewTransitionEligible && restoreNestedViewTransitions(parentFiber);
 }
+var inHydratedSubtree = !1;
 function commitPassiveMountOnFiber(
   finishedRoot,
   finishedWork,
   committedLanes,
-  committedTransitions
+  committedTransitions,
+  endTime
 ) {
+  var prevEffectStart = pushComponentEffectStart(),
+    prevEffectErrors = pushComponentEffectErrors();
+  0 !== (finishedWork.mode & 2) &&
+    0 < finishedWork.actualStartTime &&
+    0 !== (finishedWork.flags & 1) &&
+    logComponentRender(
+      finishedWork,
+      finishedWork.actualStartTime,
+      endTime,
+      inHydratedSubtree
+    );
+  var isViewTransitionEligible =
+    (committedLanes & 335544192) === committedLanes;
+  isViewTransitionEligible &&
+    null === finishedWork.alternate &&
+    null !== finishedWork.return &&
+    null !== finishedWork.return.alternate &&
+    restoreEnterViewTransitions(finishedWork);
   var flags = finishedWork.flags;
   switch (finishedWork.tag) {
     case 0:
     case 11:
     case 15:
+      0 !== (finishedWork.mode & 2) &&
+        0 < finishedWork.actualStartTime &&
+        0 !== (finishedWork.flags & 1) &&
+        logComponentRender(
+          finishedWork,
+          finishedWork.actualStartTime,
+          endTime,
+          inHydratedSubtree
+        );
       recursivelyTraversePassiveMountEffects(
         finishedRoot,
         finishedWork,
         committedLanes,
-        committedTransitions
+        committedTransitions,
+        endTime
       );
       flags & 2048 && commitHookPassiveMountEffects(finishedWork, 9);
       break;
     case 1:
+      0 !== (finishedWork.mode & 2) &&
+        0 < finishedWork.actualStartTime &&
+        (0 !== (finishedWork.flags & 128)
+          ? logComponentErrored(
+              finishedWork,
+              finishedWork.actualStartTime,
+              endTime
+            )
+          : 0 !== (finishedWork.flags & 1) &&
+            logComponentRender(
+              finishedWork,
+              finishedWork.actualStartTime,
+              endTime,
+              inHydratedSubtree
+            ));
       recursivelyTraversePassiveMountEffects(
         finishedRoot,
         finishedWork,
         committedLanes,
-        committedTransitions
+        committedTransitions,
+        endTime
       );
       break;
     case 3:
-      var prevEffectDuration = pushNestedEffectDurations();
+      var prevEffectDuration = pushNestedEffectDurations(),
+        wasInHydratedSubtree = inHydratedSubtree;
+      inHydratedSubtree =
+        null !== finishedWork.alternate &&
+        finishedWork.alternate.memoizedState.isDehydrated &&
+        0 === (finishedWork.flags & 256);
       recursivelyTraversePassiveMountEffects(
         finishedRoot,
         finishedWork,
         committedLanes,
-        committedTransitions
+        committedTransitions,
+        endTime
       );
+      inHydratedSubtree = wasInHydratedSubtree;
+      isViewTransitionEligible &&
+        ((committedLanes = finishedRoot.containerInfo),
+        (committedLanes =
+          9 === committedLanes.nodeType
+            ? committedLanes.documentElement
+            : committedLanes.ownerDocument.documentElement),
+        null !== committedLanes &&
+          "none" === committedLanes.style.viewTransitionName &&
+          (committedLanes.style.viewTransitionName = ""));
       flags & 2048 &&
         ((committedLanes = null),
         null !== finishedWork.alternate &&
           (committedLanes = finishedWork.alternate.memoizedState.cache),
-        (finishedWork = finishedWork.memoizedState.cache),
-        finishedWork !== committedLanes &&
-          (finishedWork.refCount++,
+        (committedTransitions = finishedWork.memoizedState.cache),
+        committedTransitions !== committedLanes &&
+          (committedTransitions.refCount++,
           null != committedLanes && releaseCache(committedLanes)));
       finishedRoot.passiveEffectDuration +=
         popNestedEffectDurations(prevEffectDuration);
@@ -9194,20 +10409,21 @@ function commitPassiveMountOnFiber(
           finishedRoot,
           finishedWork,
           committedLanes,
-          committedTransitions
+          committedTransitions,
+          endTime
         );
         finishedRoot = finishedWork.stateNode;
         finishedRoot.passiveEffectDuration +=
           bubbleNestedEffectDurations(flags);
         try {
           prevEffectDuration = finishedWork.memoizedProps;
-          var id = prevEffectDuration.id,
-            onPostCommit = prevEffectDuration.onPostCommit,
+          wasInHydratedSubtree = prevEffectDuration.id;
+          var onPostCommit = prevEffectDuration.onPostCommit,
             phase = null === finishedWork.alternate ? "mount" : "update";
           currentUpdateIsNested && (phase = "nested-update");
           "function" === typeof onPostCommit &&
             onPostCommit(
-              id,
+              wasInHydratedSubtree,
               phase,
               finishedRoot.passiveEffectDuration,
               commitStartTime
@@ -9220,178 +10436,314 @@ function commitPassiveMountOnFiber(
           finishedRoot,
           finishedWork,
           committedLanes,
-          committedTransitions
+          committedTransitions,
+          endTime
         );
       break;
     case 13:
+      flags = inHydratedSubtree;
+      isViewTransitionEligible =
+        null !== finishedWork.alternate
+          ? finishedWork.alternate.memoizedState
+          : null;
+      prevEffectDuration = finishedWork.memoizedState;
+      null === isViewTransitionEligible ||
+      null === isViewTransitionEligible.dehydrated ||
+      (null !== prevEffectDuration && null !== prevEffectDuration.dehydrated)
+        ? (inHydratedSubtree = !1)
+        : ((prevEffectDuration = finishedWork.deletions),
+          null !== prevEffectDuration &&
+          0 < prevEffectDuration.length &&
+          18 === prevEffectDuration[0].tag
+            ? ((inHydratedSubtree = !1),
+              null !== isViewTransitionEligible.hydrationErrors &&
+                logComponentErrored(
+                  finishedWork,
+                  finishedWork.actualStartTime,
+                  endTime
+                ))
+            : (inHydratedSubtree = !0));
       recursivelyTraversePassiveMountEffects(
         finishedRoot,
         finishedWork,
         committedLanes,
-        committedTransitions
+        committedTransitions,
+        endTime
       );
+      inHydratedSubtree = flags;
       break;
     case 23:
       break;
     case 22:
       prevEffectDuration = finishedWork.stateNode;
-      id = finishedWork.alternate;
+      wasInHydratedSubtree = finishedWork.alternate;
       null !== finishedWork.memoizedState
-        ? prevEffectDuration._visibility & 4
-          ? recursivelyTraversePassiveMountEffects(
-              finishedRoot,
-              finishedWork,
-              committedLanes,
-              committedTransitions
-            )
-          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
-        : prevEffectDuration._visibility & 4
-          ? recursivelyTraversePassiveMountEffects(
-              finishedRoot,
-              finishedWork,
-              committedLanes,
-              committedTransitions
-            )
-          : ((prevEffectDuration._visibility |= 4),
-            recursivelyTraverseReconnectPassiveEffects(
-              finishedRoot,
-              finishedWork,
-              committedLanes,
-              committedTransitions,
-              0 !== (finishedWork.subtreeFlags & 10256)
-            ));
-      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
+        ? (isViewTransitionEligible &&
+            null !== wasInHydratedSubtree &&
+            null === wasInHydratedSubtree.memoizedState &&
+            restoreExitViewTransitions(wasInHydratedSubtree),
+          prevEffectDuration._visibility & 4
+            ? recursivelyTraversePassiveMountEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions,
+                endTime
+              )
+            : recursivelyTraverseAtomicPassiveEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions,
+                endTime
+              ))
+        : (isViewTransitionEligible &&
+            null !== wasInHydratedSubtree &&
+            null !== wasInHydratedSubtree.memoizedState &&
+            restoreEnterViewTransitions(finishedWork),
+          prevEffectDuration._visibility & 4
+            ? recursivelyTraversePassiveMountEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions,
+                endTime
+              )
+            : ((prevEffectDuration._visibility |= 4),
+              recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions,
+                0 !== (finishedWork.subtreeFlags & 10256),
+                endTime
+              )));
+      flags & 2048 &&
+        commitOffscreenPassiveMountEffects(wasInHydratedSubtree, finishedWork);
       break;
     case 24:
       recursivelyTraversePassiveMountEffects(
         finishedRoot,
         finishedWork,
         committedLanes,
-        committedTransitions
+        committedTransitions,
+        endTime
       );
       flags & 2048 &&
         commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
       break;
+    case 30:
+      isViewTransitionEligible &&
+        ((flags = finishedWork.alternate),
+        null !== flags &&
+          0 !== (finishedWork.subtreeFlags & 8246) &&
+          ((finishedWork.memoizedState = null),
+          restoreViewTransitionOnHostInstances(flags.child, !0),
+          restoreViewTransitionOnHostInstances(finishedWork.child, !0)));
+      recursivelyTraversePassiveMountEffects(
+        finishedRoot,
+        finishedWork,
+        committedLanes,
+        committedTransitions,
+        endTime
+      );
+      break;
     default:
       recursivelyTraversePassiveMountEffects(
         finishedRoot,
         finishedWork,
         committedLanes,
-        committedTransitions
+        committedTransitions,
+        endTime
       );
   }
+  0 !== (finishedWork.mode & 2) &&
+    0 <= componentEffectStartTime &&
+    0 <= componentEffectEndTime &&
+    0.05 < componentEffectDuration &&
+    logComponentEffect(
+      finishedWork,
+      componentEffectStartTime,
+      componentEffectEndTime,
+      componentEffectDuration,
+      componentEffectErrors
+    );
+  popComponentEffectStart(prevEffectStart);
+  componentEffectErrors = prevEffectErrors;
 }
 function recursivelyTraverseReconnectPassiveEffects(
   finishedRoot$jscomp$0,
   parentFiber,
   committedLanes$jscomp$0,
   committedTransitions$jscomp$0,
-  includeWorkInProgressEffects
+  includeWorkInProgressEffects,
+  endTime$jscomp$0
 ) {
   includeWorkInProgressEffects =
     includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+  for (var child = parentFiber.child; null !== child; ) {
+    parentFiber = child.sibling;
     var finishedRoot = finishedRoot$jscomp$0,
-      finishedWork = parentFiber,
       committedLanes = committedLanes$jscomp$0,
       committedTransitions = committedTransitions$jscomp$0,
-      flags = finishedWork.flags;
-    switch (finishedWork.tag) {
+      endTime =
+        null !== parentFiber ? parentFiber.actualStartTime : endTime$jscomp$0,
+      prevEffectStart = pushComponentEffectStart(),
+      prevEffectErrors = pushComponentEffectErrors();
+    0 !== (child.mode & 2) &&
+      0 < child.actualStartTime &&
+      0 !== (child.flags & 1) &&
+      logComponentRender(
+        child,
+        child.actualStartTime,
+        endTime,
+        inHydratedSubtree
+      );
+    var flags = child.flags;
+    switch (child.tag) {
       case 0:
       case 11:
       case 15:
         recursivelyTraverseReconnectPassiveEffects(
           finishedRoot,
-          finishedWork,
+          child,
           committedLanes,
           committedTransitions,
-          includeWorkInProgressEffects
+          includeWorkInProgressEffects,
+          endTime
         );
-        commitHookPassiveMountEffects(finishedWork, 8);
+        commitHookPassiveMountEffects(child, 8);
         break;
       case 23:
         break;
       case 22:
-        var instance = finishedWork.stateNode;
-        null !== finishedWork.memoizedState
+        var instance = child.stateNode;
+        null !== child.memoizedState
           ? instance._visibility & 4
             ? recursivelyTraverseReconnectPassiveEffects(
                 finishedRoot,
-                finishedWork,
+                child,
                 committedLanes,
                 committedTransitions,
-                includeWorkInProgressEffects
+                includeWorkInProgressEffects,
+                endTime
               )
             : recursivelyTraverseAtomicPassiveEffects(
                 finishedRoot,
-                finishedWork
+                child,
+                committedLanes,
+                committedTransitions,
+                endTime
               )
           : ((instance._visibility |= 4),
             recursivelyTraverseReconnectPassiveEffects(
               finishedRoot,
-              finishedWork,
+              child,
               committedLanes,
               committedTransitions,
-              includeWorkInProgressEffects
+              includeWorkInProgressEffects,
+              endTime
             ));
         includeWorkInProgressEffects &&
           flags & 2048 &&
-          commitOffscreenPassiveMountEffects(
-            finishedWork.alternate,
-            finishedWork
-          );
+          commitOffscreenPassiveMountEffects(child.alternate, child);
         break;
       case 24:
         recursivelyTraverseReconnectPassiveEffects(
           finishedRoot,
-          finishedWork,
+          child,
           committedLanes,
           committedTransitions,
-          includeWorkInProgressEffects
+          includeWorkInProgressEffects,
+          endTime
         );
         includeWorkInProgressEffects &&
           flags & 2048 &&
-          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
+          commitCachePassiveMountEffect(child.alternate, child);
         break;
       default:
         recursivelyTraverseReconnectPassiveEffects(
           finishedRoot,
-          finishedWork,
+          child,
           committedLanes,
           committedTransitions,
-          includeWorkInProgressEffects
+          includeWorkInProgressEffects,
+          endTime
         );
     }
-    parentFiber = parentFiber.sibling;
+    0 !== (child.mode & 2) &&
+      0 <= componentEffectStartTime &&
+      0 <= componentEffectEndTime &&
+      0.05 < componentEffectDuration &&
+      logComponentEffect(
+        child,
+        componentEffectStartTime,
+        componentEffectEndTime,
+        componentEffectDuration,
+        componentEffectErrors
+      );
+    popComponentEffectStart(prevEffectStart);
+    componentEffectErrors = prevEffectErrors;
+    child = parentFiber;
   }
 }
 function recursivelyTraverseAtomicPassiveEffects(
   finishedRoot$jscomp$0,
-  parentFiber
+  parentFiber,
+  committedLanes$jscomp$0,
+  committedTransitions$jscomp$0,
+  endTime$jscomp$0
 ) {
   if (parentFiber.subtreeFlags & 10256)
-    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    for (var child = parentFiber.child; null !== child; ) {
+      parentFiber = child.sibling;
       var finishedRoot = finishedRoot$jscomp$0,
-        finishedWork = parentFiber,
-        flags = finishedWork.flags;
-      switch (finishedWork.tag) {
+        committedLanes = committedLanes$jscomp$0,
+        committedTransitions = committedTransitions$jscomp$0,
+        endTime =
+          null !== parentFiber ? parentFiber.actualStartTime : endTime$jscomp$0;
+      0 !== (child.mode & 2) &&
+        0 < child.actualStartTime &&
+        0 !== (child.flags & 1) &&
+        logComponentRender(
+          child,
+          child.actualStartTime,
+          endTime,
+          inHydratedSubtree
+        );
+      var flags = child.flags;
+      switch (child.tag) {
         case 22:
-          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
+          recursivelyTraverseAtomicPassiveEffects(
+            finishedRoot,
+            child,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
           flags & 2048 &&
-            commitOffscreenPassiveMountEffects(
-              finishedWork.alternate,
-              finishedWork
-            );
+            commitOffscreenPassiveMountEffects(child.alternate, child);
           break;
         case 24:
-          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
-          flags & 2048 &&
-            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
+          recursivelyTraverseAtomicPassiveEffects(
+            finishedRoot,
+            child,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
+          flags & 2048 && commitCachePassiveMountEffect(child.alternate, child);
           break;
         default:
-          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
+          recursivelyTraverseAtomicPassiveEffects(
+            finishedRoot,
+            child,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
       }
-      parentFiber = parentFiber.sibling;
+      child = parentFiber;
     }
 }
 var suspenseyCommitFlag = 8192;
@@ -9472,6 +10824,8 @@ function recursivelyTraversePassiveUnmountEffects(parentFiber) {
         (parentFiber = parentFiber.sibling);
 }
 function commitPassiveUnmountOnFiber(finishedWork) {
+  var prevEffectStart = pushComponentEffectStart(),
+    prevEffectErrors = pushComponentEffectErrors();
   switch (finishedWork.tag) {
     case 0:
     case 11:
@@ -9504,6 +10858,19 @@ function commitPassiveUnmountOnFiber(finishedWork) {
     default:
       recursivelyTraversePassiveUnmountEffects(finishedWork);
   }
+  0 !== (finishedWork.mode & 2) &&
+    0 <= componentEffectStartTime &&
+    0 <= componentEffectEndTime &&
+    0.05 < componentEffectDuration &&
+    logComponentEffect(
+      finishedWork,
+      componentEffectStartTime,
+      componentEffectEndTime,
+      componentEffectDuration,
+      componentEffectErrors
+    );
+  popComponentEffectStart(prevEffectStart);
+  componentEffectErrors = prevEffectErrors;
 }
 function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
   var deletions = parentFiber.deletions;
@@ -9542,10 +10909,13 @@ function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
 }
 function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
   deletedSubtreeRoot,
-  nearestMountedAncestor
+  nearestMountedAncestor$jscomp$0
 ) {
   for (; null !== nextEffect; ) {
-    var fiber = nextEffect;
+    var fiber = nextEffect,
+      nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
+      prevEffectStart = pushComponentEffectStart(),
+      prevEffectErrors = pushComponentEffectErrors();
     switch (fiber.tag) {
       case 0:
       case 11:
@@ -9554,35 +10924,46 @@ function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
         break;
       case 23:
       case 22:
-        if (
-          null !== fiber.memoizedState &&
-          null !== fiber.memoizedState.cachePool
-        ) {
-          var cache = fiber.memoizedState.cachePool.pool;
-          null != cache && cache.refCount++;
-        }
+        null !== fiber.memoizedState &&
+          null !== fiber.memoizedState.cachePool &&
+          ((nearestMountedAncestor = fiber.memoizedState.cachePool.pool),
+          null != nearestMountedAncestor && nearestMountedAncestor.refCount++);
         break;
       case 24:
         releaseCache(fiber.memoizedState.cache);
     }
-    cache = fiber.child;
-    if (null !== cache) (cache.return = fiber), (nextEffect = cache);
+    0 !== (fiber.mode & 2) &&
+      0 <= componentEffectStartTime &&
+      0 <= componentEffectEndTime &&
+      0.05 < componentEffectDuration &&
+      logComponentEffect(
+        fiber,
+        componentEffectStartTime,
+        componentEffectEndTime,
+        componentEffectDuration,
+        componentEffectErrors
+      );
+    popComponentEffectStart(prevEffectStart);
+    componentEffectErrors = prevEffectErrors;
+    prevEffectStart = fiber.child;
+    if (null !== prevEffectStart)
+      (prevEffectStart.return = fiber), (nextEffect = prevEffectStart);
     else
       a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
-        cache = nextEffect;
-        var sibling = cache.sibling,
-          returnFiber = cache.return;
-        detachFiberAfterEffects(cache);
-        if (cache === fiber) {
+        prevEffectStart = nextEffect;
+        prevEffectErrors = prevEffectStart.sibling;
+        nearestMountedAncestor = prevEffectStart.return;
+        detachFiberAfterEffects(prevEffectStart);
+        if (prevEffectStart === fiber) {
           nextEffect = null;
           break a;
         }
-        if (null !== sibling) {
-          sibling.return = returnFiber;
-          nextEffect = sibling;
+        if (null !== prevEffectErrors) {
+          prevEffectErrors.return = nearestMountedAncestor;
+          nextEffect = prevEffectErrors;
           break a;
         }
-        nextEffect = returnFiber;
+        nextEffect = nearestMountedAncestor;
       }
   }
 }
@@ -9750,6 +11131,15 @@ function createFiberFromTypeAndProps(
         );
       case REACT_OFFSCREEN_TYPE:
         return createFiberFromOffscreen(pendingProps, mode, lanes, key);
+      case REACT_LEGACY_HIDDEN_TYPE:
+      case REACT_VIEW_TRANSITION_TYPE:
+        return (
+          (type = createFiberImplClass(30, pendingProps, key, mode)),
+          (type.elementType = REACT_VIEW_TRANSITION_TYPE),
+          (type.lanes = lanes),
+          (type.stateNode = { autoName: null, paired: null, ref: null }),
+          type
+        );
       default:
         if ("object" === typeof type && null !== type)
           switch (type.$$typeof) {
@@ -10008,6 +11398,21 @@ function queueHydrationError(error) {
     ? (hydrationErrors = [error])
     : hydrationErrors.push(error);
 }
+var globalClientIdCounter = 0;
+function getViewTransitionName(props, instance) {
+  return null != props.name && "auto" !== props.name
+    ? props.name
+    : instance.autoName;
+}
+function getViewTransitionClassName(className, eventClassName) {
+  return null == eventClassName
+    ? className
+    : "none" === eventClassName
+      ? eventClassName
+      : null != className
+        ? className + " " + eventClassName
+        : eventClassName;
+}
 function markUpdate(workInProgress) {
   workInProgress.flags |= 4;
 }
@@ -10056,14 +11461,14 @@ function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
         break;
       case "collapsed":
         lastTailNode = renderState.tail;
-        for (var lastTailNode$143 = null; null !== lastTailNode; )
-          null !== lastTailNode.alternate && (lastTailNode$143 = lastTailNode),
+        for (var lastTailNode$150 = null; null !== lastTailNode; )
+          null !== lastTailNode.alternate && (lastTailNode$150 = lastTailNode),
             (lastTailNode = lastTailNode.sibling);
-        null === lastTailNode$143
+        null === lastTailNode$150
           ? hasRenderedATailFallback || null === renderState.tail
             ? (renderState.tail = null)
             : (renderState.tail.sibling = null)
-          : (lastTailNode$143.sibling = null);
+          : (lastTailNode$150.sibling = null);
     }
 }
 function bubbleProperties(completedWork) {
@@ -10075,57 +11480,75 @@ function bubbleProperties(completedWork) {
   if (didBailout)
     if (0 !== (completedWork.mode & 2)) {
       for (
-        var treeBaseDuration$145 = completedWork.selfBaseDuration,
-          child$146 = completedWork.child;
-        null !== child$146;
+        var treeBaseDuration$152 = completedWork.selfBaseDuration,
+          child$153 = completedWork.child;
+        null !== child$153;
 
       )
-        (newChildLanes |= child$146.lanes | child$146.childLanes),
-          (subtreeFlags |= child$146.subtreeFlags & 65011712),
-          (subtreeFlags |= child$146.flags & 65011712),
-          (treeBaseDuration$145 += child$146.treeBaseDuration),
-          (child$146 = child$146.sibling);
-      completedWork.treeBaseDuration = treeBaseDuration$145;
+        (newChildLanes |= child$153.lanes | child$153.childLanes),
+          (subtreeFlags |= child$153.subtreeFlags & 65011712),
+          (subtreeFlags |= child$153.flags & 65011712),
+          (treeBaseDuration$152 += child$153.treeBaseDuration),
+          (child$153 = child$153.sibling);
+      completedWork.treeBaseDuration = treeBaseDuration$152;
     } else
       for (
-        treeBaseDuration$145 = completedWork.child;
-        null !== treeBaseDuration$145;
+        treeBaseDuration$152 = completedWork.child;
+        null !== treeBaseDuration$152;
 
       )
         (newChildLanes |=
-          treeBaseDuration$145.lanes | treeBaseDuration$145.childLanes),
-          (subtreeFlags |= treeBaseDuration$145.subtreeFlags & 65011712),
-          (subtreeFlags |= treeBaseDuration$145.flags & 65011712),
-          (treeBaseDuration$145.return = completedWork),
-          (treeBaseDuration$145 = treeBaseDuration$145.sibling);
+          treeBaseDuration$152.lanes | treeBaseDuration$152.childLanes),
+          (subtreeFlags |= treeBaseDuration$152.subtreeFlags & 65011712),
+          (subtreeFlags |= treeBaseDuration$152.flags & 65011712),
+          (treeBaseDuration$152.return = completedWork),
+          (treeBaseDuration$152 = treeBaseDuration$152.sibling);
   else if (0 !== (completedWork.mode & 2)) {
-    treeBaseDuration$145 = completedWork.actualDuration;
-    child$146 = completedWork.selfBaseDuration;
+    treeBaseDuration$152 = completedWork.actualDuration;
+    child$153 = completedWork.selfBaseDuration;
     for (var child = completedWork.child; null !== child; )
       (newChildLanes |= child.lanes | child.childLanes),
         (subtreeFlags |= child.subtreeFlags),
         (subtreeFlags |= child.flags),
-        (treeBaseDuration$145 += child.actualDuration),
-        (child$146 += child.treeBaseDuration),
+        (treeBaseDuration$152 += child.actualDuration),
+        (child$153 += child.treeBaseDuration),
         (child = child.sibling);
-    completedWork.actualDuration = treeBaseDuration$145;
-    completedWork.treeBaseDuration = child$146;
+    completedWork.actualDuration = treeBaseDuration$152;
+    completedWork.treeBaseDuration = child$153;
   } else
     for (
-      treeBaseDuration$145 = completedWork.child;
-      null !== treeBaseDuration$145;
+      treeBaseDuration$152 = completedWork.child;
+      null !== treeBaseDuration$152;
 
     )
       (newChildLanes |=
-        treeBaseDuration$145.lanes | treeBaseDuration$145.childLanes),
-        (subtreeFlags |= treeBaseDuration$145.subtreeFlags),
-        (subtreeFlags |= treeBaseDuration$145.flags),
-        (treeBaseDuration$145.return = completedWork),
-        (treeBaseDuration$145 = treeBaseDuration$145.sibling);
+        treeBaseDuration$152.lanes | treeBaseDuration$152.childLanes),
+        (subtreeFlags |= treeBaseDuration$152.subtreeFlags),
+        (subtreeFlags |= treeBaseDuration$152.flags),
+        (treeBaseDuration$152.return = completedWork),
+        (treeBaseDuration$152 = treeBaseDuration$152.sibling);
   completedWork.subtreeFlags |= subtreeFlags;
   completedWork.childLanes = newChildLanes;
   return didBailout;
 }
+function trackReappearingViewTransitions(workInProgress) {
+  if (0 !== (workInProgress.subtreeFlags & 2097152))
+    for (workInProgress = workInProgress.child; null !== workInProgress; ) {
+      if (22 !== workInProgress.tag || null !== workInProgress.memoizedState) {
+        if (
+          30 === workInProgress.tag &&
+          0 !== (workInProgress.flags & 2097152)
+        ) {
+          var props = workInProgress.memoizedProps;
+          null != props.name &&
+            "auto" !== props.name &&
+            trackAppearingViewTransition(workInProgress.stateNode, props.name);
+        }
+        trackReappearingViewTransitions(workInProgress);
+      }
+      workInProgress = workInProgress.sibling;
+    }
+}
 function completeWork(current, workInProgress, renderLanes) {
   var newProps = workInProgress.pendingProps;
   popTreeContext(workInProgress);
@@ -10196,6 +11619,7 @@ function completeWork(current, workInProgress, renderLanes) {
           if (null === workInProgress.stateNode)
             throw Error(formatProdErrorMessage(166));
           bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
           return null;
         }
         current = contextStackCursor.current;
@@ -10206,6 +11630,7 @@ function completeWork(current, workInProgress, renderLanes) {
             markUpdate(workInProgress));
       }
       bubbleProperties(workInProgress);
+      workInProgress.subtreeFlags &= -33554433;
       return null;
     case 5:
       popHostContext(workInProgress);
@@ -10217,6 +11642,7 @@ function completeWork(current, workInProgress, renderLanes) {
           if (null === workInProgress.stateNode)
             throw Error(formatProdErrorMessage(166));
           bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
           return null;
         }
         current = contextStackCursor.current;
@@ -10313,6 +11739,7 @@ function completeWork(current, workInProgress, renderLanes) {
         }
       }
       bubbleProperties(workInProgress);
+      workInProgress.subtreeFlags &= -33554433;
       workInProgress.flags &= -16777217;
       return null;
     case 6:
@@ -10414,11 +11841,11 @@ function completeWork(current, workInProgress, renderLanes) {
           null !== newProps.alternate.memoizedState &&
           null !== newProps.alternate.memoizedState.cachePool &&
           (type = newProps.alternate.memoizedState.cachePool.pool);
-        var cache$162 = null;
+        var cache$169 = null;
         null !== newProps.memoizedState &&
           null !== newProps.memoizedState.cachePool &&
-          (cache$162 = newProps.memoizedState.cachePool.pool);
-        cache$162 !== type && (newProps.flags |= 2048);
+          (cache$169 = newProps.memoizedState.cachePool.pool);
+        cache$169 !== type && (newProps.flags |= 2048);
       }
       renderLanes !== current &&
         renderLanes &&
@@ -10448,8 +11875,8 @@ function completeWork(current, workInProgress, renderLanes) {
       type = workInProgress.memoizedState;
       if (null === type) return bubbleProperties(workInProgress), null;
       newProps = 0 !== (workInProgress.flags & 128);
-      cache$162 = type.rendering;
-      if (null === cache$162)
+      cache$169 = type.rendering;
+      if (null === cache$169)
         if (newProps) cutOffTailIfNeeded(type, !1);
         else {
           if (
@@ -10457,11 +11884,11 @@ function completeWork(current, workInProgress, renderLanes) {
             (null !== current && 0 !== (current.flags & 128))
           )
             for (current = workInProgress.child; null !== current; ) {
-              cache$162 = findFirstSuspended(current);
-              if (null !== cache$162) {
+              cache$169 = findFirstSuspended(current);
+              if (null !== cache$169) {
                 workInProgress.flags |= 128;
                 cutOffTailIfNeeded(type, !1);
-                current = cache$162.updateQueue;
+                current = cache$169.updateQueue;
                 workInProgress.updateQueue = current;
                 scheduleRetryEffect(workInProgress, current);
                 workInProgress.subtreeFlags = 0;
@@ -10486,7 +11913,7 @@ function completeWork(current, workInProgress, renderLanes) {
         }
       else {
         if (!newProps)
-          if (((current = findFirstSuspended(cache$162)), null !== current)) {
+          if (((current = findFirstSuspended(cache$169)), null !== current)) {
             if (
               ((workInProgress.flags |= 128),
               (newProps = !0),
@@ -10496,7 +11923,7 @@ function completeWork(current, workInProgress, renderLanes) {
               cutOffTailIfNeeded(type, !0),
               null === type.tail &&
                 "hidden" === type.tailMode &&
-                !cache$162.alternate &&
+                !cache$169.alternate &&
                 !isHydrating)
             )
               return bubbleProperties(workInProgress), null;
@@ -10509,13 +11936,13 @@ function completeWork(current, workInProgress, renderLanes) {
               cutOffTailIfNeeded(type, !1),
               (workInProgress.lanes = 4194304));
         type.isBackwards
-          ? ((cache$162.sibling = workInProgress.child),
-            (workInProgress.child = cache$162))
+          ? ((cache$169.sibling = workInProgress.child),
+            (workInProgress.child = cache$169))
           : ((current = type.last),
             null !== current
-              ? (current.sibling = cache$162)
-              : (workInProgress.child = cache$162),
-            (type.last = cache$162));
+              ? (current.sibling = cache$169)
+              : (workInProgress.child = cache$169),
+            (type.last = cache$169));
       }
       if (null !== type.tail)
         return (
@@ -10538,7 +11965,8 @@ function completeWork(current, workInProgress, renderLanes) {
         (newProps = null !== workInProgress.memoizedState),
         null !== current
           ? (null !== current.memoizedState) !== newProps &&
-            (workInProgress.flags |= 8192)
+            ((workInProgress.flags |= 8192),
+            newProps || trackReappearingViewTransitions(workInProgress))
           : newProps && (workInProgress.flags |= 8192),
         newProps
           ? 0 !== (renderLanes & 536870912) &&
@@ -10575,7 +12003,11 @@ function completeWork(current, workInProgress, renderLanes) {
     case 25:
       return null;
     case 30:
-      return null;
+      return (
+        (workInProgress.flags |= 33554432),
+        bubbleProperties(workInProgress),
+        null
+      );
   }
   throw Error(formatProdErrorMessage(156, workInProgress.tag));
 }
@@ -10722,8 +12154,11 @@ var DefaultAsyncDispatcher = {
   pendingFinishedWork = null,
   pendingEffectsLanes = 0,
   pendingEffectsRemainingLanes = 0,
+  pendingEffectsRenderEndTime = -0,
   pendingPassiveTransitions = null,
   pendingRecoverableErrors = null,
+  pendingViewTransitionEvents = null,
+  pendingSuspendedCommitReason = 0,
   nestedUpdateCount = 0,
   rootWithNestedUpdates = null;
 function requestUpdateLane() {
@@ -10745,6 +12180,19 @@ function requestDeferredLane() {
   null !== suspenseHandler && (suspenseHandler.flags |= 32);
   return workInProgressDeferredLane;
 }
+function scheduleViewTransitionEvent(fiber, callback) {
+  if (null != callback) {
+    var state = fiber.stateNode,
+      instance = state.ref;
+    null === instance &&
+      (instance = state.ref =
+        createViewTransitionInstance(
+          getViewTransitionName(fiber.memoizedProps, state)
+        ));
+    null === pendingViewTransitionEvents && (pendingViewTransitionEvents = []);
+    pendingViewTransitionEvents.push(callback.bind(null, instance));
+  }
+}
 function scheduleUpdateOnFiber(root, fiber, lane) {
   if (
     (root === workInProgressRoot &&
@@ -10776,34 +12224,81 @@ function scheduleUpdateOnFiber(root, fiber, lane) {
 }
 function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
   if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
-  var shouldTimeSlice =
-      (!forceSync &&
-        0 === (lanes & 60) &&
-        0 === (lanes & root$jscomp$0.expiredLanes)) ||
-      checkIfRootIsPrerendering(root$jscomp$0, lanes),
-    exitStatus = shouldTimeSlice
-      ? renderRootConcurrent(root$jscomp$0, lanes)
-      : renderRootSync(root$jscomp$0, lanes, !0),
-    renderWasConcurrent = shouldTimeSlice;
+  if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {
+    var yieldEndTime = now$1();
+    switch (yieldReason) {
+      case 3:
+      case 2:
+        var startTime = yieldStartTime;
+        supportsUserTiming &&
+          ((reusableComponentDevToolDetails.color = "primary-light"),
+          (reusableComponentOptions.start = startTime),
+          (reusableComponentOptions.end = yieldEndTime),
+          performance.measure("Suspended", reusableComponentOptions));
+        break;
+      case 9:
+        startTime = yieldStartTime;
+        supportsUserTiming &&
+          ((reusableComponentDevToolDetails.color = "primary-light"),
+          (reusableComponentOptions.start = startTime),
+          (reusableComponentOptions.end = yieldEndTime),
+          performance.measure("Action", reusableComponentOptions));
+        break;
+      default:
+        if (((startTime = yieldStartTime), supportsUserTiming)) {
+          var yieldDuration = yieldEndTime - startTime;
+          1 > yieldDuration ||
+            ((reusableComponentDevToolDetails.color =
+              5 > yieldDuration
+                ? "primary-light"
+                : 10 > yieldDuration
+                  ? "primary"
+                  : 100 > yieldDuration
+                    ? "primary-dark"
+                    : "error"),
+            (reusableComponentOptions.start = startTime),
+            (reusableComponentOptions.end = yieldEndTime),
+            performance.measure("Blocked", reusableComponentOptions));
+        }
+    }
+  }
+  var exitStatus = (yieldEndTime =
+    (!forceSync &&
+      0 === (lanes & 60) &&
+      0 === (lanes & root$jscomp$0.expiredLanes)) ||
+    checkIfRootIsPrerendering(root$jscomp$0, lanes))
+    ? renderRootConcurrent(root$jscomp$0, lanes)
+    : renderRootSync(root$jscomp$0, lanes, !0);
+  yieldDuration = yieldEndTime;
   do {
     if (0 === exitStatus) {
       workInProgressRootIsPrerendering &&
-        !shouldTimeSlice &&
+        !yieldEndTime &&
         markRootSuspended(root$jscomp$0, lanes, 0, !1);
+      lanes = workInProgressSuspendedReason;
+      yieldStartTime = now();
+      yieldReason = lanes;
       break;
     } else {
+      startTime = now$1();
       forceSync = root$jscomp$0.current.alternate;
-      if (
-        renderWasConcurrent &&
-        !isRenderConsistentWithExternalStores(forceSync)
-      ) {
+      if (yieldDuration && !isRenderConsistentWithExternalStores(forceSync)) {
+        setCurrentTrackFromLanes(lanes);
+        forceSync = renderStartTime;
+        yieldDuration = startTime;
+        supportsUserTiming &&
+          ((reusableLaneDevToolDetails.color = "error"),
+          (reusableLaneOptions.start = forceSync),
+          (reusableLaneOptions.end = yieldDuration),
+          performance.measure("Teared Render", reusableLaneOptions));
+        finalizeRender(lanes, startTime);
         exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
-        renderWasConcurrent = !1;
+        yieldDuration = !1;
         continue;
       }
       if (2 === exitStatus) {
-        renderWasConcurrent = lanes;
-        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
+        yieldDuration = lanes;
+        if (root$jscomp$0.errorRecoveryDisabledLanes & yieldDuration)
           var JSCompiler_inline_result = 0;
         else
           (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),
@@ -10814,62 +12309,64 @@ function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
                   ? 536870912
                   : 0);
         if (0 !== JSCompiler_inline_result) {
+          setCurrentTrackFromLanes(lanes);
+          logErroredRenderPhase(renderStartTime, startTime);
+          finalizeRender(lanes, startTime);
           lanes = JSCompiler_inline_result;
-          a: {
-            var root = root$jscomp$0;
-            exitStatus = workInProgressRootConcurrentErrors;
-            var wasRootDehydrated = root.current.memoizedState.isDehydrated;
-            wasRootDehydrated &&
-              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
-            JSCompiler_inline_result = renderRootSync(
-              root,
-              JSCompiler_inline_result,
-              !1
-            );
-            if (2 !== JSCompiler_inline_result) {
-              if (
-                workInProgressRootDidAttachPingListener &&
-                !wasRootDehydrated
-              ) {
-                root.errorRecoveryDisabledLanes |= renderWasConcurrent;
-                workInProgressRootInterleavedUpdatedLanes |=
-                  renderWasConcurrent;
-                exitStatus = 4;
-                break a;
-              }
-              renderWasConcurrent = workInProgressRootRecoverableErrors;
-              workInProgressRootRecoverableErrors = exitStatus;
-              null !== renderWasConcurrent &&
-                (null === workInProgressRootRecoverableErrors
-                  ? (workInProgressRootRecoverableErrors = renderWasConcurrent)
-                  : workInProgressRootRecoverableErrors.push.apply(
-                      workInProgressRootRecoverableErrors,
-                      renderWasConcurrent
-                    ));
-            }
-            exitStatus = JSCompiler_inline_result;
-          }
-          renderWasConcurrent = !1;
+          var root = root$jscomp$0;
+          startTime = workInProgressRootConcurrentErrors;
+          var wasRootDehydrated = root.current.memoizedState.isDehydrated;
+          wasRootDehydrated &&
+            (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
+          exitStatus = renderRootSync(root, JSCompiler_inline_result, !1);
+          2 !== exitStatus &&
+            (workInProgressRootDidAttachPingListener && !wasRootDehydrated
+              ? ((root.errorRecoveryDisabledLanes |= yieldDuration),
+                (workInProgressRootInterleavedUpdatedLanes |= yieldDuration),
+                (exitStatus = 4))
+              : ((yieldDuration = workInProgressRootRecoverableErrors),
+                (workInProgressRootRecoverableErrors = startTime),
+                null !== yieldDuration &&
+                  ((startTime = yieldDuration),
+                  null === workInProgressRootRecoverableErrors
+                    ? (workInProgressRootRecoverableErrors = startTime)
+                    : workInProgressRootRecoverableErrors.push.apply(
+                        workInProgressRootRecoverableErrors,
+                        startTime
+                      ))));
+          yieldDuration = !1;
           if (2 !== exitStatus) continue;
+          else startTime = now$1();
         }
       }
       if (1 === exitStatus) {
+        setCurrentTrackFromLanes(lanes);
+        logErroredRenderPhase(renderStartTime, startTime);
+        finalizeRender(lanes, startTime);
         prepareFreshStack(root$jscomp$0, 0);
         markRootSuspended(root$jscomp$0, lanes, 0, !0);
         break;
       }
       a: {
-        shouldTimeSlice = root$jscomp$0;
-        renderWasConcurrent = exitStatus;
-        switch (renderWasConcurrent) {
+        yieldEndTime = root$jscomp$0;
+        yieldDuration = exitStatus;
+        switch (yieldDuration) {
           case 0:
           case 1:
             throw Error(formatProdErrorMessage(345));
           case 4:
             if ((lanes & 4194176) !== lanes) break;
           case 6:
+            setCurrentTrackFromLanes(lanes);
+            logSuspendedRenderPhase(renderStartTime, startTime, lanes);
+            finalizeRender(lanes, startTime);
+            forceSync = lanes;
+            0 !== (forceSync & 3) || 0 !== (forceSync & 60)
+              ? (blockingSuspendedTime = startTime)
+              : 0 !== (forceSync & 4194176) &&
+                (transitionSuspendedTime = startTime);
             markRootSuspended(
-              shouldTimeSlice,
+              yieldEndTime,
               lanes,
               workInProgressDeferredLane,
               !workInProgressRootDidSkipSuspendedSiblings
@@ -10890,16 +12387,16 @@ function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
           10 < exitStatus)
         ) {
           markRootSuspended(
-            shouldTimeSlice,
+            yieldEndTime,
             lanes,
             workInProgressDeferredLane,
             !workInProgressRootDidSkipSuspendedSiblings
           );
-          if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
-          shouldTimeSlice.timeoutHandle = scheduleTimeout(
+          if (0 !== getNextLanes(yieldEndTime, 0, !0)) break a;
+          yieldEndTime.timeoutHandle = scheduleTimeout(
             commitRootWhenReady.bind(
               null,
-              shouldTimeSlice,
+              yieldEndTime,
               forceSync,
               workInProgressRootRecoverableErrors,
               workInProgressTransitions,
@@ -10910,17 +12407,17 @@ function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
               workInProgressRootInterleavedUpdatedLanes,
               workInProgressSuspendedRetryLanes,
               workInProgressRootDidSkipSuspendedSiblings,
-              renderWasConcurrent,
+              yieldDuration,
               2,
-              -0,
-              0
+              renderStartTime,
+              startTime
             ),
             exitStatus
           );
           break a;
         }
         commitRootWhenReady(
-          shouldTimeSlice,
+          yieldEndTime,
           forceSync,
           workInProgressRootRecoverableErrors,
           workInProgressTransitions,
@@ -10931,10 +12428,10 @@ function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
           workInProgressRootInterleavedUpdatedLanes,
           workInProgressSuspendedRetryLanes,
           workInProgressRootDidSkipSuspendedSiblings,
-          renderWasConcurrent,
+          yieldDuration,
           0,
-          -0,
-          0
+          renderStartTime,
+          startTime
         );
       }
     }
@@ -10960,19 +12457,30 @@ function commitRootWhenReady(
   completedRenderEndTime
 ) {
   root.timeoutHandle = -1;
-  suspendedCommitReason = finishedWork.subtreeFlags;
-  if (
-    (suspendedCommitReason =
-      suspendedCommitReason & 8192 ||
-      16785408 === (suspendedCommitReason & 16785408))
-  )
-    if (
-      ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop$1 }),
-      suspendedCommitReason && accumulateSuspenseyCommitOnFiber(finishedWork),
-      (suspendedCommitReason = waitForCommitToBeReady()),
-      null !== suspendedCommitReason)
-    ) {
-      root.cancelPendingCommit = suspendedCommitReason(
+  var subtreeFlags = finishedWork.subtreeFlags,
+    isViewTransitionEligible = (lanes & 335544192) === lanes;
+  subtreeFlags = subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408);
+  if (isViewTransitionEligible || subtreeFlags) {
+    suspendedState = { stylesheets: null, count: 0, unsuspend: noop$1 };
+    subtreeFlags && accumulateSuspenseyCommitOnFiber(finishedWork);
+    if (isViewTransitionEligible) {
+      subtreeFlags = root.containerInfo;
+      if (null === suspendedState) throw Error(formatProdErrorMessage(475));
+      isViewTransitionEligible = suspendedState;
+      subtreeFlags = (
+        9 === subtreeFlags.nodeType ? subtreeFlags : subtreeFlags.ownerDocument
+      ).__reactViewTransition;
+      null != subtreeFlags &&
+        (isViewTransitionEligible.count++,
+        (isViewTransitionEligible = onUnsuspend.bind(isViewTransitionEligible)),
+        subtreeFlags.finished.then(
+          isViewTransitionEligible,
+          isViewTransitionEligible
+        ));
+    }
+    isViewTransitionEligible = waitForCommitToBeReady();
+    if (null !== isViewTransitionEligible) {
+      root.cancelPendingCommit = isViewTransitionEligible(
         commitRoot.bind(
           null,
           root,
@@ -10994,6 +12502,7 @@ function commitRootWhenReady(
       markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
       return;
     }
+  }
   commitRoot(
     root,
     finishedWork,
@@ -11004,7 +12513,11 @@ function commitRootWhenReady(
     didIncludeRenderPhaseUpdate,
     spawnedLane,
     updatedLanes,
-    suspendedRetryLanes
+    suspendedRetryLanes,
+    exitStatus,
+    suspendedCommitReason,
+    completedRenderStartTime,
+    completedRenderEndTime
   );
 }
 function isRenderConsistentWithExternalStores(finishedWork) {
@@ -11084,16 +12597,169 @@ function resetWorkInProgressStack() {
     workInProgress = null;
   }
 }
+function finalizeRender(lanes, finalizationTime) {
+  if (0 !== (lanes & 3) || 0 !== (lanes & 60))
+    blockingClampTime = finalizationTime;
+  0 !== (lanes & 4194176) && (transitionClampTime = finalizationTime);
+}
 function prepareFreshStack(root, lanes) {
-  var timeoutHandle = root.timeoutHandle;
-  -1 !== timeoutHandle &&
-    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
-  timeoutHandle = root.cancelPendingCommit;
-  null !== timeoutHandle &&
-    ((root.cancelPendingCommit = null), timeoutHandle());
+  supportsUserTiming &&
+    (performance.mark("Blocking Track", blockingLaneMarker),
+    performance.mark("Transition Track", transitionLaneMarker),
+    performance.mark("Suspense Track", suspenseLaneMarker),
+    performance.mark("Idle Track", idleLaneMarker));
+  var previousRenderStartTime = renderStartTime;
+  renderStartTime = now();
+  if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {
+    setCurrentTrackFromLanes(workInProgressRootRenderLanes);
+    if (
+      3 === workInProgressRootExitStatus ||
+      4 === workInProgressRootExitStatus
+    )
+      logSuspendedRenderPhase(previousRenderStartTime, renderStartTime, lanes);
+    else {
+      var endTime = renderStartTime;
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color =
+          (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+        (reusableLaneOptions.start = previousRenderStartTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure(
+          (lanes & 536870912) === lanes
+            ? "Prewarm"
+            : (lanes & 201326677) === lanes
+              ? "Interrupted Hydration"
+              : "Interrupted Render",
+          reusableLaneOptions
+        ));
+    }
+    finalizeRender(workInProgressRootRenderLanes, renderStartTime);
+  }
+  if (0 !== (lanes & 3) || 0 !== (lanes & 60)) {
+    previousRenderStartTime =
+      0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime
+        ? blockingClampTime
+        : blockingUpdateTime;
+    endTime =
+      0 <= blockingEventTime && blockingEventTime < blockingClampTime
+        ? blockingClampTime
+        : blockingEventTime;
+    0 <= blockingSuspendedTime &&
+      (setCurrentTrackFromLanes(lanes),
+      logSuspendedWithDelayPhase(
+        blockingSuspendedTime,
+        0 <= endTime
+          ? endTime
+          : 0 <= previousRenderStartTime
+            ? previousRenderStartTime
+            : renderStartTime,
+        lanes
+      ));
+    var eventType = blockingEventType,
+      eventIsRepeat = blockingEventIsRepeat,
+      isSpawnedUpdate = blockingSpawnedUpdate,
+      renderStartTime$jscomp$0 = renderStartTime;
+    supportsUserTiming &&
+      ((reusableLaneDevToolDetails.track = "Blocking"),
+      0 < endTime &&
+        null !== eventType &&
+        ((reusableLaneDevToolDetails.color = eventIsRepeat
+          ? "secondary-light"
+          : "warning"),
+        (reusableLaneOptions.start = endTime),
+        (reusableLaneOptions.end =
+          0 < previousRenderStartTime
+            ? previousRenderStartTime
+            : renderStartTime$jscomp$0),
+        performance.measure(
+          eventIsRepeat ? "" : "Event: " + eventType,
+          reusableLaneOptions
+        )),
+      0 < previousRenderStartTime &&
+        ((reusableLaneDevToolDetails.color = isSpawnedUpdate
+          ? "error"
+          : (lanes & 738197589) === lanes
+            ? "tertiary-light"
+            : "primary-light"),
+        (reusableLaneOptions.start = previousRenderStartTime),
+        (reusableLaneOptions.end = renderStartTime$jscomp$0),
+        performance.measure(
+          isSpawnedUpdate ? "Cascade" : "Blocked",
+          reusableLaneOptions
+        )));
+    blockingSuspendedTime = blockingUpdateTime = -1.1;
+    blockingEventIsRepeat = !0;
+    blockingSpawnedUpdate = !1;
+  }
+  0 !== (lanes & 4194176) &&
+    ((previousRenderStartTime =
+      0 <= transitionStartTime && transitionStartTime < transitionClampTime
+        ? transitionClampTime
+        : transitionStartTime),
+    (endTime =
+      0 <= transitionUpdateTime && transitionUpdateTime < transitionClampTime
+        ? transitionClampTime
+        : transitionUpdateTime),
+    (eventType =
+      0 <= transitionEventTime && transitionEventTime < transitionClampTime
+        ? transitionClampTime
+        : transitionEventTime),
+    0 <= transitionSuspendedTime &&
+      (setCurrentTrackFromLanes(lanes),
+      logSuspendedWithDelayPhase(
+        transitionSuspendedTime,
+        0 <= eventType ? eventType : 0 <= endTime ? endTime : renderStartTime,
+        lanes
+      )),
+    (eventIsRepeat = transitionEventType),
+    (isSpawnedUpdate = transitionEventIsRepeat),
+    (renderStartTime$jscomp$0 = renderStartTime),
+    supportsUserTiming &&
+      ((reusableLaneDevToolDetails.track = "Transition"),
+      0 < eventType &&
+        null !== eventIsRepeat &&
+        ((reusableLaneDevToolDetails.color = isSpawnedUpdate
+          ? "secondary-light"
+          : "warning"),
+        (reusableLaneOptions.start = eventType),
+        (reusableLaneOptions.end =
+          0 < previousRenderStartTime
+            ? previousRenderStartTime
+            : 0 < endTime
+              ? endTime
+              : renderStartTime$jscomp$0),
+        performance.measure(
+          isSpawnedUpdate ? "" : "Event: " + eventIsRepeat,
+          reusableLaneOptions
+        )),
+      0 < previousRenderStartTime &&
+        ((reusableLaneDevToolDetails.color = "primary-dark"),
+        (reusableLaneOptions.start = previousRenderStartTime),
+        (reusableLaneOptions.end =
+          0 < endTime ? endTime : renderStartTime$jscomp$0),
+        performance.measure("Action", reusableLaneOptions)),
+      0 < endTime &&
+        ((reusableLaneDevToolDetails.color = "primary-light"),
+        (reusableLaneOptions.start = endTime),
+        (reusableLaneOptions.end = renderStartTime$jscomp$0),
+        performance.measure("Blocked", reusableLaneOptions))),
+    (transitionSuspendedTime =
+      transitionUpdateTime =
+      transitionStartTime =
+        -1.1),
+    (transitionEventIsRepeat = !0));
+  previousRenderStartTime = root.timeoutHandle;
+  -1 !== previousRenderStartTime &&
+    ((root.timeoutHandle = -1), cancelTimeout(previousRenderStartTime));
+  previousRenderStartTime = root.cancelPendingCommit;
+  null !== previousRenderStartTime &&
+    ((root.cancelPendingCommit = null), previousRenderStartTime());
   resetWorkInProgressStack();
   workInProgressRoot = root;
-  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
+  workInProgress = previousRenderStartTime = createWorkInProgress(
+    root.current,
+    null
+  );
   workInProgressRootRenderLanes = lanes;
   workInProgressSuspendedReason = 0;
   workInProgressThrownValue = null;
@@ -11112,21 +12778,16 @@ function prepareFreshStack(root, lanes) {
   workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
   workInProgressAppearingViewTransitions = null;
   0 !== (lanes & 8) && (lanes |= lanes & 32);
-  var allEntangledLanes = root.entangledLanes;
-  if (0 !== allEntangledLanes)
-    for (
-      root = root.entanglements, allEntangledLanes &= lanes;
-      0 < allEntangledLanes;
-
-    ) {
-      var index$2 = 31 - clz32(allEntangledLanes),
-        lane = 1 << index$2;
-      lanes |= root[index$2];
-      allEntangledLanes &= ~lane;
-    }
+  endTime = root.entangledLanes;
+  if (0 !== endTime)
+    for (root = root.entanglements, endTime &= lanes; 0 < endTime; )
+      (eventType = 31 - clz32(endTime)),
+        (eventIsRepeat = 1 << eventType),
+        (lanes |= root[eventType]),
+        (endTime &= ~eventIsRepeat);
   entangledRenderLanes = lanes;
   finishQueueingConcurrentUpdates();
-  return timeoutHandle;
+  return previousRenderStartTime;
 }
 function handleThrow(root, thrownValue) {
   currentlyRenderingFiber = null;
@@ -11147,41 +12808,14 @@ function handleThrow(root, thrownValue) {
               : 1);
   workInProgressThrownValue = thrownValue;
   var erroredWork = workInProgress;
-  if (null === erroredWork)
-    (workInProgressRootExitStatus = 1),
+  null === erroredWork
+    ? ((workInProgressRootExitStatus = 1),
       logUncaughtError(
         root,
         createCapturedValueAtFiber(thrownValue, root.current)
-      );
-  else
-    switch (
-      (erroredWork.mode & 2 &&
-        stopProfilerTimerIfRunningAndRecordDuration(erroredWork),
-      markComponentRenderStopped(),
-      workInProgressSuspendedReason)
-    ) {
-      case 1:
-        null !== injectedProfilingHooks &&
-          "function" === typeof injectedProfilingHooks.markComponentErrored &&
-          injectedProfilingHooks.markComponentErrored(
-            erroredWork,
-            thrownValue,
-            workInProgressRootRenderLanes
-          );
-        break;
-      case 2:
-      case 9:
-      case 3:
-      case 6:
-      case 7:
-        null !== injectedProfilingHooks &&
-          "function" === typeof injectedProfilingHooks.markComponentSuspended &&
-          injectedProfilingHooks.markComponentSuspended(
-            erroredWork,
-            thrownValue,
-            workInProgressRootRenderLanes
-          );
-    }
+      ))
+    : erroredWork.mode & 2 &&
+      stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
 }
 function pushDispatcher() {
   var prevDispatcher = ReactSharedInternals.H;
@@ -11210,6 +12844,23 @@ function renderDidSuspendDelayIfPossible() {
       !1
     );
 }
+function queueConcurrentError(error) {
+  null === workInProgressRootConcurrentErrors
+    ? (workInProgressRootConcurrentErrors = [error])
+    : workInProgressRootConcurrentErrors.push(error);
+}
+function trackAppearingViewTransition(instance, name) {
+  if (null === workInProgressAppearingViewTransitions) {
+    if (
+      (workInProgressRootRenderLanes & 335544192) !==
+      workInProgressRootRenderLanes
+    )
+      return;
+    workInProgressAppearingViewTransitions = new Map();
+  }
+  instance.paired = null;
+  workInProgressAppearingViewTransitions.set(name, instance);
+}
 function renderRootSync(root, lanes, shouldYieldForPrerendering) {
   var prevExecutionContext = executionContext;
   executionContext |= 2;
@@ -11226,7 +12877,6 @@ function renderRootSync(root, lanes, shouldYieldForPrerendering) {
     workInProgressTransitions = null;
     prepareFreshStack(root, lanes);
   }
-  markRenderStarted(lanes);
   lanes = !1;
   memoizedUpdaters = workInProgressRootExitStatus;
   a: do
@@ -11266,8 +12916,8 @@ function renderRootSync(root, lanes, shouldYieldForPrerendering) {
       workLoopSync();
       memoizedUpdaters = workInProgressRootExitStatus;
       break;
-    } catch (thrownValue$181) {
-      handleThrow(root, thrownValue$181);
+    } catch (thrownValue$190) {
+      handleThrow(root, thrownValue$190);
     }
   while (1);
   lanes && root.shellSuspendCounter++;
@@ -11275,7 +12925,6 @@ function renderRootSync(root, lanes, shouldYieldForPrerendering) {
   executionContext = prevExecutionContext;
   ReactSharedInternals.H = prevDispatcher;
   ReactSharedInternals.A = prevAsyncDispatcher;
-  markRenderStopped();
   null === workInProgress &&
     ((workInProgressRoot = null),
     (workInProgressRootRenderLanes = 0),
@@ -11303,7 +12952,6 @@ function renderRootConcurrent(root, lanes) {
     prepareFreshStack(root, lanes);
   } else
     workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
-  markRenderStarted(lanes);
   a: do
     try {
       if (0 !== workInProgressSuspendedReason && null !== workInProgress)
@@ -11390,22 +13038,15 @@ function renderRootConcurrent(root, lanes) {
         }
       workLoopConcurrentByScheduler();
       break;
-    } catch (thrownValue$183) {
-      handleThrow(root, thrownValue$183);
+    } catch (thrownValue$192) {
+      handleThrow(root, thrownValue$192);
     }
   while (1);
   lastContextDependency = currentlyRenderingFiber$1 = null;
   ReactSharedInternals.H = prevDispatcher;
   ReactSharedInternals.A = prevAsyncDispatcher;
   executionContext = prevExecutionContext;
-  if (null !== workInProgress)
-    return (
-      null !== injectedProfilingHooks &&
-        "function" === typeof injectedProfilingHooks.markRenderYielded &&
-        injectedProfilingHooks.markRenderYielded(),
-      0
-    );
-  markRenderStopped();
+  if (null !== workInProgress) return 0;
   workInProgressRoot = null;
   workInProgressRootRenderLanes = 0;
   finishQueueingConcurrentUpdates();
@@ -11596,17 +13237,42 @@ function commitRoot(
   didIncludeRenderPhaseUpdate,
   spawnedLane,
   updatedLanes,
-  suspendedRetryLanes
+  suspendedRetryLanes,
+  exitStatus,
+  suspendedCommitReason,
+  completedRenderStartTime,
+  completedRenderEndTime
 ) {
   root.cancelPendingCommit = null;
   do flushPendingEffects();
   while (0 !== pendingEffectsStatus);
   if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
-  null !== injectedProfilingHooks &&
-    "function" === typeof injectedProfilingHooks.markCommitStarted &&
-    injectedProfilingHooks.markCommitStarted(lanes);
-  if (null === finishedWork) markCommitStopped();
-  else {
+  setCurrentTrackFromLanes(lanes);
+  2 === exitStatus
+    ? logErroredRenderPhase(completedRenderStartTime, completedRenderEndTime)
+    : null !== recoverableErrors
+      ? supportsUserTiming &&
+        performance.measure("Recovered", {
+          start: completedRenderStartTime,
+          end: completedRenderEndTime,
+          detail: {
+            devtools: {
+              color: "primary-dark",
+              track: reusableLaneDevToolDetails.track,
+              trackGroup: "Scheduler \u269b",
+              tooltipText:
+                null !== finishedWork &&
+                null !== finishedWork.alternate &&
+                finishedWork.alternate.memoizedState.isDehydrated &&
+                0 !== (finishedWork.flags & 256)
+                  ? "Hydration Failed"
+                  : "Recovered after Error",
+              properties: []
+            }
+          }
+        })
+      : logRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes);
+  if (null !== finishedWork) {
     if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
     didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
     didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
@@ -11627,23 +13293,34 @@ function commitRoot(
     pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
     pendingPassiveTransitions = transitions;
     pendingRecoverableErrors = recoverableErrors;
-    0 !== (finishedWork.subtreeFlags & 10256) ||
-    0 !== (finishedWork.flags & 10256)
+    pendingViewTransitionEvents = null;
+    pendingEffectsRenderEndTime = completedRenderEndTime;
+    pendingSuspendedCommitReason = suspendedCommitReason;
+    recoverableErrors = (lanes & 335544192) === lanes ? 10262 : 10256;
+    0 !== finishedWork.actualDuration ||
+    0 !== (finishedWork.subtreeFlags & recoverableErrors) ||
+    0 !== (finishedWork.flags & recoverableErrors)
       ? ((root.callbackNode = null),
         (root.callbackPriority = 0),
         scheduleCallback$1(NormalPriority$1, function () {
+          schedulerEvent = window.event;
           flushPassiveEffects(!0);
           return null;
         }))
       : ((root.callbackNode = null), (root.callbackPriority = 0));
+    commitErrors = null;
     commitStartTime = now();
-    recoverableErrors = 0 !== (finishedWork.flags & 13878);
-    if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
-      recoverableErrors = ReactSharedInternals.T;
+    1 === suspendedCommitReason
+      ? logSuspendedCommitPhase(completedRenderEndTime, commitStartTime)
+      : 2 === suspendedCommitReason &&
+        logSuspenseThrottlePhase(completedRenderEndTime, commitStartTime);
+    suspendedCommitReason = 0 !== (finishedWork.flags & 13878);
+    if (0 !== (finishedWork.subtreeFlags & 13878) || suspendedCommitReason) {
+      suspendedCommitReason = ReactSharedInternals.T;
       ReactSharedInternals.T = null;
-      transitions = ReactDOMSharedInternals.p;
+      completedRenderEndTime = ReactDOMSharedInternals.p;
       ReactDOMSharedInternals.p = 2;
-      spawnedLane = executionContext;
+      recoverableErrors = executionContext;
       executionContext |= 4;
       try {
         commitBeforeMutationEffects(
@@ -11653,17 +13330,30 @@ function commitRoot(
           appearingViewTransitions
         );
       } finally {
-        (executionContext = spawnedLane),
-          (ReactDOMSharedInternals.p = transitions),
-          (ReactSharedInternals.T = recoverableErrors);
+        (executionContext = recoverableErrors),
+          (ReactDOMSharedInternals.p = completedRenderEndTime),
+          (ReactSharedInternals.T = suspendedCommitReason);
       }
     }
     pendingEffectsStatus = 1;
-    flushMutationEffects();
-    flushLayoutEffects();
-    flushSpawnedWork();
+    (shouldStartViewTransition &&
+      startViewTransition(
+        root.containerInfo,
+        flushMutationEffects,
+        flushLayoutEffects,
+        flushAfterMutationEffects,
+        flushSpawnedWork,
+        flushPassiveEffects
+      )) ||
+      (flushMutationEffects(), flushLayoutEffects(), flushSpawnedWork());
   }
 }
+function flushAfterMutationEffects() {
+  3 === pendingEffectsStatus &&
+    ((pendingEffectsStatus = 0),
+    commitAfterMutationEffectsOnFiber(pendingFinishedWork, pendingEffectsRoot),
+    (pendingEffectsStatus = 4));
+}
 function flushMutationEffects() {
   if (1 === pendingEffectsStatus) {
     pendingEffectsStatus = 0;
@@ -11681,7 +13371,8 @@ function flushMutationEffects() {
       try {
         inProgressLanes = lanes;
         inProgressRoot = root;
-        commitMutationEffectsOnFiber(finishedWork, root);
+        resetComponentEffectTimers();
+        commitMutationEffectsOnFiber(finishedWork, root, lanes);
         inProgressRoot = inProgressLanes = null;
         lanes = selectionInformation;
         var curFocusedElem = getActiveElementDeep(root.containerInfo),
@@ -11805,18 +13496,11 @@ function flushLayoutEffects() {
       var prevExecutionContext = executionContext;
       executionContext |= 4;
       try {
-        null !== injectedProfilingHooks &&
-          "function" ===
-            typeof injectedProfilingHooks.markLayoutEffectsStarted &&
-          injectedProfilingHooks.markLayoutEffectsStarted(lanes),
-          (inProgressLanes = lanes),
+        (inProgressLanes = lanes),
           (inProgressRoot = root),
+          resetComponentEffectTimers(),
           commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork),
-          (inProgressRoot = inProgressLanes = null),
-          null !== injectedProfilingHooks &&
-            "function" ===
-              typeof injectedProfilingHooks.markLayoutEffectsStopped &&
-            injectedProfilingHooks.markLayoutEffectsStopped();
+          (inProgressRoot = inProgressLanes = null);
       } finally {
         (executionContext = prevExecutionContext),
           (ReactDOMSharedInternals.p = previousPriority),
@@ -11833,21 +13517,43 @@ function flushSpawnedWork() {
     var root = pendingEffectsRoot,
       finishedWork = pendingFinishedWork,
       lanes = pendingEffectsLanes,
-      recoverableErrors = pendingRecoverableErrors;
-    0 !== (finishedWork.subtreeFlags & 10256) ||
-    0 !== (finishedWork.flags & 10256)
+      completedRenderEndTime = pendingEffectsRenderEndTime,
+      recoverableErrors = pendingRecoverableErrors,
+      suspendedCommitReason = pendingSuspendedCommitReason;
+    commitEndTime = now();
+    completedRenderEndTime =
+      0 === suspendedCommitReason ? completedRenderEndTime : commitStartTime;
+    suspendedCommitReason = commitEndTime;
+    null !== commitErrors
+      ? logCommitErrored(
+          completedRenderEndTime,
+          suspendedCommitReason,
+          commitErrors,
+          !1
+        )
+      : supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color = "secondary-dark"),
+        (reusableLaneOptions.start = completedRenderEndTime),
+        (reusableLaneOptions.end = suspendedCommitReason),
+        performance.measure("Commit", reusableLaneOptions));
+    completedRenderEndTime = (lanes & 335544192) === lanes ? 10262 : 10256;
+    (completedRenderEndTime =
+      0 !== finishedWork.actualDuration ||
+      0 !== (finishedWork.subtreeFlags & completedRenderEndTime) ||
+      0 !== (finishedWork.flags & completedRenderEndTime))
       ? (pendingEffectsStatus = 5)
       : ((pendingEffectsStatus = 0),
         (pendingEffectsRoot = null),
         releaseRootPooledCache(root, root.pendingLanes));
-    var remainingLanes = root.pendingLanes;
-    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
-    remainingLanes = lanesToEventPriority(lanes);
+    suspendedCommitReason = root.pendingLanes;
+    0 === suspendedCommitReason &&
+      (legacyErrorBoundariesThatAlreadyFailed = null);
+    suspendedCommitReason = lanesToEventPriority(lanes);
     finishedWork = finishedWork.stateNode;
     if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
       try {
         var didError = 128 === (finishedWork.current.flags & 128);
-        switch (remainingLanes) {
+        switch (suspendedCommitReason) {
           case 2:
             var schedulerPriority = ImmediatePriority;
             break;
@@ -11893,17 +13599,25 @@ function flushSpawnedWork() {
           (ReactDOMSharedInternals.p = schedulerPriority);
       }
     }
+    recoverableErrors = pendingViewTransitionEvents;
+    if (null !== recoverableErrors)
+      for (
+        pendingViewTransitionEvents = null, onRecoverableError = 0;
+        onRecoverableError < recoverableErrors.length;
+        onRecoverableError++
+      )
+        (0, recoverableErrors[onRecoverableError])();
     0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
     ensureRootIsScheduled(root);
-    remainingLanes = root.pendingLanes;
-    0 !== (lanes & 4194218) && 0 !== (remainingLanes & 42)
+    suspendedCommitReason = root.pendingLanes;
+    0 !== (lanes & 4194218) && 0 !== (suspendedCommitReason & 42)
       ? ((nestedUpdateScheduled = !0),
         root === rootWithNestedUpdates
           ? nestedUpdateCount++
           : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)))
       : (nestedUpdateCount = 0);
+    completedRenderEndTime || finalizeRender(lanes, commitEndTime);
     flushSyncWorkAcrossRoots_impl(0, !1);
-    markCommitStopped();
   }
 }
 function releaseRootPooledCache(root, remainingLanes) {
@@ -11918,7 +13632,7 @@ function flushPendingEffects(wasDelayedCommit) {
   flushSpawnedWork();
   return flushPassiveEffects(wasDelayedCommit);
 }
-function flushPassiveEffects() {
+function flushPassiveEffects(wasDelayedCommit) {
   if (5 !== pendingEffectsStatus) return !1;
   var root = pendingEffectsRoot,
     remainingLanes = pendingEffectsRemainingLanes;
@@ -11929,39 +13643,69 @@ function flushPassiveEffects() {
   try {
     ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
     ReactSharedInternals.T = null;
-    renderPriority = pendingPassiveTransitions;
+    var transitions = pendingPassiveTransitions;
     pendingPassiveTransitions = null;
-    var root$jscomp$0 = pendingEffectsRoot,
-      lanes = pendingEffectsLanes;
+    renderPriority = pendingEffectsRoot;
+    var lanes = pendingEffectsLanes;
     pendingEffectsStatus = 0;
     pendingEffectsRoot = null;
     pendingEffectsLanes = 0;
     if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
-    null !== injectedProfilingHooks &&
-      "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted &&
-      injectedProfilingHooks.markPassiveEffectsStarted(lanes);
-    var prevExecutionContext = executionContext;
+    setCurrentTrackFromLanes(lanes);
+    var passiveEffectStartTime = 0;
+    commitErrors = null;
+    passiveEffectStartTime = now$1();
+    var startTime = commitEndTime,
+      endTime = passiveEffectStartTime;
+    wasDelayedCommit = !!wasDelayedCommit;
+    supportsUserTiming &&
+      ((reusableLaneDevToolDetails.color = "secondary-light"),
+      (reusableLaneOptions.start = startTime),
+      (reusableLaneOptions.end = endTime),
+      performance.measure(
+        wasDelayedCommit ? "Waiting for Paint" : "",
+        reusableLaneOptions
+      ));
+    wasDelayedCommit = executionContext;
     executionContext |= 4;
-    commitPassiveUnmountOnFiber(root$jscomp$0.current);
+    var finishedWork = renderPriority.current;
+    resetComponentEffectTimers();
+    commitPassiveUnmountOnFiber(finishedWork);
+    var finishedWork$jscomp$0 = renderPriority.current;
+    finishedWork = pendingEffectsRenderEndTime;
+    resetComponentEffectTimers();
     commitPassiveMountOnFiber(
-      root$jscomp$0,
-      root$jscomp$0.current,
+      renderPriority,
+      finishedWork$jscomp$0,
       lanes,
-      renderPriority
+      transitions,
+      finishedWork
     );
-    null !== injectedProfilingHooks &&
-      "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped &&
-      injectedProfilingHooks.markPassiveEffectsStopped();
-    executionContext = prevExecutionContext;
+    executionContext = wasDelayedCommit;
+    var passiveEffectsEndTime = now$1();
+    finishedWork$jscomp$0 = passiveEffectStartTime;
+    null !== commitErrors
+      ? logCommitErrored(
+          finishedWork$jscomp$0,
+          passiveEffectsEndTime,
+          commitErrors,
+          !0
+        )
+      : supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color = "secondary-dark"),
+        (reusableLaneOptions.start = finishedWork$jscomp$0),
+        (reusableLaneOptions.end = passiveEffectsEndTime),
+        performance.measure("Remaining Effects", reusableLaneOptions));
+    finalizeRender(lanes, passiveEffectsEndTime);
     flushSyncWorkAcrossRoots_impl(0, !1);
     if (
       injectedHook &&
       "function" === typeof injectedHook.onPostCommitFiberRoot
     )
       try {
-        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
+        injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);
       } catch (err) {}
-    var stateNode = root$jscomp$0.current.stateNode;
+    var stateNode = renderPriority.current.stateNode;
     stateNode.effectDuration = 0;
     stateNode.passiveEffectDuration = 0;
     return !0;
@@ -11973,6 +13717,7 @@ function flushPassiveEffects() {
 }
 function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
   sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+  recordEffectError(sourceFiber);
   sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
   rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
   null !== rootFiber &&
@@ -12000,6 +13745,7 @@ function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
               !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
         ) {
           sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+          recordEffectError(sourceFiber);
           error = createClassErrorUpdate(2);
           instance = enqueueUpdate(nearestMountedAncestor, error, 2);
           null !== instance &&
@@ -12039,6 +13785,11 @@ function pingSuspendedRoot(root, wakeable, pingedLanes) {
   null !== pingCache && pingCache.delete(wakeable);
   root.pingedLanes |= root.suspendedLanes & pingedLanes;
   root.warmLanes &= ~pingedLanes;
+  0 !== (pingedLanes & 3) || 0 !== (pingedLanes & 60)
+    ? 0 > blockingUpdateTime && (blockingClampTime = blockingUpdateTime = now())
+    : 0 !== (pingedLanes & 4194176) &&
+      0 > transitionUpdateTime &&
+      (transitionClampTime = transitionUpdateTime = now());
   workInProgressRoot === root &&
     (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
     (4 === workInProgressRootExitStatus ||
@@ -12115,14 +13866,14 @@ function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
     isFlushingWork = !0;
     do {
       var didPerformSomeWork = !1;
-      for (var root$188 = firstScheduledRoot; null !== root$188; ) {
+      for (var root$198 = firstScheduledRoot; null !== root$198; ) {
         if (!onlyLegacy)
           if (0 !== syncTransitionLanes) {
-            var pendingLanes = root$188.pendingLanes;
+            var pendingLanes = root$198.pendingLanes;
             if (0 === pendingLanes) var JSCompiler_inline_result = 0;
             else {
-              var suspendedLanes = root$188.suspendedLanes,
-                pingedLanes = root$188.pingedLanes;
+              var suspendedLanes = root$198.suspendedLanes,
+                pingedLanes = root$198.pingedLanes;
               JSCompiler_inline_result =
                 (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
               JSCompiler_inline_result &=
@@ -12136,26 +13887,27 @@ function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
             }
             0 !== JSCompiler_inline_result &&
               ((didPerformSomeWork = !0),
-              performSyncWorkOnRoot(root$188, JSCompiler_inline_result));
+              performSyncWorkOnRoot(root$198, JSCompiler_inline_result));
           } else
             (JSCompiler_inline_result = workInProgressRootRenderLanes),
               (JSCompiler_inline_result = getNextLanes(
-                root$188,
-                root$188 === workInProgressRoot ? JSCompiler_inline_result : 0,
-                null !== root$188.cancelPendingCommit ||
-                  -1 !== root$188.timeoutHandle
+                root$198,
+                root$198 === workInProgressRoot ? JSCompiler_inline_result : 0,
+                null !== root$198.cancelPendingCommit ||
+                  -1 !== root$198.timeoutHandle
               )),
               0 === (JSCompiler_inline_result & 3) ||
-                checkIfRootIsPrerendering(root$188, JSCompiler_inline_result) ||
+                checkIfRootIsPrerendering(root$198, JSCompiler_inline_result) ||
                 ((didPerformSomeWork = !0),
-                performSyncWorkOnRoot(root$188, JSCompiler_inline_result));
-        root$188 = root$188.next;
+                performSyncWorkOnRoot(root$198, JSCompiler_inline_result));
+        root$198 = root$198.next;
       }
     } while (didPerformSomeWork);
     isFlushingWork = !1;
   }
 }
 function processRootScheduleInImmediateTask() {
+  schedulerEvent = window.event;
   processRootScheduleInMicrotask();
 }
 function processRootScheduleInMicrotask() {
@@ -12225,39 +13977,43 @@ function scheduleTaskForRootDuringMicrotask(root, currentTime) {
       (root.callbackPriority = 0)
     );
   if (
-    0 === (suspendedLanes & 3) ||
-    checkIfRootIsPrerendering(root, suspendedLanes)
-  ) {
-    currentTime = suspendedLanes & -suspendedLanes;
-    if (currentTime === root.callbackPriority) return currentTime;
-    null !== pingedLanes && cancelCallback$1(pingedLanes);
-    switch (lanesToEventPriority(suspendedLanes)) {
-      case 2:
-      case 8:
-        suspendedLanes = UserBlockingPriority;
-        break;
-      case 32:
-        suspendedLanes = NormalPriority$1;
-        break;
-      case 268435456:
-        suspendedLanes = IdlePriority;
-        break;
-      default:
-        suspendedLanes = NormalPriority$1;
-    }
-    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
-    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
-    root.callbackPriority = currentTime;
-    root.callbackNode = suspendedLanes;
-    return currentTime;
+    0 !== (suspendedLanes & 3) &&
+    !checkIfRootIsPrerendering(root, suspendedLanes)
+  )
+    return (
+      null !== pingedLanes &&
+        null !== pingedLanes &&
+        cancelCallback$1(pingedLanes),
+      (root.callbackPriority = 2),
+      (root.callbackNode = null),
+      2
+    );
+  currentTime = suspendedLanes & -suspendedLanes;
+  if (currentTime === root.callbackPriority) return currentTime;
+  null !== pingedLanes && cancelCallback$1(pingedLanes);
+  switch (lanesToEventPriority(suspendedLanes)) {
+    case 2:
+    case 8:
+      suspendedLanes = UserBlockingPriority;
+      break;
+    case 32:
+      suspendedLanes = NormalPriority$1;
+      break;
+    case 268435456:
+      suspendedLanes = IdlePriority;
+      break;
+    default:
+      suspendedLanes = NormalPriority$1;
   }
-  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
-  root.callbackPriority = 2;
-  root.callbackNode = null;
-  return 2;
+  pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
+  suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
+  root.callbackPriority = currentTime;
+  root.callbackNode = suspendedLanes;
+  return currentTime;
 }
 function performWorkOnRootViaSchedulerTask(root, didTimeout) {
   nestedUpdateScheduled = currentUpdateIsNested = !1;
+  schedulerEvent = window.event;
   if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
     return (root.callbackNode = null), (root.callbackPriority = 0), null;
   var originalCallbackNode = root.callbackNode;
@@ -12392,20 +14148,20 @@ function extractEvents$1(
   }
 }
 for (
-  var i$jscomp$inline_1586 = 0;
-  i$jscomp$inline_1586 < simpleEventPluginEvents.length;
-  i$jscomp$inline_1586++
+  var i$jscomp$inline_1700 = 0;
+  i$jscomp$inline_1700 < simpleEventPluginEvents.length;
+  i$jscomp$inline_1700++
 ) {
-  var eventName$jscomp$inline_1587 =
-      simpleEventPluginEvents[i$jscomp$inline_1586],
-    domEventName$jscomp$inline_1588 =
-      eventName$jscomp$inline_1587.toLowerCase(),
-    capitalizedEvent$jscomp$inline_1589 =
-      eventName$jscomp$inline_1587[0].toUpperCase() +
-      eventName$jscomp$inline_1587.slice(1);
+  var eventName$jscomp$inline_1701 =
+      simpleEventPluginEvents[i$jscomp$inline_1700],
+    domEventName$jscomp$inline_1702 =
+      eventName$jscomp$inline_1701.toLowerCase(),
+    capitalizedEvent$jscomp$inline_1703 =
+      eventName$jscomp$inline_1701[0].toUpperCase() +
+      eventName$jscomp$inline_1701.slice(1);
   registerSimpleEvent(
-    domEventName$jscomp$inline_1588,
-    "on" + capitalizedEvent$jscomp$inline_1589
+    domEventName$jscomp$inline_1702,
+    "on" + capitalizedEvent$jscomp$inline_1703
   );
 }
 registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
@@ -13156,13 +14912,13 @@ function noop$2() {}
 function setProp(domElement, tag, key, value, props, prevValue) {
   switch (key) {
     case "children":
-      "string" === typeof value
-        ? "body" === tag ||
+      if ("string" === typeof value)
+        "body" === tag ||
           ("textarea" === tag && "" === value) ||
-          setTextContent(domElement, value)
-        : ("number" === typeof value || "bigint" === typeof value) &&
-          "body" !== tag &&
-          setTextContent(domElement, "" + value);
+          setTextContent(domElement, value);
+      else if ("number" === typeof value || "bigint" === typeof value)
+        "body" !== tag && setTextContent(domElement, "" + value);
+      else return;
       break;
     case "className":
       setValueForKnownAttribute(domElement, "class", value);
@@ -13179,7 +14935,7 @@ function setProp(domElement, tag, key, value, props, prevValue) {
       break;
     case "style":
       setValueForStyles(domElement, value, prevValue);
-      break;
+      return;
     case "data":
       if ("object" !== tag) {
         setValueForKnownAttribute(domElement, "data", value);
@@ -13256,13 +15012,13 @@ function setProp(domElement, tag, key, value, props, prevValue) {
       break;
     case "onClick":
       null != value && (domElement.onclick = noop$2);
-      break;
+      return;
     case "onScroll":
       null != value && listenToNonDelegatedEvent("scroll", domElement);
-      break;
+      return;
     case "onScrollEnd":
       null != value && listenToNonDelegatedEvent("scrollend", domElement);
-      break;
+      return;
     case "dangerouslySetInnerHTML":
       if (null != value) {
         if ("object" !== typeof value || !("__html" in value))
@@ -13461,7 +15217,7 @@ function setProp(domElement, tag, key, value, props, prevValue) {
       break;
     case "innerText":
     case "textContent":
-      break;
+      return;
     default:
       if (
         !(2 < key.length) ||
@@ -13470,13 +15226,15 @@ function setProp(domElement, tag, key, value, props, prevValue) {
       )
         (key = aliases.get(key) || key),
           setValueForAttribute(domElement, key, value);
+      else return;
   }
+  viewTransitionMutationContext = !0;
 }
 function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
   switch (key) {
     case "style":
       setValueForStyles(domElement, value, prevValue);
-      break;
+      return;
     case "dangerouslySetInnerHTML":
       if (null != value) {
         if ("object" !== typeof value || !("__html" in value))
@@ -13489,28 +15247,28 @@ function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
       }
       break;
     case "children":
-      "string" === typeof value
-        ? setTextContent(domElement, value)
-        : ("number" === typeof value || "bigint" === typeof value) &&
-          setTextContent(domElement, "" + value);
+      if ("string" === typeof value) setTextContent(domElement, value);
+      else if ("number" === typeof value || "bigint" === typeof value)
+        setTextContent(domElement, "" + value);
+      else return;
       break;
     case "onScroll":
       null != value && listenToNonDelegatedEvent("scroll", domElement);
-      break;
+      return;
     case "onScrollEnd":
       null != value && listenToNonDelegatedEvent("scrollend", domElement);
-      break;
+      return;
     case "onClick":
       null != value && (domElement.onclick = noop$2);
-      break;
+      return;
     case "suppressContentEditableWarning":
     case "suppressHydrationWarning":
     case "innerHTML":
     case "ref":
-      break;
+      return;
     case "innerText":
     case "textContent":
-      break;
+      return;
     default:
       if (!registrationNameDependencies.hasOwnProperty(key))
         a: {
@@ -13534,13 +15292,16 @@ function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
             domElement.addEventListener(tag, value, props);
             break a;
           }
+          viewTransitionMutationContext = !0;
           key in domElement
             ? (domElement[key] = value)
             : !0 === value
               ? domElement.setAttribute(key, "")
               : setValueForAttribute(domElement, key, value);
         }
+      return;
   }
+  viewTransitionMutationContext = !0;
 }
 function setInitialProperties(domElement, tag, props) {
   switch (tag) {
@@ -13588,34 +15349,34 @@ function setInitialProperties(domElement, tag, props) {
         defaultChecked = null;
       for (hasSrc in props)
         if (props.hasOwnProperty(hasSrc)) {
-          var propValue$202 = props[hasSrc];
-          if (null != propValue$202)
+          var propValue$212 = props[hasSrc];
+          if (null != propValue$212)
             switch (hasSrc) {
               case "name":
-                hasSrcSet = propValue$202;
+                hasSrcSet = propValue$212;
                 break;
               case "type":
-                propValue = propValue$202;
+                propValue = propValue$212;
                 break;
               case "checked":
-                checked = propValue$202;
+                checked = propValue$212;
                 break;
               case "defaultChecked":
-                defaultChecked = propValue$202;
+                defaultChecked = propValue$212;
                 break;
               case "value":
-                propKey = propValue$202;
+                propKey = propValue$212;
                 break;
               case "defaultValue":
-                defaultValue = propValue$202;
+                defaultValue = propValue$212;
                 break;
               case "children":
               case "dangerouslySetInnerHTML":
-                if (null != propValue$202)
+                if (null != propValue$212)
                   throw Error(formatProdErrorMessage(137, tag));
                 break;
               default:
-                setProp(domElement, tag, hasSrc, propValue$202, props, null);
+                setProp(domElement, tag, hasSrc, propValue$212, props, null);
             }
         }
       initInput(
@@ -13752,14 +15513,14 @@ function setInitialProperties(domElement, tag, props) {
       return;
     default:
       if (isCustomElement(tag)) {
-        for (propValue$202 in props)
-          props.hasOwnProperty(propValue$202) &&
-            ((hasSrc = props[propValue$202]),
+        for (propValue$212 in props)
+          props.hasOwnProperty(propValue$212) &&
+            ((hasSrc = props[propValue$212]),
             void 0 !== hasSrc &&
               setPropOnCustomElement(
                 domElement,
                 tag,
-                propValue$202,
+                propValue$212,
                 hasSrc,
                 props,
                 void 0
@@ -13807,30 +15568,36 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
                 setProp(domElement, tag, propKey, null, nextProps, lastProp);
           }
       }
-      for (var propKey$219 in nextProps) {
-        var propKey = nextProps[propKey$219];
-        lastProp = lastProps[propKey$219];
+      for (var propKey$229 in nextProps) {
+        var propKey = nextProps[propKey$229];
+        lastProp = lastProps[propKey$229];
         if (
-          nextProps.hasOwnProperty(propKey$219) &&
+          nextProps.hasOwnProperty(propKey$229) &&
           (null != propKey || null != lastProp)
         )
-          switch (propKey$219) {
+          switch (propKey$229) {
             case "type":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               type = propKey;
               break;
             case "name":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               name = propKey;
               break;
             case "checked":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               checked = propKey;
               break;
             case "defaultChecked":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               defaultChecked = propKey;
               break;
             case "value":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               value = propKey;
               break;
             case "defaultValue":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
               defaultValue = propKey;
               break;
             case "children":
@@ -13843,7 +15610,7 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
                 setProp(
                   domElement,
                   tag,
-                  propKey$219,
+                  propKey$229,
                   propKey,
                   nextProps,
                   lastProp
@@ -13862,7 +15629,7 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
       );
       return;
     case "select":
-      propKey = value = defaultValue = propKey$219 = null;
+      propKey = value = defaultValue = propKey$229 = null;
       for (type in lastProps)
         if (
           ((lastDefaultValue = lastProps[type]),
@@ -13893,13 +15660,16 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
         )
           switch (name) {
             case "value":
-              propKey$219 = type;
+              type !== lastDefaultValue && (viewTransitionMutationContext = !0);
+              propKey$229 = type;
               break;
             case "defaultValue":
+              type !== lastDefaultValue && (viewTransitionMutationContext = !0);
               defaultValue = type;
               break;
             case "multiple":
-              value = type;
+              type !== lastDefaultValue && (viewTransitionMutationContext = !0),
+                (value = type);
             default:
               type !== lastDefaultValue &&
                 setProp(
@@ -13914,15 +15684,15 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
       tag = defaultValue;
       lastProps = value;
       nextProps = propKey;
-      null != propKey$219
-        ? updateOptions(domElement, !!lastProps, propKey$219, !1)
+      null != propKey$229
+        ? updateOptions(domElement, !!lastProps, propKey$229, !1)
         : !!nextProps !== !!lastProps &&
           (null != tag
             ? updateOptions(domElement, !!lastProps, tag, !0)
             : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));
       return;
     case "textarea":
-      propKey = propKey$219 = null;
+      propKey = propKey$229 = null;
       for (defaultValue in lastProps)
         if (
           ((name = lastProps[defaultValue]),
@@ -13946,9 +15716,11 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
         )
           switch (value) {
             case "value":
-              propKey$219 = name;
+              name !== type && (viewTransitionMutationContext = !0);
+              propKey$229 = name;
               break;
             case "defaultValue":
+              name !== type && (viewTransitionMutationContext = !0);
               propKey = name;
               break;
             case "children":
@@ -13960,17 +15732,17 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
               name !== type &&
                 setProp(domElement, tag, value, name, nextProps, type);
           }
-      updateTextarea(domElement, propKey$219, propKey);
+      updateTextarea(domElement, propKey$229, propKey);
       return;
     case "option":
-      for (var propKey$235 in lastProps)
+      for (var propKey$245 in lastProps)
         if (
-          ((propKey$219 = lastProps[propKey$235]),
-          lastProps.hasOwnProperty(propKey$235) &&
-            null != propKey$219 &&
-            !nextProps.hasOwnProperty(propKey$235))
+          ((propKey$229 = lastProps[propKey$245]),
+          lastProps.hasOwnProperty(propKey$245) &&
+            null != propKey$229 &&
+            !nextProps.hasOwnProperty(propKey$245))
         )
-          switch (propKey$235) {
+          switch (propKey$245) {
             case "selected":
               domElement.selected = !1;
               break;
@@ -13978,33 +15750,34 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
               setProp(
                 domElement,
                 tag,
-                propKey$235,
+                propKey$245,
                 null,
                 nextProps,
-                propKey$219
+                propKey$229
               );
           }
       for (lastDefaultValue in nextProps)
         if (
-          ((propKey$219 = nextProps[lastDefaultValue]),
+          ((propKey$229 = nextProps[lastDefaultValue]),
           (propKey = lastProps[lastDefaultValue]),
           nextProps.hasOwnProperty(lastDefaultValue) &&
-            propKey$219 !== propKey &&
-            (null != propKey$219 || null != propKey))
+            propKey$229 !== propKey &&
+            (null != propKey$229 || null != propKey))
         )
           switch (lastDefaultValue) {
             case "selected":
+              propKey$229 !== propKey && (viewTransitionMutationContext = !0);
               domElement.selected =
-                propKey$219 &&
-                "function" !== typeof propKey$219 &&
-                "symbol" !== typeof propKey$219;
+                propKey$229 &&
+                "function" !== typeof propKey$229 &&
+                "symbol" !== typeof propKey$229;
               break;
             default:
               setProp(
                 domElement,
                 tag,
                 lastDefaultValue,
-                propKey$219,
+                propKey$229,
                 nextProps,
                 propKey
               );
@@ -14025,24 +15798,24 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
     case "track":
     case "wbr":
     case "menuitem":
-      for (var propKey$240 in lastProps)
-        (propKey$219 = lastProps[propKey$240]),
-          lastProps.hasOwnProperty(propKey$240) &&
-            null != propKey$219 &&
-            !nextProps.hasOwnProperty(propKey$240) &&
-            setProp(domElement, tag, propKey$240, null, nextProps, propKey$219);
+      for (var propKey$250 in lastProps)
+        (propKey$229 = lastProps[propKey$250]),
+          lastProps.hasOwnProperty(propKey$250) &&
+            null != propKey$229 &&
+            !nextProps.hasOwnProperty(propKey$250) &&
+            setProp(domElement, tag, propKey$250, null, nextProps, propKey$229);
       for (checked in nextProps)
         if (
-          ((propKey$219 = nextProps[checked]),
+          ((propKey$229 = nextProps[checked]),
           (propKey = lastProps[checked]),
           nextProps.hasOwnProperty(checked) &&
-            propKey$219 !== propKey &&
-            (null != propKey$219 || null != propKey))
+            propKey$229 !== propKey &&
+            (null != propKey$229 || null != propKey))
         )
           switch (checked) {
             case "children":
             case "dangerouslySetInnerHTML":
-              if (null != propKey$219)
+              if (null != propKey$229)
                 throw Error(formatProdErrorMessage(137, tag));
               break;
             default:
@@ -14050,7 +15823,7 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
                 domElement,
                 tag,
                 checked,
-                propKey$219,
+                propKey$229,
                 nextProps,
                 propKey
               );
@@ -14058,49 +15831,49 @@ function updateProperties(domElement, tag, lastProps, nextProps) {
       return;
     default:
       if (isCustomElement(tag)) {
-        for (var propKey$245 in lastProps)
-          (propKey$219 = lastProps[propKey$245]),
-            lastProps.hasOwnProperty(propKey$245) &&
-              void 0 !== propKey$219 &&
-              !nextProps.hasOwnProperty(propKey$245) &&
+        for (var propKey$255 in lastProps)
+          (propKey$229 = lastProps[propKey$255]),
+            lastProps.hasOwnProperty(propKey$255) &&
+              void 0 !== propKey$229 &&
+              !nextProps.hasOwnProperty(propKey$255) &&
               setPropOnCustomElement(
                 domElement,
                 tag,
-                propKey$245,
+                propKey$255,
                 void 0,
                 nextProps,
-                propKey$219
+                propKey$229
               );
         for (defaultChecked in nextProps)
-          (propKey$219 = nextProps[defaultChecked]),
+          (propKey$229 = nextProps[defaultChecked]),
             (propKey = lastProps[defaultChecked]),
             !nextProps.hasOwnProperty(defaultChecked) ||
-              propKey$219 === propKey ||
-              (void 0 === propKey$219 && void 0 === propKey) ||
+              propKey$229 === propKey ||
+              (void 0 === propKey$229 && void 0 === propKey) ||
               setPropOnCustomElement(
                 domElement,
                 tag,
                 defaultChecked,
-                propKey$219,
+                propKey$229,
                 nextProps,
                 propKey
               );
         return;
       }
   }
-  for (var propKey$250 in lastProps)
-    (propKey$219 = lastProps[propKey$250]),
-      lastProps.hasOwnProperty(propKey$250) &&
-        null != propKey$219 &&
-        !nextProps.hasOwnProperty(propKey$250) &&
-        setProp(domElement, tag, propKey$250, null, nextProps, propKey$219);
+  for (var propKey$260 in lastProps)
+    (propKey$229 = lastProps[propKey$260]),
+      lastProps.hasOwnProperty(propKey$260) &&
+        null != propKey$229 &&
+        !nextProps.hasOwnProperty(propKey$260) &&
+        setProp(domElement, tag, propKey$260, null, nextProps, propKey$229);
   for (lastProp in nextProps)
-    (propKey$219 = nextProps[lastProp]),
+    (propKey$229 = nextProps[lastProp]),
       (propKey = lastProps[lastProp]),
       !nextProps.hasOwnProperty(lastProp) ||
-        propKey$219 === propKey ||
-        (null == propKey$219 && null == propKey) ||
-        setProp(domElement, tag, lastProp, propKey$219, nextProps, propKey);
+        propKey$229 === propKey ||
+        (null == propKey$229 && null == propKey) ||
+        setProp(domElement, tag, lastProp, propKey$229, nextProps, propKey);
 }
 var eventsEnabled = null,
   selectionInformation = null;
@@ -14156,6 +15929,15 @@ function shouldAttemptEagerTransition() {
   currentPopstateTransitionEvent = null;
   return !1;
 }
+var schedulerEvent = void 0;
+function resolveEventType() {
+  var event = window.event;
+  return event && event !== schedulerEvent ? event.type : null;
+}
+function resolveEventTimeStamp() {
+  var event = window.event;
+  return event && event !== schedulerEvent ? event.timeStamp : -1.1;
+}
 var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
   cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
   localPromise = "function" === typeof Promise ? Promise : void 0,
@@ -14194,6 +15976,148 @@ function clearSuspenseBoundary(parentInstance, suspenseInstance) {
   } while (node);
   retryIfBlockedOn(suspenseInstance);
 }
+function restoreViewTransitionName(instance, props) {
+  props = props.style;
+  var viewTransitionName =
+    null != props
+      ? props.hasOwnProperty("viewTransitionName")
+        ? props.viewTransitionName
+        : props.hasOwnProperty("view-transition-name")
+          ? props["view-transition-name"]
+          : null
+      : null;
+  instance.style.viewTransitionName =
+    null == viewTransitionName || "boolean" === typeof viewTransitionName
+      ? ""
+      : ("" + viewTransitionName).trim();
+  props =
+    null != props
+      ? props.hasOwnProperty("viewTransitionClass")
+        ? props.viewTransitionClass
+        : props.hasOwnProperty("view-transition-class")
+          ? props["view-transition-class"]
+          : null
+      : null;
+  instance.style.viewTransitionClass =
+    null == props || "boolean" === typeof props ? "" : ("" + props).trim();
+}
+function measureInstance(instance) {
+  var ownerWindow = instance.ownerDocument.defaultView,
+    rect = instance.getBoundingClientRect();
+  instance = getComputedStyle(instance);
+  return {
+    rect: rect,
+    abs: "absolute" === instance.position || "fixed" === instance.position,
+    clip:
+      "none" !== instance.clipPath ||
+      "visible" !== instance.overflow ||
+      "none" !== instance.filter ||
+      "none" !== instance.mask ||
+      "none" !== instance.mask ||
+      "0px" !== instance.borderRadius,
+    view:
+      0 <= rect.bottom &&
+      0 <= rect.right &&
+      rect.top <= ownerWindow.innerHeight &&
+      rect.left <= ownerWindow.innerWidth
+  };
+}
+function startViewTransition(
+  rootContainer,
+  mutationCallback,
+  layoutCallback,
+  afterMutationCallback,
+  spawnedWorkCallback,
+  passiveCallback
+) {
+  var ownerDocument =
+    9 === rootContainer.nodeType ? rootContainer : rootContainer.ownerDocument;
+  try {
+    var transition = ownerDocument.startViewTransition({
+      update: function () {
+        var ownerWindow = ownerDocument.defaultView;
+        ownerWindow =
+          ownerWindow.navigation && ownerWindow.navigation.transition;
+        var previousFontLoadingStatus = ownerDocument.fonts.status;
+        mutationCallback();
+        if (
+          "loaded" === previousFontLoadingStatus &&
+          (ownerDocument.documentElement.clientHeight,
+          "loading" === ownerDocument.fonts.status)
+        )
+          return (
+            (previousFontLoadingStatus = Promise.race([
+              ownerDocument.fonts.ready,
+              new Promise(function (resolve) {
+                return setTimeout(resolve, 500);
+              })
+            ]).then(layoutCallback, layoutCallback)),
+            (ownerWindow
+              ? Promise.allSettled([
+                  ownerWindow.finished,
+                  previousFontLoadingStatus
+                ])
+              : previousFontLoadingStatus
+            ).then(afterMutationCallback, afterMutationCallback)
+          );
+        layoutCallback();
+        if (ownerWindow)
+          return ownerWindow.finished.then(
+            afterMutationCallback,
+            afterMutationCallback
+          );
+        afterMutationCallback();
+      },
+      types: null
+    });
+    ownerDocument.__reactViewTransition = transition;
+    transition.ready.then(spawnedWorkCallback, spawnedWorkCallback);
+    transition.finished.then(function () {
+      ownerDocument.__reactViewTransition = null;
+      passiveCallback();
+    });
+    return !0;
+  } catch (x) {
+    return !1;
+  }
+}
+function ViewTransitionPseudoElement(pseudo, name) {
+  this._scope = document.documentElement;
+  this._selector = "::view-transition-" + pseudo + "(" + name + ")";
+}
+ViewTransitionPseudoElement.prototype.animate = function (keyframes, options) {
+  options =
+    "number" === typeof options ? { duration: options } : assign({}, options);
+  options.pseudoElement = this._selector;
+  return this._scope.animate(keyframes, options);
+};
+ViewTransitionPseudoElement.prototype.getAnimations = function () {
+  for (
+    var scope = this._scope,
+      selector = this._selector,
+      animations = scope.getAnimations({ subtree: !0 }),
+      result = [],
+      i = 0;
+    i < animations.length;
+    i++
+  ) {
+    var effect = animations[i].effect;
+    null !== effect &&
+      effect.target === scope &&
+      effect.pseudoElement === selector &&
+      result.push(animations[i]);
+  }
+  return result;
+};
+function createViewTransitionInstance(name) {
+  return {
+    name: name,
+    group: new ViewTransitionPseudoElement("group", name),
+    imagePair: new ViewTransitionPseudoElement("image-pair", name),
+    old: new ViewTransitionPseudoElement("old", name),
+    new: new ViewTransitionPseudoElement("new", name)
+  };
+}
 function clearContainerSparingly(container) {
   var nextNode = container.firstChild;
   nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
@@ -14367,11 +16291,6 @@ function resolveSingletonInstance(type, props, rootContainerInstance) {
       throw Error(formatProdErrorMessage(451));
   }
 }
-function releaseSingletonInstance(instance) {
-  for (var attributes = instance.attributes; attributes.length; )
-    instance.removeAttributeNode(attributes[0]);
-  detachDeletedInstance(instance);
-}
 var preloadPropsMap = new Map(),
   preconnectsSet = new Set();
 function getHoistableRoot(container) {
@@ -14671,26 +16590,26 @@ function getResource(type, currentProps, pendingProps, currentResource) {
         "string" === typeof pendingProps.precedence
       ) {
         type = getStyleKey(pendingProps.href);
-        var styles$258 = getResourcesFromRoot(
+        var styles$268 = getResourcesFromRoot(
             JSCompiler_inline_result
           ).hoistableStyles,
-          resource$259 = styles$258.get(type);
-        resource$259 ||
+          resource$269 = styles$268.get(type);
+        resource$269 ||
           ((JSCompiler_inline_result =
             JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
-          (resource$259 = {
+          (resource$269 = {
             type: "stylesheet",
             instance: null,
             count: 0,
             state: { loading: 0, preload: null }
           }),
-          styles$258.set(type, resource$259),
-          (styles$258 = JSCompiler_inline_result.querySelector(
+          styles$268.set(type, resource$269),
+          (styles$268 = JSCompiler_inline_result.querySelector(
             getStylesheetSelectorFromKey(type)
           )) &&
-            !styles$258._p &&
-            ((resource$259.instance = styles$258),
-            (resource$259.state.loading = 5)),
+            !styles$268._p &&
+            ((resource$269.instance = styles$268),
+            (resource$269.state.loading = 5)),
           preloadPropsMap.has(type) ||
             ((pendingProps = {
               rel: "preload",
@@ -14703,16 +16622,16 @@ function getResource(type, currentProps, pendingProps, currentResource) {
               referrerPolicy: pendingProps.referrerPolicy
             }),
             preloadPropsMap.set(type, pendingProps),
-            styles$258 ||
+            styles$268 ||
               preloadStylesheet(
                 JSCompiler_inline_result,
                 type,
                 pendingProps,
-                resource$259.state
+                resource$269.state
               )));
         if (currentProps && null === currentResource)
           throw Error(formatProdErrorMessage(528, ""));
-        return resource$259;
+        return resource$269;
       }
       if (currentProps && null !== currentResource)
         throw Error(formatProdErrorMessage(529, ""));
@@ -14809,37 +16728,37 @@ function acquireResource(hoistableRoot, resource, props) {
         return (resource.instance = instance);
       case "stylesheet":
         styleProps = getStyleKey(props.href);
-        var instance$264 = hoistableRoot.querySelector(
+        var instance$274 = hoistableRoot.querySelector(
           getStylesheetSelectorFromKey(styleProps)
         );
-        if (instance$264)
+        if (instance$274)
           return (
             (resource.state.loading |= 4),
-            (resource.instance = instance$264),
-            markNodeAsHoistable(instance$264),
-            instance$264
+            (resource.instance = instance$274),
+            markNodeAsHoistable(instance$274),
+            instance$274
           );
         instance = stylesheetPropsFromRawProps(props);
         (styleProps = preloadPropsMap.get(styleProps)) &&
           adoptPreloadPropsForStylesheet(instance, styleProps);
-        instance$264 = (
+        instance$274 = (
           hoistableRoot.ownerDocument || hoistableRoot
         ).createElement("link");
-        markNodeAsHoistable(instance$264);
-        var linkInstance = instance$264;
+        markNodeAsHoistable(instance$274);
+        var linkInstance = instance$274;
         linkInstance._p = new Promise(function (resolve, reject) {
           linkInstance.onload = resolve;
           linkInstance.onerror = reject;
         });
-        setInitialProperties(instance$264, "link", instance);
+        setInitialProperties(instance$274, "link", instance);
         resource.state.loading |= 4;
-        insertStylesheet(instance$264, props.precedence, hoistableRoot);
-        return (resource.instance = instance$264);
+        insertStylesheet(instance$274, props.precedence, hoistableRoot);
+        return (resource.instance = instance$274);
       case "script":
-        instance$264 = getScriptKey(props.src);
+        instance$274 = getScriptKey(props.src);
         if (
           (styleProps = hoistableRoot.querySelector(
-            getScriptSelectorFromKey(instance$264)
+            getScriptSelectorFromKey(instance$274)
           ))
         )
           return (
@@ -14848,7 +16767,7 @@ function acquireResource(hoistableRoot, resource, props) {
             styleProps
           );
         instance = props;
-        if ((styleProps = preloadPropsMap.get(instance$264)))
+        if ((styleProps = preloadPropsMap.get(instance$274)))
           (instance = assign({}, props)),
             adoptPreloadPropsForScript(instance, styleProps);
         hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
@@ -15252,9 +17171,6 @@ function updateContainerImpl(
   parentComponent,
   callback
 ) {
-  null !== injectedProfilingHooks &&
-    "function" === typeof injectedProfilingHooks.markRenderScheduled &&
-    injectedProfilingHooks.markRenderScheduled(lane);
   parentComponent = getContextForSubtree(parentComponent);
   null === container.context
     ? (container.context = parentComponent)
@@ -15265,7 +17181,8 @@ function updateContainerImpl(
   null !== callback && (container.callback = callback);
   element = enqueueUpdate(rootFiber, container, lane);
   null !== element &&
-    (scheduleUpdateOnFiber(element, rootFiber, lane),
+    (startUpdateTimerByLane(lane),
+    scheduleUpdateOnFiber(element, rootFiber, lane),
     entangleTransitions(element, rootFiber, lane));
 }
 function markRetryLaneImpl(fiber, retryLane) {
@@ -15886,16 +17803,16 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
     0 === i && attemptExplicitHydrationTarget(target);
   }
 };
-var isomorphicReactPackageVersion$jscomp$inline_1835 = React.version;
+var isomorphicReactPackageVersion$jscomp$inline_1947 = React.version;
 if (
-  "19.1.0-canary-c492f975-20250128" !==
-  isomorphicReactPackageVersion$jscomp$inline_1835
+  "19.1.0-experimental-b3a95caf-20250113" !==
+  isomorphicReactPackageVersion$jscomp$inline_1947
 )
   throw Error(
     formatProdErrorMessage(
       527,
-      isomorphicReactPackageVersion$jscomp$inline_1835,
-      "19.1.0-canary-c492f975-20250128"
+      isomorphicReactPackageVersion$jscomp$inline_1947,
+      "19.1.0-experimental-b3a95caf-20250113"
     )
   );
 ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
@@ -15915,39 +17832,24 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
     null === componentOrElement ? null : componentOrElement.stateNode;
   return componentOrElement;
 };
-var internals$jscomp$inline_1842 = {
+var internals$jscomp$inline_2471 = {
   bundleType: 0,
-  version: "19.1.0-canary-c492f975-20250128",
+  version: "19.1.0-experimental-b3a95caf-20250113",
   rendererPackageName: "react-dom",
   currentDispatcherRef: ReactSharedInternals,
-  reconcilerVersion: "19.1.0-canary-c492f975-20250128",
-  getLaneLabelMap: function () {
-    for (
-      var map = new Map(), lane = 1, index$281 = 0;
-      31 > index$281;
-      index$281++
-    ) {
-      var label = getLabelForLane(lane);
-      map.set(lane, label);
-      lane *= 2;
-    }
-    return map;
-  },
-  injectProfilingHooks: function (profilingHooks) {
-    injectedProfilingHooks = profilingHooks;
-  }
+  reconcilerVersion: "19.1.0-experimental-b3a95caf-20250113"
 };
 if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
-  var hook$jscomp$inline_2280 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+  var hook$jscomp$inline_2472 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
   if (
-    !hook$jscomp$inline_2280.isDisabled &&
-    hook$jscomp$inline_2280.supportsFiber
+    !hook$jscomp$inline_2472.isDisabled &&
+    hook$jscomp$inline_2472.supportsFiber
   )
     try {
-      (rendererID = hook$jscomp$inline_2280.inject(
-        internals$jscomp$inline_1842
+      (rendererID = hook$jscomp$inline_2472.inject(
+        internals$jscomp$inline_2471
       )),
-        (injectedHook = hook$jscomp$inline_2280);
+        (injectedHook = hook$jscomp$inline_2472);
     } catch (err) {}
 }
 function noop() {}
@@ -16202,7 +18104,7 @@ exports.useFormState = function (action, initialState, permalink) {
 exports.useFormStatus = function () {
   return ReactSharedInternals.H.useHostTransitionStatus();
 };
-exports.version = "19.1.0-canary-c492f975-20250128";
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
 "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
   "function" ===
     typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
diff --git a/node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js b/node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
index e365d99..221485b 100644
--- a/node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
+++ b/node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
@@ -81,6 +81,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (type.$$typeof) {
@@ -738,10 +740,12 @@
       bootstrapScripts,
       bootstrapModules
     ) {
+      var streamingFormat = ScriptStreamingFormat;
+      void 0 !== externalRuntimeConfig && (streamingFormat = 1);
       return {
         idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
         nextFormID: 0,
-        streamingFormat: 0,
+        streamingFormat: streamingFormat,
         bootstrapScriptContent: bootstrapScriptContent,
         bootstrapScripts: bootstrapScripts,
         bootstrapModules: bootstrapModules,
@@ -758,9 +762,6 @@
         moduleScriptResources: {}
       };
     }
-    function createPreambleState() {
-      return { htmlChunks: null, headChunks: null, bodyChunks: null };
-    }
     function createFormatContext(insertionMode, selectedValue, tagScope) {
       return {
         insertionMode: insertionMode,
@@ -820,26 +821,16 @@
             null,
             parentContext.tagScope
           );
-        case "head":
-          if (parentContext.insertionMode < HTML_MODE)
-            return createFormatContext(
-              HTML_HEAD_MODE,
-              null,
-              parentContext.tagScope
-            );
-          break;
-        case "html":
-          if (parentContext.insertionMode === ROOT_HTML_MODE)
-            return createFormatContext(
-              HTML_HTML_MODE,
-              null,
-              parentContext.tagScope
-            );
       }
-      return parentContext.insertionMode >= HTML_TABLE_MODE ||
-        parentContext.insertionMode < HTML_MODE
+      return parentContext.insertionMode >= HTML_TABLE_MODE
         ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
-        : parentContext;
+        : parentContext.insertionMode === ROOT_HTML_MODE
+          ? "html" === type
+            ? createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope)
+            : createFormatContext(HTML_MODE, null, parentContext.tagScope)
+          : parentContext.insertionMode === HTML_HTML_MODE
+            ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
+            : parentContext;
     }
     function pushStyleAttribute(target, style) {
       if ("object" !== typeof style)
@@ -1342,7 +1333,8 @@
       return content;
     }
     function injectFormReplayingRuntime(resumableState, renderState) {
-      (resumableState.instructions & 16) === NothingSent &&
+      (resumableState.instructions & 16) !== NothingSent ||
+        renderState.externalRuntimeScript ||
         ((resumableState.instructions |= 16),
         renderState.bootstrapChunks.unshift(
           renderState.startInlineScript,
@@ -1507,7 +1499,6 @@
       props,
       resumableState,
       renderState,
-      preambleState,
       hoistableState,
       formatContext,
       textEmbedded,
@@ -2662,13 +2653,13 @@
         case "missing-glyph":
           break;
         case "head":
-          if (formatContext.insertionMode < HTML_MODE) {
-            var preamble = preambleState || renderState.preamble;
-            if (preamble.headChunks)
-              throw Error("The `<head>` tag may only be rendered once.");
-            preamble.headChunks = [];
+          if (
+            formatContext.insertionMode < HTML_MODE &&
+            null === renderState.headChunks
+          ) {
+            renderState.headChunks = [];
             var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-              preamble.headChunks,
+              renderState.headChunks,
               props,
               "head"
             );
@@ -2679,42 +2670,24 @@
               "head"
             );
           return JSCompiler_inline_result$jscomp$9;
-        case "body":
-          if (formatContext.insertionMode < HTML_MODE) {
-            var preamble$jscomp$0 = preambleState || renderState.preamble;
-            if (preamble$jscomp$0.bodyChunks)
-              throw Error("The `<body>` tag may only be rendered once.");
-            preamble$jscomp$0.bodyChunks = [];
-            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-              preamble$jscomp$0.bodyChunks,
-              props,
-              "body"
-            );
-          } else
-            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-              target$jscomp$0,
-              props,
-              "body"
-            );
-          return JSCompiler_inline_result$jscomp$10;
         case "html":
-          if (formatContext.insertionMode === ROOT_HTML_MODE) {
-            var preamble$jscomp$1 = preambleState || renderState.preamble;
-            if (preamble$jscomp$1.htmlChunks)
-              throw Error("The `<html>` tag may only be rendered once.");
-            preamble$jscomp$1.htmlChunks = [doctypeChunk];
-            var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-              preamble$jscomp$1.htmlChunks,
+          if (
+            formatContext.insertionMode === ROOT_HTML_MODE &&
+            null === renderState.htmlChunks
+          ) {
+            renderState.htmlChunks = [doctypeChunk];
+            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+              renderState.htmlChunks,
               props,
               "html"
             );
           } else
-            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
               target$jscomp$0,
               props,
               "html"
             );
-          return JSCompiler_inline_result$jscomp$11;
+          return JSCompiler_inline_result$jscomp$10;
         default:
           if (-1 !== type.indexOf("-")) {
             target$jscomp$0.push(startChunkForTag(type));
@@ -2781,15 +2754,6 @@
         ((chunk = "</" + tag + ">"), endTagCache.set(tag, chunk));
       return chunk;
     }
-    function hoistPreambleState(renderState, preambleState) {
-      renderState = renderState.preamble;
-      null === renderState.htmlChunks &&
-        (renderState.htmlChunks = preambleState.htmlChunks);
-      null === renderState.headChunks &&
-        (renderState.headChunks = preambleState.headChunks);
-      null === renderState.bodyChunks &&
-        (renderState.bodyChunks = preambleState.bodyChunks);
-    }
     function writeBootstrap(destination, renderState) {
       renderState = renderState.bootstrapChunks;
       for (var i = 0; i < renderState.length - 1; i++)
@@ -2813,7 +2777,6 @@
       switch (formatContext.insertionMode) {
         case ROOT_HTML_MODE:
         case HTML_HTML_MODE:
-        case HTML_HEAD_MODE:
         case HTML_MODE:
           return (
             destination.push(startSegmentHTML),
@@ -2878,7 +2841,6 @@
       switch (formatContext.insertionMode) {
         case ROOT_HTML_MODE:
         case HTML_HTML_MODE:
-        case HTML_HEAD_MODE:
         case HTML_MODE:
           return destination.push(endSegmentHTML);
         case SVG_MODE:
@@ -3149,6 +3111,109 @@
       attributeName = escapeJSObjectForInstructionScripts(name);
       destination.push(attributeName);
     }
+    function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+      destination.push(arrayFirstOpenBracket);
+      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
+      hoistableState.stylesheets.forEach(function (resource) {
+        if (resource.state !== PREAMBLE)
+          if (resource.state === LATE)
+            destination.push(nextArrayOpenBrackChunk),
+              (resource = resource.props.href),
+              checkAttributeStringCoercion(resource, "href"),
+              (resource = escapeTextForBrowser(JSON.stringify("" + resource))),
+              destination.push(resource),
+              destination.push(arrayCloseBracket),
+              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);
+          else {
+            destination.push(nextArrayOpenBrackChunk);
+            var precedence = resource.props["data-precedence"],
+              props = resource.props,
+              coercedHref = sanitizeURL("" + resource.props.href);
+            coercedHref = escapeTextForBrowser(JSON.stringify(coercedHref));
+            destination.push(coercedHref);
+            checkAttributeStringCoercion(precedence, "precedence");
+            precedence = "" + precedence;
+            destination.push(arrayInterstitial);
+            precedence = escapeTextForBrowser(JSON.stringify(precedence));
+            destination.push(precedence);
+            for (var propKey in props)
+              if (
+                hasOwnProperty.call(props, propKey) &&
+                ((precedence = props[propKey]), null != precedence)
+              )
+                switch (propKey) {
+                  case "href":
+                  case "rel":
+                  case "precedence":
+                  case "data-precedence":
+                    break;
+                  case "children":
+                  case "dangerouslySetInnerHTML":
+                    throw Error(
+                      "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                    );
+                  default:
+                    writeStyleResourceAttributeInAttr(
+                      destination,
+                      propKey,
+                      precedence
+                    );
+                }
+            destination.push(arrayCloseBracket);
+            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
+            resource.state = LATE;
+          }
+      });
+      destination.push(arrayCloseBracket);
+    }
+    function writeStyleResourceAttributeInAttr(destination, name, value) {
+      var attributeName = name.toLowerCase();
+      switch (typeof value) {
+        case "function":
+        case "symbol":
+          return;
+      }
+      switch (name) {
+        case "innerHTML":
+        case "dangerouslySetInnerHTML":
+        case "suppressContentEditableWarning":
+        case "suppressHydrationWarning":
+        case "style":
+        case "ref":
+          return;
+        case "className":
+          attributeName = "class";
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+          break;
+        case "hidden":
+          if (!1 === value) return;
+          name = "";
+          break;
+        case "src":
+        case "href":
+          value = sanitizeURL(value);
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+          break;
+        default:
+          if (
+            (2 < name.length &&
+              ("o" === name[0] || "O" === name[0]) &&
+              ("n" === name[1] || "N" === name[1])) ||
+            !isAttributeNameSafe(name)
+          )
+            return;
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+      }
+      destination.push(arrayInterstitial);
+      attributeName = escapeTextForBrowser(JSON.stringify(attributeName));
+      destination.push(attributeName);
+      destination.push(arrayInterstitial);
+      attributeName = escapeTextForBrowser(JSON.stringify(name));
+      destination.push(attributeName);
+    }
     function createHoistableState() {
       return { styles: new Set(), stylesheets: new Set() };
     }
@@ -3272,7 +3337,8 @@
         segmentPrefix: idPrefix + "S:",
         boundaryPrefix: idPrefix + "B:",
         startInlineScript: "<script>",
-        preamble: createPreambleState(),
+        htmlChunks: null,
+        headChunks: null,
         externalRuntimeScript: null,
         bootstrapChunks: bootstrapChunks,
         importMapChunks: [],
@@ -3402,7 +3468,8 @@
         segmentPrefix: idPrefix.segmentPrefix,
         boundaryPrefix: idPrefix.boundaryPrefix,
         startInlineScript: idPrefix.startInlineScript,
-        preamble: idPrefix.preamble,
+        htmlChunks: idPrefix.htmlChunks,
+        headChunks: idPrefix.headChunks,
         externalRuntimeScript: idPrefix.externalRuntimeScript,
         bootstrapChunks: idPrefix.bootstrapChunks,
         importMapChunks: idPrefix.importMapChunks,
@@ -3463,6 +3530,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (
@@ -3839,6 +3908,11 @@
           queue.next = componentIdentity;
         }
     }
+    function throwOnUseEffectEventCall() {
+      throw Error(
+        "A function wrapped in useEffectEvent can't be called during rendering."
+      );
+    }
     function unsupportedStartTransition() {
       throw Error("startTransition cannot be called during server rendering.");
     }
@@ -3919,8 +3993,15 @@
       null === thenableState && (thenableState = []);
       return trackUsedThenable(thenableState, thenable, index);
     }
-    function unsupportedRefresh() {
-      throw Error("Cache cannot be refreshed during server rendering.");
+    function readPreviousThenableFromState() {
+      var index = thenableIndexCounter;
+      thenableIndexCounter += 1;
+      if (null !== thenableState)
+        return (
+          (index = thenableState[index]),
+          (index = void 0 === index ? void 0 : index.value),
+          index
+        );
     }
     function noop$1() {}
     function disabledLog() {}
@@ -4142,6 +4223,27 @@
       "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
       return sampleLines;
     }
+    function formatOwnerStack(error) {
+      var prevPrepareStackTrace = Error.prepareStackTrace;
+      Error.prepareStackTrace = void 0;
+      error = error.stack;
+      Error.prepareStackTrace = prevPrepareStackTrace;
+      error.startsWith("Error: react-stack-top-frame\n") &&
+        (error = error.slice(29));
+      prevPrepareStackTrace = error.indexOf("\n");
+      -1 !== prevPrepareStackTrace &&
+        (error = error.slice(prevPrepareStackTrace + 1));
+      prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
+      -1 !== prevPrepareStackTrace &&
+        (prevPrepareStackTrace = error.lastIndexOf(
+          "\n",
+          prevPrepareStackTrace
+        ));
+      if (-1 !== prevPrepareStackTrace)
+        error = error.slice(0, prevPrepareStackTrace);
+      else return "";
+      return error;
+    }
     function describeComponentStackByType(type) {
       if ("string" === typeof type) return describeBuiltInComponentFrame(type);
       if ("function" === typeof type)
@@ -4178,21 +4280,11 @@
           return describeBuiltInComponentFrame("SuspenseList");
         case REACT_SUSPENSE_TYPE:
           return describeBuiltInComponentFrame("Suspense");
+        case REACT_VIEW_TRANSITION_TYPE:
+          return describeBuiltInComponentFrame("ViewTransition");
       }
       return "";
     }
-    function getStackByComponentStackNode(componentStack) {
-      try {
-        var info = "";
-        do
-          (info += describeComponentStackByType(componentStack.type)),
-            (componentStack = componentStack.parent);
-        while (componentStack);
-        return info;
-      } catch (x) {
-        return "\nError generating stack: " + x.message + "\n" + x.stack;
-      }
-    }
     function defaultErrorHandler(error) {
       if (
         "object" === typeof error &&
@@ -4240,7 +4332,7 @@
       this.status = 10;
       this.fatalError = null;
       this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-      this.completedPreambleSegments = this.completedRootSegment = null;
+      this.completedRootSegment = null;
       this.abortableTasks = abortSet;
       this.pingedTasks = [];
       this.clientRenderedBoundaries = [];
@@ -4300,14 +4392,15 @@
         null,
         renderState,
         null,
-        null,
         resumableState.abortableTasks,
         null,
         rootFormatContext,
         null,
         emptyTreeContext,
         null,
-        !1
+        !1,
+        emptyContextObject,
+        null
       );
       pushComponentStack(children);
       resumableState.pingedTasks.push(children);
@@ -4319,12 +4412,7 @@
         ((request.flushScheduled = null !== request.destination),
         performWork(request));
     }
-    function createSuspenseBoundary(
-      request,
-      fallbackAbortableTasks,
-      contentPreamble,
-      fallbackPreamble
-    ) {
+    function createSuspenseBoundary(request, fallbackAbortableTasks) {
       return {
         status: PENDING,
         rootSegmentID: -1,
@@ -4336,8 +4424,6 @@
         errorDigest: null,
         contentState: createHoistableState(),
         fallbackState: createHoistableState(),
-        contentPreamble: contentPreamble,
-        fallbackPreamble: fallbackPreamble,
         trackedContentKeyPath: null,
         trackedFallbackNode: null,
         errorMessage: null,
@@ -4352,7 +4438,6 @@
       childIndex,
       blockedBoundary,
       blockedSegment,
-      blockedPreamble,
       hoistableState,
       abortSet,
       keyPath,
@@ -4360,7 +4445,9 @@
       context,
       treeContext,
       componentStack,
-      isFallback
+      isFallback,
+      legacyContext,
+      debugTask
     ) {
       request.allPendingTasks++;
       null === blockedBoundary
@@ -4375,7 +4462,6 @@
         },
         blockedBoundary: blockedBoundary,
         blockedSegment: blockedSegment,
-        blockedPreamble: blockedPreamble,
         hoistableState: hoistableState,
         abortSet: abortSet,
         keyPath: keyPath,
@@ -4386,6 +4472,7 @@
         thenableState: thenableState,
         isFallback: isFallback
       };
+      task.debugTask = debugTask;
       abortSet.add(task);
       return task;
     }
@@ -4403,7 +4490,9 @@
       context,
       treeContext,
       componentStack,
-      isFallback
+      isFallback,
+      legacyContext,
+      debugTask
     ) {
       request.allPendingTasks++;
       null === blockedBoundary
@@ -4419,7 +4508,6 @@
         },
         blockedBoundary: blockedBoundary,
         blockedSegment: null,
-        blockedPreamble: null,
         hoistableState: hoistableState,
         abortSet: abortSet,
         keyPath: keyPath,
@@ -4430,6 +4518,7 @@
         thenableState: thenableState,
         isFallback: isFallback
       };
+      task.debugTask = debugTask;
       abortSet.add(task);
       return task;
     }
@@ -4443,12 +4532,11 @@
     ) {
       return {
         status: PENDING,
-        parentFlushed: !1,
         id: -1,
         index: index,
+        parentFlushed: !1,
         chunks: [],
         children: [],
-        preambleChildren: [],
         parentFormatContext: parentFormatContext,
         boundary: boundary,
         lastPushedText: lastPushedText,
@@ -4456,22 +4544,63 @@
       };
     }
     function getCurrentStackInDEV() {
-      return null === currentTaskInDEV ||
-        null === currentTaskInDEV.componentStack
-        ? ""
-        : getStackByComponentStackNode(currentTaskInDEV.componentStack);
+      if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
+        return "";
+      var componentStack = currentTaskInDEV.componentStack;
+      try {
+        var info = "";
+        if ("string" === typeof componentStack.type)
+          info += describeBuiltInComponentFrame(componentStack.type);
+        else if ("function" === typeof componentStack.type) {
+          if (!componentStack.owner) {
+            var JSCompiler_temp_const = info,
+              fn = componentStack.type,
+              name = fn ? fn.displayName || fn.name : "";
+            var JSCompiler_inline_result = name
+              ? describeBuiltInComponentFrame(name)
+              : "";
+            info = JSCompiler_temp_const + JSCompiler_inline_result;
+          }
+        } else
+          componentStack.owner ||
+            (info += describeComponentStackByType(componentStack.type));
+        for (; componentStack; )
+          (JSCompiler_temp_const = null),
+            null != componentStack.debugStack
+              ? (JSCompiler_temp_const = formatOwnerStack(
+                  componentStack.debugStack
+                ))
+              : ((JSCompiler_inline_result = componentStack),
+                null != JSCompiler_inline_result.stack &&
+                  (JSCompiler_temp_const =
+                    "string" !== typeof JSCompiler_inline_result.stack
+                      ? (JSCompiler_inline_result.stack = formatOwnerStack(
+                          JSCompiler_inline_result.stack
+                        ))
+                      : JSCompiler_inline_result.stack)),
+            (componentStack = componentStack.owner) &&
+              JSCompiler_temp_const &&
+              (info += "\n" + JSCompiler_temp_const);
+        var JSCompiler_inline_result$jscomp$0 = info;
+      } catch (x) {
+        JSCompiler_inline_result$jscomp$0 =
+          "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+      return JSCompiler_inline_result$jscomp$0;
     }
     function pushServerComponentStack(task, debugInfo) {
       if (null != debugInfo)
         for (var i = 0; i < debugInfo.length; i++) {
           var componentInfo = debugInfo[i];
           "string" === typeof componentInfo.name &&
-            (task.componentStack = {
+            void 0 !== componentInfo.debugStack &&
+            ((task.componentStack = {
               parent: task.componentStack,
               type: componentInfo,
               owner: componentInfo.owner,
-              stack: null
-            });
+              stack: componentInfo.debugStack
+            }),
+            (task.debugTask = componentInfo.debugTask));
         }
     }
     function pushComponentStack(task) {
@@ -4480,13 +4609,15 @@
         switch (node.$$typeof) {
           case REACT_ELEMENT_TYPE:
             var type = node.type,
-              owner = node._owner;
+              owner = node._owner,
+              stack = node._debugStack;
             pushServerComponentStack(task, node._debugInfo);
+            task.debugTask = node._debugTask;
             task.componentStack = {
               parent: task.componentStack,
               type: type,
               owner: owner,
-              stack: null
+              stack: stack
             };
             break;
           case REACT_LAZY_TYPE:
@@ -4497,14 +4628,24 @@
               pushServerComponentStack(task, node._debugInfo);
         }
     }
-    function getThrownInfo(node) {
+    function getThrownInfo(node$jscomp$0) {
       var errorInfo = {};
-      node &&
+      node$jscomp$0 &&
         Object.defineProperty(errorInfo, "componentStack", {
           configurable: !0,
           enumerable: !0,
           get: function () {
-            var stack = getStackByComponentStackNode(node);
+            try {
+              var info = "",
+                node = node$jscomp$0;
+              do
+                (info += describeComponentStackByType(node.type)),
+                  (node = node.parent);
+              while (node);
+              var stack = info;
+            } catch (x) {
+              stack = "\nError generating stack: " + x.message + "\n" + x.stack;
+            }
             Object.defineProperty(errorInfo, "componentStack", {
               value: stack
             });
@@ -4535,9 +4676,17 @@
       boundary.errorStack = null !== error ? wasAborted + error : null;
       boundary.errorComponentStack = thrownInfo.componentStack;
     }
-    function logRecoverableError(request, error, errorInfo) {
+    function logPostpone(request, reason, postponeInfo, debugTask) {
+      request = request.onPostpone;
+      debugTask
+        ? debugTask.run(request.bind(null, reason, postponeInfo))
+        : request(reason, postponeInfo);
+    }
+    function logRecoverableError(request, error, errorInfo, debugTask) {
       request = request.onError;
-      error = request(error, errorInfo);
+      error = debugTask
+        ? debugTask.run(request.bind(null, error, errorInfo))
+        : request(error, errorInfo);
       if (null != error && "string" !== typeof error)
         console.error(
           'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
@@ -4545,11 +4694,13 @@
         );
       else return error;
     }
-    function fatalError(request, error) {
-      var onShellError = request.onShellError,
-        onFatalError = request.onFatalError;
-      onShellError(error);
-      onFatalError(error);
+    function fatalError(request, error, errorInfo, debugTask) {
+      errorInfo = request.onShellError;
+      var onFatalError = request.onFatalError;
+      debugTask
+        ? (debugTask.run(errorInfo.bind(null, error)),
+          debugTask.run(onFatalError.bind(null, error)))
+        : (errorInfo(error), onFatalError(error));
       null !== request.destination
         ? ((request.status = CLOSED), request.destination.destroy(error))
         : ((request.status = 13), (request.fatalError = error));
@@ -5088,7 +5239,6 @@
             props,
             request.resumableState,
             request.renderState,
-            task.blockedPreamble,
             task.hoistableState,
             task.formatContext,
             segment.lastPushedText,
@@ -5097,43 +5247,9 @@
           segment.lastPushedText = !1;
           var _prevContext = task.formatContext,
             _prevKeyPath2 = task.keyPath;
+          task.formatContext = getChildFormatContext(_prevContext, type, props);
           task.keyPath = keyPath;
-          if (
-            (task.formatContext = getChildFormatContext(
-              _prevContext,
-              type,
-              props
-            )).insertionMode === HTML_HEAD_MODE
-          ) {
-            var preambleSegment = createPendingSegment(
-              request,
-              0,
-              null,
-              task.formatContext,
-              !1,
-              !1
-            );
-            segment.preambleChildren.push(preambleSegment);
-            var preambleTask = createRenderTask(
-              request,
-              null,
-              _children,
-              -1,
-              task.blockedBoundary,
-              preambleSegment,
-              task.blockedPreamble,
-              task.hoistableState,
-              request.abortableTasks,
-              task.keyPath,
-              task.formatContext,
-              task.context,
-              task.treeContext,
-              task.componentStack,
-              task.isFallback
-            );
-            pushComponentStack(preambleTask);
-            request.pingedTasks.push(preambleTask);
-          } else renderNode(request, task, _children, -1);
+          renderNode(request, task, _children, -1);
           task.formatContext = _prevContext;
           task.keyPath = _prevKeyPath2;
           a: {
@@ -5170,9 +5286,6 @@
                   resumableState.hasHtml = !0;
                   break a;
                 }
-                break;
-              case "head":
-                if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;
             }
             target.push(endChunkForTag(type));
           }
@@ -5204,6 +5317,11 @@
             task.keyPath = _prevKeyPath3;
             return;
           case REACT_VIEW_TRANSITION_TYPE:
+            var _prevKeyPath4 = task.keyPath;
+            task.keyPath = keyPath;
+            renderNodeDestructive(request, task, props.children, -1);
+            task.keyPath = _prevKeyPath4;
+            return;
           case REACT_SCOPE_TYPE:
             throw Error(
               "ReactDOMServer does not yet support scope components."
@@ -5221,26 +5339,12 @@
             } else {
               var prevKeyPath$jscomp$3 = task.keyPath,
                 parentBoundary = task.blockedBoundary,
-                parentPreamble = task.blockedPreamble,
                 parentHoistableState = task.hoistableState,
                 parentSegment = task.blockedSegment,
                 fallback = props.fallback,
                 content = props.children,
-                fallbackAbortSet = new Set();
-              var newBoundary =
-                task.formatContext.insertionMode < HTML_MODE
-                  ? createSuspenseBoundary(
-                      request,
-                      fallbackAbortSet,
-                      createPreambleState(),
-                      createPreambleState()
-                    )
-                  : createSuspenseBoundary(
-                      request,
-                      fallbackAbortSet,
-                      null,
-                      null
-                    );
+                fallbackAbortSet = new Set(),
+                newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
               null !== request.trackedPostpones &&
                 (newBoundary.trackedContentKeyPath = keyPath);
               var boundarySegment = createPendingSegment(
@@ -5280,7 +5384,6 @@
                 );
                 newBoundary.trackedFallbackNode = fallbackReplayNode;
                 task.blockedSegment = boundarySegment;
-                task.blockedPreamble = newBoundary.fallbackPreamble;
                 task.keyPath = fallbackKeyPath;
                 boundarySegment.status = 6;
                 try {
@@ -5299,7 +5402,6 @@
                   );
                 } finally {
                   (task.blockedSegment = parentSegment),
-                    (task.blockedPreamble = parentPreamble),
                     (task.keyPath = prevKeyPath$jscomp$3);
                 }
                 var suspendedPrimaryTask = createRenderTask(
@@ -5309,7 +5411,6 @@
                   -1,
                   newBoundary,
                   contentRootSegment,
-                  newBoundary.contentPreamble,
                   newBoundary.contentState,
                   task.abortSet,
                   keyPath,
@@ -5317,13 +5418,14 @@
                   task.context,
                   task.treeContext,
                   task.componentStack,
-                  task.isFallback
+                  task.isFallback,
+                  emptyContextObject,
+                  task.debugTask
                 );
                 pushComponentStack(suspendedPrimaryTask);
                 request.pingedTasks.push(suspendedPrimaryTask);
               } else {
                 task.blockedBoundary = newBoundary;
-                task.blockedPreamble = newBoundary.contentPreamble;
                 task.hoistableState = newBoundary.contentState;
                 task.blockedSegment = contentRootSegment;
                 task.keyPath = keyPath;
@@ -5343,9 +5445,6 @@
                       newBoundary.status === PENDING)
                   ) {
                     newBoundary.status = COMPLETED;
-                    0 === request.pendingRootTasks &&
-                      task.blockedPreamble &&
-                      preparePreamble(request);
                     break a;
                   }
                 } catch (thrownValue$2) {
@@ -5356,11 +5455,25 @@
                   } else
                     (contentRootSegment.status = 4), (error = thrownValue$2);
                   var thrownInfo = getThrownInfo(task.componentStack);
-                  var errorDigest = logRecoverableError(
-                    request,
-                    error,
-                    thrownInfo
-                  );
+                  if (
+                    "object" === typeof error &&
+                    null !== error &&
+                    error.$$typeof === REACT_POSTPONE_TYPE
+                  ) {
+                    logPostpone(
+                      request,
+                      error.message,
+                      thrownInfo,
+                      task.debugTask
+                    );
+                    var errorDigest = "POSTPONE";
+                  } else
+                    errorDigest = logRecoverableError(
+                      request,
+                      error,
+                      thrownInfo,
+                      task.debugTask
+                    );
                   encodeErrorForBoundary(
                     newBoundary,
                     errorDigest,
@@ -5371,7 +5484,6 @@
                   untrackBoundary(request, newBoundary);
                 } finally {
                   (task.blockedBoundary = parentBoundary),
-                    (task.blockedPreamble = parentPreamble),
                     (task.hoistableState = parentHoistableState),
                     (task.blockedSegment = parentSegment),
                     (task.keyPath = prevKeyPath$jscomp$3);
@@ -5383,7 +5495,6 @@
                   -1,
                   parentBoundary,
                   boundarySegment,
-                  newBoundary.fallbackPreamble,
                   newBoundary.fallbackState,
                   fallbackAbortSet,
                   [keyPath[0], "Suspense Fallback", keyPath[2]],
@@ -5391,7 +5502,9 @@
                   task.context,
                   task.treeContext,
                   task.componentStack,
-                  !0
+                  !0,
+                  emptyContextObject,
+                  task.debugTask
                 );
                 pushComponentStack(suspendedFallbackTask);
                 request.pingedTasks.push(suspendedFallbackTask);
@@ -5543,15 +5656,186 @@
         (task.replay = prevReplay), (task.blockedSegment = null);
       }
     }
+    function replayElement(
+      request,
+      task,
+      keyPath,
+      name,
+      keyOrIndex,
+      childIndex,
+      type,
+      props,
+      ref,
+      replay
+    ) {
+      childIndex = replay.nodes;
+      for (var i = 0; i < childIndex.length; i++) {
+        var node = childIndex[i];
+        if (keyOrIndex === node[1]) {
+          if (4 === node.length) {
+            if (null !== name && name !== node[0])
+              throw Error(
+                "Expected the resume to render <" +
+                  node[0] +
+                  "> in this slot but instead it rendered <" +
+                  name +
+                  ">. The tree doesn't match so React will fallback to client rendering."
+              );
+            var childNodes = node[2];
+            node = node[3];
+            name = task.node;
+            task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
+            try {
+              renderElement(request, task, keyPath, type, props, ref);
+              if (
+                1 === task.replay.pendingTasks &&
+                0 < task.replay.nodes.length
+              )
+                throw Error(
+                  "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+                );
+              task.replay.pendingTasks--;
+            } catch (x) {
+              if (
+                "object" === typeof x &&
+                null !== x &&
+                (x === SuspenseException || "function" === typeof x.then)
+              )
+                throw (task.node === name && (task.replay = replay), x);
+              task.replay.pendingTasks--;
+              props = getThrownInfo(task.componentStack);
+              erroredReplay(
+                request,
+                task.blockedBoundary,
+                x,
+                props,
+                childNodes,
+                node,
+                task.debugTask
+              );
+            }
+            task.replay = replay;
+          } else {
+            if (type !== REACT_SUSPENSE_TYPE)
+              throw Error(
+                "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
+                  (getComponentNameFromType(type) || "Unknown") +
+                  ">. The tree doesn't match so React will fallback to client rendering."
+              );
+            a: {
+              replay = void 0;
+              type = node[5];
+              ref = node[2];
+              name = node[3];
+              keyOrIndex = null === node[4] ? [] : node[4][2];
+              node = null === node[4] ? null : node[4][3];
+              var prevKeyPath = task.keyPath,
+                previousReplaySet = task.replay,
+                parentBoundary = task.blockedBoundary,
+                parentHoistableState = task.hoistableState,
+                content = props.children;
+              props = props.fallback;
+              var fallbackAbortSet = new Set(),
+                resumedBoundary = createSuspenseBoundary(
+                  request,
+                  fallbackAbortSet
+                );
+              resumedBoundary.parentFlushed = !0;
+              resumedBoundary.rootSegmentID = type;
+              task.blockedBoundary = resumedBoundary;
+              task.hoistableState = resumedBoundary.contentState;
+              task.keyPath = keyPath;
+              task.replay = { nodes: ref, slots: name, pendingTasks: 1 };
+              try {
+                renderNode(request, task, content, -1);
+                if (
+                  1 === task.replay.pendingTasks &&
+                  0 < task.replay.nodes.length
+                )
+                  throw Error(
+                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+                  );
+                task.replay.pendingTasks--;
+                if (
+                  0 === resumedBoundary.pendingTasks &&
+                  resumedBoundary.status === PENDING
+                ) {
+                  resumedBoundary.status = COMPLETED;
+                  request.completedBoundaries.push(resumedBoundary);
+                  break a;
+                }
+              } catch (error) {
+                (resumedBoundary.status = CLIENT_RENDERED),
+                  (childNodes = getThrownInfo(task.componentStack)),
+                  "object" === typeof error &&
+                  null !== error &&
+                  error.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        error.message,
+                        childNodes,
+                        task.debugTask
+                      ),
+                      (replay = "POSTPONE"))
+                    : (replay = logRecoverableError(
+                        request,
+                        error,
+                        childNodes,
+                        task.debugTask
+                      )),
+                  encodeErrorForBoundary(
+                    resumedBoundary,
+                    replay,
+                    error,
+                    childNodes,
+                    !1
+                  ),
+                  task.replay.pendingTasks--,
+                  request.clientRenderedBoundaries.push(resumedBoundary);
+              } finally {
+                (task.blockedBoundary = parentBoundary),
+                  (task.hoistableState = parentHoistableState),
+                  (task.replay = previousReplaySet),
+                  (task.keyPath = prevKeyPath);
+              }
+              props = createReplayTask(
+                request,
+                null,
+                { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
+                props,
+                -1,
+                parentBoundary,
+                resumedBoundary.fallbackState,
+                fallbackAbortSet,
+                [keyPath[0], "Suspense Fallback", keyPath[2]],
+                task.formatContext,
+                task.context,
+                task.treeContext,
+                task.componentStack,
+                !0,
+                emptyContextObject,
+                task.debugTask
+              );
+              pushComponentStack(props);
+              request.pingedTasks.push(props);
+            }
+          }
+          childIndex.splice(i, 1);
+          break;
+        }
+      }
+    }
     function renderNodeDestructive(request, task, node, childIndex) {
       null !== task.replay && "number" === typeof task.replay.slots
         ? resumeNode(request, task, task.replay.slots, node, childIndex)
         : ((task.node = node),
           (task.childIndex = childIndex),
           (node = task.componentStack),
+          (childIndex = task.debugTask),
           pushComponentStack(task),
           retryNode(request, task),
-          (task.componentStack = node));
+          (task.componentStack = node),
+          (task.debugTask = childIndex));
     }
     function retryNode(request, task) {
       var node = task.node,
@@ -5561,178 +5845,56 @@
           switch (node.$$typeof) {
             case REACT_ELEMENT_TYPE:
               var type = node.type,
-                key = node.key,
-                props = node.props;
-              node = props.ref;
-              var ref = void 0 !== node ? node : null,
-                name = getComponentNameFromType(type),
-                keyOrIndex =
-                  null == key ? (-1 === childIndex ? 0 : childIndex) : key,
-                keyPath = [task.keyPath, name, keyOrIndex];
-              if (null !== task.replay) {
-                var replay = task.replay;
-                childIndex = replay.nodes;
-                for (node = 0; node < childIndex.length; node++)
-                  if (((key = childIndex[node]), keyOrIndex === key[1])) {
-                    if (4 === key.length) {
-                      if (null !== name && name !== key[0])
-                        throw Error(
-                          "Expected the resume to render <" +
-                            key[0] +
-                            "> in this slot but instead it rendered <" +
-                            name +
-                            ">. The tree doesn't match so React will fallback to client rendering."
-                        );
-                      var childNodes = key[2];
-                      key = key[3];
-                      name = task.node;
-                      task.replay = {
-                        nodes: childNodes,
-                        slots: key,
-                        pendingTasks: 1
-                      };
-                      try {
-                        renderElement(request, task, keyPath, type, props, ref);
-                        if (
-                          1 === task.replay.pendingTasks &&
-                          0 < task.replay.nodes.length
-                        )
-                          throw Error(
-                            "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                          );
-                        task.replay.pendingTasks--;
-                      } catch (x) {
-                        if (
-                          "object" === typeof x &&
-                          null !== x &&
-                          (x === SuspenseException ||
-                            "function" === typeof x.then)
-                        )
-                          throw (
-                            (task.node === name && (task.replay = replay), x)
-                          );
-                        task.replay.pendingTasks--;
-                        props = getThrownInfo(task.componentStack);
-                        erroredReplay(
-                          request,
-                          task.blockedBoundary,
-                          x,
-                          props,
-                          childNodes,
-                          key
-                        );
-                      }
-                      task.replay = replay;
-                    } else {
-                      if (type !== REACT_SUSPENSE_TYPE)
-                        throw Error(
-                          "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
-                            (getComponentNameFromType(type) || "Unknown") +
-                            ">. The tree doesn't match so React will fallback to client rendering."
-                        );
-                      a: {
-                        type = void 0;
-                        ref = key[5];
-                        replay = key[2];
-                        name = key[3];
-                        keyOrIndex = null === key[4] ? [] : key[4][2];
-                        key = null === key[4] ? null : key[4][3];
-                        var prevKeyPath = task.keyPath,
-                          previousReplaySet = task.replay,
-                          parentBoundary = task.blockedBoundary,
-                          parentHoistableState = task.hoistableState,
-                          content = props.children,
-                          fallback = props.fallback,
-                          fallbackAbortSet = new Set();
-                        props =
-                          task.formatContext.insertionMode < HTML_MODE
-                            ? createSuspenseBoundary(
-                                request,
-                                fallbackAbortSet,
-                                createPreambleState(),
-                                createPreambleState()
-                              )
-                            : createSuspenseBoundary(
-                                request,
-                                fallbackAbortSet,
-                                null,
-                                null
-                              );
-                        props.parentFlushed = !0;
-                        props.rootSegmentID = ref;
-                        task.blockedBoundary = props;
-                        task.hoistableState = props.contentState;
-                        task.keyPath = keyPath;
-                        task.replay = {
-                          nodes: replay,
-                          slots: name,
-                          pendingTasks: 1
-                        };
-                        try {
-                          renderNode(request, task, content, -1);
-                          if (
-                            1 === task.replay.pendingTasks &&
-                            0 < task.replay.nodes.length
-                          )
-                            throw Error(
-                              "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                            );
-                          task.replay.pendingTasks--;
-                          if (
-                            0 === props.pendingTasks &&
-                            props.status === PENDING
-                          ) {
-                            props.status = COMPLETED;
-                            request.completedBoundaries.push(props);
-                            break a;
-                          }
-                        } catch (error) {
-                          (props.status = CLIENT_RENDERED),
-                            (childNodes = getThrownInfo(task.componentStack)),
-                            (type = logRecoverableError(
-                              request,
-                              error,
-                              childNodes
-                            )),
-                            encodeErrorForBoundary(
-                              props,
-                              type,
-                              error,
-                              childNodes,
-                              !1
-                            ),
-                            task.replay.pendingTasks--,
-                            request.clientRenderedBoundaries.push(props);
-                        } finally {
-                          (task.blockedBoundary = parentBoundary),
-                            (task.hoistableState = parentHoistableState),
-                            (task.replay = previousReplaySet),
-                            (task.keyPath = prevKeyPath);
-                        }
-                        childNodes = createReplayTask(
-                          request,
-                          null,
-                          { nodes: keyOrIndex, slots: key, pendingTasks: 0 },
-                          fallback,
-                          -1,
-                          parentBoundary,
-                          props.fallbackState,
-                          fallbackAbortSet,
-                          [keyPath[0], "Suspense Fallback", keyPath[2]],
-                          task.formatContext,
-                          task.context,
-                          task.treeContext,
-                          task.componentStack,
-                          !0
-                        );
-                        pushComponentStack(childNodes);
-                        request.pingedTasks.push(childNodes);
-                      }
-                    }
-                    childIndex.splice(node, 1);
-                    break;
-                  }
-              } else renderElement(request, task, keyPath, type, props, ref);
+                key = node.key;
+              node = node.props;
+              var refProp = node.ref;
+              refProp = void 0 !== refProp ? refProp : null;
+              var debugTask = task.debugTask,
+                name = getComponentNameFromType(type);
+              key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;
+              var keyPath = [task.keyPath, name, key];
+              null !== task.replay
+                ? debugTask
+                  ? debugTask.run(
+                      replayElement.bind(
+                        null,
+                        request,
+                        task,
+                        keyPath,
+                        name,
+                        key,
+                        childIndex,
+                        type,
+                        node,
+                        refProp,
+                        task.replay
+                      )
+                    )
+                  : replayElement(
+                      request,
+                      task,
+                      keyPath,
+                      name,
+                      key,
+                      childIndex,
+                      type,
+                      node,
+                      refProp,
+                      task.replay
+                    )
+                : debugTask
+                  ? debugTask.run(
+                      renderElement.bind(
+                        null,
+                        request,
+                        task,
+                        keyPath,
+                        type,
+                        node,
+                        refProp
+                      )
+                    )
+                  : renderElement(request, task, keyPath, type, node, refProp);
               return;
             case REACT_PORTAL_TYPE:
               throw Error(
@@ -5749,21 +5911,20 @@
             return;
           }
           null === node || "object" !== typeof node
-            ? (props = null)
-            : ((childNodes =
+            ? (key = null)
+            : ((type =
                 (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||
                 node["@@iterator"]),
-              (props = "function" === typeof childNodes ? childNodes : null));
-          if (props && (childNodes = props.call(node))) {
-            if (childNodes === node) {
+              (key = "function" === typeof type ? type : null));
+          if (key && (type = key.call(node))) {
+            if (type === node) {
               if (
                 -1 !== childIndex ||
                 null === task.componentStack ||
                 "function" !== typeof task.componentStack.type ||
                 "[object GeneratorFunction]" !==
                   Object.prototype.toString.call(task.componentStack.type) ||
-                "[object Generator]" !==
-                  Object.prototype.toString.call(childNodes)
+                "[object Generator]" !== Object.prototype.toString.call(type)
               )
                 didWarnAboutGenerators ||
                   console.error(
@@ -5771,21 +5932,59 @@
                   ),
                   (didWarnAboutGenerators = !0);
             } else
-              node.entries !== props ||
+              node.entries !== key ||
                 didWarnAboutMaps ||
                 (console.error(
                   "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                 ),
                 (didWarnAboutMaps = !0));
-            node = childNodes.next();
+            node = type.next();
             if (!node.done) {
-              props = [];
-              do props.push(node.value), (node = childNodes.next());
+              key = [];
+              do key.push(node.value), (node = type.next());
               while (!node.done);
-              renderChildrenArray(request, task, props, childIndex);
+              renderChildrenArray(request, task, key, childIndex);
             }
             return;
           }
+          if (
+            "function" === typeof node[ASYNC_ITERATOR] &&
+            (type = node[ASYNC_ITERATOR]())
+          ) {
+            type !== node ||
+              (-1 === childIndex &&
+                null !== task.componentStack &&
+                "function" === typeof task.componentStack.type &&
+                "[object AsyncGeneratorFunction]" ===
+                  Object.prototype.toString.call(task.componentStack.type) &&
+                "[object AsyncGenerator]" ===
+                  Object.prototype.toString.call(type)) ||
+              (didWarnAboutGenerators ||
+                console.error(
+                  "Using AsyncIterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You can use an AsyncIterable that can iterate multiple times over the same items."
+                ),
+              (didWarnAboutGenerators = !0));
+            key = task.thenableState;
+            task.thenableState = null;
+            thenableIndexCounter = 0;
+            thenableState = key;
+            key = [];
+            refProp = !1;
+            if (type === node)
+              for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+                if (node.done) {
+                  refProp = !0;
+                  break;
+                }
+                key.push(node.value);
+                node = readPreviousThenableFromState();
+              }
+            if (!refProp)
+              for (node = unwrapThenable(type.next()); !node.done; )
+                key.push(node.value), (node = unwrapThenable(type.next()));
+            renderChildrenArray(request, task, key, childIndex);
+            return;
+          }
           if ("function" === typeof node.then)
             return (
               (task.thenableState = null),
@@ -5803,39 +6002,39 @@
               node._currentValue2,
               childIndex
             );
-          childIndex = Object.prototype.toString.call(node);
+          request = Object.prototype.toString.call(node);
           throw Error(
             "Objects are not valid as a React child (found: " +
-              ("[object Object]" === childIndex
+              ("[object Object]" === request
                 ? "object with keys {" + Object.keys(node).join(", ") + "}"
-                : childIndex) +
+                : request) +
               "). If you meant to render a collection of children, use an array instead."
           );
         }
         "string" === typeof node
-          ? ((childIndex = task.blockedSegment),
-            null !== childIndex &&
-              (childIndex.lastPushedText = pushTextInstance(
-                childIndex.chunks,
+          ? ((task = task.blockedSegment),
+            null !== task &&
+              (task.lastPushedText = pushTextInstance(
+                task.chunks,
                 node,
                 request.renderState,
-                childIndex.lastPushedText
+                task.lastPushedText
               )))
           : "number" === typeof node || "bigint" === typeof node
-            ? ((childIndex = task.blockedSegment),
-              null !== childIndex &&
-                (childIndex.lastPushedText = pushTextInstance(
-                  childIndex.chunks,
+            ? ((task = task.blockedSegment),
+              null !== task &&
+                (task.lastPushedText = pushTextInstance(
+                  task.chunks,
                   "" + node,
                   request.renderState,
-                  childIndex.lastPushedText
+                  task.lastPushedText
                 )))
             : ("function" === typeof node &&
-                ((childIndex = node.displayName || node.name || "Component"),
+                ((request = node.displayName || node.name || "Component"),
                 console.error(
                   "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
-                  childIndex,
-                  childIndex
+                  request,
+                  request
                 )),
               "symbol" === typeof node &&
                 console.error(
@@ -5847,6 +6046,7 @@
     function renderChildrenArray(request$jscomp$0, task, children, childIndex) {
       var prevKeyPath = task.keyPath,
         previousComponentStack = task.componentStack;
+      var previousDebugTask = task.debugTask;
       pushServerComponentStack(task, task.node._debugInfo);
       if (
         -1 !== childIndex &&
@@ -5888,7 +6088,8 @@
                 x,
                 children,
                 childIndex,
-                node
+                node,
+                task.debugTask
               );
             }
             task.replay = replay;
@@ -5898,6 +6099,7 @@
         }
         task.keyPath = prevKeyPath;
         task.componentStack = previousComponentStack;
+        task.debugTask = previousDebugTask;
         return;
       }
       replay = task.treeContext;
@@ -5924,6 +6126,7 @@
         task.treeContext = replay;
         task.keyPath = prevKeyPath;
         task.componentStack = previousComponentStack;
+        task.debugTask = previousDebugTask;
         return;
       }
       for (j = 0; j < replayNodes; j++) {
@@ -5982,7 +6185,7 @@
               parent: node.componentStack,
               type: resumeSegmentID.type,
               owner: resumeSegmentID._owner,
-              stack: null
+              stack: resumeSegmentID._debugStack
             };
             console.error(
               'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
@@ -5998,6 +6201,106 @@
       task.treeContext = replay;
       task.keyPath = prevKeyPath;
       task.componentStack = previousComponentStack;
+      task.debugTask = previousDebugTask;
+    }
+    function trackPostpone(request, trackedPostpones, task, segment) {
+      segment.status = POSTPONED;
+      var keyPath = task.keyPath,
+        boundary = task.blockedBoundary;
+      if (null === boundary)
+        (segment.id = request.nextSegmentId++),
+          (trackedPostpones.rootSlots = segment.id),
+          null !== request.completedRootSegment &&
+            (request.completedRootSegment.status = POSTPONED);
+      else {
+        if (null !== boundary && boundary.status === PENDING) {
+          boundary.status = POSTPONED;
+          boundary.rootSegmentID = request.nextSegmentId++;
+          var boundaryKeyPath = boundary.trackedContentKeyPath;
+          if (null === boundaryKeyPath)
+            throw Error(
+              "It should not be possible to postpone at the root. This is a bug in React."
+            );
+          var fallbackReplayNode = boundary.trackedFallbackNode,
+            children = [];
+          if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+            -1 === segment.id &&
+              (segment.id = segment.parentFlushed
+                ? boundary.rootSegmentID
+                : request.nextSegmentId++);
+            segment = [
+              boundaryKeyPath[1],
+              boundaryKeyPath[2],
+              children,
+              segment.id,
+              fallbackReplayNode,
+              boundary.rootSegmentID
+            ];
+            trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+            addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+            return;
+          }
+          var _boundaryNode = trackedPostpones.workingMap.get(boundaryKeyPath);
+          void 0 === _boundaryNode
+            ? ((_boundaryNode = [
+                boundaryKeyPath[1],
+                boundaryKeyPath[2],
+                children,
+                null,
+                fallbackReplayNode,
+                boundary.rootSegmentID
+              ]),
+              trackedPostpones.workingMap.set(boundaryKeyPath, _boundaryNode),
+              addToReplayParent(
+                _boundaryNode,
+                boundaryKeyPath[0],
+                trackedPostpones
+              ))
+            : ((boundaryKeyPath = _boundaryNode),
+              (boundaryKeyPath[4] = fallbackReplayNode),
+              (boundaryKeyPath[5] = boundary.rootSegmentID));
+        }
+        -1 === segment.id &&
+          (segment.id =
+            segment.parentFlushed && null !== boundary
+              ? boundary.rootSegmentID
+              : request.nextSegmentId++);
+        if (-1 === task.childIndex)
+          null === keyPath
+            ? (trackedPostpones.rootSlots = segment.id)
+            : ((task = trackedPostpones.workingMap.get(keyPath)),
+              void 0 === task
+                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+                  addToReplayParent(task, keyPath[0], trackedPostpones))
+                : (task[3] = segment.id));
+        else {
+          if (null === keyPath)
+            if (((request = trackedPostpones.rootSlots), null === request))
+              request = trackedPostpones.rootSlots = {};
+            else {
+              if ("number" === typeof request)
+                throw Error(
+                  "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+                );
+            }
+          else if (
+            ((boundary = trackedPostpones.workingMap),
+            (boundaryKeyPath = boundary.get(keyPath)),
+            void 0 === boundaryKeyPath)
+          )
+            (request = {}),
+              (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+              boundary.set(keyPath, boundaryKeyPath),
+              addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+          else if (((request = boundaryKeyPath[3]), null === request))
+            request = boundaryKeyPath[3] = {};
+          else if ("number" === typeof request)
+            throw Error(
+              "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+            );
+          request[task.childIndex] = segment.id;
+        }
+      }
     }
     function untrackBoundary(request, boundary) {
       request = request.trackedPostpones;
@@ -6023,7 +6326,9 @@
         task.context,
         task.treeContext,
         task.componentStack,
-        task.isFallback
+        task.isFallback,
+        emptyContextObject,
+        task.debugTask
       );
     }
     function spawnNewSuspendedRenderTask(request, task, thenableState) {
@@ -6045,7 +6350,6 @@
         task.childIndex,
         task.blockedBoundary,
         newSegment,
-        task.blockedPreamble,
         task.hoistableState,
         task.abortSet,
         task.keyPath,
@@ -6053,7 +6357,9 @@
         task.context,
         task.treeContext,
         task.componentStack,
-        task.isFallback
+        task.isFallback,
+        emptyContextObject,
+        task.debugTask
       );
     }
     function renderNode(request, task, node, childIndex) {
@@ -6062,6 +6368,7 @@
         previousKeyPath = task.keyPath,
         previousTreeContext = task.treeContext,
         previousComponentStack = task.componentStack,
+        previousDebugTask = task.debugTask,
         segment = task.blockedSegment;
       if (null === segment)
         try {
@@ -6069,13 +6376,14 @@
         } catch (thrownValue) {
           if (
             (resetHooksState(),
-            (node =
+            (childIndex =
               thrownValue === SuspenseException
                 ? getSuspendedThenable()
                 : thrownValue),
-            "object" === typeof node && null !== node)
+            "object" === typeof childIndex && null !== childIndex)
           ) {
-            if ("function" === typeof node.then) {
+            if ("function" === typeof childIndex.then) {
+              node = childIndex;
               childIndex = getThenableStateAfterSuspending();
               request = spawnNewSuspendedReplayTask(
                 request,
@@ -6088,10 +6396,11 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
-            if ("Maximum call stack size exceeded" === node.message) {
+            if ("Maximum call stack size exceeded" === childIndex.message) {
               node = getThenableStateAfterSuspending();
               node = spawnNewSuspendedReplayTask(request, task, node);
               request.pingedTasks.push(node);
@@ -6100,6 +6409,7 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
@@ -6115,13 +6425,14 @@
             (resetHooksState(),
             (segment.children.length = childrenLength),
             (segment.chunks.length = chunkLength),
-            (node =
+            (childIndex =
               thrownValue$3 === SuspenseException
                 ? getSuspendedThenable()
                 : thrownValue$3),
-            "object" === typeof node && null !== node)
+            "object" === typeof childIndex && null !== childIndex)
           ) {
-            if ("function" === typeof node.then) {
+            if ("function" === typeof childIndex.then) {
+              node = childIndex;
               childIndex = getThenableStateAfterSuspending();
               request = spawnNewSuspendedRenderTask(
                 request,
@@ -6134,10 +6445,40 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
+              switchContext(previousContext);
+              return;
+            }
+            if (
+              childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+              null !== request.trackedPostpones &&
+              null !== task.blockedBoundary
+            ) {
+              node = request.trackedPostpones;
+              segment = getThrownInfo(task.componentStack);
+              logPostpone(request, childIndex.message, segment, task.debugTask);
+              childIndex = task.blockedSegment;
+              segment = createPendingSegment(
+                request,
+                childIndex.chunks.length,
+                null,
+                task.formatContext,
+                childIndex.lastPushedText,
+                !0
+              );
+              childIndex.children.push(segment);
+              childIndex.lastPushedText = !1;
+              trackPostpone(request, node, task, segment);
+              task.formatContext = previousFormatContext;
+              task.context = previousContext;
+              task.keyPath = previousKeyPath;
+              task.treeContext = previousTreeContext;
+              task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
-            if ("Maximum call stack size exceeded" === node.message) {
+            if ("Maximum call stack size exceeded" === childIndex.message) {
               node = getThenableStateAfterSuspending();
               node = spawnNewSuspendedRenderTask(request, task, node);
               request.pingedTasks.push(node);
@@ -6146,6 +6487,7 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
@@ -6157,7 +6499,7 @@
       task.keyPath = previousKeyPath;
       task.treeContext = previousTreeContext;
       switchContext(previousContext);
-      throw node;
+      throw childIndex;
     }
     function erroredReplay(
       request,
@@ -6165,16 +6507,27 @@
       error,
       errorInfo,
       replayNodes,
-      resumeSlots
+      resumeSlots,
+      debugTask
     ) {
-      var errorDigest = logRecoverableError(request, error, errorInfo);
+      "object" === typeof error &&
+      null !== error &&
+      error.$$typeof === REACT_POSTPONE_TYPE
+        ? (logPostpone(request, error.message, errorInfo, debugTask),
+          (debugTask = "POSTPONE"))
+        : (debugTask = logRecoverableError(
+            request,
+            error,
+            errorInfo,
+            debugTask
+          ));
       abortRemainingReplayNodes(
         request,
         boundary,
         replayNodes,
         resumeSlots,
         error,
-        errorDigest,
+        debugTask,
         errorInfo,
         !1
       );
@@ -6214,12 +6567,7 @@
             errorDigest = errorDigest$jscomp$0,
             errorInfo = errorInfo$jscomp$0,
             wasAborted = aborted,
-            resumedBoundary = createSuspenseBoundary(
-              request,
-              new Set(),
-              null,
-              null
-            );
+            resumedBoundary = createSuspenseBoundary(request, new Set());
           resumedBoundary.parentFlushed = !0;
           resumedBoundary.rootSegmentID = node;
           resumedBoundary.status = CLIENT_RENDERED;
@@ -6262,19 +6610,43 @@
         if (6 === segment.status) return;
         segment.status = 3;
       }
-      segment = getThrownInfo(task.componentStack);
+      var errorInfo = getThrownInfo(task.componentStack);
       if (null === boundary) {
         if (13 !== request.status && request.status !== CLOSED) {
           boundary = task.replay;
           if (null === boundary) {
-            logRecoverableError(request, error, segment);
-            fatalError(request, error);
+            "object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+              ? ((boundary = request.trackedPostpones),
+                null !== boundary && null !== segment
+                  ? (logPostpone(request, error.message, errorInfo, null),
+                    trackPostpone(request, boundary, task, segment),
+                    finishedTask(request, null, segment))
+                  : ((task = Error(
+                      "The render was aborted with postpone when the shell is incomplete. Reason: " +
+                        error.message
+                    )),
+                    logRecoverableError(request, task, errorInfo, null),
+                    fatalError(request, task, errorInfo, null)))
+              : null !== request.trackedPostpones && null !== segment
+                ? ((boundary = request.trackedPostpones),
+                  logRecoverableError(request, error, errorInfo, null),
+                  trackPostpone(request, boundary, task, segment),
+                  finishedTask(request, null, segment))
+                : (logRecoverableError(request, error, errorInfo, null),
+                  fatalError(request, error, errorInfo, null));
             return;
           }
           boundary.pendingTasks--;
           0 === boundary.pendingTasks &&
             0 < boundary.nodes.length &&
-            ((task = logRecoverableError(request, error, segment)),
+            ("object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+              ? (logPostpone(request, error.message, errorInfo, null),
+                (task = "POSTPONE"))
+              : (task = logRecoverableError(request, error, errorInfo, null)),
             abortRemainingReplayNodes(
               request,
               null,
@@ -6282,26 +6654,59 @@
               boundary.slots,
               error,
               task,
-              segment,
+              errorInfo,
               !0
             ));
           request.pendingRootTasks--;
           0 === request.pendingRootTasks && completeShell(request);
         }
-      } else
-        boundary.pendingTasks--,
-          boundary.status !== CLIENT_RENDERED &&
-            ((boundary.status = CLIENT_RENDERED),
-            (task = logRecoverableError(request, error, segment)),
-            (boundary.status = CLIENT_RENDERED),
-            encodeErrorForBoundary(boundary, task, error, segment, !0),
-            untrackBoundary(request, boundary),
-            boundary.parentFlushed &&
-              request.clientRenderedBoundaries.push(boundary)),
-          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-            return abortTask(fallbackTask, request, error);
-          }),
-          boundary.fallbackAbortableTasks.clear();
+      } else {
+        boundary.pendingTasks--;
+        var _trackedPostpones2 = request.trackedPostpones;
+        if (boundary.status !== CLIENT_RENDERED) {
+          if (null !== _trackedPostpones2 && null !== segment)
+            return (
+              "object" === typeof error &&
+              null !== error &&
+              error.$$typeof === REACT_POSTPONE_TYPE
+                ? logPostpone(request, error.message, errorInfo, null)
+                : logRecoverableError(request, error, errorInfo, null),
+              trackPostpone(request, _trackedPostpones2, task, segment),
+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+                return abortTask(fallbackTask, request, error);
+              }),
+              boundary.fallbackAbortableTasks.clear(),
+              finishedTask(request, boundary, segment)
+            );
+          boundary.status = CLIENT_RENDERED;
+          if (
+            "object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+          ) {
+            logPostpone(request, error.message, errorInfo, null);
+            if (null !== request.trackedPostpones && null !== segment) {
+              trackPostpone(request, request.trackedPostpones, task, segment);
+              finishedTask(request, task.blockedBoundary, segment);
+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+                return abortTask(fallbackTask, request, error);
+              });
+              boundary.fallbackAbortableTasks.clear();
+              return;
+            }
+            task = "POSTPONE";
+          } else task = logRecoverableError(request, error, errorInfo, null);
+          boundary.status = CLIENT_RENDERED;
+          encodeErrorForBoundary(boundary, task, error, errorInfo, !0);
+          untrackBoundary(request, boundary);
+          boundary.parentFlushed &&
+            request.clientRenderedBoundaries.push(boundary);
+        }
+        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+          return abortTask(fallbackTask, request, error);
+        });
+        boundary.fallbackAbortableTasks.clear();
+      }
       request.allPendingTasks--;
       0 === request.allPendingTasks && completeAll(request);
     }
@@ -6367,12 +6772,11 @@
           }
         }
       } catch (error) {
-        logRecoverableError(request, error, {});
+        logRecoverableError(request, error, {}, null);
       }
     }
     function completeShell(request) {
       null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-      null === request.trackedPostpones && preparePreamble(request);
       request.onShellError = noop;
       request = request.onShellReady;
       request();
@@ -6385,7 +6789,6 @@
           : null === request.completedRootSegment ||
               request.completedRootSegment.status !== POSTPONED
       );
-      preparePreamble(request);
       request = request.onAllReady;
       request();
     }
@@ -6430,11 +6833,7 @@
                     abortTaskSoft,
                     request
                   ),
-                  boundary.fallbackAbortableTasks.clear(),
-                  0 === request.pendingRootTasks &&
-                    null === request.trackedPostpones &&
-                    null !== boundary.contentPreamble &&
-                    preparePreamble(request)))
+                  boundary.fallbackAbortableTasks.clear()))
               : null !== segment &&
                 segment.parentFlushed &&
                 segment.status === COMPLETED &&
@@ -6522,7 +6921,8 @@
                         : x,
                       errorInfo,
                       request.replay.nodes,
-                      request.replay.slots
+                      request.replay.slots,
+                      request.debugTask
                     );
                     request$jscomp$0.pendingRootTasks--;
                     0 === request$jscomp$0.pendingRootTasks &&
@@ -6535,91 +6935,171 @@
                   currentTaskInDEV = prevTaskInDEV;
                 }
               }
-            } else {
-              request$jscomp$0 = prevTaskInDEV = void 0;
-              var task$jscomp$0 = task,
-                segment$jscomp$0 = segment;
-              if (segment$jscomp$0.status === PENDING) {
-                segment$jscomp$0.status = 6;
-                switchContext(task$jscomp$0.context);
-                request$jscomp$0 = currentTaskInDEV;
-                currentTaskInDEV = task$jscomp$0;
-                var childrenLength = segment$jscomp$0.children.length,
-                  chunkLength = segment$jscomp$0.chunks.length;
-                try {
-                  retryNode(request, task$jscomp$0),
-                    pushSegmentFinale(
-                      segment$jscomp$0.chunks,
-                      request.renderState,
-                      segment$jscomp$0.lastPushedText,
-                      segment$jscomp$0.textEmbedded
-                    ),
-                    task$jscomp$0.abortSet.delete(task$jscomp$0),
-                    (segment$jscomp$0.status = COMPLETED),
-                    finishedTask(
-                      request,
-                      task$jscomp$0.blockedBoundary,
-                      segment$jscomp$0
-                    );
-                } catch (thrownValue) {
-                  resetHooksState();
-                  segment$jscomp$0.children.length = childrenLength;
-                  segment$jscomp$0.chunks.length = chunkLength;
-                  var x$jscomp$0 =
-                    thrownValue === SuspenseException
-                      ? getSuspendedThenable()
-                      : 12 === request.status
-                        ? request.fatalError
-                        : thrownValue;
-                  if (
-                    "object" === typeof x$jscomp$0 &&
-                    null !== x$jscomp$0 &&
-                    "function" === typeof x$jscomp$0.then
-                  ) {
-                    segment$jscomp$0.status = PENDING;
-                    task$jscomp$0.thenableState =
-                      getThenableStateAfterSuspending();
-                    var ping$jscomp$0 = task$jscomp$0.ping;
-                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-                  } else {
-                    var errorInfo$jscomp$0 = getThrownInfo(
-                      task$jscomp$0.componentStack
-                    );
-                    task$jscomp$0.abortSet.delete(task$jscomp$0);
-                    segment$jscomp$0.status = 4;
-                    var boundary = task$jscomp$0.blockedBoundary;
-                    prevTaskInDEV = logRecoverableError(
-                      request,
-                      x$jscomp$0,
-                      errorInfo$jscomp$0
-                    );
-                    null === boundary
-                      ? fatalError(request, x$jscomp$0)
-                      : (boundary.pendingTasks--,
-                        boundary.status !== CLIENT_RENDERED &&
-                          ((boundary.status = CLIENT_RENDERED),
-                          encodeErrorForBoundary(
-                            boundary,
-                            prevTaskInDEV,
+            } else
+              a: {
+                request$jscomp$0 = prevTaskInDEV = void 0;
+                var task$jscomp$0 = task,
+                  segment$jscomp$0 = segment;
+                if (segment$jscomp$0.status === PENDING) {
+                  segment$jscomp$0.status = 6;
+                  switchContext(task$jscomp$0.context);
+                  request$jscomp$0 = currentTaskInDEV;
+                  currentTaskInDEV = task$jscomp$0;
+                  var childrenLength = segment$jscomp$0.children.length,
+                    chunkLength = segment$jscomp$0.chunks.length;
+                  try {
+                    retryNode(request, task$jscomp$0),
+                      pushSegmentFinale(
+                        segment$jscomp$0.chunks,
+                        request.renderState,
+                        segment$jscomp$0.lastPushedText,
+                        segment$jscomp$0.textEmbedded
+                      ),
+                      task$jscomp$0.abortSet.delete(task$jscomp$0),
+                      (segment$jscomp$0.status = COMPLETED),
+                      finishedTask(
+                        request,
+                        task$jscomp$0.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                  } catch (thrownValue) {
+                    resetHooksState();
+                    segment$jscomp$0.children.length = childrenLength;
+                    segment$jscomp$0.chunks.length = chunkLength;
+                    var x$jscomp$0 =
+                      thrownValue === SuspenseException
+                        ? getSuspendedThenable()
+                        : 12 === request.status
+                          ? request.fatalError
+                          : thrownValue;
+                    if (
+                      12 === request.status &&
+                      null !== request.trackedPostpones
+                    ) {
+                      var trackedPostpones = request.trackedPostpones,
+                        thrownInfo = getThrownInfo(
+                          task$jscomp$0.componentStack
+                        );
+                      task$jscomp$0.abortSet.delete(task$jscomp$0);
+                      "object" === typeof x$jscomp$0 &&
+                      null !== x$jscomp$0 &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ? logPostpone(
+                            request,
+                            x$jscomp$0.message,
+                            thrownInfo,
+                            task$jscomp$0.debugTask
+                          )
+                        : logRecoverableError(
+                            request,
                             x$jscomp$0,
+                            thrownInfo,
+                            task$jscomp$0.debugTask
+                          );
+                      trackPostpone(
+                        request,
+                        trackedPostpones,
+                        task$jscomp$0,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task$jscomp$0.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                    } else {
+                      if (
+                        "object" === typeof x$jscomp$0 &&
+                        null !== x$jscomp$0
+                      ) {
+                        if ("function" === typeof x$jscomp$0.then) {
+                          segment$jscomp$0.status = PENDING;
+                          task$jscomp$0.thenableState =
+                            getThenableStateAfterSuspending();
+                          var ping$jscomp$0 = task$jscomp$0.ping;
+                          x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                          break a;
+                        }
+                        if (
+                          null !== request.trackedPostpones &&
+                          x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ) {
+                          var _trackedPostpones3 = request.trackedPostpones;
+                          task$jscomp$0.abortSet.delete(task$jscomp$0);
+                          var postponeInfo = getThrownInfo(
+                            task$jscomp$0.componentStack
+                          );
+                          logPostpone(
+                            request,
+                            x$jscomp$0.message,
+                            postponeInfo,
+                            task$jscomp$0.debugTask
+                          );
+                          trackPostpone(
+                            request,
+                            _trackedPostpones3,
+                            task$jscomp$0,
+                            segment$jscomp$0
+                          );
+                          finishedTask(
+                            request,
+                            task$jscomp$0.blockedBoundary,
+                            segment$jscomp$0
+                          );
+                          break a;
+                        }
+                      }
+                      var errorInfo$jscomp$0 = getThrownInfo(
+                        task$jscomp$0.componentStack
+                      );
+                      task$jscomp$0.abortSet.delete(task$jscomp$0);
+                      segment$jscomp$0.status = 4;
+                      var boundary = task$jscomp$0.blockedBoundary,
+                        debugTask = task$jscomp$0.debugTask;
+                      "object" === typeof x$jscomp$0 &&
+                      null !== x$jscomp$0 &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ? (logPostpone(
+                            request,
+                            x$jscomp$0.message,
                             errorInfo$jscomp$0,
-                            !1
+                            debugTask
                           ),
-                          untrackBoundary(request, boundary),
-                          boundary.parentFlushed &&
-                            request.clientRenderedBoundaries.push(boundary),
-                          0 === request.pendingRootTasks &&
-                            null === request.trackedPostpones &&
-                            null !== boundary.contentPreamble &&
-                            preparePreamble(request)));
-                    request.allPendingTasks--;
-                    0 === request.allPendingTasks && completeAll(request);
+                          (prevTaskInDEV = "POSTPONE"))
+                        : (prevTaskInDEV = logRecoverableError(
+                            request,
+                            x$jscomp$0,
+                            errorInfo$jscomp$0,
+                            debugTask
+                          ));
+                      null === boundary
+                        ? fatalError(
+                            request,
+                            x$jscomp$0,
+                            errorInfo$jscomp$0,
+                            debugTask
+                          )
+                        : (boundary.pendingTasks--,
+                          boundary.status !== CLIENT_RENDERED &&
+                            ((boundary.status = CLIENT_RENDERED),
+                            encodeErrorForBoundary(
+                              boundary,
+                              prevTaskInDEV,
+                              x$jscomp$0,
+                              errorInfo$jscomp$0,
+                              !1
+                            ),
+                            untrackBoundary(request, boundary),
+                            boundary.parentFlushed &&
+                              request.clientRenderedBoundaries.push(boundary)));
+                      request.allPendingTasks--;
+                      0 === request.allPendingTasks && completeAll(request);
+                    }
+                  } finally {
+                    currentTaskInDEV = request$jscomp$0;
                   }
-                } finally {
-                  currentTaskInDEV = request$jscomp$0;
                 }
               }
-            }
           }
           pingedTasks.splice(0, i);
           null !== request$jscomp$1.destination &&
@@ -6628,8 +7108,9 @@
               request$jscomp$1.destination
             );
         } catch (error) {
-          logRecoverableError(request$jscomp$1, error, {}),
-            fatalError(request$jscomp$1, error);
+          (pingedTasks = {}),
+            logRecoverableError(request$jscomp$1, error, pingedTasks, null),
+            fatalError(request$jscomp$1, error, pingedTasks, null);
         } finally {
           (currentResumableState = prevResumableState),
             (ReactSharedInternals.H = prevDispatcher),
@@ -6640,85 +7121,6 @@
         }
       }
     }
-    function preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    ) {
-      segment.preambleChildren.length &&
-        collectedPreambleSegments.push(segment.preambleChildren);
-      for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-        pendingPreambles =
-          preparePreambleFromSegment(
-            request,
-            segment.children[i],
-            collectedPreambleSegments
-          ) || pendingPreambles;
-      return pendingPreambles;
-    }
-    function preparePreambleFromSegment(
-      request,
-      segment,
-      collectedPreambleSegments
-    ) {
-      var boundary = segment.boundary;
-      if (null === boundary)
-        return preparePreambleFromSubtree(
-          request,
-          segment,
-          collectedPreambleSegments
-        );
-      var preamble = boundary.contentPreamble,
-        fallbackPreamble = boundary.fallbackPreamble;
-      if (null === preamble || null === fallbackPreamble) return !1;
-      switch (boundary.status) {
-        case COMPLETED:
-          hoistPreambleState(request.renderState, preamble);
-          segment = boundary.completedSegments[0];
-          if (!segment)
-            throw Error(
-              "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
-            );
-          return preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          );
-        case POSTPONED:
-          if (null !== request.trackedPostpones) return !0;
-        case CLIENT_RENDERED:
-          if (segment.status === COMPLETED)
-            return (
-              hoistPreambleState(request.renderState, fallbackPreamble),
-              preparePreambleFromSubtree(
-                request,
-                segment,
-                collectedPreambleSegments
-              )
-            );
-        default:
-          return !0;
-      }
-    }
-    function preparePreamble(request) {
-      if (
-        request.completedRootSegment &&
-        null === request.completedPreambleSegments
-      ) {
-        var collectedPreambleSegments = [],
-          hasPendingPreambles = preparePreambleFromSegment(
-            request,
-            request.completedRootSegment,
-            collectedPreambleSegments
-          ),
-          preamble = request.renderState.preamble;
-        if (
-          !1 === hasPendingPreambles ||
-          (preamble.headChunks && preamble.bodyChunks)
-        )
-          request.completedPreambleSegments = collectedPreambleSegments;
-      }
-    }
     function flushSubtree(request, destination, segment, hoistableState) {
       segment.parentFlushed = !0;
       switch (segment.status) {
@@ -6898,37 +7300,57 @@
       boundary = boundary.contentState;
       var requiresStyleInsertion = request.stylesToHoist;
       request.stylesToHoist = !1;
-      destination.push(request.startInlineScript);
-      requiresStyleInsertion
-        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-          NothingSent
-          ? ((completedSegments.instructions =
-              completedSegments.instructions |
-              SentStyleInsertionFunction |
-              SentCompleteBoundaryFunction),
-            destination.push(completeBoundaryWithStylesScript1FullBoth))
-          : (completedSegments.instructions & SentStyleInsertionFunction) ===
+      var scriptFormat =
+        completedSegments.streamingFormat === ScriptStreamingFormat;
+      scriptFormat
+        ? (destination.push(request.startInlineScript),
+          requiresStyleInsertion
+            ? (completedSegments.instructions &
+                SentCompleteBoundaryFunction) ===
               NothingSent
-            ? ((completedSegments.instructions |= SentStyleInsertionFunction),
-              destination.push(completeBoundaryWithStylesScript1FullPartial))
-            : destination.push(completeBoundaryWithStylesScript1Partial)
-        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-            NothingSent
-          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),
-            destination.push(completeBoundaryScript1Full))
-          : destination.push(completeBoundaryScript1Partial);
+              ? ((completedSegments.instructions =
+                  completedSegments.instructions |
+                  SentStyleInsertionFunction |
+                  SentCompleteBoundaryFunction),
+                destination.push(completeBoundaryWithStylesScript1FullBoth))
+              : (completedSegments.instructions &
+                    SentStyleInsertionFunction) ===
+                  NothingSent
+                ? ((completedSegments.instructions |=
+                    SentStyleInsertionFunction),
+                  destination.push(
+                    completeBoundaryWithStylesScript1FullPartial
+                  ))
+                : destination.push(completeBoundaryWithStylesScript1Partial)
+            : (completedSegments.instructions &
+                  SentCompleteBoundaryFunction) ===
+                NothingSent
+              ? ((completedSegments.instructions |=
+                  SentCompleteBoundaryFunction),
+                destination.push(completeBoundaryScript1Full))
+              : destination.push(completeBoundaryScript1Partial))
+        : requiresStyleInsertion
+          ? destination.push(completeBoundaryWithStylesData1)
+          : destination.push(completeBoundaryData1);
       completedSegments = i.toString(16);
       destination.push(request.boundaryPrefix);
       destination.push(completedSegments);
-      destination.push(completeBoundaryScript2);
+      scriptFormat
+        ? destination.push(completeBoundaryScript2)
+        : destination.push(completeBoundaryData2);
       destination.push(request.segmentPrefix);
       destination.push(completedSegments);
       requiresStyleInsertion
-        ? (destination.push(completeBoundaryScript3a),
-          writeStyleResourceDependenciesInJS(destination, boundary))
-        : destination.push(completeBoundaryScript3b);
-      boundary = destination.push(completeBoundaryScriptEnd);
-      return writeBootstrap(destination, request) && boundary;
+        ? scriptFormat
+          ? (destination.push(completeBoundaryScript3a),
+            writeStyleResourceDependenciesInJS(destination, boundary))
+          : (destination.push(completeBoundaryData3a),
+            writeStyleResourceDependenciesInAttr(destination, boundary))
+        : scriptFormat && destination.push(completeBoundaryScript3b);
+      completedSegments = scriptFormat
+        ? destination.push(completeBoundaryScriptEnd)
+        : destination.push(completeBoundaryDataEnd);
+      return writeBootstrap(destination, request) && completedSegments;
     }
     function flushPartiallyCompletedSegment(
       request,
@@ -6961,18 +7383,24 @@
       flushSegmentContainer(request, destination, segment, hoistableState);
       boundary = request.resumableState;
       request = request.renderState;
-      destination.push(request.startInlineScript);
-      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
-        ? ((boundary.instructions |= SentCompleteSegmentFunction),
-          destination.push(completeSegmentScript1Full))
-        : destination.push(completeSegmentScript1Partial);
+      (segment = boundary.streamingFormat === ScriptStreamingFormat)
+        ? (destination.push(request.startInlineScript),
+          (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
+            ? ((boundary.instructions |= SentCompleteSegmentFunction),
+              destination.push(completeSegmentScript1Full))
+            : destination.push(completeSegmentScript1Partial))
+        : destination.push(completeSegmentData1);
       destination.push(request.segmentPrefix);
       segmentID = segmentID.toString(16);
       destination.push(segmentID);
-      destination.push(completeSegmentScript2);
+      segment
+        ? destination.push(completeSegmentScript2)
+        : destination.push(completeSegmentData2);
       destination.push(request.placeholderPrefix);
       destination.push(segmentID);
-      destination = destination.push(completeSegmentScriptEnd);
+      destination = segment
+        ? destination.push(completeSegmentScriptEnd)
+        : destination.push(completeSegmentDataEnd);
       return destination;
     }
     function flushCompletedQueues(request, destination) {
@@ -6982,12 +7410,22 @@
             completedRootSegment = request.completedRootSegment;
           if (null !== completedRootSegment) {
             if (completedRootSegment.status === POSTPONED) return;
-            var completedPreambleSegments = request.completedPreambleSegments;
-            if (null === completedPreambleSegments) return;
-            var renderState = request.renderState,
-              preamble = renderState.preamble,
-              htmlChunks = preamble.htmlChunks,
-              headChunks = preamble.headChunks,
+            var renderState = request.renderState;
+            if (
+              (0 !== request.allPendingTasks ||
+                null !== request.trackedPostpones) &&
+              renderState.externalRuntimeScript
+            ) {
+              var _renderState$external = renderState.externalRuntimeScript,
+                resumableState = request.resumableState,
+                src = _renderState$external.src,
+                chunks = _renderState$external.chunks;
+              resumableState.scriptResources.hasOwnProperty(src) ||
+                ((resumableState.scriptResources[src] = EXISTS),
+                renderState.scripts.add(chunks));
+            }
+            var htmlChunks = renderState.htmlChunks,
+              headChunks = renderState.headChunks,
               i$jscomp$0;
             if (htmlChunks) {
               for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -7050,29 +7488,11 @@
               i$jscomp$0++
             )
               destination.push(hoistableChunks[i$jscomp$0]);
-            for (
-              renderState = hoistableChunks.length = 0;
-              renderState < completedPreambleSegments.length;
-              renderState++
-            ) {
-              var segments = completedPreambleSegments[renderState];
-              for (preamble = 0; preamble < segments.length; preamble++)
-                flushSegment(request, destination, segments[preamble], null);
-            }
-            var preamble$jscomp$0 = request.renderState.preamble,
-              headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-            if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
+            hoistableChunks.length = 0;
+            if (htmlChunks && null === headChunks) {
               var chunk$jscomp$0 = endChunkForTag("head");
               destination.push(chunk$jscomp$0);
             }
-            var bodyChunks = preamble$jscomp$0.bodyChunks;
-            if (bodyChunks)
-              for (
-                completedPreambleSegments = 0;
-                completedPreambleSegments < bodyChunks.length;
-                completedPreambleSegments++
-              )
-                destination.push(bodyChunks[completedPreambleSegments]);
             flushSegment(request, destination, completedRootSegment, null);
             request.completedRootSegment = null;
             writeBootstrap(destination, request.renderState);
@@ -7113,58 +7533,95 @@
           for (i = 0; i < clientRenderedBoundaries.length; i++) {
             var boundary = clientRenderedBoundaries[i];
             renderState$jscomp$0 = destination;
-            var resumableState = request.resumableState,
+            var resumableState$jscomp$0 = request.resumableState,
               renderState$jscomp$1 = request.renderState,
               id = boundary.rootSegmentID,
               errorDigest = boundary.errorDigest,
               errorMessage = boundary.errorMessage,
               errorStack = boundary.errorStack,
-              errorComponentStack = boundary.errorComponentStack;
-            renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);
-            (resumableState.instructions & SentClientRenderFunction) ===
-            NothingSent
-              ? ((resumableState.instructions |= SentClientRenderFunction),
-                renderState$jscomp$0.push(clientRenderScript1Full))
-              : renderState$jscomp$0.push(clientRenderScript1Partial);
+              errorComponentStack = boundary.errorComponentStack,
+              scriptFormat =
+                resumableState$jscomp$0.streamingFormat ===
+                ScriptStreamingFormat;
+            scriptFormat
+              ? (renderState$jscomp$0.push(
+                  renderState$jscomp$1.startInlineScript
+                ),
+                (resumableState$jscomp$0.instructions &
+                  SentClientRenderFunction) ===
+                NothingSent
+                  ? ((resumableState$jscomp$0.instructions |=
+                      SentClientRenderFunction),
+                    renderState$jscomp$0.push(clientRenderScript1Full))
+                  : renderState$jscomp$0.push(clientRenderScript1Partial))
+              : renderState$jscomp$0.push(clientRenderData1);
             renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);
             var chunk$jscomp$1 = id.toString(16);
             renderState$jscomp$0.push(chunk$jscomp$1);
-            renderState$jscomp$0.push(clientRenderScript1A);
+            scriptFormat && renderState$jscomp$0.push(clientRenderScript1A);
             if (
               errorDigest ||
               errorMessage ||
               errorStack ||
               errorComponentStack
-            ) {
-              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
-              var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
-                errorDigest || ""
-              );
-              renderState$jscomp$0.push(chunk$jscomp$2);
-            }
-            if (errorMessage || errorStack || errorComponentStack) {
-              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
-              var chunk$jscomp$3 = escapeJSStringsForInstructionScripts(
-                errorMessage || ""
-              );
-              renderState$jscomp$0.push(chunk$jscomp$3);
-            }
-            if (errorStack || errorComponentStack) {
-              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
-              var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(
-                errorStack || ""
-              );
-              renderState$jscomp$0.push(chunk$jscomp$4);
-            }
-            if (errorComponentStack) {
-              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
-              var chunk$jscomp$5 =
-                escapeJSStringsForInstructionScripts(errorComponentStack);
-              renderState$jscomp$0.push(chunk$jscomp$5);
-            }
-            var JSCompiler_inline_result = renderState$jscomp$0.push(
-              clientRenderScriptEnd
-            );
+            )
+              if (scriptFormat) {
+                renderState$jscomp$0.push(
+                  clientRenderErrorScriptArgInterstitial
+                );
+                var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
+                  errorDigest || ""
+                );
+                renderState$jscomp$0.push(chunk$jscomp$2);
+              } else {
+                renderState$jscomp$0.push(clientRenderData2);
+                var chunk$jscomp$3 = escapeTextForBrowser(errorDigest || "");
+                renderState$jscomp$0.push(chunk$jscomp$3);
+              }
+            if (errorMessage || errorStack || errorComponentStack)
+              if (scriptFormat) {
+                renderState$jscomp$0.push(
+                  clientRenderErrorScriptArgInterstitial
+                );
+                var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(
+                  errorMessage || ""
+                );
+                renderState$jscomp$0.push(chunk$jscomp$4);
+              } else {
+                renderState$jscomp$0.push(clientRenderData3);
+                var chunk$jscomp$5 = escapeTextForBrowser(errorMessage || "");
+                renderState$jscomp$0.push(chunk$jscomp$5);
+              }
+            if (errorStack || errorComponentStack)
+              if (scriptFormat) {
+                renderState$jscomp$0.push(
+                  clientRenderErrorScriptArgInterstitial
+                );
+                var chunk$jscomp$6 = escapeJSStringsForInstructionScripts(
+                  errorStack || ""
+                );
+                renderState$jscomp$0.push(chunk$jscomp$6);
+              } else {
+                renderState$jscomp$0.push(clientRenderData4);
+                var chunk$jscomp$7 = escapeTextForBrowser(errorStack || "");
+                renderState$jscomp$0.push(chunk$jscomp$7);
+              }
+            if (errorComponentStack)
+              if (scriptFormat) {
+                renderState$jscomp$0.push(
+                  clientRenderErrorScriptArgInterstitial
+                );
+                var chunk$jscomp$8 =
+                  escapeJSStringsForInstructionScripts(errorComponentStack);
+                renderState$jscomp$0.push(chunk$jscomp$8);
+              } else {
+                renderState$jscomp$0.push(clientRenderData5);
+                var chunk$jscomp$9 = escapeTextForBrowser(errorComponentStack);
+                renderState$jscomp$0.push(chunk$jscomp$9);
+              }
+            var JSCompiler_inline_result = scriptFormat
+              ? renderState$jscomp$0.push(clientRenderScriptEnd)
+              : renderState$jscomp$0.push(clientRenderDataEnd);
             if (!JSCompiler_inline_result) {
               request.destination = null;
               i++;
@@ -7246,11 +7703,12 @@
           0 === request.clientRenderedBoundaries.length &&
           0 === request.completedBoundaries.length &&
           ((request.flushScheduled = !1),
-          (i = request.resumableState),
-          i.hasBody &&
-            ((partialBoundaries = endChunkForTag("body")),
-            destination.push(partialBoundaries)),
-          i.hasHtml && ((i = endChunkForTag("html")), destination.push(i)),
+          null === request.trackedPostpones &&
+            ((i = request.resumableState),
+            i.hasBody &&
+              ((partialBoundaries = endChunkForTag("body")),
+              destination.push(partialBoundaries)),
+            i.hasHtml && ((i = endChunkForTag("html")), destination.push(i))),
           0 !== request.abortableTasks.size &&
             console.error(
               "There was still abortable task at the root when we closed. This is a bug in React."
@@ -7288,7 +7746,9 @@
         try {
           flushCompletedQueues(request, destination);
         } catch (error) {
-          logRecoverableError(request, error, {}), fatalError(request, error);
+          (destination = {}),
+            logRecoverableError(request, error, destination, null),
+            fatalError(request, error, destination, null);
         }
       }
     }
@@ -7314,7 +7774,21 @@
         null !== request.destination &&
           flushCompletedQueues(request, request.destination);
       } catch (error$4) {
-        logRecoverableError(request, error$4, {}), fatalError(request, error$4);
+        (reason = {}),
+          logRecoverableError(request, error$4, reason, null),
+          fatalError(request, error$4, reason, null);
+      }
+    }
+    function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+      if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+      else {
+        var workingMap = trackedPostpones.workingMap,
+          parentNode = workingMap.get(parentKeyPath);
+        void 0 === parentNode &&
+          ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+          workingMap.set(parentKeyPath, parentNode),
+          addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+        parentNode[2].push(node);
       }
     }
     function onError() {}
@@ -7329,7 +7803,8 @@
         result = "",
         readyToStream = !1;
       options = createResumableState(
-        options ? options.identifierPrefix : void 0
+        options ? options.identifierPrefix : void 0,
+        void 0
       );
       children = createRequest(
         children,
@@ -7383,9 +7858,10 @@
       REACT_SCOPE_TYPE = Symbol.for("react.scope"),
       REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
       REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-      REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+      REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
       REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
       MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+      ASYNC_ITERATOR = Symbol.asyncIterator,
       isArrayImpl = Array.isArray,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
@@ -8427,7 +8903,8 @@
         } else previousDispatcher.M(src, options);
       }
     };
-    var NothingSent = 0,
+    var ScriptStreamingFormat = 0,
+      NothingSent = 0,
       SentCompleteSegmentFunction = 1,
       SentCompleteBoundaryFunction = 2,
       SentClientRenderFunction = 4,
@@ -8440,13 +8917,12 @@
     var ROOT_HTML_MODE = 0,
       HTML_HTML_MODE = 1,
       HTML_MODE = 2,
-      HTML_HEAD_MODE = 3,
-      SVG_MODE = 4,
-      MATHML_MODE = 5,
-      HTML_TABLE_MODE = 6,
-      HTML_TABLE_BODY_MODE = 7,
-      HTML_TABLE_ROW_MODE = 8,
-      HTML_COLGROUP_MODE = 9,
+      SVG_MODE = 3,
+      MATHML_MODE = 4,
+      HTML_TABLE_MODE = 5,
+      HTML_TABLE_BODY_MODE = 6,
+      HTML_TABLE_ROW_MODE = 7,
+      HTML_COLGROUP_MODE = 8,
       styleNameCache = new Map(),
       styleAttributeStart = ' style="',
       styleAssign = ":",
@@ -8518,6 +8994,9 @@
       completeSegmentScript1Partial = '$RS("',
       completeSegmentScript2 = '","',
       completeSegmentScriptEnd = '")\x3c/script>',
+      completeSegmentData1 = '<template data-rsi="" data-sid="',
+      completeSegmentData2 = '" data-pid="',
+      completeSegmentDataEnd = '"></template>',
       completeBoundaryScript1Full =
         '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("',
       completeBoundaryScript1Partial = '$RC("',
@@ -8530,12 +9009,23 @@
       completeBoundaryScript3a = '",',
       completeBoundaryScript3b = '"',
       completeBoundaryScriptEnd = ")\x3c/script>",
+      completeBoundaryData1 = '<template data-rci="" data-bid="',
+      completeBoundaryWithStylesData1 = '<template data-rri="" data-bid="',
+      completeBoundaryData2 = '" data-sid="',
+      completeBoundaryData3a = '" data-sty="',
+      completeBoundaryDataEnd = '"></template>',
       clientRenderScript1Full =
         '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("',
       clientRenderScript1Partial = '$RX("',
       clientRenderScript1A = '"',
       clientRenderErrorScriptArgInterstitial = ",",
       clientRenderScriptEnd = ")\x3c/script>",
+      clientRenderData1 = '<template data-rxi="" data-bid="',
+      clientRenderData2 = '" data-dgst="',
+      clientRenderData3 = '" data-msg="',
+      clientRenderData4 = '" data-stck="',
+      clientRenderData5 = '" data-cstck="',
+      clientRenderDataEnd = '"></template>',
       regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g,
       regexForJSStringsInScripts = /[&><\u2028\u2029]/g,
       lateStyleTagResourceOpen1 = '<style media="not all" data-precedence="',
@@ -8719,13 +9209,8 @@
           resolveCurrentlyRenderingComponent();
           return NotPending;
         },
-        useMemoCache: function (size) {
-          for (var data = Array(size), i = 0; i < size; i++)
-            data[i] = REACT_MEMO_CACHE_SENTINEL;
-          return data;
-        },
-        useCacheRefresh: function () {
-          return unsupportedRefresh;
+        useEffectEvent: function () {
+          return throwOnUseEffectEventCall;
         }
       },
       currentResumableState = null,
@@ -8806,5 +9291,5 @@
         'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server'
       );
     };
-    exports.version = "19.1.0-canary-c492f975-20250128";
+    exports.version = "19.1.0-experimental-b3a95caf-20250113";
   })();
diff --git a/node_modules/react-dom/cjs/react-dom-server-legacy.browser.production.js b/node_modules/react-dom/cjs/react-dom-server-legacy.browser.production.js
index 0e2c220..602d27e 100644
--- a/node_modules/react-dom/cjs/react-dom-server-legacy.browser.production.js
+++ b/node_modules/react-dom/cjs/react-dom-server-legacy.browser.production.js
@@ -66,9 +66,10 @@ var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
   REACT_SCOPE_TYPE = Symbol.for("react.scope"),
   REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
   REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
   REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
   MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+  ASYNC_ITERATOR = Symbol.asyncIterator,
   isArrayImpl = Array.isArray;
 function murmurhash3_32_gc(key, seed) {
   var remainder = key.length & 3;
@@ -309,10 +310,12 @@ function createResumableState(
   bootstrapScripts,
   bootstrapModules
 ) {
+  var streamingFormat = 0;
+  void 0 !== externalRuntimeConfig && (streamingFormat = 1);
   return {
     idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
     nextFormID: 0,
-    streamingFormat: 0,
+    streamingFormat: streamingFormat,
     bootstrapScriptContent: bootstrapScriptContent,
     bootstrapScripts: bootstrapScripts,
     bootstrapModules: bootstrapModules,
@@ -329,9 +332,6 @@ function createResumableState(
     moduleScriptResources: {}
   };
 }
-function createPreambleState() {
-  return { htmlChunks: null, headChunks: null, bodyChunks: null };
-}
 function createFormatContext(insertionMode, selectedValue, tagScope) {
   return {
     insertionMode: insertionMode,
@@ -350,34 +350,33 @@ function getChildFormatContext(parentContext, type, props) {
         parentContext.tagScope
       );
     case "svg":
-      return createFormatContext(4, null, parentContext.tagScope);
+      return createFormatContext(3, null, parentContext.tagScope);
     case "picture":
       return createFormatContext(2, null, parentContext.tagScope | 2);
     case "math":
-      return createFormatContext(5, null, parentContext.tagScope);
+      return createFormatContext(4, null, parentContext.tagScope);
     case "foreignObject":
       return createFormatContext(2, null, parentContext.tagScope);
     case "table":
-      return createFormatContext(6, null, parentContext.tagScope);
+      return createFormatContext(5, null, parentContext.tagScope);
     case "thead":
     case "tbody":
     case "tfoot":
-      return createFormatContext(7, null, parentContext.tagScope);
+      return createFormatContext(6, null, parentContext.tagScope);
     case "colgroup":
-      return createFormatContext(9, null, parentContext.tagScope);
-    case "tr":
       return createFormatContext(8, null, parentContext.tagScope);
-    case "head":
-      if (2 > parentContext.insertionMode)
-        return createFormatContext(3, null, parentContext.tagScope);
-      break;
-    case "html":
-      if (0 === parentContext.insertionMode)
-        return createFormatContext(1, null, parentContext.tagScope);
+    case "tr":
+      return createFormatContext(7, null, parentContext.tagScope);
   }
-  return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode
+  return 5 <= parentContext.insertionMode
     ? createFormatContext(2, null, parentContext.tagScope)
-    : parentContext;
+    : 0 === parentContext.insertionMode
+      ? "html" === type
+        ? createFormatContext(1, null, parentContext.tagScope)
+        : createFormatContext(2, null, parentContext.tagScope)
+      : 1 === parentContext.insertionMode
+        ? createFormatContext(2, null, parentContext.tagScope)
+        : parentContext;
 }
 var styleNameCache = new Map();
 function pushStyleAttribute(target, style) {
@@ -677,7 +676,8 @@ function flattenOptionChildren(children) {
   return content;
 }
 function injectFormReplayingRuntime(resumableState, renderState) {
-  0 === (resumableState.instructions & 16) &&
+  0 !== (resumableState.instructions & 16) ||
+    renderState.externalRuntimeScript ||
     ((resumableState.instructions |= 16),
     renderState.bootstrapChunks.unshift(
       renderState.startInlineScript,
@@ -828,7 +828,6 @@ function pushStartInstance(
   props,
   resumableState,
   renderState,
-  preambleState,
   hoistableState,
   formatContext,
   textEmbedded,
@@ -1299,7 +1298,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$2;
     case "title":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1318,7 +1317,7 @@ function pushStartInstance(
         href = props.href,
         precedence = props.precedence;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof rel ||
@@ -1400,7 +1399,7 @@ function pushStartInstance(
         "symbol" === typeof asyncProp ||
         props.onLoad ||
         props.onError ||
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1441,7 +1440,7 @@ function pushStartInstance(
       var precedence$jscomp$0 = props.precedence,
         href$jscomp$0 = props.href;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof precedence$jscomp$0 ||
@@ -1544,7 +1543,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$6;
     case "meta":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1717,13 +1716,10 @@ function pushStartInstance(
     case "missing-glyph":
       break;
     case "head":
-      if (2 > formatContext.insertionMode) {
-        var preamble = preambleState || renderState.preamble;
-        if (preamble.headChunks)
-          throw Error(formatProdErrorMessage(545, "`<head>`"));
-        preamble.headChunks = [];
+      if (2 > formatContext.insertionMode && null === renderState.headChunks) {
+        renderState.headChunks = [];
         var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-          preamble.headChunks,
+          renderState.headChunks,
           props,
           "head"
         );
@@ -1734,42 +1730,24 @@ function pushStartInstance(
           "head"
         );
       return JSCompiler_inline_result$jscomp$9;
-    case "body":
-      if (2 > formatContext.insertionMode) {
-        var preamble$jscomp$0 = preambleState || renderState.preamble;
-        if (preamble$jscomp$0.bodyChunks)
-          throw Error(formatProdErrorMessage(545, "`<body>`"));
-        preamble$jscomp$0.bodyChunks = [];
-        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          preamble$jscomp$0.bodyChunks,
-          props,
-          "body"
-        );
-      } else
-        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          target$jscomp$0,
-          props,
-          "body"
-        );
-      return JSCompiler_inline_result$jscomp$10;
     case "html":
-      if (0 === formatContext.insertionMode) {
-        var preamble$jscomp$1 = preambleState || renderState.preamble;
-        if (preamble$jscomp$1.htmlChunks)
-          throw Error(formatProdErrorMessage(545, "`<html>`"));
-        preamble$jscomp$1.htmlChunks = [""];
-        var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-          preamble$jscomp$1.htmlChunks,
+      if (
+        0 === formatContext.insertionMode &&
+        null === renderState.htmlChunks
+      ) {
+        renderState.htmlChunks = [""];
+        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+          renderState.htmlChunks,
           props,
           "html"
         );
       } else
-        JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
           target$jscomp$0,
           props,
           "html"
         );
-      return JSCompiler_inline_result$jscomp$11;
+      return JSCompiler_inline_result$jscomp$10;
     default:
       if (-1 !== type.indexOf("-")) {
         target$jscomp$0.push(startChunkForTag(type));
@@ -1830,15 +1808,6 @@ function endChunkForTag(tag) {
   void 0 === chunk && ((chunk = "</" + tag + ">"), endTagCache.set(tag, chunk));
   return chunk;
 }
-function hoistPreambleState(renderState, preambleState) {
-  renderState = renderState.preamble;
-  null === renderState.htmlChunks &&
-    (renderState.htmlChunks = preambleState.htmlChunks);
-  null === renderState.headChunks &&
-    (renderState.headChunks = preambleState.headChunks);
-  null === renderState.bodyChunks &&
-    (renderState.bodyChunks = preambleState.bodyChunks);
-}
 function writeBootstrap(destination, renderState) {
   renderState = renderState.bootstrapChunks;
   for (var i = 0; i < renderState.length - 1; i++)
@@ -1859,7 +1828,6 @@ function writeStartSegment(destination, renderState, formatContext, id) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return (
         destination.push('<div hidden id="'),
@@ -1868,7 +1836,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 4:
+    case 3:
       return (
         destination.push('<svg aria-hidden="true" style="display:none" id="'),
         destination.push(renderState.segmentPrefix),
@@ -1876,7 +1844,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 5:
+    case 4:
       return (
         destination.push('<math aria-hidden="true" style="display:none" id="'),
         destination.push(renderState.segmentPrefix),
@@ -1884,7 +1852,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 6:
+    case 5:
       return (
         destination.push('<table hidden id="'),
         destination.push(renderState.segmentPrefix),
@@ -1892,7 +1860,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 7:
+    case 6:
       return (
         destination.push('<table hidden><tbody id="'),
         destination.push(renderState.segmentPrefix),
@@ -1900,7 +1868,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 8:
+    case 7:
       return (
         destination.push('<table hidden><tr id="'),
         destination.push(renderState.segmentPrefix),
@@ -1908,7 +1876,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 9:
+    case 8:
       return (
         destination.push('<table hidden><colgroup id="'),
         destination.push(renderState.segmentPrefix),
@@ -1924,20 +1892,19 @@ function writeEndSegment(destination, formatContext) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return destination.push("</div>");
-    case 4:
+    case 3:
       return destination.push("</svg>");
-    case 5:
+    case 4:
       return destination.push("</math>");
-    case 6:
+    case 5:
       return destination.push("</table>");
-    case 7:
+    case 6:
       return destination.push("</tbody></table>");
-    case 8:
+    case 7:
       return destination.push("</tr></table>");
-    case 9:
+    case 8:
       return destination.push("</colgroup></table>");
     default:
       throw Error(formatProdErrorMessage(397));
@@ -2185,6 +2152,103 @@ function writeStyleResourceAttributeInJS(destination, name, value) {
   attributeName = escapeJSObjectForInstructionScripts(name);
   destination.push(attributeName);
 }
+function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+  destination.push("[");
+  var nextArrayOpenBrackChunk = "[";
+  hoistableState.stylesheets.forEach(function (resource) {
+    if (2 !== resource.state)
+      if (3 === resource.state)
+        destination.push(nextArrayOpenBrackChunk),
+          (resource = escapeTextForBrowser(
+            JSON.stringify("" + resource.props.href)
+          )),
+          destination.push(resource),
+          destination.push("]"),
+          (nextArrayOpenBrackChunk = ",[");
+      else {
+        destination.push(nextArrayOpenBrackChunk);
+        var precedence = resource.props["data-precedence"],
+          props = resource.props,
+          coercedHref = sanitizeURL("" + resource.props.href);
+        coercedHref = escapeTextForBrowser(JSON.stringify(coercedHref));
+        destination.push(coercedHref);
+        precedence = "" + precedence;
+        destination.push(",");
+        precedence = escapeTextForBrowser(JSON.stringify(precedence));
+        destination.push(precedence);
+        for (var propKey in props)
+          if (
+            hasOwnProperty.call(props, propKey) &&
+            ((precedence = props[propKey]), null != precedence)
+          )
+            switch (propKey) {
+              case "href":
+              case "rel":
+              case "precedence":
+              case "data-precedence":
+                break;
+              case "children":
+              case "dangerouslySetInnerHTML":
+                throw Error(formatProdErrorMessage(399, "link"));
+              default:
+                writeStyleResourceAttributeInAttr(
+                  destination,
+                  propKey,
+                  precedence
+                );
+            }
+        destination.push("]");
+        nextArrayOpenBrackChunk = ",[";
+        resource.state = 3;
+      }
+  });
+  destination.push("]");
+}
+function writeStyleResourceAttributeInAttr(destination, name, value) {
+  var attributeName = name.toLowerCase();
+  switch (typeof value) {
+    case "function":
+    case "symbol":
+      return;
+  }
+  switch (name) {
+    case "innerHTML":
+    case "dangerouslySetInnerHTML":
+    case "suppressContentEditableWarning":
+    case "suppressHydrationWarning":
+    case "style":
+    case "ref":
+      return;
+    case "className":
+      attributeName = "class";
+      name = "" + value;
+      break;
+    case "hidden":
+      if (!1 === value) return;
+      name = "";
+      break;
+    case "src":
+    case "href":
+      value = sanitizeURL(value);
+      name = "" + value;
+      break;
+    default:
+      if (
+        (2 < name.length &&
+          ("o" === name[0] || "O" === name[0]) &&
+          ("n" === name[1] || "N" === name[1])) ||
+        !isAttributeNameSafe(name)
+      )
+        return;
+      name = "" + value;
+  }
+  destination.push(",");
+  attributeName = escapeTextForBrowser(JSON.stringify(attributeName));
+  destination.push(attributeName);
+  destination.push(",");
+  attributeName = escapeTextForBrowser(JSON.stringify(name));
+  destination.push(attributeName);
+}
 function createHoistableState() {
   return { styles: new Set(), stylesheets: new Set() };
 }
@@ -2603,17 +2667,16 @@ function createRenderState(resumableState, generateStaticMarkup) {
       "\x3c/script>"
     );
   bootstrapScriptContent = idPrefix + "P:";
-  var JSCompiler_object_inline_segmentPrefix_1521 = idPrefix + "S:";
+  var JSCompiler_object_inline_segmentPrefix_1641 = idPrefix + "S:";
   idPrefix += "B:";
-  var JSCompiler_object_inline_preamble_1524 = createPreambleState(),
-    JSCompiler_object_inline_preconnects_1534 = new Set(),
-    JSCompiler_object_inline_fontPreloads_1535 = new Set(),
-    JSCompiler_object_inline_highImagePreloads_1536 = new Set(),
-    JSCompiler_object_inline_styles_1537 = new Map(),
-    JSCompiler_object_inline_bootstrapScripts_1538 = new Set(),
-    JSCompiler_object_inline_scripts_1539 = new Set(),
-    JSCompiler_object_inline_bulkPreloads_1540 = new Set(),
-    JSCompiler_object_inline_preloads_1541 = {
+  var JSCompiler_object_inline_preconnects_1655 = new Set(),
+    JSCompiler_object_inline_fontPreloads_1656 = new Set(),
+    JSCompiler_object_inline_highImagePreloads_1657 = new Set(),
+    JSCompiler_object_inline_styles_1658 = new Map(),
+    JSCompiler_object_inline_bootstrapScripts_1659 = new Set(),
+    JSCompiler_object_inline_scripts_1660 = new Set(),
+    JSCompiler_object_inline_bulkPreloads_1661 = new Set(),
+    JSCompiler_object_inline_preloads_1662 = {
       images: new Map(),
       stylesheets: new Map(),
       scripts: new Map(),
@@ -2650,7 +2713,7 @@ function createRenderState(resumableState, generateStaticMarkup) {
       scriptConfig.moduleScriptResources[href] = null;
       scriptConfig = [];
       pushLinkImpl(scriptConfig, props);
-      JSCompiler_object_inline_bootstrapScripts_1538.add(scriptConfig);
+      JSCompiler_object_inline_bootstrapScripts_1659.add(scriptConfig);
       bootstrapChunks.push('<script src="', escapeTextForBrowser(src));
       "string" === typeof integrity &&
         bootstrapChunks.push('" integrity="', escapeTextForBrowser(integrity));
@@ -2691,7 +2754,7 @@ function createRenderState(resumableState, generateStaticMarkup) {
         (props.moduleScriptResources[scriptConfig] = null),
         (props = []),
         pushLinkImpl(props, integrity),
-        JSCompiler_object_inline_bootstrapScripts_1538.add(props),
+        JSCompiler_object_inline_bootstrapScripts_1659.add(props),
         bootstrapChunks.push(
           '<script type="module" src="',
           escapeTextForBrowser(i)
@@ -2706,10 +2769,11 @@ function createRenderState(resumableState, generateStaticMarkup) {
         bootstrapChunks.push('" async="">\x3c/script>');
   return {
     placeholderPrefix: bootstrapScriptContent,
-    segmentPrefix: JSCompiler_object_inline_segmentPrefix_1521,
+    segmentPrefix: JSCompiler_object_inline_segmentPrefix_1641,
     boundaryPrefix: idPrefix,
     startInlineScript: "<script>",
-    preamble: JSCompiler_object_inline_preamble_1524,
+    htmlChunks: null,
+    headChunks: null,
     externalRuntimeScript: null,
     bootstrapChunks: bootstrapChunks,
     importMapChunks: [],
@@ -2725,14 +2789,14 @@ function createRenderState(resumableState, generateStaticMarkup) {
     charsetChunks: [],
     viewportChunks: [],
     hoistableChunks: [],
-    preconnects: JSCompiler_object_inline_preconnects_1534,
-    fontPreloads: JSCompiler_object_inline_fontPreloads_1535,
-    highImagePreloads: JSCompiler_object_inline_highImagePreloads_1536,
-    styles: JSCompiler_object_inline_styles_1537,
-    bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1538,
-    scripts: JSCompiler_object_inline_scripts_1539,
-    bulkPreloads: JSCompiler_object_inline_bulkPreloads_1540,
-    preloads: JSCompiler_object_inline_preloads_1541,
+    preconnects: JSCompiler_object_inline_preconnects_1655,
+    fontPreloads: JSCompiler_object_inline_fontPreloads_1656,
+    highImagePreloads: JSCompiler_object_inline_highImagePreloads_1657,
+    styles: JSCompiler_object_inline_styles_1658,
+    bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1659,
+    scripts: JSCompiler_object_inline_scripts_1660,
+    bulkPreloads: JSCompiler_object_inline_bulkPreloads_1661,
+    preloads: JSCompiler_object_inline_preloads_1662,
     stylesToHoist: !1,
     generateStaticMarkup: generateStaticMarkup
   };
@@ -2773,6 +2837,8 @@ function getComponentNameFromType(type) {
       return "Suspense";
     case REACT_SUSPENSE_LIST_TYPE:
       return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
   }
   if ("object" === typeof type)
     switch (type.$$typeof) {
@@ -3092,6 +3158,9 @@ function dispatchAction(componentIdentity, queue, action) {
       queue.next = componentIdentity;
     }
 }
+function throwOnUseEffectEventCall() {
+  throw Error(formatProdErrorMessage(440));
+}
 function unsupportedStartTransition() {
   throw Error(formatProdErrorMessage(394));
 }
@@ -3166,8 +3235,15 @@ function unwrapThenable(thenable) {
   null === thenableState && (thenableState = []);
   return trackUsedThenable(thenableState, thenable, index);
 }
-function unsupportedRefresh() {
-  throw Error(formatProdErrorMessage(393));
+function readPreviousThenableFromState() {
+  var index = thenableIndexCounter;
+  thenableIndexCounter += 1;
+  if (null !== thenableState)
+    return (
+      (index = thenableState[index]),
+      (index = void 0 === index ? void 0 : index.value),
+      index
+    );
 }
 function noop$1() {}
 var HooksDispatcher = {
@@ -3250,13 +3326,8 @@ var HooksDispatcher = {
       resolveCurrentlyRenderingComponent();
       return sharedNotPendingObject;
     },
-    useMemoCache: function (size) {
-      for (var data = Array(size), i = 0; i < size; i++)
-        data[i] = REACT_MEMO_CACHE_SENTINEL;
-      return data;
-    },
-    useCacheRefresh: function () {
-      return unsupportedRefresh;
+    useEffectEvent: function () {
+      return throwOnUseEffectEventCall;
     }
   },
   currentResumableState = null,
@@ -3453,6 +3524,8 @@ function describeComponentStackByType(type) {
       return describeBuiltInComponentFrame("SuspenseList");
     case REACT_SUSPENSE_TYPE:
       return describeBuiltInComponentFrame("Suspense");
+    case REACT_VIEW_TRANSITION_TYPE:
+      return describeBuiltInComponentFrame("ViewTransition");
   }
   return "";
 }
@@ -3503,7 +3576,7 @@ function RequestInstance(
   this.status = 10;
   this.fatalError = null;
   this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-  this.completedPreambleSegments = this.completedRootSegment = null;
+  this.completedRootSegment = null;
   this.abortableTasks = abortSet;
   this.pingedTasks = [];
   this.clientRenderedBoundaries = [];
@@ -3562,7 +3635,6 @@ function createRequest(
     null,
     renderState,
     null,
-    null,
     resumableState.abortableTasks,
     null,
     rootFormatContext,
@@ -3582,12 +3654,7 @@ function pingTask(request, task) {
     ((request.flushScheduled = null !== request.destination),
     performWork(request));
 }
-function createSuspenseBoundary(
-  request,
-  fallbackAbortableTasks,
-  contentPreamble,
-  fallbackPreamble
-) {
+function createSuspenseBoundary(request, fallbackAbortableTasks) {
   return {
     status: 0,
     rootSegmentID: -1,
@@ -3599,8 +3666,6 @@ function createSuspenseBoundary(
     errorDigest: null,
     contentState: createHoistableState(),
     fallbackState: createHoistableState(),
-    contentPreamble: contentPreamble,
-    fallbackPreamble: fallbackPreamble,
     trackedContentKeyPath: null,
     trackedFallbackNode: null
   };
@@ -3612,7 +3677,6 @@ function createRenderTask(
   childIndex,
   blockedBoundary,
   blockedSegment,
-  blockedPreamble,
   hoistableState,
   abortSet,
   keyPath,
@@ -3635,7 +3699,6 @@ function createRenderTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: blockedSegment,
-    blockedPreamble: blockedPreamble,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -3679,7 +3742,6 @@ function createReplayTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: null,
-    blockedPreamble: null,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -3703,12 +3765,11 @@ function createPendingSegment(
 ) {
   return {
     status: 0,
-    parentFlushed: !1,
     id: -1,
     index: index,
+    parentFlushed: !1,
     chunks: [],
     children: [],
-    preambleChildren: [],
     parentFormatContext: parentFormatContext,
     boundary: boundary,
     lastPushedText: lastPushedText,
@@ -3750,6 +3811,10 @@ function getThrownInfo(node$jscomp$0) {
     });
   return errorInfo;
 }
+function logPostpone(request, reason, postponeInfo) {
+  request = request.onPostpone;
+  request(reason, postponeInfo);
+}
 function logRecoverableError(request, error, errorInfo) {
   request = request.onError;
   error = request(error, errorInfo);
@@ -3936,13 +4001,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
         (task.formatContext = defaultProps),
         (task.keyPath = initialState);
     else {
-      ref = pushStartInstance(
+      initialState = pushStartInstance(
         newProps.chunks,
         type,
         props,
         request.resumableState,
         request.renderState,
-        task.blockedPreamble,
         task.hoistableState,
         task.formatContext,
         newProps.lastPushedText,
@@ -3950,42 +4014,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
       );
       newProps.lastPushedText = !1;
       defaultProps = task.formatContext;
-      initialState = task.keyPath;
+      ref = task.keyPath;
+      task.formatContext = getChildFormatContext(defaultProps, type, props);
       task.keyPath = keyPath;
-      3 ===
-      (task.formatContext = getChildFormatContext(defaultProps, type, props))
-        .insertionMode
-        ? ((keyPath = createPendingSegment(
-            request,
-            0,
-            null,
-            task.formatContext,
-            !1,
-            !1
-          )),
-          newProps.preambleChildren.push(keyPath),
-          (keyPath = createRenderTask(
-            request,
-            null,
-            ref,
-            -1,
-            task.blockedBoundary,
-            keyPath,
-            task.blockedPreamble,
-            task.hoistableState,
-            request.abortableTasks,
-            task.keyPath,
-            task.formatContext,
-            task.context,
-            task.treeContext,
-            task.componentStack,
-            task.isFallback
-          )),
-          pushComponentStack(keyPath),
-          request.pingedTasks.push(keyPath))
-        : renderNode(request, task, ref, -1);
+      renderNode(request, task, initialState, -1);
       task.formatContext = defaultProps;
-      task.keyPath = initialState;
+      task.keyPath = ref;
       a: {
         task = newProps.chunks;
         request = request.resumableState;
@@ -4020,9 +4054,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
               request.hasHtml = !0;
               break a;
             }
-            break;
-          case "head":
-            if (1 >= defaultProps.insertionMode) break a;
         }
         task.push(endChunkForTag(type));
       }
@@ -4053,6 +4084,11 @@ function renderElement(request, task, keyPath, type, props, ref) {
         task.keyPath = type;
         return;
       case REACT_VIEW_TRANSITION_TYPE:
+        type = task.keyPath;
+        task.keyPath = keyPath;
+        renderNodeDestructive(request, task, props.children, -1);
+        task.keyPath = type;
+        return;
       case REACT_SCOPE_TYPE:
         throw Error(formatProdErrorMessage(343));
       case REACT_SUSPENSE_TYPE:
@@ -4067,34 +4103,25 @@ function renderElement(request, task, keyPath, type, props, ref) {
           }
         } else {
           type = task.keyPath;
-          var parentBoundary = task.blockedBoundary;
-          ref = task.blockedPreamble;
-          var parentHoistableState = task.hoistableState;
-          propName$33 = task.blockedSegment;
-          propName = props.fallback;
+          var parentBoundary = task.blockedBoundary,
+            parentHoistableState = task.hoistableState;
+          ref = task.blockedSegment;
+          propName$33 = props.fallback;
           props = props.children;
           var fallbackAbortSet = new Set();
-          var newBoundary =
-            2 > task.formatContext.insertionMode
-              ? createSuspenseBoundary(
-                  request,
-                  fallbackAbortSet,
-                  createPreambleState(),
-                  createPreambleState()
-                )
-              : createSuspenseBoundary(request, fallbackAbortSet, null, null);
+          propName = createSuspenseBoundary(request, fallbackAbortSet);
           null !== request.trackedPostpones &&
-            (newBoundary.trackedContentKeyPath = keyPath);
+            (propName.trackedContentKeyPath = keyPath);
           var boundarySegment = createPendingSegment(
             request,
-            propName$33.chunks.length,
-            newBoundary,
+            ref.chunks.length,
+            propName,
             task.formatContext,
             !1,
             !1
           );
-          propName$33.children.push(boundarySegment);
-          propName$33.lastPushedText = !1;
+          ref.children.push(boundarySegment);
+          ref.lastPushedText = !1;
           var contentRootSegment = createPendingSegment(
             request,
             0,
@@ -4108,13 +4135,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
             newProps = [keyPath[0], "Suspense Fallback", keyPath[2]];
             defaultProps = [newProps[1], newProps[2], [], null];
             request.trackedPostpones.workingMap.set(newProps, defaultProps);
-            newBoundary.trackedFallbackNode = defaultProps;
+            propName.trackedFallbackNode = defaultProps;
             task.blockedSegment = boundarySegment;
-            task.blockedPreamble = newBoundary.fallbackPreamble;
             task.keyPath = newProps;
             boundarySegment.status = 6;
             try {
-              renderNode(request, task, propName, -1),
+              renderNode(request, task, propName$33, -1),
                 pushSegmentFinale(
                   boundarySegment.chunks,
                   request.renderState,
@@ -4128,19 +4154,16 @@ function renderElement(request, task, keyPath, type, props, ref) {
                 thrownValue)
               );
             } finally {
-              (task.blockedSegment = propName$33),
-                (task.blockedPreamble = ref),
-                (task.keyPath = type);
+              (task.blockedSegment = ref), (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
               props,
               -1,
-              newBoundary,
+              propName,
               contentRootSegment,
-              newBoundary.contentPreamble,
-              newBoundary.contentState,
+              propName.contentState,
               task.abortSet,
               keyPath,
               task.formatContext,
@@ -4152,9 +4175,8 @@ function renderElement(request, task, keyPath, type, props, ref) {
             pushComponentStack(task);
             request.pingedTasks.push(task);
           } else {
-            task.blockedBoundary = newBoundary;
-            task.blockedPreamble = newBoundary.contentPreamble;
-            task.hoistableState = newBoundary.contentState;
+            task.blockedBoundary = propName;
+            task.hoistableState = propName.contentState;
             task.blockedSegment = contentRootSegment;
             task.keyPath = keyPath;
             contentRootSegment.status = 6;
@@ -4168,46 +4190,46 @@ function renderElement(request, task, keyPath, type, props, ref) {
                   contentRootSegment.textEmbedded
                 ),
                 (contentRootSegment.status = 1),
-                queueCompletedSegment(newBoundary, contentRootSegment),
-                0 === newBoundary.pendingTasks && 0 === newBoundary.status)
+                queueCompletedSegment(propName, contentRootSegment),
+                0 === propName.pendingTasks && 0 === propName.status)
               ) {
-                newBoundary.status = 1;
-                0 === request.pendingRootTasks &&
-                  task.blockedPreamble &&
-                  preparePreamble(request);
+                propName.status = 1;
                 break a;
               }
             } catch (thrownValue$28) {
-              (newBoundary.status = 4),
+              (propName.status = 4),
                 12 === request.status
                   ? ((contentRootSegment.status = 3),
                     (newProps = request.fatalError))
                   : ((contentRootSegment.status = 4),
                     (newProps = thrownValue$28)),
                 (defaultProps = getThrownInfo(task.componentStack)),
-                (initialState = logRecoverableError(
-                  request,
-                  newProps,
-                  defaultProps
-                )),
-                (newBoundary.errorDigest = initialState),
-                untrackBoundary(request, newBoundary);
+                "object" === typeof newProps &&
+                null !== newProps &&
+                newProps.$$typeof === REACT_POSTPONE_TYPE
+                  ? (logPostpone(request, newProps.message, defaultProps),
+                    (initialState = "POSTPONE"))
+                  : (initialState = logRecoverableError(
+                      request,
+                      newProps,
+                      defaultProps
+                    )),
+                (propName.errorDigest = initialState),
+                untrackBoundary(request, propName);
             } finally {
               (task.blockedBoundary = parentBoundary),
-                (task.blockedPreamble = ref),
                 (task.hoistableState = parentHoistableState),
-                (task.blockedSegment = propName$33),
+                (task.blockedSegment = ref),
                 (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
-              propName,
+              propName$33,
               -1,
               parentBoundary,
               boundarySegment,
-              newBoundary.fallbackPreamble,
-              newBoundary.fallbackState,
+              propName.fallbackState,
               fallbackAbortSet,
               [keyPath[0], "Suspense Fallback", keyPath[2]],
               task.formatContext,
@@ -4226,9 +4248,9 @@ function renderElement(request, task, keyPath, type, props, ref) {
       switch (type.$$typeof) {
         case REACT_FORWARD_REF_TYPE:
           if ("ref" in props)
-            for (newBoundary in ((newProps = {}), props))
-              "ref" !== newBoundary &&
-                (newProps[newBoundary] = props[newBoundary]);
+            for (boundarySegment in ((newProps = {}), props))
+              "ref" !== boundarySegment &&
+                (newProps[boundarySegment] = props[boundarySegment]);
           else newProps = props;
           type = renderWithHooks(
             request,
@@ -4390,16 +4412,13 @@ function retryNode(request, task) {
                         );
                       task.replay.pendingTasks--;
                       props = getThrownInfo(task.componentStack);
-                      key = task.blockedBoundary;
-                      type = x;
-                      props = logRecoverableError(request, type, props);
-                      abortRemainingReplayNodes(
+                      erroredReplay(
                         request,
-                        key,
+                        task.blockedBoundary,
+                        x,
+                        props,
                         childNodes,
-                        name,
-                        type,
-                        props
+                        name
                       );
                     }
                     task.replay = replay;
@@ -4413,9 +4432,9 @@ function retryNode(request, task) {
                         )
                       );
                     b: {
-                      replay = void 0;
-                      type = node$jscomp$0[5];
-                      ref = node$jscomp$0[2];
+                      type = void 0;
+                      ref = node$jscomp$0[5];
+                      replay = node$jscomp$0[2];
                       name = node$jscomp$0[3];
                       keyOrIndex =
                         null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
@@ -4425,30 +4444,20 @@ function retryNode(request, task) {
                         previousReplaySet = task.replay,
                         parentBoundary = task.blockedBoundary,
                         parentHoistableState = task.hoistableState,
-                        content = props.children,
-                        fallback = props.fallback,
-                        fallbackAbortSet = new Set();
-                      props =
-                        2 > task.formatContext.insertionMode
-                          ? createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              createPreambleState(),
-                              createPreambleState()
-                            )
-                          : createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              null,
-                              null
-                            );
-                      props.parentFlushed = !0;
-                      props.rootSegmentID = type;
-                      task.blockedBoundary = props;
-                      task.hoistableState = props.contentState;
+                        content = props.children;
+                      props = props.fallback;
+                      var fallbackAbortSet = new Set(),
+                        resumedBoundary = createSuspenseBoundary(
+                          request,
+                          fallbackAbortSet
+                        );
+                      resumedBoundary.parentFlushed = !0;
+                      resumedBoundary.rootSegmentID = ref;
+                      task.blockedBoundary = resumedBoundary;
+                      task.hoistableState = resumedBoundary.contentState;
                       task.keyPath = key;
                       task.replay = {
-                        nodes: ref,
+                        nodes: replay,
                         slots: name,
                         pendingTasks: 1
                       };
@@ -4460,22 +4469,32 @@ function retryNode(request, task) {
                         )
                           throw Error(formatProdErrorMessage(488));
                         task.replay.pendingTasks--;
-                        if (0 === props.pendingTasks && 0 === props.status) {
-                          props.status = 1;
-                          request.completedBoundaries.push(props);
+                        if (
+                          0 === resumedBoundary.pendingTasks &&
+                          0 === resumedBoundary.status
+                        ) {
+                          resumedBoundary.status = 1;
+                          request.completedBoundaries.push(resumedBoundary);
                           break b;
                         }
                       } catch (error) {
-                        (props.status = 4),
+                        (resumedBoundary.status = 4),
                           (childNodes = getThrownInfo(task.componentStack)),
-                          (replay = logRecoverableError(
-                            request,
-                            error,
-                            childNodes
-                          )),
-                          (props.errorDigest = replay),
+                          "object" === typeof error &&
+                          null !== error &&
+                          error.$$typeof === REACT_POSTPONE_TYPE
+                            ? (logPostpone(request, error.message, childNodes),
+                              (type = "POSTPONE"))
+                            : (type = logRecoverableError(
+                                request,
+                                error,
+                                childNodes
+                              )),
+                          (resumedBoundary.errorDigest = type),
                           task.replay.pendingTasks--,
-                          request.clientRenderedBoundaries.push(props);
+                          request.clientRenderedBoundaries.push(
+                            resumedBoundary
+                          );
                       } finally {
                         (task.blockedBoundary = parentBoundary),
                           (task.hoistableState = parentHoistableState),
@@ -4490,10 +4509,10 @@ function retryNode(request, task) {
                           slots: node$jscomp$0,
                           pendingTasks: 0
                         },
-                        fallback,
+                        props,
                         -1,
                         parentBoundary,
-                        props.fallbackState,
+                        resumedBoundary.fallbackState,
                         fallbackAbortSet,
                         [key[0], "Suspense Fallback", key[2]],
                         task.formatContext,
@@ -4542,6 +4561,31 @@ function retryNode(request, task) {
         }
         return;
       }
+      if (
+        "function" === typeof node[ASYNC_ITERATOR] &&
+        (childNodes = node[ASYNC_ITERATOR]())
+      ) {
+        props = task.thenableState;
+        task.thenableState = null;
+        thenableIndexCounter = 0;
+        thenableState = props;
+        props = [];
+        key = !1;
+        if (childNodes === node)
+          for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+            if (node.done) {
+              key = !0;
+              break;
+            }
+            props.push(node.value);
+            node = readPreviousThenableFromState();
+          }
+        if (!key)
+          for (node = unwrapThenable(childNodes.next()); !node.done; )
+            props.push(node.value), (node = unwrapThenable(childNodes.next()));
+        renderChildrenArray(request, task, props, childIndex);
+        return;
+      }
       if ("function" === typeof node.then)
         return (
           (task.thenableState = null),
@@ -4554,33 +4598,33 @@ function retryNode(request, task) {
           node._currentValue2,
           childIndex
         );
-      childIndex = Object.prototype.toString.call(node);
+      request = Object.prototype.toString.call(node);
       throw Error(
         formatProdErrorMessage(
           31,
-          "[object Object]" === childIndex
+          "[object Object]" === request
             ? "object with keys {" + Object.keys(node).join(", ") + "}"
-            : childIndex
+            : request
         )
       );
     }
     if ("string" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
     else if ("number" === typeof node || "bigint" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             "" + node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
   }
 }
@@ -4615,16 +4659,13 @@ function renderChildrenArray(request, task, children, childIndex) {
             throw x;
           task.replay.pendingTasks--;
           children = getThrownInfo(task.componentStack);
-          var boundary = task.blockedBoundary,
-            error = x;
-          children = logRecoverableError(request, error, children);
-          abortRemainingReplayNodes(
+          erroredReplay(
             request,
-            boundary,
+            task.blockedBoundary,
+            x,
+            children,
             childIndex,
-            node,
-            error,
-            children
+            node
           );
         }
         task.replay = replay;
@@ -4641,14 +4682,15 @@ function renderChildrenArray(request, task, children, childIndex) {
     null !== task.replay &&
     ((j = task.replay.slots), null !== j && "object" === typeof j)
   ) {
-    for (childIndex = 0; childIndex < replayNodes; childIndex++)
-      (node = children[childIndex]),
-        (task.treeContext = pushTreeContext(replay, replayNodes, childIndex)),
-        (boundary = j[childIndex]),
-        "number" === typeof boundary
-          ? (resumeNode(request, task, boundary, node, childIndex),
-            delete j[childIndex])
-          : renderNode(request, task, node, childIndex);
+    for (childIndex = 0; childIndex < replayNodes; childIndex++) {
+      node = children[childIndex];
+      task.treeContext = pushTreeContext(replay, replayNodes, childIndex);
+      var resumeSegmentID = j[childIndex];
+      "number" === typeof resumeSegmentID
+        ? (resumeNode(request, task, resumeSegmentID, node, childIndex),
+          delete j[childIndex])
+        : renderNode(request, task, node, childIndex);
+    }
     task.treeContext = replay;
     task.keyPath = prevKeyPath;
     return;
@@ -4660,6 +4702,98 @@ function renderChildrenArray(request, task, children, childIndex) {
   task.treeContext = replay;
   task.keyPath = prevKeyPath;
 }
+function trackPostpone(request, trackedPostpones, task, segment) {
+  segment.status = 5;
+  var keyPath = task.keyPath,
+    boundary = task.blockedBoundary;
+  if (null === boundary)
+    (segment.id = request.nextSegmentId++),
+      (trackedPostpones.rootSlots = segment.id),
+      null !== request.completedRootSegment &&
+        (request.completedRootSegment.status = 5);
+  else {
+    if (null !== boundary && 0 === boundary.status) {
+      boundary.status = 5;
+      boundary.rootSegmentID = request.nextSegmentId++;
+      var boundaryKeyPath = boundary.trackedContentKeyPath;
+      if (null === boundaryKeyPath) throw Error(formatProdErrorMessage(486));
+      var fallbackReplayNode = boundary.trackedFallbackNode,
+        children = [];
+      if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+        -1 === segment.id &&
+          (segment.id = segment.parentFlushed
+            ? boundary.rootSegmentID
+            : request.nextSegmentId++);
+        segment = [
+          boundaryKeyPath[1],
+          boundaryKeyPath[2],
+          children,
+          segment.id,
+          fallbackReplayNode,
+          boundary.rootSegmentID
+        ];
+        trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+        addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+        return;
+      }
+      var boundaryNode$44 = trackedPostpones.workingMap.get(boundaryKeyPath);
+      void 0 === boundaryNode$44
+        ? ((boundaryNode$44 = [
+            boundaryKeyPath[1],
+            boundaryKeyPath[2],
+            children,
+            null,
+            fallbackReplayNode,
+            boundary.rootSegmentID
+          ]),
+          trackedPostpones.workingMap.set(boundaryKeyPath, boundaryNode$44),
+          addToReplayParent(
+            boundaryNode$44,
+            boundaryKeyPath[0],
+            trackedPostpones
+          ))
+        : ((boundaryKeyPath = boundaryNode$44),
+          (boundaryKeyPath[4] = fallbackReplayNode),
+          (boundaryKeyPath[5] = boundary.rootSegmentID));
+    }
+    -1 === segment.id &&
+      (segment.id =
+        segment.parentFlushed && null !== boundary
+          ? boundary.rootSegmentID
+          : request.nextSegmentId++);
+    if (-1 === task.childIndex)
+      null === keyPath
+        ? (trackedPostpones.rootSlots = segment.id)
+        : ((task = trackedPostpones.workingMap.get(keyPath)),
+          void 0 === task
+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+              addToReplayParent(task, keyPath[0], trackedPostpones))
+            : (task[3] = segment.id));
+    else {
+      if (null === keyPath)
+        if (((request = trackedPostpones.rootSlots), null === request))
+          request = trackedPostpones.rootSlots = {};
+        else {
+          if ("number" === typeof request)
+            throw Error(formatProdErrorMessage(491));
+        }
+      else if (
+        ((boundary = trackedPostpones.workingMap),
+        (boundaryKeyPath = boundary.get(keyPath)),
+        void 0 === boundaryKeyPath)
+      )
+        (request = {}),
+          (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+          boundary.set(keyPath, boundaryKeyPath),
+          addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+      else if (((request = boundaryKeyPath[3]), null === request))
+        request = boundaryKeyPath[3] = {};
+      else if ("number" === typeof request)
+        throw Error(formatProdErrorMessage(491));
+      request[task.childIndex] = segment.id;
+    }
+  }
+}
 function untrackBoundary(request, boundary) {
   request = request.trackedPostpones;
   null !== request &&
@@ -4706,7 +4840,6 @@ function spawnNewSuspendedRenderTask(request, task, thenableState) {
     task.childIndex,
     task.blockedBoundary,
     newSegment,
-    task.blockedPreamble,
     task.hoistableState,
     task.abortSet,
     task.keyPath,
@@ -4730,13 +4863,14 @@ function renderNode(request, task, node, childIndex) {
     } catch (thrownValue) {
       if (
         (resetHooksState(),
-        (node =
+        (childIndex =
           thrownValue === SuspenseException
             ? getSuspendedThenable()
             : thrownValue),
-        "object" === typeof node && null !== node)
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -4748,7 +4882,7 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedReplayTask(request, task, node);
           request.pingedTasks.push(node);
@@ -4767,18 +4901,19 @@ function renderNode(request, task, node, childIndex) {
       chunkLength = segment.chunks.length;
     try {
       return renderNodeDestructive(request, task, node, childIndex);
-    } catch (thrownValue$48) {
+    } catch (thrownValue$56) {
       if (
         (resetHooksState(),
         (segment.children.length = childrenLength),
         (segment.chunks.length = chunkLength),
-        (node =
-          thrownValue$48 === SuspenseException
+        (childIndex =
+          thrownValue$56 === SuspenseException
             ? getSuspendedThenable()
-            : thrownValue$48),
-        "object" === typeof node && null !== node)
+            : thrownValue$56),
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -4790,7 +4925,35 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if (
+          childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+          null !== request.trackedPostpones &&
+          null !== task.blockedBoundary
+        ) {
+          node = request.trackedPostpones;
+          segment = getThrownInfo(task.componentStack);
+          logPostpone(request, childIndex.message, segment);
+          childIndex = task.blockedSegment;
+          segment = createPendingSegment(
+            request,
+            childIndex.chunks.length,
+            null,
+            task.formatContext,
+            childIndex.lastPushedText,
+            !0
+          );
+          childIndex.children.push(segment);
+          childIndex.lastPushedText = !1;
+          trackPostpone(request, node, task, segment);
+          task.formatContext = previousFormatContext;
+          task.context = previousContext;
+          task.keyPath = previousKeyPath;
+          task.treeContext = previousTreeContext;
+          task.componentStack = previousComponentStack;
+          switchContext(previousContext);
+          return;
+        }
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedRenderTask(request, task, node);
           request.pingedTasks.push(node);
@@ -4810,7 +4973,29 @@ function renderNode(request, task, node, childIndex) {
   task.keyPath = previousKeyPath;
   task.treeContext = previousTreeContext;
   switchContext(previousContext);
-  throw node;
+  throw childIndex;
+}
+function erroredReplay(
+  request,
+  boundary,
+  error,
+  errorInfo,
+  replayNodes,
+  resumeSlots
+) {
+  "object" === typeof error &&
+  null !== error &&
+  error.$$typeof === REACT_POSTPONE_TYPE
+    ? (logPostpone(request, error.message, errorInfo), (errorInfo = "POSTPONE"))
+    : (errorInfo = logRecoverableError(request, error, errorInfo));
+  abortRemainingReplayNodes(
+    request,
+    boundary,
+    replayNodes,
+    resumeSlots,
+    error,
+    errorInfo
+  );
 }
 function abortTaskSoft(task) {
   var boundary = task.blockedBoundary;
@@ -4840,12 +5025,7 @@ function abortRemainingReplayNodes(
       node = node[5];
       var request = request$jscomp$0,
         errorDigest = errorDigest$jscomp$0,
-        resumedBoundary = createSuspenseBoundary(
-          request,
-          new Set(),
-          null,
-          null
-        );
+        resumedBoundary = createSuspenseBoundary(request, new Set());
       resumedBoundary.parentFlushed = !0;
       resumedBoundary.rootSegmentID = node;
       resumedBoundary.status = 4;
@@ -4872,44 +5052,97 @@ function abortTask(task, request, error) {
     if (6 === segment.status) return;
     segment.status = 3;
   }
-  segment = getThrownInfo(task.componentStack);
+  var errorInfo = getThrownInfo(task.componentStack);
   if (null === boundary) {
     if (13 !== request.status && 14 !== request.status) {
       boundary = task.replay;
       if (null === boundary) {
-        logRecoverableError(request, error, segment);
-        fatalError(request, error);
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? ((boundary = request.trackedPostpones),
+            null !== boundary && null !== segment
+              ? (logPostpone(request, error.message, errorInfo),
+                trackPostpone(request, boundary, task, segment),
+                finishedTask(request, null, segment))
+              : ((task = Error(formatProdErrorMessage(501, error.message))),
+                logRecoverableError(request, task, errorInfo),
+                fatalError(request, task)))
+          : null !== request.trackedPostpones && null !== segment
+            ? ((boundary = request.trackedPostpones),
+              logRecoverableError(request, error, errorInfo),
+              trackPostpone(request, boundary, task, segment),
+              finishedTask(request, null, segment))
+            : (logRecoverableError(request, error, errorInfo),
+              fatalError(request, error));
         return;
       }
       boundary.pendingTasks--;
       0 === boundary.pendingTasks &&
         0 < boundary.nodes.length &&
-        ((task = logRecoverableError(request, error, segment)),
+        ("object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? (logPostpone(request, error.message, errorInfo),
+            (errorInfo = "POSTPONE"))
+          : (errorInfo = logRecoverableError(request, error, errorInfo)),
         abortRemainingReplayNodes(
           request,
           null,
           boundary.nodes,
           boundary.slots,
           error,
-          task
+          errorInfo
         ));
       request.pendingRootTasks--;
       0 === request.pendingRootTasks && completeShell(request);
     }
-  } else
-    boundary.pendingTasks--,
-      4 !== boundary.status &&
-        ((boundary.status = 4),
-        (task = logRecoverableError(request, error, segment)),
-        (boundary.status = 4),
-        (boundary.errorDigest = task),
-        untrackBoundary(request, boundary),
-        boundary.parentFlushed &&
-          request.clientRenderedBoundaries.push(boundary)),
-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-        return abortTask(fallbackTask, request, error);
-      }),
-      boundary.fallbackAbortableTasks.clear();
+  } else {
+    boundary.pendingTasks--;
+    var trackedPostpones$59 = request.trackedPostpones;
+    if (4 !== boundary.status) {
+      if (null !== trackedPostpones$59 && null !== segment)
+        return (
+          "object" === typeof error &&
+          null !== error &&
+          error.$$typeof === REACT_POSTPONE_TYPE
+            ? logPostpone(request, error.message, errorInfo)
+            : logRecoverableError(request, error, errorInfo),
+          trackPostpone(request, trackedPostpones$59, task, segment),
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          }),
+          boundary.fallbackAbortableTasks.clear(),
+          finishedTask(request, boundary, segment)
+        );
+      boundary.status = 4;
+      if (
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+      ) {
+        logPostpone(request, error.message, errorInfo);
+        if (null !== request.trackedPostpones && null !== segment) {
+          trackPostpone(request, request.trackedPostpones, task, segment);
+          finishedTask(request, task.blockedBoundary, segment);
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          });
+          boundary.fallbackAbortableTasks.clear();
+          return;
+        }
+        errorInfo = "POSTPONE";
+      } else errorInfo = logRecoverableError(request, error, errorInfo);
+      boundary.status = 4;
+      boundary.errorDigest = errorInfo;
+      untrackBoundary(request, boundary);
+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
+    }
+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+      return abortTask(fallbackTask, request, error);
+    });
+    boundary.fallbackAbortableTasks.clear();
+  }
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
@@ -4976,7 +5209,6 @@ function safelyEmitEarlyPreloads(request, shellComplete) {
 }
 function completeShell(request) {
   null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-  null === request.trackedPostpones && preparePreamble(request);
   request.onShellError = noop;
   request = request.onShellReady;
   request();
@@ -4989,7 +5221,6 @@ function completeAll(request) {
       : null === request.completedRootSegment ||
           5 !== request.completedRootSegment.status
   );
-  preparePreamble(request);
   request = request.onAllReady;
   request();
 }
@@ -5028,11 +5259,7 @@ function finishedTask(request, boundary, segment) {
               request.completedBoundaries.push(boundary),
             1 === boundary.status &&
               (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),
-              boundary.fallbackAbortableTasks.clear(),
-              0 === request.pendingRootTasks &&
-                null === request.trackedPostpones &&
-                null !== boundary.contentPreamble &&
-                preparePreamble(request)))
+              boundary.fallbackAbortableTasks.clear()))
           : null !== segment &&
             segment.parentFlushed &&
             1 === segment.status &&
@@ -5043,23 +5270,23 @@ function finishedTask(request, boundary, segment) {
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
-function performWork(request$jscomp$2) {
-  if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
+function performWork(request$jscomp$1) {
+  if (14 !== request$jscomp$1.status && 13 !== request$jscomp$1.status) {
     var prevContext = currentActiveSnapshot,
       prevDispatcher = ReactSharedInternals.H;
     ReactSharedInternals.H = HooksDispatcher;
     var prevAsyncDispatcher = ReactSharedInternals.A;
     ReactSharedInternals.A = DefaultAsyncDispatcher;
     var prevRequest = currentRequest;
-    currentRequest = request$jscomp$2;
+    currentRequest = request$jscomp$1;
     var prevResumableState = currentResumableState;
-    currentResumableState = request$jscomp$2.resumableState;
+    currentResumableState = request$jscomp$1.resumableState;
     try {
-      var pingedTasks = request$jscomp$2.pingedTasks,
+      var pingedTasks = request$jscomp$1.pingedTasks,
         i;
       for (i = 0; i < pingedTasks.length; i++) {
         var task = pingedTasks[i],
-          request = request$jscomp$2,
+          request = request$jscomp$1,
           segment = task.blockedSegment;
         if (null === segment) {
           var request$jscomp$0 = request;
@@ -5101,27 +5328,15 @@ function performWork(request$jscomp$2) {
                 task.replay.pendingTasks--;
                 task.abortSet.delete(task);
                 var errorInfo = getThrownInfo(task.componentStack);
-                request = void 0;
-                var request$jscomp$1 = request$jscomp$0,
-                  boundary = task.blockedBoundary,
-                  error$jscomp$0 =
-                    12 === request$jscomp$0.status
-                      ? request$jscomp$0.fatalError
-                      : x,
-                  replayNodes = task.replay.nodes,
-                  resumeSlots = task.replay.slots;
-                request = logRecoverableError(
-                  request$jscomp$1,
-                  error$jscomp$0,
-                  errorInfo
-                );
-                abortRemainingReplayNodes(
-                  request$jscomp$1,
-                  boundary,
-                  replayNodes,
-                  resumeSlots,
-                  error$jscomp$0,
-                  request
+                erroredReplay(
+                  request$jscomp$0,
+                  task.blockedBoundary,
+                  12 === request$jscomp$0.status
+                    ? request$jscomp$0.fatalError
+                    : x,
+                  errorInfo,
+                  task.replay.nodes,
+                  task.replay.slots
                 );
                 request$jscomp$0.pendingRootTasks--;
                 0 === request$jscomp$0.pendingRootTasks &&
@@ -5133,81 +5348,127 @@ function performWork(request$jscomp$2) {
             } finally {
             }
           }
-        } else if (
-          ((request$jscomp$0 = void 0),
-          (request$jscomp$1 = segment),
-          0 === request$jscomp$1.status)
-        ) {
-          request$jscomp$1.status = 6;
-          switchContext(task.context);
-          var childrenLength = request$jscomp$1.children.length,
-            chunkLength = request$jscomp$1.chunks.length;
-          try {
-            retryNode(request, task),
-              pushSegmentFinale(
-                request$jscomp$1.chunks,
-                request.renderState,
-                request$jscomp$1.lastPushedText,
-                request$jscomp$1.textEmbedded
-              ),
-              task.abortSet.delete(task),
-              (request$jscomp$1.status = 1),
-              finishedTask(request, task.blockedBoundary, request$jscomp$1);
-          } catch (thrownValue) {
-            resetHooksState();
-            request$jscomp$1.children.length = childrenLength;
-            request$jscomp$1.chunks.length = chunkLength;
-            var x$jscomp$0 =
-              thrownValue === SuspenseException
-                ? getSuspendedThenable()
-                : 12 === request.status
-                  ? request.fatalError
-                  : thrownValue;
-            if (
-              "object" === typeof x$jscomp$0 &&
-              null !== x$jscomp$0 &&
-              "function" === typeof x$jscomp$0.then
-            ) {
-              request$jscomp$1.status = 0;
-              task.thenableState = getThenableStateAfterSuspending();
-              var ping$jscomp$0 = task.ping;
-              x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-            } else {
-              var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
-              task.abortSet.delete(task);
-              request$jscomp$1.status = 4;
-              var boundary$jscomp$0 = task.blockedBoundary;
-              request$jscomp$0 = logRecoverableError(
-                request,
-                x$jscomp$0,
-                errorInfo$jscomp$0
-              );
-              null === boundary$jscomp$0
-                ? fatalError(request, x$jscomp$0)
-                : (boundary$jscomp$0.pendingTasks--,
-                  4 !== boundary$jscomp$0.status &&
-                    ((boundary$jscomp$0.status = 4),
-                    (boundary$jscomp$0.errorDigest = request$jscomp$0),
-                    untrackBoundary(request, boundary$jscomp$0),
-                    boundary$jscomp$0.parentFlushed &&
-                      request.clientRenderedBoundaries.push(boundary$jscomp$0),
-                    0 === request.pendingRootTasks &&
-                      null === request.trackedPostpones &&
-                      null !== boundary$jscomp$0.contentPreamble &&
-                      preparePreamble(request)));
-              request.allPendingTasks--;
-              0 === request.allPendingTasks && completeAll(request);
+        } else
+          a: {
+            request$jscomp$0 = void 0;
+            var segment$jscomp$0 = segment;
+            if (0 === segment$jscomp$0.status) {
+              segment$jscomp$0.status = 6;
+              switchContext(task.context);
+              var childrenLength = segment$jscomp$0.children.length,
+                chunkLength = segment$jscomp$0.chunks.length;
+              try {
+                retryNode(request, task),
+                  pushSegmentFinale(
+                    segment$jscomp$0.chunks,
+                    request.renderState,
+                    segment$jscomp$0.lastPushedText,
+                    segment$jscomp$0.textEmbedded
+                  ),
+                  task.abortSet.delete(task),
+                  (segment$jscomp$0.status = 1),
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+              } catch (thrownValue) {
+                resetHooksState();
+                segment$jscomp$0.children.length = childrenLength;
+                segment$jscomp$0.chunks.length = chunkLength;
+                var x$jscomp$0 =
+                  thrownValue === SuspenseException
+                    ? getSuspendedThenable()
+                    : 12 === request.status
+                      ? request.fatalError
+                      : thrownValue;
+                if (
+                  12 === request.status &&
+                  null !== request.trackedPostpones
+                ) {
+                  var trackedPostpones = request.trackedPostpones,
+                    thrownInfo = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? logPostpone(request, x$jscomp$0.message, thrownInfo)
+                    : logRecoverableError(request, x$jscomp$0, thrownInfo);
+                  trackPostpone(
+                    request,
+                    trackedPostpones,
+                    task,
+                    segment$jscomp$0
+                  );
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+                } else {
+                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0) {
+                    if ("function" === typeof x$jscomp$0.then) {
+                      segment$jscomp$0.status = 0;
+                      task.thenableState = getThenableStateAfterSuspending();
+                      var ping$jscomp$0 = task.ping;
+                      x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                      break a;
+                    }
+                    if (
+                      null !== request.trackedPostpones &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ) {
+                      var trackedPostpones$63 = request.trackedPostpones;
+                      task.abortSet.delete(task);
+                      var postponeInfo = getThrownInfo(task.componentStack);
+                      logPostpone(request, x$jscomp$0.message, postponeInfo);
+                      trackPostpone(
+                        request,
+                        trackedPostpones$63,
+                        task,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                      break a;
+                    }
+                  }
+                  var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  segment$jscomp$0.status = 4;
+                  var boundary = task.blockedBoundary;
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        x$jscomp$0.message,
+                        errorInfo$jscomp$0
+                      ),
+                      (request$jscomp$0 = "POSTPONE"))
+                    : (request$jscomp$0 = logRecoverableError(
+                        request,
+                        x$jscomp$0,
+                        errorInfo$jscomp$0
+                      ));
+                  null === boundary
+                    ? fatalError(request, x$jscomp$0)
+                    : (boundary.pendingTasks--,
+                      4 !== boundary.status &&
+                        ((boundary.status = 4),
+                        (boundary.errorDigest = request$jscomp$0),
+                        untrackBoundary(request, boundary),
+                        boundary.parentFlushed &&
+                          request.clientRenderedBoundaries.push(boundary)));
+                  request.allPendingTasks--;
+                  0 === request.allPendingTasks && completeAll(request);
+                }
+              } finally {
+              }
             }
-          } finally {
           }
-        }
       }
       pingedTasks.splice(0, i);
-      null !== request$jscomp$2.destination &&
-        flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
+      null !== request$jscomp$1.destination &&
+        flushCompletedQueues(request$jscomp$1, request$jscomp$1.destination);
     } catch (error) {
-      logRecoverableError(request$jscomp$2, error, {}),
-        fatalError(request$jscomp$2, error);
+      logRecoverableError(request$jscomp$1, error, {}),
+        fatalError(request$jscomp$1, error);
     } finally {
       (currentResumableState = prevResumableState),
         (ReactSharedInternals.H = prevDispatcher),
@@ -5217,82 +5478,6 @@ function performWork(request$jscomp$2) {
     }
   }
 }
-function preparePreambleFromSubtree(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  segment.preambleChildren.length &&
-    collectedPreambleSegments.push(segment.preambleChildren);
-  for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-    pendingPreambles =
-      preparePreambleFromSegment(
-        request,
-        segment.children[i],
-        collectedPreambleSegments
-      ) || pendingPreambles;
-  return pendingPreambles;
-}
-function preparePreambleFromSegment(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  var boundary = segment.boundary;
-  if (null === boundary)
-    return preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    );
-  var preamble = boundary.contentPreamble,
-    fallbackPreamble = boundary.fallbackPreamble;
-  if (null === preamble || null === fallbackPreamble) return !1;
-  switch (boundary.status) {
-    case 1:
-      hoistPreambleState(request.renderState, preamble);
-      segment = boundary.completedSegments[0];
-      if (!segment) throw Error(formatProdErrorMessage(391));
-      return preparePreambleFromSubtree(
-        request,
-        segment,
-        collectedPreambleSegments
-      );
-    case 5:
-      if (null !== request.trackedPostpones) return !0;
-    case 4:
-      if (1 === segment.status)
-        return (
-          hoistPreambleState(request.renderState, fallbackPreamble),
-          preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          )
-        );
-    default:
-      return !0;
-  }
-}
-function preparePreamble(request) {
-  if (
-    request.completedRootSegment &&
-    null === request.completedPreambleSegments
-  ) {
-    var collectedPreambleSegments = [],
-      hasPendingPreambles = preparePreambleFromSegment(
-        request,
-        request.completedRootSegment,
-        collectedPreambleSegments
-      ),
-      preamble = request.renderState.preamble;
-    if (
-      !1 === hasPendingPreambles ||
-      (preamble.headChunks && preamble.bodyChunks)
-    )
-      request.completedPreambleSegments = collectedPreambleSegments;
-  }
-}
 function flushSubtree(request, destination, segment, hoistableState) {
   segment.parentFlushed = !0;
   switch (segment.status) {
@@ -5433,37 +5618,47 @@ function flushCompletedBoundary(request, destination, boundary) {
   boundary = boundary.contentState;
   var requiresStyleInsertion = request.stylesToHoist;
   request.stylesToHoist = !1;
-  destination.push(request.startInlineScript);
-  requiresStyleInsertion
-    ? 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 10),
-        destination.push(
-          '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
-        ))
-      : 0 === (completedSegments.instructions & 8)
-        ? ((completedSegments.instructions |= 8),
-          destination.push(
-            '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
-          ))
-        : destination.push('$RR("')
-    : 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 2),
-        destination.push(
-          '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
-        ))
-      : destination.push('$RC("');
+  var scriptFormat = 0 === completedSegments.streamingFormat;
+  scriptFormat
+    ? (destination.push(request.startInlineScript),
+      requiresStyleInsertion
+        ? 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 10),
+            destination.push(
+              '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
+            ))
+          : 0 === (completedSegments.instructions & 8)
+            ? ((completedSegments.instructions |= 8),
+              destination.push(
+                '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
+              ))
+            : destination.push('$RR("')
+        : 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 2),
+            destination.push(
+              '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
+            ))
+          : destination.push('$RC("'))
+    : requiresStyleInsertion
+      ? destination.push('<template data-rri="" data-bid="')
+      : destination.push('<template data-rci="" data-bid="');
   completedSegments = i.toString(16);
   destination.push(request.boundaryPrefix);
   destination.push(completedSegments);
-  destination.push('","');
+  scriptFormat ? destination.push('","') : destination.push('" data-sid="');
   destination.push(request.segmentPrefix);
   destination.push(completedSegments);
   requiresStyleInsertion
-    ? (destination.push('",'),
-      writeStyleResourceDependenciesInJS(destination, boundary))
-    : destination.push('"');
-  boundary = destination.push(")\x3c/script>");
-  return writeBootstrap(destination, request) && boundary;
+    ? scriptFormat
+      ? (destination.push('",'),
+        writeStyleResourceDependenciesInJS(destination, boundary))
+      : (destination.push('" data-sty="'),
+        writeStyleResourceDependenciesInAttr(destination, boundary))
+    : scriptFormat && destination.push('"');
+  completedSegments = scriptFormat
+    ? destination.push(")\x3c/script>")
+    : destination.push('"></template>');
+  return writeBootstrap(destination, request) && completedSegments;
 }
 function flushPartiallyCompletedSegment(
   request,
@@ -5484,20 +5679,24 @@ function flushPartiallyCompletedSegment(
   flushSegmentContainer(request, destination, segment, hoistableState);
   boundary = request.resumableState;
   request = request.renderState;
-  destination.push(request.startInlineScript);
-  0 === (boundary.instructions & 1)
-    ? ((boundary.instructions |= 1),
-      destination.push(
-        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
-      ))
-    : destination.push('$RS("');
+  (segment = 0 === boundary.streamingFormat)
+    ? (destination.push(request.startInlineScript),
+      0 === (boundary.instructions & 1)
+        ? ((boundary.instructions |= 1),
+          destination.push(
+            '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
+          ))
+        : destination.push('$RS("'))
+    : destination.push('<template data-rsi="" data-sid="');
   destination.push(request.segmentPrefix);
   segmentID = segmentID.toString(16);
   destination.push(segmentID);
-  destination.push('","');
+  segment ? destination.push('","') : destination.push('" data-pid="');
   destination.push(request.placeholderPrefix);
   destination.push(segmentID);
-  destination = destination.push('")\x3c/script>');
+  destination = segment
+    ? destination.push('")\x3c/script>')
+    : destination.push('"></template>');
   return destination;
 }
 function flushCompletedQueues(request, destination) {
@@ -5507,12 +5706,22 @@ function flushCompletedQueues(request, destination) {
         completedRootSegment = request.completedRootSegment;
       if (null !== completedRootSegment) {
         if (5 === completedRootSegment.status) return;
-        var completedPreambleSegments = request.completedPreambleSegments;
-        if (null === completedPreambleSegments) return;
-        var renderState = request.renderState,
-          preamble = renderState.preamble,
-          htmlChunks = preamble.htmlChunks,
-          headChunks = preamble.headChunks,
+        var renderState = request.renderState;
+        if (
+          (0 !== request.allPendingTasks ||
+            null !== request.trackedPostpones) &&
+          renderState.externalRuntimeScript
+        ) {
+          var _renderState$external = renderState.externalRuntimeScript,
+            resumableState = request.resumableState,
+            src = _renderState$external.src,
+            chunks = _renderState$external.chunks;
+          resumableState.scriptResources.hasOwnProperty(src) ||
+            ((resumableState.scriptResources[src] = null),
+            renderState.scripts.add(chunks));
+        }
+        var htmlChunks = renderState.htmlChunks,
+          headChunks = renderState.headChunks,
           i$jscomp$0;
         if (htmlChunks) {
           for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -5555,29 +5764,11 @@ function flushCompletedQueues(request, destination) {
         var hoistableChunks = renderState.hoistableChunks;
         for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
           destination.push(hoistableChunks[i$jscomp$0]);
-        for (
-          renderState = hoistableChunks.length = 0;
-          renderState < completedPreambleSegments.length;
-          renderState++
-        ) {
-          var segments = completedPreambleSegments[renderState];
-          for (preamble = 0; preamble < segments.length; preamble++)
-            flushSegment(request, destination, segments[preamble], null);
-        }
-        var preamble$jscomp$0 = request.renderState.preamble,
-          headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-        if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
+        hoistableChunks.length = 0;
+        if (htmlChunks && null === headChunks) {
           var chunk$jscomp$0 = endChunkForTag("head");
           destination.push(chunk$jscomp$0);
         }
-        var bodyChunks = preamble$jscomp$0.bodyChunks;
-        if (bodyChunks)
-          for (
-            completedPreambleSegments = 0;
-            completedPreambleSegments < bodyChunks.length;
-            completedPreambleSegments++
-          )
-            destination.push(bodyChunks[completedPreambleSegments]);
         flushSegment(request, destination, completedRootSegment, null);
         request.completedRootSegment = null;
         writeBootstrap(destination, request.renderState);
@@ -5618,30 +5809,39 @@ function flushCompletedQueues(request, destination) {
       for (i = 0; i < clientRenderedBoundaries.length; i++) {
         var boundary = clientRenderedBoundaries[i];
         renderState$jscomp$0 = destination;
-        var resumableState = request.resumableState,
+        var resumableState$jscomp$0 = request.resumableState,
           renderState$jscomp$1 = request.renderState,
           id = boundary.rootSegmentID,
-          errorDigest = boundary.errorDigest;
-        renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);
-        0 === (resumableState.instructions & 4)
-          ? ((resumableState.instructions |= 4),
-            renderState$jscomp$0.push(
-              '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
-            ))
-          : renderState$jscomp$0.push('$RX("');
+          errorDigest = boundary.errorDigest,
+          scriptFormat = 0 === resumableState$jscomp$0.streamingFormat;
+        scriptFormat
+          ? (renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript),
+            0 === (resumableState$jscomp$0.instructions & 4)
+              ? ((resumableState$jscomp$0.instructions |= 4),
+                renderState$jscomp$0.push(
+                  '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
+                ))
+              : renderState$jscomp$0.push('$RX("'))
+          : renderState$jscomp$0.push('<template data-rxi="" data-bid="');
         renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);
         var chunk$jscomp$1 = id.toString(16);
         renderState$jscomp$0.push(chunk$jscomp$1);
-        renderState$jscomp$0.push('"');
-        if (errorDigest) {
-          renderState$jscomp$0.push(",");
-          var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
-            errorDigest || ""
-          );
-          renderState$jscomp$0.push(chunk$jscomp$2);
-        }
-        var JSCompiler_inline_result =
-          renderState$jscomp$0.push(")\x3c/script>");
+        scriptFormat && renderState$jscomp$0.push('"');
+        if (errorDigest)
+          if (scriptFormat) {
+            renderState$jscomp$0.push(",");
+            var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
+              errorDigest || ""
+            );
+            renderState$jscomp$0.push(chunk$jscomp$2);
+          } else {
+            renderState$jscomp$0.push('" data-dgst="');
+            var chunk$jscomp$3 = escapeTextForBrowser(errorDigest || "");
+            renderState$jscomp$0.push(chunk$jscomp$3);
+          }
+        var JSCompiler_inline_result = scriptFormat
+          ? renderState$jscomp$0.push(")\x3c/script>")
+          : renderState$jscomp$0.push('"></template>');
         if (!JSCompiler_inline_result) {
           request.destination = null;
           i++;
@@ -5663,11 +5863,11 @@ function flushCompletedQueues(request, destination) {
       completedBoundaries.splice(0, i);
       var partialBoundaries = request.partialBoundaries;
       for (i = 0; i < partialBoundaries.length; i++) {
-        var boundary$51 = partialBoundaries[i];
+        var boundary$66 = partialBoundaries[i];
         a: {
           clientRenderedBoundaries = request;
           boundary = destination;
-          var completedSegments = boundary$51.completedSegments;
+          var completedSegments = boundary$66.completedSegments;
           for (
             JSCompiler_inline_result = 0;
             JSCompiler_inline_result < completedSegments.length;
@@ -5677,7 +5877,7 @@ function flushCompletedQueues(request, destination) {
               !flushPartiallyCompletedSegment(
                 clientRenderedBoundaries,
                 boundary,
-                boundary$51,
+                boundary$66,
                 completedSegments[JSCompiler_inline_result]
               )
             ) {
@@ -5689,7 +5889,7 @@ function flushCompletedQueues(request, destination) {
           completedSegments.splice(0, JSCompiler_inline_result);
           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
             boundary,
-            boundary$51.contentState,
+            boundary$66.contentState,
             clientRenderedBoundaries.renderState
           );
         }
@@ -5717,11 +5917,12 @@ function flushCompletedQueues(request, destination) {
       0 === request.clientRenderedBoundaries.length &&
       0 === request.completedBoundaries.length &&
       ((request.flushScheduled = !1),
-      (i = request.resumableState),
-      i.hasBody &&
-        ((partialBoundaries = endChunkForTag("body")),
-        destination.push(partialBoundaries)),
-      i.hasHtml && ((i = endChunkForTag("html")), destination.push(i)),
+      null === request.trackedPostpones &&
+        ((i = request.resumableState),
+        i.hasBody &&
+          ((partialBoundaries = endChunkForTag("body")),
+          destination.push(partialBoundaries)),
+        i.hasHtml && ((i = endChunkForTag("html")), destination.push(i))),
       (request.status = 14),
       destination.push(null),
       (request.destination = null));
@@ -5773,8 +5974,20 @@ function abort(request, reason) {
     }
     null !== request.destination &&
       flushCompletedQueues(request, request.destination);
-  } catch (error$53) {
-    logRecoverableError(request, error$53, {}), fatalError(request, error$53);
+  } catch (error$68) {
+    logRecoverableError(request, error$68, {}), fatalError(request, error$68);
+  }
+}
+function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+  if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+  else {
+    var workingMap = trackedPostpones.workingMap,
+      parentNode = workingMap.get(parentKeyPath);
+    void 0 === parentNode &&
+      ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+      workingMap.set(parentKeyPath, parentNode),
+      addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+    parentNode[2].push(node);
   }
 }
 function onError() {}
@@ -5788,7 +6001,10 @@ function renderToStringImpl(
     fatalError = null,
     result = "",
     readyToStream = !1;
-  options = createResumableState(options ? options.identifierPrefix : void 0);
+  options = createResumableState(
+    options ? options.identifierPrefix : void 0,
+    void 0
+  );
   children = createRequest(
     children,
     options,
@@ -5840,4 +6056,4 @@ exports.renderToString = function (children, options) {
     'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server'
   );
 };
-exports.version = "19.1.0-canary-c492f975-20250128";
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
diff --git a/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js b/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js
index 91a0128..354a05e 100644
--- a/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js
+++ b/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js
@@ -81,6 +81,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (type.$$typeof) {
@@ -738,10 +740,12 @@
       bootstrapScripts,
       bootstrapModules
     ) {
+      var streamingFormat = ScriptStreamingFormat;
+      void 0 !== externalRuntimeConfig && (streamingFormat = 1);
       return {
         idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
         nextFormID: 0,
-        streamingFormat: 0,
+        streamingFormat: streamingFormat,
         bootstrapScriptContent: bootstrapScriptContent,
         bootstrapScripts: bootstrapScripts,
         bootstrapModules: bootstrapModules,
@@ -758,9 +762,6 @@
         moduleScriptResources: {}
       };
     }
-    function createPreambleState() {
-      return { htmlChunks: null, headChunks: null, bodyChunks: null };
-    }
     function createFormatContext(insertionMode, selectedValue, tagScope) {
       return {
         insertionMode: insertionMode,
@@ -820,26 +821,16 @@
             null,
             parentContext.tagScope
           );
-        case "head":
-          if (parentContext.insertionMode < HTML_MODE)
-            return createFormatContext(
-              HTML_HEAD_MODE,
-              null,
-              parentContext.tagScope
-            );
-          break;
-        case "html":
-          if (parentContext.insertionMode === ROOT_HTML_MODE)
-            return createFormatContext(
-              HTML_HTML_MODE,
-              null,
-              parentContext.tagScope
-            );
       }
-      return parentContext.insertionMode >= HTML_TABLE_MODE ||
-        parentContext.insertionMode < HTML_MODE
+      return parentContext.insertionMode >= HTML_TABLE_MODE
         ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
-        : parentContext;
+        : parentContext.insertionMode === ROOT_HTML_MODE
+          ? "html" === type
+            ? createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope)
+            : createFormatContext(HTML_MODE, null, parentContext.tagScope)
+          : parentContext.insertionMode === HTML_HTML_MODE
+            ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
+            : parentContext;
     }
     function pushStyleAttribute(target, style) {
       if ("object" !== typeof style)
@@ -1342,7 +1333,8 @@
       return content;
     }
     function injectFormReplayingRuntime(resumableState, renderState) {
-      (resumableState.instructions & 16) === NothingSent &&
+      (resumableState.instructions & 16) !== NothingSent ||
+        renderState.externalRuntimeScript ||
         ((resumableState.instructions |= 16),
         renderState.bootstrapChunks.unshift(
           renderState.startInlineScript,
@@ -1507,7 +1499,6 @@
       props,
       resumableState,
       renderState,
-      preambleState,
       hoistableState,
       formatContext,
       textEmbedded,
@@ -2662,13 +2653,13 @@
         case "missing-glyph":
           break;
         case "head":
-          if (formatContext.insertionMode < HTML_MODE) {
-            var preamble = preambleState || renderState.preamble;
-            if (preamble.headChunks)
-              throw Error("The `<head>` tag may only be rendered once.");
-            preamble.headChunks = [];
+          if (
+            formatContext.insertionMode < HTML_MODE &&
+            null === renderState.headChunks
+          ) {
+            renderState.headChunks = [];
             var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-              preamble.headChunks,
+              renderState.headChunks,
               props,
               "head"
             );
@@ -2679,42 +2670,24 @@
               "head"
             );
           return JSCompiler_inline_result$jscomp$9;
-        case "body":
-          if (formatContext.insertionMode < HTML_MODE) {
-            var preamble$jscomp$0 = preambleState || renderState.preamble;
-            if (preamble$jscomp$0.bodyChunks)
-              throw Error("The `<body>` tag may only be rendered once.");
-            preamble$jscomp$0.bodyChunks = [];
-            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-              preamble$jscomp$0.bodyChunks,
-              props,
-              "body"
-            );
-          } else
-            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-              target$jscomp$0,
-              props,
-              "body"
-            );
-          return JSCompiler_inline_result$jscomp$10;
         case "html":
-          if (formatContext.insertionMode === ROOT_HTML_MODE) {
-            var preamble$jscomp$1 = preambleState || renderState.preamble;
-            if (preamble$jscomp$1.htmlChunks)
-              throw Error("The `<html>` tag may only be rendered once.");
-            preamble$jscomp$1.htmlChunks = [doctypeChunk];
-            var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-              preamble$jscomp$1.htmlChunks,
+          if (
+            formatContext.insertionMode === ROOT_HTML_MODE &&
+            null === renderState.htmlChunks
+          ) {
+            renderState.htmlChunks = [doctypeChunk];
+            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+              renderState.htmlChunks,
               props,
               "html"
             );
           } else
-            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
               target$jscomp$0,
               props,
               "html"
             );
-          return JSCompiler_inline_result$jscomp$11;
+          return JSCompiler_inline_result$jscomp$10;
         default:
           if (-1 !== type.indexOf("-")) {
             target$jscomp$0.push(startChunkForTag(type));
@@ -2781,15 +2754,6 @@
         ((chunk = "</" + tag + ">"), endTagCache.set(tag, chunk));
       return chunk;
     }
-    function hoistPreambleState(renderState, preambleState) {
-      renderState = renderState.preamble;
-      null === renderState.htmlChunks &&
-        (renderState.htmlChunks = preambleState.htmlChunks);
-      null === renderState.headChunks &&
-        (renderState.headChunks = preambleState.headChunks);
-      null === renderState.bodyChunks &&
-        (renderState.bodyChunks = preambleState.bodyChunks);
-    }
     function writeBootstrap(destination, renderState) {
       renderState = renderState.bootstrapChunks;
       for (var i = 0; i < renderState.length - 1; i++)
@@ -2813,7 +2777,6 @@
       switch (formatContext.insertionMode) {
         case ROOT_HTML_MODE:
         case HTML_HTML_MODE:
-        case HTML_HEAD_MODE:
         case HTML_MODE:
           return (
             destination.push(startSegmentHTML),
@@ -2878,7 +2841,6 @@
       switch (formatContext.insertionMode) {
         case ROOT_HTML_MODE:
         case HTML_HTML_MODE:
-        case HTML_HEAD_MODE:
         case HTML_MODE:
           return destination.push(endSegmentHTML);
         case SVG_MODE:
@@ -3149,6 +3111,109 @@
       attributeName = escapeJSObjectForInstructionScripts(name);
       destination.push(attributeName);
     }
+    function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+      destination.push(arrayFirstOpenBracket);
+      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
+      hoistableState.stylesheets.forEach(function (resource) {
+        if (resource.state !== PREAMBLE)
+          if (resource.state === LATE)
+            destination.push(nextArrayOpenBrackChunk),
+              (resource = resource.props.href),
+              checkAttributeStringCoercion(resource, "href"),
+              (resource = escapeTextForBrowser(JSON.stringify("" + resource))),
+              destination.push(resource),
+              destination.push(arrayCloseBracket),
+              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);
+          else {
+            destination.push(nextArrayOpenBrackChunk);
+            var precedence = resource.props["data-precedence"],
+              props = resource.props,
+              coercedHref = sanitizeURL("" + resource.props.href);
+            coercedHref = escapeTextForBrowser(JSON.stringify(coercedHref));
+            destination.push(coercedHref);
+            checkAttributeStringCoercion(precedence, "precedence");
+            precedence = "" + precedence;
+            destination.push(arrayInterstitial);
+            precedence = escapeTextForBrowser(JSON.stringify(precedence));
+            destination.push(precedence);
+            for (var propKey in props)
+              if (
+                hasOwnProperty.call(props, propKey) &&
+                ((precedence = props[propKey]), null != precedence)
+              )
+                switch (propKey) {
+                  case "href":
+                  case "rel":
+                  case "precedence":
+                  case "data-precedence":
+                    break;
+                  case "children":
+                  case "dangerouslySetInnerHTML":
+                    throw Error(
+                      "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                    );
+                  default:
+                    writeStyleResourceAttributeInAttr(
+                      destination,
+                      propKey,
+                      precedence
+                    );
+                }
+            destination.push(arrayCloseBracket);
+            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
+            resource.state = LATE;
+          }
+      });
+      destination.push(arrayCloseBracket);
+    }
+    function writeStyleResourceAttributeInAttr(destination, name, value) {
+      var attributeName = name.toLowerCase();
+      switch (typeof value) {
+        case "function":
+        case "symbol":
+          return;
+      }
+      switch (name) {
+        case "innerHTML":
+        case "dangerouslySetInnerHTML":
+        case "suppressContentEditableWarning":
+        case "suppressHydrationWarning":
+        case "style":
+        case "ref":
+          return;
+        case "className":
+          attributeName = "class";
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+          break;
+        case "hidden":
+          if (!1 === value) return;
+          name = "";
+          break;
+        case "src":
+        case "href":
+          value = sanitizeURL(value);
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+          break;
+        default:
+          if (
+            (2 < name.length &&
+              ("o" === name[0] || "O" === name[0]) &&
+              ("n" === name[1] || "N" === name[1])) ||
+            !isAttributeNameSafe(name)
+          )
+            return;
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+      }
+      destination.push(arrayInterstitial);
+      attributeName = escapeTextForBrowser(JSON.stringify(attributeName));
+      destination.push(attributeName);
+      destination.push(arrayInterstitial);
+      attributeName = escapeTextForBrowser(JSON.stringify(name));
+      destination.push(attributeName);
+    }
     function createHoistableState() {
       return { styles: new Set(), stylesheets: new Set() };
     }
@@ -3272,7 +3337,8 @@
         segmentPrefix: idPrefix + "S:",
         boundaryPrefix: idPrefix + "B:",
         startInlineScript: "<script>",
-        preamble: createPreambleState(),
+        htmlChunks: null,
+        headChunks: null,
         externalRuntimeScript: null,
         bootstrapChunks: bootstrapChunks,
         importMapChunks: [],
@@ -3402,7 +3468,8 @@
         segmentPrefix: idPrefix.segmentPrefix,
         boundaryPrefix: idPrefix.boundaryPrefix,
         startInlineScript: idPrefix.startInlineScript,
-        preamble: idPrefix.preamble,
+        htmlChunks: idPrefix.htmlChunks,
+        headChunks: idPrefix.headChunks,
         externalRuntimeScript: idPrefix.externalRuntimeScript,
         bootstrapChunks: idPrefix.bootstrapChunks,
         importMapChunks: idPrefix.importMapChunks,
@@ -3463,6 +3530,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (
@@ -3839,6 +3908,11 @@
           queue.next = componentIdentity;
         }
     }
+    function throwOnUseEffectEventCall() {
+      throw Error(
+        "A function wrapped in useEffectEvent can't be called during rendering."
+      );
+    }
     function unsupportedStartTransition() {
       throw Error("startTransition cannot be called during server rendering.");
     }
@@ -3919,8 +3993,15 @@
       null === thenableState && (thenableState = []);
       return trackUsedThenable(thenableState, thenable, index);
     }
-    function unsupportedRefresh() {
-      throw Error("Cache cannot be refreshed during server rendering.");
+    function readPreviousThenableFromState() {
+      var index = thenableIndexCounter;
+      thenableIndexCounter += 1;
+      if (null !== thenableState)
+        return (
+          (index = thenableState[index]),
+          (index = void 0 === index ? void 0 : index.value),
+          index
+        );
     }
     function noop$1() {}
     function disabledLog() {}
@@ -4142,6 +4223,27 @@
       "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
       return sampleLines;
     }
+    function formatOwnerStack(error) {
+      var prevPrepareStackTrace = Error.prepareStackTrace;
+      Error.prepareStackTrace = void 0;
+      error = error.stack;
+      Error.prepareStackTrace = prevPrepareStackTrace;
+      error.startsWith("Error: react-stack-top-frame\n") &&
+        (error = error.slice(29));
+      prevPrepareStackTrace = error.indexOf("\n");
+      -1 !== prevPrepareStackTrace &&
+        (error = error.slice(prevPrepareStackTrace + 1));
+      prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
+      -1 !== prevPrepareStackTrace &&
+        (prevPrepareStackTrace = error.lastIndexOf(
+          "\n",
+          prevPrepareStackTrace
+        ));
+      if (-1 !== prevPrepareStackTrace)
+        error = error.slice(0, prevPrepareStackTrace);
+      else return "";
+      return error;
+    }
     function describeComponentStackByType(type) {
       if ("string" === typeof type) return describeBuiltInComponentFrame(type);
       if ("function" === typeof type)
@@ -4178,21 +4280,11 @@
           return describeBuiltInComponentFrame("SuspenseList");
         case REACT_SUSPENSE_TYPE:
           return describeBuiltInComponentFrame("Suspense");
+        case REACT_VIEW_TRANSITION_TYPE:
+          return describeBuiltInComponentFrame("ViewTransition");
       }
       return "";
     }
-    function getStackByComponentStackNode(componentStack) {
-      try {
-        var info = "";
-        do
-          (info += describeComponentStackByType(componentStack.type)),
-            (componentStack = componentStack.parent);
-        while (componentStack);
-        return info;
-      } catch (x) {
-        return "\nError generating stack: " + x.message + "\n" + x.stack;
-      }
-    }
     function defaultErrorHandler(error) {
       if (
         "object" === typeof error &&
@@ -4240,7 +4332,7 @@
       this.status = 10;
       this.fatalError = null;
       this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-      this.completedPreambleSegments = this.completedRootSegment = null;
+      this.completedRootSegment = null;
       this.abortableTasks = abortSet;
       this.pingedTasks = [];
       this.clientRenderedBoundaries = [];
@@ -4300,14 +4392,15 @@
         null,
         renderState,
         null,
-        null,
         resumableState.abortableTasks,
         null,
         rootFormatContext,
         null,
         emptyTreeContext,
         null,
-        !1
+        !1,
+        emptyContextObject,
+        null
       );
       pushComponentStack(children);
       resumableState.pingedTasks.push(children);
@@ -4319,12 +4412,7 @@
         ((request.flushScheduled = null !== request.destination),
         performWork(request));
     }
-    function createSuspenseBoundary(
-      request,
-      fallbackAbortableTasks,
-      contentPreamble,
-      fallbackPreamble
-    ) {
+    function createSuspenseBoundary(request, fallbackAbortableTasks) {
       return {
         status: PENDING,
         rootSegmentID: -1,
@@ -4336,8 +4424,6 @@
         errorDigest: null,
         contentState: createHoistableState(),
         fallbackState: createHoistableState(),
-        contentPreamble: contentPreamble,
-        fallbackPreamble: fallbackPreamble,
         trackedContentKeyPath: null,
         trackedFallbackNode: null,
         errorMessage: null,
@@ -4352,7 +4438,6 @@
       childIndex,
       blockedBoundary,
       blockedSegment,
-      blockedPreamble,
       hoistableState,
       abortSet,
       keyPath,
@@ -4360,7 +4445,9 @@
       context,
       treeContext,
       componentStack,
-      isFallback
+      isFallback,
+      legacyContext,
+      debugTask
     ) {
       request.allPendingTasks++;
       null === blockedBoundary
@@ -4375,7 +4462,6 @@
         },
         blockedBoundary: blockedBoundary,
         blockedSegment: blockedSegment,
-        blockedPreamble: blockedPreamble,
         hoistableState: hoistableState,
         abortSet: abortSet,
         keyPath: keyPath,
@@ -4386,6 +4472,7 @@
         thenableState: thenableState,
         isFallback: isFallback
       };
+      task.debugTask = debugTask;
       abortSet.add(task);
       return task;
     }
@@ -4403,7 +4490,9 @@
       context,
       treeContext,
       componentStack,
-      isFallback
+      isFallback,
+      legacyContext,
+      debugTask
     ) {
       request.allPendingTasks++;
       null === blockedBoundary
@@ -4419,7 +4508,6 @@
         },
         blockedBoundary: blockedBoundary,
         blockedSegment: null,
-        blockedPreamble: null,
         hoistableState: hoistableState,
         abortSet: abortSet,
         keyPath: keyPath,
@@ -4430,6 +4518,7 @@
         thenableState: thenableState,
         isFallback: isFallback
       };
+      task.debugTask = debugTask;
       abortSet.add(task);
       return task;
     }
@@ -4443,12 +4532,11 @@
     ) {
       return {
         status: PENDING,
-        parentFlushed: !1,
         id: -1,
         index: index,
+        parentFlushed: !1,
         chunks: [],
         children: [],
-        preambleChildren: [],
         parentFormatContext: parentFormatContext,
         boundary: boundary,
         lastPushedText: lastPushedText,
@@ -4456,22 +4544,63 @@
       };
     }
     function getCurrentStackInDEV() {
-      return null === currentTaskInDEV ||
-        null === currentTaskInDEV.componentStack
-        ? ""
-        : getStackByComponentStackNode(currentTaskInDEV.componentStack);
+      if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
+        return "";
+      var componentStack = currentTaskInDEV.componentStack;
+      try {
+        var info = "";
+        if ("string" === typeof componentStack.type)
+          info += describeBuiltInComponentFrame(componentStack.type);
+        else if ("function" === typeof componentStack.type) {
+          if (!componentStack.owner) {
+            var JSCompiler_temp_const = info,
+              fn = componentStack.type,
+              name = fn ? fn.displayName || fn.name : "";
+            var JSCompiler_inline_result = name
+              ? describeBuiltInComponentFrame(name)
+              : "";
+            info = JSCompiler_temp_const + JSCompiler_inline_result;
+          }
+        } else
+          componentStack.owner ||
+            (info += describeComponentStackByType(componentStack.type));
+        for (; componentStack; )
+          (JSCompiler_temp_const = null),
+            null != componentStack.debugStack
+              ? (JSCompiler_temp_const = formatOwnerStack(
+                  componentStack.debugStack
+                ))
+              : ((JSCompiler_inline_result = componentStack),
+                null != JSCompiler_inline_result.stack &&
+                  (JSCompiler_temp_const =
+                    "string" !== typeof JSCompiler_inline_result.stack
+                      ? (JSCompiler_inline_result.stack = formatOwnerStack(
+                          JSCompiler_inline_result.stack
+                        ))
+                      : JSCompiler_inline_result.stack)),
+            (componentStack = componentStack.owner) &&
+              JSCompiler_temp_const &&
+              (info += "\n" + JSCompiler_temp_const);
+        var JSCompiler_inline_result$jscomp$0 = info;
+      } catch (x) {
+        JSCompiler_inline_result$jscomp$0 =
+          "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+      return JSCompiler_inline_result$jscomp$0;
     }
     function pushServerComponentStack(task, debugInfo) {
       if (null != debugInfo)
         for (var i = 0; i < debugInfo.length; i++) {
           var componentInfo = debugInfo[i];
           "string" === typeof componentInfo.name &&
-            (task.componentStack = {
+            void 0 !== componentInfo.debugStack &&
+            ((task.componentStack = {
               parent: task.componentStack,
               type: componentInfo,
               owner: componentInfo.owner,
-              stack: null
-            });
+              stack: componentInfo.debugStack
+            }),
+            (task.debugTask = componentInfo.debugTask));
         }
     }
     function pushComponentStack(task) {
@@ -4480,13 +4609,15 @@
         switch (node.$$typeof) {
           case REACT_ELEMENT_TYPE:
             var type = node.type,
-              owner = node._owner;
+              owner = node._owner,
+              stack = node._debugStack;
             pushServerComponentStack(task, node._debugInfo);
+            task.debugTask = node._debugTask;
             task.componentStack = {
               parent: task.componentStack,
               type: type,
               owner: owner,
-              stack: null
+              stack: stack
             };
             break;
           case REACT_LAZY_TYPE:
@@ -4497,14 +4628,24 @@
               pushServerComponentStack(task, node._debugInfo);
         }
     }
-    function getThrownInfo(node) {
+    function getThrownInfo(node$jscomp$0) {
       var errorInfo = {};
-      node &&
+      node$jscomp$0 &&
         Object.defineProperty(errorInfo, "componentStack", {
           configurable: !0,
           enumerable: !0,
           get: function () {
-            var stack = getStackByComponentStackNode(node);
+            try {
+              var info = "",
+                node = node$jscomp$0;
+              do
+                (info += describeComponentStackByType(node.type)),
+                  (node = node.parent);
+              while (node);
+              var stack = info;
+            } catch (x) {
+              stack = "\nError generating stack: " + x.message + "\n" + x.stack;
+            }
             Object.defineProperty(errorInfo, "componentStack", {
               value: stack
             });
@@ -4535,9 +4676,17 @@
       boundary.errorStack = null !== error ? wasAborted + error : null;
       boundary.errorComponentStack = thrownInfo.componentStack;
     }
-    function logRecoverableError(request, error, errorInfo) {
+    function logPostpone(request, reason, postponeInfo, debugTask) {
+      request = request.onPostpone;
+      debugTask
+        ? debugTask.run(request.bind(null, reason, postponeInfo))
+        : request(reason, postponeInfo);
+    }
+    function logRecoverableError(request, error, errorInfo, debugTask) {
       request = request.onError;
-      error = request(error, errorInfo);
+      error = debugTask
+        ? debugTask.run(request.bind(null, error, errorInfo))
+        : request(error, errorInfo);
       if (null != error && "string" !== typeof error)
         console.error(
           'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
@@ -4545,11 +4694,13 @@
         );
       else return error;
     }
-    function fatalError(request, error) {
-      var onShellError = request.onShellError,
-        onFatalError = request.onFatalError;
-      onShellError(error);
-      onFatalError(error);
+    function fatalError(request, error, errorInfo, debugTask) {
+      errorInfo = request.onShellError;
+      var onFatalError = request.onFatalError;
+      debugTask
+        ? (debugTask.run(errorInfo.bind(null, error)),
+          debugTask.run(onFatalError.bind(null, error)))
+        : (errorInfo(error), onFatalError(error));
       null !== request.destination
         ? ((request.status = CLOSED), request.destination.destroy(error))
         : ((request.status = 13), (request.fatalError = error));
@@ -5088,7 +5239,6 @@
             props,
             request.resumableState,
             request.renderState,
-            task.blockedPreamble,
             task.hoistableState,
             task.formatContext,
             segment.lastPushedText,
@@ -5097,43 +5247,9 @@
           segment.lastPushedText = !1;
           var _prevContext = task.formatContext,
             _prevKeyPath2 = task.keyPath;
+          task.formatContext = getChildFormatContext(_prevContext, type, props);
           task.keyPath = keyPath;
-          if (
-            (task.formatContext = getChildFormatContext(
-              _prevContext,
-              type,
-              props
-            )).insertionMode === HTML_HEAD_MODE
-          ) {
-            var preambleSegment = createPendingSegment(
-              request,
-              0,
-              null,
-              task.formatContext,
-              !1,
-              !1
-            );
-            segment.preambleChildren.push(preambleSegment);
-            var preambleTask = createRenderTask(
-              request,
-              null,
-              _children,
-              -1,
-              task.blockedBoundary,
-              preambleSegment,
-              task.blockedPreamble,
-              task.hoistableState,
-              request.abortableTasks,
-              task.keyPath,
-              task.formatContext,
-              task.context,
-              task.treeContext,
-              task.componentStack,
-              task.isFallback
-            );
-            pushComponentStack(preambleTask);
-            request.pingedTasks.push(preambleTask);
-          } else renderNode(request, task, _children, -1);
+          renderNode(request, task, _children, -1);
           task.formatContext = _prevContext;
           task.keyPath = _prevKeyPath2;
           a: {
@@ -5170,9 +5286,6 @@
                   resumableState.hasHtml = !0;
                   break a;
                 }
-                break;
-              case "head":
-                if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;
             }
             target.push(endChunkForTag(type));
           }
@@ -5204,6 +5317,11 @@
             task.keyPath = _prevKeyPath3;
             return;
           case REACT_VIEW_TRANSITION_TYPE:
+            var _prevKeyPath4 = task.keyPath;
+            task.keyPath = keyPath;
+            renderNodeDestructive(request, task, props.children, -1);
+            task.keyPath = _prevKeyPath4;
+            return;
           case REACT_SCOPE_TYPE:
             throw Error(
               "ReactDOMServer does not yet support scope components."
@@ -5221,26 +5339,12 @@
             } else {
               var prevKeyPath$jscomp$3 = task.keyPath,
                 parentBoundary = task.blockedBoundary,
-                parentPreamble = task.blockedPreamble,
                 parentHoistableState = task.hoistableState,
                 parentSegment = task.blockedSegment,
                 fallback = props.fallback,
                 content = props.children,
-                fallbackAbortSet = new Set();
-              var newBoundary =
-                task.formatContext.insertionMode < HTML_MODE
-                  ? createSuspenseBoundary(
-                      request,
-                      fallbackAbortSet,
-                      createPreambleState(),
-                      createPreambleState()
-                    )
-                  : createSuspenseBoundary(
-                      request,
-                      fallbackAbortSet,
-                      null,
-                      null
-                    );
+                fallbackAbortSet = new Set(),
+                newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
               null !== request.trackedPostpones &&
                 (newBoundary.trackedContentKeyPath = keyPath);
               var boundarySegment = createPendingSegment(
@@ -5280,7 +5384,6 @@
                 );
                 newBoundary.trackedFallbackNode = fallbackReplayNode;
                 task.blockedSegment = boundarySegment;
-                task.blockedPreamble = newBoundary.fallbackPreamble;
                 task.keyPath = fallbackKeyPath;
                 boundarySegment.status = 6;
                 try {
@@ -5299,7 +5402,6 @@
                   );
                 } finally {
                   (task.blockedSegment = parentSegment),
-                    (task.blockedPreamble = parentPreamble),
                     (task.keyPath = prevKeyPath$jscomp$3);
                 }
                 var suspendedPrimaryTask = createRenderTask(
@@ -5309,7 +5411,6 @@
                   -1,
                   newBoundary,
                   contentRootSegment,
-                  newBoundary.contentPreamble,
                   newBoundary.contentState,
                   task.abortSet,
                   keyPath,
@@ -5317,13 +5418,14 @@
                   task.context,
                   task.treeContext,
                   task.componentStack,
-                  task.isFallback
+                  task.isFallback,
+                  emptyContextObject,
+                  task.debugTask
                 );
                 pushComponentStack(suspendedPrimaryTask);
                 request.pingedTasks.push(suspendedPrimaryTask);
               } else {
                 task.blockedBoundary = newBoundary;
-                task.blockedPreamble = newBoundary.contentPreamble;
                 task.hoistableState = newBoundary.contentState;
                 task.blockedSegment = contentRootSegment;
                 task.keyPath = keyPath;
@@ -5343,9 +5445,6 @@
                       newBoundary.status === PENDING)
                   ) {
                     newBoundary.status = COMPLETED;
-                    0 === request.pendingRootTasks &&
-                      task.blockedPreamble &&
-                      preparePreamble(request);
                     break a;
                   }
                 } catch (thrownValue$2) {
@@ -5356,11 +5455,25 @@
                   } else
                     (contentRootSegment.status = 4), (error = thrownValue$2);
                   var thrownInfo = getThrownInfo(task.componentStack);
-                  var errorDigest = logRecoverableError(
-                    request,
-                    error,
-                    thrownInfo
-                  );
+                  if (
+                    "object" === typeof error &&
+                    null !== error &&
+                    error.$$typeof === REACT_POSTPONE_TYPE
+                  ) {
+                    logPostpone(
+                      request,
+                      error.message,
+                      thrownInfo,
+                      task.debugTask
+                    );
+                    var errorDigest = "POSTPONE";
+                  } else
+                    errorDigest = logRecoverableError(
+                      request,
+                      error,
+                      thrownInfo,
+                      task.debugTask
+                    );
                   encodeErrorForBoundary(
                     newBoundary,
                     errorDigest,
@@ -5371,7 +5484,6 @@
                   untrackBoundary(request, newBoundary);
                 } finally {
                   (task.blockedBoundary = parentBoundary),
-                    (task.blockedPreamble = parentPreamble),
                     (task.hoistableState = parentHoistableState),
                     (task.blockedSegment = parentSegment),
                     (task.keyPath = prevKeyPath$jscomp$3);
@@ -5383,7 +5495,6 @@
                   -1,
                   parentBoundary,
                   boundarySegment,
-                  newBoundary.fallbackPreamble,
                   newBoundary.fallbackState,
                   fallbackAbortSet,
                   [keyPath[0], "Suspense Fallback", keyPath[2]],
@@ -5391,7 +5502,9 @@
                   task.context,
                   task.treeContext,
                   task.componentStack,
-                  !0
+                  !0,
+                  emptyContextObject,
+                  task.debugTask
                 );
                 pushComponentStack(suspendedFallbackTask);
                 request.pingedTasks.push(suspendedFallbackTask);
@@ -5543,15 +5656,186 @@
         (task.replay = prevReplay), (task.blockedSegment = null);
       }
     }
+    function replayElement(
+      request,
+      task,
+      keyPath,
+      name,
+      keyOrIndex,
+      childIndex,
+      type,
+      props,
+      ref,
+      replay
+    ) {
+      childIndex = replay.nodes;
+      for (var i = 0; i < childIndex.length; i++) {
+        var node = childIndex[i];
+        if (keyOrIndex === node[1]) {
+          if (4 === node.length) {
+            if (null !== name && name !== node[0])
+              throw Error(
+                "Expected the resume to render <" +
+                  node[0] +
+                  "> in this slot but instead it rendered <" +
+                  name +
+                  ">. The tree doesn't match so React will fallback to client rendering."
+              );
+            var childNodes = node[2];
+            node = node[3];
+            name = task.node;
+            task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
+            try {
+              renderElement(request, task, keyPath, type, props, ref);
+              if (
+                1 === task.replay.pendingTasks &&
+                0 < task.replay.nodes.length
+              )
+                throw Error(
+                  "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+                );
+              task.replay.pendingTasks--;
+            } catch (x) {
+              if (
+                "object" === typeof x &&
+                null !== x &&
+                (x === SuspenseException || "function" === typeof x.then)
+              )
+                throw (task.node === name && (task.replay = replay), x);
+              task.replay.pendingTasks--;
+              props = getThrownInfo(task.componentStack);
+              erroredReplay(
+                request,
+                task.blockedBoundary,
+                x,
+                props,
+                childNodes,
+                node,
+                task.debugTask
+              );
+            }
+            task.replay = replay;
+          } else {
+            if (type !== REACT_SUSPENSE_TYPE)
+              throw Error(
+                "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
+                  (getComponentNameFromType(type) || "Unknown") +
+                  ">. The tree doesn't match so React will fallback to client rendering."
+              );
+            a: {
+              replay = void 0;
+              type = node[5];
+              ref = node[2];
+              name = node[3];
+              keyOrIndex = null === node[4] ? [] : node[4][2];
+              node = null === node[4] ? null : node[4][3];
+              var prevKeyPath = task.keyPath,
+                previousReplaySet = task.replay,
+                parentBoundary = task.blockedBoundary,
+                parentHoistableState = task.hoistableState,
+                content = props.children;
+              props = props.fallback;
+              var fallbackAbortSet = new Set(),
+                resumedBoundary = createSuspenseBoundary(
+                  request,
+                  fallbackAbortSet
+                );
+              resumedBoundary.parentFlushed = !0;
+              resumedBoundary.rootSegmentID = type;
+              task.blockedBoundary = resumedBoundary;
+              task.hoistableState = resumedBoundary.contentState;
+              task.keyPath = keyPath;
+              task.replay = { nodes: ref, slots: name, pendingTasks: 1 };
+              try {
+                renderNode(request, task, content, -1);
+                if (
+                  1 === task.replay.pendingTasks &&
+                  0 < task.replay.nodes.length
+                )
+                  throw Error(
+                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+                  );
+                task.replay.pendingTasks--;
+                if (
+                  0 === resumedBoundary.pendingTasks &&
+                  resumedBoundary.status === PENDING
+                ) {
+                  resumedBoundary.status = COMPLETED;
+                  request.completedBoundaries.push(resumedBoundary);
+                  break a;
+                }
+              } catch (error) {
+                (resumedBoundary.status = CLIENT_RENDERED),
+                  (childNodes = getThrownInfo(task.componentStack)),
+                  "object" === typeof error &&
+                  null !== error &&
+                  error.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        error.message,
+                        childNodes,
+                        task.debugTask
+                      ),
+                      (replay = "POSTPONE"))
+                    : (replay = logRecoverableError(
+                        request,
+                        error,
+                        childNodes,
+                        task.debugTask
+                      )),
+                  encodeErrorForBoundary(
+                    resumedBoundary,
+                    replay,
+                    error,
+                    childNodes,
+                    !1
+                  ),
+                  task.replay.pendingTasks--,
+                  request.clientRenderedBoundaries.push(resumedBoundary);
+              } finally {
+                (task.blockedBoundary = parentBoundary),
+                  (task.hoistableState = parentHoistableState),
+                  (task.replay = previousReplaySet),
+                  (task.keyPath = prevKeyPath);
+              }
+              props = createReplayTask(
+                request,
+                null,
+                { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
+                props,
+                -1,
+                parentBoundary,
+                resumedBoundary.fallbackState,
+                fallbackAbortSet,
+                [keyPath[0], "Suspense Fallback", keyPath[2]],
+                task.formatContext,
+                task.context,
+                task.treeContext,
+                task.componentStack,
+                !0,
+                emptyContextObject,
+                task.debugTask
+              );
+              pushComponentStack(props);
+              request.pingedTasks.push(props);
+            }
+          }
+          childIndex.splice(i, 1);
+          break;
+        }
+      }
+    }
     function renderNodeDestructive(request, task, node, childIndex) {
       null !== task.replay && "number" === typeof task.replay.slots
         ? resumeNode(request, task, task.replay.slots, node, childIndex)
         : ((task.node = node),
           (task.childIndex = childIndex),
           (node = task.componentStack),
+          (childIndex = task.debugTask),
           pushComponentStack(task),
           retryNode(request, task),
-          (task.componentStack = node));
+          (task.componentStack = node),
+          (task.debugTask = childIndex));
     }
     function retryNode(request, task) {
       var node = task.node,
@@ -5561,178 +5845,56 @@
           switch (node.$$typeof) {
             case REACT_ELEMENT_TYPE:
               var type = node.type,
-                key = node.key,
-                props = node.props;
-              node = props.ref;
-              var ref = void 0 !== node ? node : null,
-                name = getComponentNameFromType(type),
-                keyOrIndex =
-                  null == key ? (-1 === childIndex ? 0 : childIndex) : key,
-                keyPath = [task.keyPath, name, keyOrIndex];
-              if (null !== task.replay) {
-                var replay = task.replay;
-                childIndex = replay.nodes;
-                for (node = 0; node < childIndex.length; node++)
-                  if (((key = childIndex[node]), keyOrIndex === key[1])) {
-                    if (4 === key.length) {
-                      if (null !== name && name !== key[0])
-                        throw Error(
-                          "Expected the resume to render <" +
-                            key[0] +
-                            "> in this slot but instead it rendered <" +
-                            name +
-                            ">. The tree doesn't match so React will fallback to client rendering."
-                        );
-                      var childNodes = key[2];
-                      key = key[3];
-                      name = task.node;
-                      task.replay = {
-                        nodes: childNodes,
-                        slots: key,
-                        pendingTasks: 1
-                      };
-                      try {
-                        renderElement(request, task, keyPath, type, props, ref);
-                        if (
-                          1 === task.replay.pendingTasks &&
-                          0 < task.replay.nodes.length
-                        )
-                          throw Error(
-                            "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                          );
-                        task.replay.pendingTasks--;
-                      } catch (x) {
-                        if (
-                          "object" === typeof x &&
-                          null !== x &&
-                          (x === SuspenseException ||
-                            "function" === typeof x.then)
-                        )
-                          throw (
-                            (task.node === name && (task.replay = replay), x)
-                          );
-                        task.replay.pendingTasks--;
-                        props = getThrownInfo(task.componentStack);
-                        erroredReplay(
-                          request,
-                          task.blockedBoundary,
-                          x,
-                          props,
-                          childNodes,
-                          key
-                        );
-                      }
-                      task.replay = replay;
-                    } else {
-                      if (type !== REACT_SUSPENSE_TYPE)
-                        throw Error(
-                          "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
-                            (getComponentNameFromType(type) || "Unknown") +
-                            ">. The tree doesn't match so React will fallback to client rendering."
-                        );
-                      a: {
-                        type = void 0;
-                        ref = key[5];
-                        replay = key[2];
-                        name = key[3];
-                        keyOrIndex = null === key[4] ? [] : key[4][2];
-                        key = null === key[4] ? null : key[4][3];
-                        var prevKeyPath = task.keyPath,
-                          previousReplaySet = task.replay,
-                          parentBoundary = task.blockedBoundary,
-                          parentHoistableState = task.hoistableState,
-                          content = props.children,
-                          fallback = props.fallback,
-                          fallbackAbortSet = new Set();
-                        props =
-                          task.formatContext.insertionMode < HTML_MODE
-                            ? createSuspenseBoundary(
-                                request,
-                                fallbackAbortSet,
-                                createPreambleState(),
-                                createPreambleState()
-                              )
-                            : createSuspenseBoundary(
-                                request,
-                                fallbackAbortSet,
-                                null,
-                                null
-                              );
-                        props.parentFlushed = !0;
-                        props.rootSegmentID = ref;
-                        task.blockedBoundary = props;
-                        task.hoistableState = props.contentState;
-                        task.keyPath = keyPath;
-                        task.replay = {
-                          nodes: replay,
-                          slots: name,
-                          pendingTasks: 1
-                        };
-                        try {
-                          renderNode(request, task, content, -1);
-                          if (
-                            1 === task.replay.pendingTasks &&
-                            0 < task.replay.nodes.length
-                          )
-                            throw Error(
-                              "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                            );
-                          task.replay.pendingTasks--;
-                          if (
-                            0 === props.pendingTasks &&
-                            props.status === PENDING
-                          ) {
-                            props.status = COMPLETED;
-                            request.completedBoundaries.push(props);
-                            break a;
-                          }
-                        } catch (error) {
-                          (props.status = CLIENT_RENDERED),
-                            (childNodes = getThrownInfo(task.componentStack)),
-                            (type = logRecoverableError(
-                              request,
-                              error,
-                              childNodes
-                            )),
-                            encodeErrorForBoundary(
-                              props,
-                              type,
-                              error,
-                              childNodes,
-                              !1
-                            ),
-                            task.replay.pendingTasks--,
-                            request.clientRenderedBoundaries.push(props);
-                        } finally {
-                          (task.blockedBoundary = parentBoundary),
-                            (task.hoistableState = parentHoistableState),
-                            (task.replay = previousReplaySet),
-                            (task.keyPath = prevKeyPath);
-                        }
-                        childNodes = createReplayTask(
-                          request,
-                          null,
-                          { nodes: keyOrIndex, slots: key, pendingTasks: 0 },
-                          fallback,
-                          -1,
-                          parentBoundary,
-                          props.fallbackState,
-                          fallbackAbortSet,
-                          [keyPath[0], "Suspense Fallback", keyPath[2]],
-                          task.formatContext,
-                          task.context,
-                          task.treeContext,
-                          task.componentStack,
-                          !0
-                        );
-                        pushComponentStack(childNodes);
-                        request.pingedTasks.push(childNodes);
-                      }
-                    }
-                    childIndex.splice(node, 1);
-                    break;
-                  }
-              } else renderElement(request, task, keyPath, type, props, ref);
+                key = node.key;
+              node = node.props;
+              var refProp = node.ref;
+              refProp = void 0 !== refProp ? refProp : null;
+              var debugTask = task.debugTask,
+                name = getComponentNameFromType(type);
+              key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;
+              var keyPath = [task.keyPath, name, key];
+              null !== task.replay
+                ? debugTask
+                  ? debugTask.run(
+                      replayElement.bind(
+                        null,
+                        request,
+                        task,
+                        keyPath,
+                        name,
+                        key,
+                        childIndex,
+                        type,
+                        node,
+                        refProp,
+                        task.replay
+                      )
+                    )
+                  : replayElement(
+                      request,
+                      task,
+                      keyPath,
+                      name,
+                      key,
+                      childIndex,
+                      type,
+                      node,
+                      refProp,
+                      task.replay
+                    )
+                : debugTask
+                  ? debugTask.run(
+                      renderElement.bind(
+                        null,
+                        request,
+                        task,
+                        keyPath,
+                        type,
+                        node,
+                        refProp
+                      )
+                    )
+                  : renderElement(request, task, keyPath, type, node, refProp);
               return;
             case REACT_PORTAL_TYPE:
               throw Error(
@@ -5749,21 +5911,20 @@
             return;
           }
           null === node || "object" !== typeof node
-            ? (props = null)
-            : ((childNodes =
+            ? (key = null)
+            : ((type =
                 (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||
                 node["@@iterator"]),
-              (props = "function" === typeof childNodes ? childNodes : null));
-          if (props && (childNodes = props.call(node))) {
-            if (childNodes === node) {
+              (key = "function" === typeof type ? type : null));
+          if (key && (type = key.call(node))) {
+            if (type === node) {
               if (
                 -1 !== childIndex ||
                 null === task.componentStack ||
                 "function" !== typeof task.componentStack.type ||
                 "[object GeneratorFunction]" !==
                   Object.prototype.toString.call(task.componentStack.type) ||
-                "[object Generator]" !==
-                  Object.prototype.toString.call(childNodes)
+                "[object Generator]" !== Object.prototype.toString.call(type)
               )
                 didWarnAboutGenerators ||
                   console.error(
@@ -5771,21 +5932,59 @@
                   ),
                   (didWarnAboutGenerators = !0);
             } else
-              node.entries !== props ||
+              node.entries !== key ||
                 didWarnAboutMaps ||
                 (console.error(
                   "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                 ),
                 (didWarnAboutMaps = !0));
-            node = childNodes.next();
+            node = type.next();
             if (!node.done) {
-              props = [];
-              do props.push(node.value), (node = childNodes.next());
+              key = [];
+              do key.push(node.value), (node = type.next());
               while (!node.done);
-              renderChildrenArray(request, task, props, childIndex);
+              renderChildrenArray(request, task, key, childIndex);
             }
             return;
           }
+          if (
+            "function" === typeof node[ASYNC_ITERATOR] &&
+            (type = node[ASYNC_ITERATOR]())
+          ) {
+            type !== node ||
+              (-1 === childIndex &&
+                null !== task.componentStack &&
+                "function" === typeof task.componentStack.type &&
+                "[object AsyncGeneratorFunction]" ===
+                  Object.prototype.toString.call(task.componentStack.type) &&
+                "[object AsyncGenerator]" ===
+                  Object.prototype.toString.call(type)) ||
+              (didWarnAboutGenerators ||
+                console.error(
+                  "Using AsyncIterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You can use an AsyncIterable that can iterate multiple times over the same items."
+                ),
+              (didWarnAboutGenerators = !0));
+            key = task.thenableState;
+            task.thenableState = null;
+            thenableIndexCounter = 0;
+            thenableState = key;
+            key = [];
+            refProp = !1;
+            if (type === node)
+              for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+                if (node.done) {
+                  refProp = !0;
+                  break;
+                }
+                key.push(node.value);
+                node = readPreviousThenableFromState();
+              }
+            if (!refProp)
+              for (node = unwrapThenable(type.next()); !node.done; )
+                key.push(node.value), (node = unwrapThenable(type.next()));
+            renderChildrenArray(request, task, key, childIndex);
+            return;
+          }
           if ("function" === typeof node.then)
             return (
               (task.thenableState = null),
@@ -5803,39 +6002,39 @@
               node._currentValue2,
               childIndex
             );
-          childIndex = Object.prototype.toString.call(node);
+          request = Object.prototype.toString.call(node);
           throw Error(
             "Objects are not valid as a React child (found: " +
-              ("[object Object]" === childIndex
+              ("[object Object]" === request
                 ? "object with keys {" + Object.keys(node).join(", ") + "}"
-                : childIndex) +
+                : request) +
               "). If you meant to render a collection of children, use an array instead."
           );
         }
         "string" === typeof node
-          ? ((childIndex = task.blockedSegment),
-            null !== childIndex &&
-              (childIndex.lastPushedText = pushTextInstance(
-                childIndex.chunks,
+          ? ((task = task.blockedSegment),
+            null !== task &&
+              (task.lastPushedText = pushTextInstance(
+                task.chunks,
                 node,
                 request.renderState,
-                childIndex.lastPushedText
+                task.lastPushedText
               )))
           : "number" === typeof node || "bigint" === typeof node
-            ? ((childIndex = task.blockedSegment),
-              null !== childIndex &&
-                (childIndex.lastPushedText = pushTextInstance(
-                  childIndex.chunks,
+            ? ((task = task.blockedSegment),
+              null !== task &&
+                (task.lastPushedText = pushTextInstance(
+                  task.chunks,
                   "" + node,
                   request.renderState,
-                  childIndex.lastPushedText
+                  task.lastPushedText
                 )))
             : ("function" === typeof node &&
-                ((childIndex = node.displayName || node.name || "Component"),
+                ((request = node.displayName || node.name || "Component"),
                 console.error(
                   "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
-                  childIndex,
-                  childIndex
+                  request,
+                  request
                 )),
               "symbol" === typeof node &&
                 console.error(
@@ -5847,6 +6046,7 @@
     function renderChildrenArray(request$jscomp$0, task, children, childIndex) {
       var prevKeyPath = task.keyPath,
         previousComponentStack = task.componentStack;
+      var previousDebugTask = task.debugTask;
       pushServerComponentStack(task, task.node._debugInfo);
       if (
         -1 !== childIndex &&
@@ -5888,7 +6088,8 @@
                 x,
                 children,
                 childIndex,
-                node
+                node,
+                task.debugTask
               );
             }
             task.replay = replay;
@@ -5898,6 +6099,7 @@
         }
         task.keyPath = prevKeyPath;
         task.componentStack = previousComponentStack;
+        task.debugTask = previousDebugTask;
         return;
       }
       replay = task.treeContext;
@@ -5924,6 +6126,7 @@
         task.treeContext = replay;
         task.keyPath = prevKeyPath;
         task.componentStack = previousComponentStack;
+        task.debugTask = previousDebugTask;
         return;
       }
       for (j = 0; j < replayNodes; j++) {
@@ -5982,7 +6185,7 @@
               parent: node.componentStack,
               type: resumeSegmentID.type,
               owner: resumeSegmentID._owner,
-              stack: null
+              stack: resumeSegmentID._debugStack
             };
             console.error(
               'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
@@ -5998,6 +6201,106 @@
       task.treeContext = replay;
       task.keyPath = prevKeyPath;
       task.componentStack = previousComponentStack;
+      task.debugTask = previousDebugTask;
+    }
+    function trackPostpone(request, trackedPostpones, task, segment) {
+      segment.status = POSTPONED;
+      var keyPath = task.keyPath,
+        boundary = task.blockedBoundary;
+      if (null === boundary)
+        (segment.id = request.nextSegmentId++),
+          (trackedPostpones.rootSlots = segment.id),
+          null !== request.completedRootSegment &&
+            (request.completedRootSegment.status = POSTPONED);
+      else {
+        if (null !== boundary && boundary.status === PENDING) {
+          boundary.status = POSTPONED;
+          boundary.rootSegmentID = request.nextSegmentId++;
+          var boundaryKeyPath = boundary.trackedContentKeyPath;
+          if (null === boundaryKeyPath)
+            throw Error(
+              "It should not be possible to postpone at the root. This is a bug in React."
+            );
+          var fallbackReplayNode = boundary.trackedFallbackNode,
+            children = [];
+          if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+            -1 === segment.id &&
+              (segment.id = segment.parentFlushed
+                ? boundary.rootSegmentID
+                : request.nextSegmentId++);
+            segment = [
+              boundaryKeyPath[1],
+              boundaryKeyPath[2],
+              children,
+              segment.id,
+              fallbackReplayNode,
+              boundary.rootSegmentID
+            ];
+            trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+            addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+            return;
+          }
+          var _boundaryNode = trackedPostpones.workingMap.get(boundaryKeyPath);
+          void 0 === _boundaryNode
+            ? ((_boundaryNode = [
+                boundaryKeyPath[1],
+                boundaryKeyPath[2],
+                children,
+                null,
+                fallbackReplayNode,
+                boundary.rootSegmentID
+              ]),
+              trackedPostpones.workingMap.set(boundaryKeyPath, _boundaryNode),
+              addToReplayParent(
+                _boundaryNode,
+                boundaryKeyPath[0],
+                trackedPostpones
+              ))
+            : ((boundaryKeyPath = _boundaryNode),
+              (boundaryKeyPath[4] = fallbackReplayNode),
+              (boundaryKeyPath[5] = boundary.rootSegmentID));
+        }
+        -1 === segment.id &&
+          (segment.id =
+            segment.parentFlushed && null !== boundary
+              ? boundary.rootSegmentID
+              : request.nextSegmentId++);
+        if (-1 === task.childIndex)
+          null === keyPath
+            ? (trackedPostpones.rootSlots = segment.id)
+            : ((task = trackedPostpones.workingMap.get(keyPath)),
+              void 0 === task
+                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+                  addToReplayParent(task, keyPath[0], trackedPostpones))
+                : (task[3] = segment.id));
+        else {
+          if (null === keyPath)
+            if (((request = trackedPostpones.rootSlots), null === request))
+              request = trackedPostpones.rootSlots = {};
+            else {
+              if ("number" === typeof request)
+                throw Error(
+                  "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+                );
+            }
+          else if (
+            ((boundary = trackedPostpones.workingMap),
+            (boundaryKeyPath = boundary.get(keyPath)),
+            void 0 === boundaryKeyPath)
+          )
+            (request = {}),
+              (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+              boundary.set(keyPath, boundaryKeyPath),
+              addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+          else if (((request = boundaryKeyPath[3]), null === request))
+            request = boundaryKeyPath[3] = {};
+          else if ("number" === typeof request)
+            throw Error(
+              "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+            );
+          request[task.childIndex] = segment.id;
+        }
+      }
     }
     function untrackBoundary(request, boundary) {
       request = request.trackedPostpones;
@@ -6023,7 +6326,9 @@
         task.context,
         task.treeContext,
         task.componentStack,
-        task.isFallback
+        task.isFallback,
+        emptyContextObject,
+        task.debugTask
       );
     }
     function spawnNewSuspendedRenderTask(request, task, thenableState) {
@@ -6045,7 +6350,6 @@
         task.childIndex,
         task.blockedBoundary,
         newSegment,
-        task.blockedPreamble,
         task.hoistableState,
         task.abortSet,
         task.keyPath,
@@ -6053,7 +6357,9 @@
         task.context,
         task.treeContext,
         task.componentStack,
-        task.isFallback
+        task.isFallback,
+        emptyContextObject,
+        task.debugTask
       );
     }
     function renderNode(request, task, node, childIndex) {
@@ -6062,6 +6368,7 @@
         previousKeyPath = task.keyPath,
         previousTreeContext = task.treeContext,
         previousComponentStack = task.componentStack,
+        previousDebugTask = task.debugTask,
         segment = task.blockedSegment;
       if (null === segment)
         try {
@@ -6069,13 +6376,14 @@
         } catch (thrownValue) {
           if (
             (resetHooksState(),
-            (node =
+            (childIndex =
               thrownValue === SuspenseException
                 ? getSuspendedThenable()
                 : thrownValue),
-            "object" === typeof node && null !== node)
+            "object" === typeof childIndex && null !== childIndex)
           ) {
-            if ("function" === typeof node.then) {
+            if ("function" === typeof childIndex.then) {
+              node = childIndex;
               childIndex = getThenableStateAfterSuspending();
               request = spawnNewSuspendedReplayTask(
                 request,
@@ -6088,10 +6396,11 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
-            if ("Maximum call stack size exceeded" === node.message) {
+            if ("Maximum call stack size exceeded" === childIndex.message) {
               node = getThenableStateAfterSuspending();
               node = spawnNewSuspendedReplayTask(request, task, node);
               request.pingedTasks.push(node);
@@ -6100,6 +6409,7 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
@@ -6115,13 +6425,14 @@
             (resetHooksState(),
             (segment.children.length = childrenLength),
             (segment.chunks.length = chunkLength),
-            (node =
+            (childIndex =
               thrownValue$3 === SuspenseException
                 ? getSuspendedThenable()
                 : thrownValue$3),
-            "object" === typeof node && null !== node)
+            "object" === typeof childIndex && null !== childIndex)
           ) {
-            if ("function" === typeof node.then) {
+            if ("function" === typeof childIndex.then) {
+              node = childIndex;
               childIndex = getThenableStateAfterSuspending();
               request = spawnNewSuspendedRenderTask(
                 request,
@@ -6134,10 +6445,40 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
+              switchContext(previousContext);
+              return;
+            }
+            if (
+              childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+              null !== request.trackedPostpones &&
+              null !== task.blockedBoundary
+            ) {
+              node = request.trackedPostpones;
+              segment = getThrownInfo(task.componentStack);
+              logPostpone(request, childIndex.message, segment, task.debugTask);
+              childIndex = task.blockedSegment;
+              segment = createPendingSegment(
+                request,
+                childIndex.chunks.length,
+                null,
+                task.formatContext,
+                childIndex.lastPushedText,
+                !0
+              );
+              childIndex.children.push(segment);
+              childIndex.lastPushedText = !1;
+              trackPostpone(request, node, task, segment);
+              task.formatContext = previousFormatContext;
+              task.context = previousContext;
+              task.keyPath = previousKeyPath;
+              task.treeContext = previousTreeContext;
+              task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
-            if ("Maximum call stack size exceeded" === node.message) {
+            if ("Maximum call stack size exceeded" === childIndex.message) {
               node = getThenableStateAfterSuspending();
               node = spawnNewSuspendedRenderTask(request, task, node);
               request.pingedTasks.push(node);
@@ -6146,6 +6487,7 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
@@ -6157,7 +6499,7 @@
       task.keyPath = previousKeyPath;
       task.treeContext = previousTreeContext;
       switchContext(previousContext);
-      throw node;
+      throw childIndex;
     }
     function erroredReplay(
       request,
@@ -6165,16 +6507,27 @@
       error,
       errorInfo,
       replayNodes,
-      resumeSlots
+      resumeSlots,
+      debugTask
     ) {
-      var errorDigest = logRecoverableError(request, error, errorInfo);
+      "object" === typeof error &&
+      null !== error &&
+      error.$$typeof === REACT_POSTPONE_TYPE
+        ? (logPostpone(request, error.message, errorInfo, debugTask),
+          (debugTask = "POSTPONE"))
+        : (debugTask = logRecoverableError(
+            request,
+            error,
+            errorInfo,
+            debugTask
+          ));
       abortRemainingReplayNodes(
         request,
         boundary,
         replayNodes,
         resumeSlots,
         error,
-        errorDigest,
+        debugTask,
         errorInfo,
         !1
       );
@@ -6214,12 +6567,7 @@
             errorDigest = errorDigest$jscomp$0,
             errorInfo = errorInfo$jscomp$0,
             wasAborted = aborted,
-            resumedBoundary = createSuspenseBoundary(
-              request,
-              new Set(),
-              null,
-              null
-            );
+            resumedBoundary = createSuspenseBoundary(request, new Set());
           resumedBoundary.parentFlushed = !0;
           resumedBoundary.rootSegmentID = node;
           resumedBoundary.status = CLIENT_RENDERED;
@@ -6262,19 +6610,43 @@
         if (6 === segment.status) return;
         segment.status = 3;
       }
-      segment = getThrownInfo(task.componentStack);
+      var errorInfo = getThrownInfo(task.componentStack);
       if (null === boundary) {
         if (13 !== request.status && request.status !== CLOSED) {
           boundary = task.replay;
           if (null === boundary) {
-            logRecoverableError(request, error, segment);
-            fatalError(request, error);
+            "object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+              ? ((boundary = request.trackedPostpones),
+                null !== boundary && null !== segment
+                  ? (logPostpone(request, error.message, errorInfo, null),
+                    trackPostpone(request, boundary, task, segment),
+                    finishedTask(request, null, segment))
+                  : ((task = Error(
+                      "The render was aborted with postpone when the shell is incomplete. Reason: " +
+                        error.message
+                    )),
+                    logRecoverableError(request, task, errorInfo, null),
+                    fatalError(request, task, errorInfo, null)))
+              : null !== request.trackedPostpones && null !== segment
+                ? ((boundary = request.trackedPostpones),
+                  logRecoverableError(request, error, errorInfo, null),
+                  trackPostpone(request, boundary, task, segment),
+                  finishedTask(request, null, segment))
+                : (logRecoverableError(request, error, errorInfo, null),
+                  fatalError(request, error, errorInfo, null));
             return;
           }
           boundary.pendingTasks--;
           0 === boundary.pendingTasks &&
             0 < boundary.nodes.length &&
-            ((task = logRecoverableError(request, error, segment)),
+            ("object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+              ? (logPostpone(request, error.message, errorInfo, null),
+                (task = "POSTPONE"))
+              : (task = logRecoverableError(request, error, errorInfo, null)),
             abortRemainingReplayNodes(
               request,
               null,
@@ -6282,26 +6654,59 @@
               boundary.slots,
               error,
               task,
-              segment,
+              errorInfo,
               !0
             ));
           request.pendingRootTasks--;
           0 === request.pendingRootTasks && completeShell(request);
         }
-      } else
-        boundary.pendingTasks--,
-          boundary.status !== CLIENT_RENDERED &&
-            ((boundary.status = CLIENT_RENDERED),
-            (task = logRecoverableError(request, error, segment)),
-            (boundary.status = CLIENT_RENDERED),
-            encodeErrorForBoundary(boundary, task, error, segment, !0),
-            untrackBoundary(request, boundary),
-            boundary.parentFlushed &&
-              request.clientRenderedBoundaries.push(boundary)),
-          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-            return abortTask(fallbackTask, request, error);
-          }),
-          boundary.fallbackAbortableTasks.clear();
+      } else {
+        boundary.pendingTasks--;
+        var _trackedPostpones2 = request.trackedPostpones;
+        if (boundary.status !== CLIENT_RENDERED) {
+          if (null !== _trackedPostpones2 && null !== segment)
+            return (
+              "object" === typeof error &&
+              null !== error &&
+              error.$$typeof === REACT_POSTPONE_TYPE
+                ? logPostpone(request, error.message, errorInfo, null)
+                : logRecoverableError(request, error, errorInfo, null),
+              trackPostpone(request, _trackedPostpones2, task, segment),
+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+                return abortTask(fallbackTask, request, error);
+              }),
+              boundary.fallbackAbortableTasks.clear(),
+              finishedTask(request, boundary, segment)
+            );
+          boundary.status = CLIENT_RENDERED;
+          if (
+            "object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+          ) {
+            logPostpone(request, error.message, errorInfo, null);
+            if (null !== request.trackedPostpones && null !== segment) {
+              trackPostpone(request, request.trackedPostpones, task, segment);
+              finishedTask(request, task.blockedBoundary, segment);
+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+                return abortTask(fallbackTask, request, error);
+              });
+              boundary.fallbackAbortableTasks.clear();
+              return;
+            }
+            task = "POSTPONE";
+          } else task = logRecoverableError(request, error, errorInfo, null);
+          boundary.status = CLIENT_RENDERED;
+          encodeErrorForBoundary(boundary, task, error, errorInfo, !0);
+          untrackBoundary(request, boundary);
+          boundary.parentFlushed &&
+            request.clientRenderedBoundaries.push(boundary);
+        }
+        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+          return abortTask(fallbackTask, request, error);
+        });
+        boundary.fallbackAbortableTasks.clear();
+      }
       request.allPendingTasks--;
       0 === request.allPendingTasks && completeAll(request);
     }
@@ -6367,12 +6772,11 @@
           }
         }
       } catch (error) {
-        logRecoverableError(request, error, {});
+        logRecoverableError(request, error, {}, null);
       }
     }
     function completeShell(request) {
       null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-      null === request.trackedPostpones && preparePreamble(request);
       request.onShellError = noop;
       request = request.onShellReady;
       request();
@@ -6385,7 +6789,6 @@
           : null === request.completedRootSegment ||
               request.completedRootSegment.status !== POSTPONED
       );
-      preparePreamble(request);
       request = request.onAllReady;
       request();
     }
@@ -6430,11 +6833,7 @@
                     abortTaskSoft,
                     request
                   ),
-                  boundary.fallbackAbortableTasks.clear(),
-                  0 === request.pendingRootTasks &&
-                    null === request.trackedPostpones &&
-                    null !== boundary.contentPreamble &&
-                    preparePreamble(request)))
+                  boundary.fallbackAbortableTasks.clear()))
               : null !== segment &&
                 segment.parentFlushed &&
                 segment.status === COMPLETED &&
@@ -6522,7 +6921,8 @@
                         : x,
                       errorInfo,
                       request.replay.nodes,
-                      request.replay.slots
+                      request.replay.slots,
+                      request.debugTask
                     );
                     request$jscomp$0.pendingRootTasks--;
                     0 === request$jscomp$0.pendingRootTasks &&
@@ -6535,91 +6935,171 @@
                   currentTaskInDEV = prevTaskInDEV;
                 }
               }
-            } else {
-              request$jscomp$0 = prevTaskInDEV = void 0;
-              var task$jscomp$0 = task,
-                segment$jscomp$0 = segment;
-              if (segment$jscomp$0.status === PENDING) {
-                segment$jscomp$0.status = 6;
-                switchContext(task$jscomp$0.context);
-                request$jscomp$0 = currentTaskInDEV;
-                currentTaskInDEV = task$jscomp$0;
-                var childrenLength = segment$jscomp$0.children.length,
-                  chunkLength = segment$jscomp$0.chunks.length;
-                try {
-                  retryNode(request, task$jscomp$0),
-                    pushSegmentFinale(
-                      segment$jscomp$0.chunks,
-                      request.renderState,
-                      segment$jscomp$0.lastPushedText,
-                      segment$jscomp$0.textEmbedded
-                    ),
-                    task$jscomp$0.abortSet.delete(task$jscomp$0),
-                    (segment$jscomp$0.status = COMPLETED),
-                    finishedTask(
-                      request,
-                      task$jscomp$0.blockedBoundary,
-                      segment$jscomp$0
-                    );
-                } catch (thrownValue) {
-                  resetHooksState();
-                  segment$jscomp$0.children.length = childrenLength;
-                  segment$jscomp$0.chunks.length = chunkLength;
-                  var x$jscomp$0 =
-                    thrownValue === SuspenseException
-                      ? getSuspendedThenable()
-                      : 12 === request.status
-                        ? request.fatalError
-                        : thrownValue;
-                  if (
-                    "object" === typeof x$jscomp$0 &&
-                    null !== x$jscomp$0 &&
-                    "function" === typeof x$jscomp$0.then
-                  ) {
-                    segment$jscomp$0.status = PENDING;
-                    task$jscomp$0.thenableState =
-                      getThenableStateAfterSuspending();
-                    var ping$jscomp$0 = task$jscomp$0.ping;
-                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-                  } else {
-                    var errorInfo$jscomp$0 = getThrownInfo(
-                      task$jscomp$0.componentStack
-                    );
-                    task$jscomp$0.abortSet.delete(task$jscomp$0);
-                    segment$jscomp$0.status = 4;
-                    var boundary = task$jscomp$0.blockedBoundary;
-                    prevTaskInDEV = logRecoverableError(
-                      request,
-                      x$jscomp$0,
-                      errorInfo$jscomp$0
-                    );
-                    null === boundary
-                      ? fatalError(request, x$jscomp$0)
-                      : (boundary.pendingTasks--,
-                        boundary.status !== CLIENT_RENDERED &&
-                          ((boundary.status = CLIENT_RENDERED),
-                          encodeErrorForBoundary(
-                            boundary,
-                            prevTaskInDEV,
+            } else
+              a: {
+                request$jscomp$0 = prevTaskInDEV = void 0;
+                var task$jscomp$0 = task,
+                  segment$jscomp$0 = segment;
+                if (segment$jscomp$0.status === PENDING) {
+                  segment$jscomp$0.status = 6;
+                  switchContext(task$jscomp$0.context);
+                  request$jscomp$0 = currentTaskInDEV;
+                  currentTaskInDEV = task$jscomp$0;
+                  var childrenLength = segment$jscomp$0.children.length,
+                    chunkLength = segment$jscomp$0.chunks.length;
+                  try {
+                    retryNode(request, task$jscomp$0),
+                      pushSegmentFinale(
+                        segment$jscomp$0.chunks,
+                        request.renderState,
+                        segment$jscomp$0.lastPushedText,
+                        segment$jscomp$0.textEmbedded
+                      ),
+                      task$jscomp$0.abortSet.delete(task$jscomp$0),
+                      (segment$jscomp$0.status = COMPLETED),
+                      finishedTask(
+                        request,
+                        task$jscomp$0.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                  } catch (thrownValue) {
+                    resetHooksState();
+                    segment$jscomp$0.children.length = childrenLength;
+                    segment$jscomp$0.chunks.length = chunkLength;
+                    var x$jscomp$0 =
+                      thrownValue === SuspenseException
+                        ? getSuspendedThenable()
+                        : 12 === request.status
+                          ? request.fatalError
+                          : thrownValue;
+                    if (
+                      12 === request.status &&
+                      null !== request.trackedPostpones
+                    ) {
+                      var trackedPostpones = request.trackedPostpones,
+                        thrownInfo = getThrownInfo(
+                          task$jscomp$0.componentStack
+                        );
+                      task$jscomp$0.abortSet.delete(task$jscomp$0);
+                      "object" === typeof x$jscomp$0 &&
+                      null !== x$jscomp$0 &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ? logPostpone(
+                            request,
+                            x$jscomp$0.message,
+                            thrownInfo,
+                            task$jscomp$0.debugTask
+                          )
+                        : logRecoverableError(
+                            request,
                             x$jscomp$0,
+                            thrownInfo,
+                            task$jscomp$0.debugTask
+                          );
+                      trackPostpone(
+                        request,
+                        trackedPostpones,
+                        task$jscomp$0,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task$jscomp$0.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                    } else {
+                      if (
+                        "object" === typeof x$jscomp$0 &&
+                        null !== x$jscomp$0
+                      ) {
+                        if ("function" === typeof x$jscomp$0.then) {
+                          segment$jscomp$0.status = PENDING;
+                          task$jscomp$0.thenableState =
+                            getThenableStateAfterSuspending();
+                          var ping$jscomp$0 = task$jscomp$0.ping;
+                          x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                          break a;
+                        }
+                        if (
+                          null !== request.trackedPostpones &&
+                          x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ) {
+                          var _trackedPostpones3 = request.trackedPostpones;
+                          task$jscomp$0.abortSet.delete(task$jscomp$0);
+                          var postponeInfo = getThrownInfo(
+                            task$jscomp$0.componentStack
+                          );
+                          logPostpone(
+                            request,
+                            x$jscomp$0.message,
+                            postponeInfo,
+                            task$jscomp$0.debugTask
+                          );
+                          trackPostpone(
+                            request,
+                            _trackedPostpones3,
+                            task$jscomp$0,
+                            segment$jscomp$0
+                          );
+                          finishedTask(
+                            request,
+                            task$jscomp$0.blockedBoundary,
+                            segment$jscomp$0
+                          );
+                          break a;
+                        }
+                      }
+                      var errorInfo$jscomp$0 = getThrownInfo(
+                        task$jscomp$0.componentStack
+                      );
+                      task$jscomp$0.abortSet.delete(task$jscomp$0);
+                      segment$jscomp$0.status = 4;
+                      var boundary = task$jscomp$0.blockedBoundary,
+                        debugTask = task$jscomp$0.debugTask;
+                      "object" === typeof x$jscomp$0 &&
+                      null !== x$jscomp$0 &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ? (logPostpone(
+                            request,
+                            x$jscomp$0.message,
                             errorInfo$jscomp$0,
-                            !1
+                            debugTask
                           ),
-                          untrackBoundary(request, boundary),
-                          boundary.parentFlushed &&
-                            request.clientRenderedBoundaries.push(boundary),
-                          0 === request.pendingRootTasks &&
-                            null === request.trackedPostpones &&
-                            null !== boundary.contentPreamble &&
-                            preparePreamble(request)));
-                    request.allPendingTasks--;
-                    0 === request.allPendingTasks && completeAll(request);
+                          (prevTaskInDEV = "POSTPONE"))
+                        : (prevTaskInDEV = logRecoverableError(
+                            request,
+                            x$jscomp$0,
+                            errorInfo$jscomp$0,
+                            debugTask
+                          ));
+                      null === boundary
+                        ? fatalError(
+                            request,
+                            x$jscomp$0,
+                            errorInfo$jscomp$0,
+                            debugTask
+                          )
+                        : (boundary.pendingTasks--,
+                          boundary.status !== CLIENT_RENDERED &&
+                            ((boundary.status = CLIENT_RENDERED),
+                            encodeErrorForBoundary(
+                              boundary,
+                              prevTaskInDEV,
+                              x$jscomp$0,
+                              errorInfo$jscomp$0,
+                              !1
+                            ),
+                            untrackBoundary(request, boundary),
+                            boundary.parentFlushed &&
+                              request.clientRenderedBoundaries.push(boundary)));
+                      request.allPendingTasks--;
+                      0 === request.allPendingTasks && completeAll(request);
+                    }
+                  } finally {
+                    currentTaskInDEV = request$jscomp$0;
                   }
-                } finally {
-                  currentTaskInDEV = request$jscomp$0;
                 }
               }
-            }
           }
           pingedTasks.splice(0, i);
           null !== request$jscomp$1.destination &&
@@ -6628,8 +7108,9 @@
               request$jscomp$1.destination
             );
         } catch (error) {
-          logRecoverableError(request$jscomp$1, error, {}),
-            fatalError(request$jscomp$1, error);
+          (pingedTasks = {}),
+            logRecoverableError(request$jscomp$1, error, pingedTasks, null),
+            fatalError(request$jscomp$1, error, pingedTasks, null);
         } finally {
           (currentResumableState = prevResumableState),
             (ReactSharedInternals.H = prevDispatcher),
@@ -6640,85 +7121,6 @@
         }
       }
     }
-    function preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    ) {
-      segment.preambleChildren.length &&
-        collectedPreambleSegments.push(segment.preambleChildren);
-      for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-        pendingPreambles =
-          preparePreambleFromSegment(
-            request,
-            segment.children[i],
-            collectedPreambleSegments
-          ) || pendingPreambles;
-      return pendingPreambles;
-    }
-    function preparePreambleFromSegment(
-      request,
-      segment,
-      collectedPreambleSegments
-    ) {
-      var boundary = segment.boundary;
-      if (null === boundary)
-        return preparePreambleFromSubtree(
-          request,
-          segment,
-          collectedPreambleSegments
-        );
-      var preamble = boundary.contentPreamble,
-        fallbackPreamble = boundary.fallbackPreamble;
-      if (null === preamble || null === fallbackPreamble) return !1;
-      switch (boundary.status) {
-        case COMPLETED:
-          hoistPreambleState(request.renderState, preamble);
-          segment = boundary.completedSegments[0];
-          if (!segment)
-            throw Error(
-              "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
-            );
-          return preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          );
-        case POSTPONED:
-          if (null !== request.trackedPostpones) return !0;
-        case CLIENT_RENDERED:
-          if (segment.status === COMPLETED)
-            return (
-              hoistPreambleState(request.renderState, fallbackPreamble),
-              preparePreambleFromSubtree(
-                request,
-                segment,
-                collectedPreambleSegments
-              )
-            );
-        default:
-          return !0;
-      }
-    }
-    function preparePreamble(request) {
-      if (
-        request.completedRootSegment &&
-        null === request.completedPreambleSegments
-      ) {
-        var collectedPreambleSegments = [],
-          hasPendingPreambles = preparePreambleFromSegment(
-            request,
-            request.completedRootSegment,
-            collectedPreambleSegments
-          ),
-          preamble = request.renderState.preamble;
-        if (
-          !1 === hasPendingPreambles ||
-          (preamble.headChunks && preamble.bodyChunks)
-        )
-          request.completedPreambleSegments = collectedPreambleSegments;
-      }
-    }
     function flushSubtree(request, destination, segment, hoistableState) {
       segment.parentFlushed = !0;
       switch (segment.status) {
@@ -6898,37 +7300,57 @@
       boundary = boundary.contentState;
       var requiresStyleInsertion = request.stylesToHoist;
       request.stylesToHoist = !1;
-      destination.push(request.startInlineScript);
-      requiresStyleInsertion
-        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-          NothingSent
-          ? ((completedSegments.instructions =
-              completedSegments.instructions |
-              SentStyleInsertionFunction |
-              SentCompleteBoundaryFunction),
-            destination.push(completeBoundaryWithStylesScript1FullBoth))
-          : (completedSegments.instructions & SentStyleInsertionFunction) ===
+      var scriptFormat =
+        completedSegments.streamingFormat === ScriptStreamingFormat;
+      scriptFormat
+        ? (destination.push(request.startInlineScript),
+          requiresStyleInsertion
+            ? (completedSegments.instructions &
+                SentCompleteBoundaryFunction) ===
               NothingSent
-            ? ((completedSegments.instructions |= SentStyleInsertionFunction),
-              destination.push(completeBoundaryWithStylesScript1FullPartial))
-            : destination.push(completeBoundaryWithStylesScript1Partial)
-        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-            NothingSent
-          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),
-            destination.push(completeBoundaryScript1Full))
-          : destination.push(completeBoundaryScript1Partial);
+              ? ((completedSegments.instructions =
+                  completedSegments.instructions |
+                  SentStyleInsertionFunction |
+                  SentCompleteBoundaryFunction),
+                destination.push(completeBoundaryWithStylesScript1FullBoth))
+              : (completedSegments.instructions &
+                    SentStyleInsertionFunction) ===
+                  NothingSent
+                ? ((completedSegments.instructions |=
+                    SentStyleInsertionFunction),
+                  destination.push(
+                    completeBoundaryWithStylesScript1FullPartial
+                  ))
+                : destination.push(completeBoundaryWithStylesScript1Partial)
+            : (completedSegments.instructions &
+                  SentCompleteBoundaryFunction) ===
+                NothingSent
+              ? ((completedSegments.instructions |=
+                  SentCompleteBoundaryFunction),
+                destination.push(completeBoundaryScript1Full))
+              : destination.push(completeBoundaryScript1Partial))
+        : requiresStyleInsertion
+          ? destination.push(completeBoundaryWithStylesData1)
+          : destination.push(completeBoundaryData1);
       completedSegments = i.toString(16);
       destination.push(request.boundaryPrefix);
       destination.push(completedSegments);
-      destination.push(completeBoundaryScript2);
+      scriptFormat
+        ? destination.push(completeBoundaryScript2)
+        : destination.push(completeBoundaryData2);
       destination.push(request.segmentPrefix);
       destination.push(completedSegments);
       requiresStyleInsertion
-        ? (destination.push(completeBoundaryScript3a),
-          writeStyleResourceDependenciesInJS(destination, boundary))
-        : destination.push(completeBoundaryScript3b);
-      boundary = destination.push(completeBoundaryScriptEnd);
-      return writeBootstrap(destination, request) && boundary;
+        ? scriptFormat
+          ? (destination.push(completeBoundaryScript3a),
+            writeStyleResourceDependenciesInJS(destination, boundary))
+          : (destination.push(completeBoundaryData3a),
+            writeStyleResourceDependenciesInAttr(destination, boundary))
+        : scriptFormat && destination.push(completeBoundaryScript3b);
+      completedSegments = scriptFormat
+        ? destination.push(completeBoundaryScriptEnd)
+        : destination.push(completeBoundaryDataEnd);
+      return writeBootstrap(destination, request) && completedSegments;
     }
     function flushPartiallyCompletedSegment(
       request,
@@ -6961,18 +7383,24 @@
       flushSegmentContainer(request, destination, segment, hoistableState);
       boundary = request.resumableState;
       request = request.renderState;
-      destination.push(request.startInlineScript);
-      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
-        ? ((boundary.instructions |= SentCompleteSegmentFunction),
-          destination.push(completeSegmentScript1Full))
-        : destination.push(completeSegmentScript1Partial);
+      (segment = boundary.streamingFormat === ScriptStreamingFormat)
+        ? (destination.push(request.startInlineScript),
+          (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
+            ? ((boundary.instructions |= SentCompleteSegmentFunction),
+              destination.push(completeSegmentScript1Full))
+            : destination.push(completeSegmentScript1Partial))
+        : destination.push(completeSegmentData1);
       destination.push(request.segmentPrefix);
       segmentID = segmentID.toString(16);
       destination.push(segmentID);
-      destination.push(completeSegmentScript2);
+      segment
+        ? destination.push(completeSegmentScript2)
+        : destination.push(completeSegmentData2);
       destination.push(request.placeholderPrefix);
       destination.push(segmentID);
-      destination = destination.push(completeSegmentScriptEnd);
+      destination = segment
+        ? destination.push(completeSegmentScriptEnd)
+        : destination.push(completeSegmentDataEnd);
       return destination;
     }
     function flushCompletedQueues(request, destination) {
@@ -6982,12 +7410,22 @@
             completedRootSegment = request.completedRootSegment;
           if (null !== completedRootSegment) {
             if (completedRootSegment.status === POSTPONED) return;
-            var completedPreambleSegments = request.completedPreambleSegments;
-            if (null === completedPreambleSegments) return;
-            var renderState = request.renderState,
-              preamble = renderState.preamble,
-              htmlChunks = preamble.htmlChunks,
-              headChunks = preamble.headChunks,
+            var renderState = request.renderState;
+            if (
+              (0 !== request.allPendingTasks ||
+                null !== request.trackedPostpones) &&
+              renderState.externalRuntimeScript
+            ) {
+              var _renderState$external = renderState.externalRuntimeScript,
+                resumableState = request.resumableState,
+                src = _renderState$external.src,
+                chunks = _renderState$external.chunks;
+              resumableState.scriptResources.hasOwnProperty(src) ||
+                ((resumableState.scriptResources[src] = EXISTS),
+                renderState.scripts.add(chunks));
+            }
+            var htmlChunks = renderState.htmlChunks,
+              headChunks = renderState.headChunks,
               i$jscomp$0;
             if (htmlChunks) {
               for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -7050,29 +7488,11 @@
               i$jscomp$0++
             )
               destination.push(hoistableChunks[i$jscomp$0]);
-            for (
-              renderState = hoistableChunks.length = 0;
-              renderState < completedPreambleSegments.length;
-              renderState++
-            ) {
-              var segments = completedPreambleSegments[renderState];
-              for (preamble = 0; preamble < segments.length; preamble++)
-                flushSegment(request, destination, segments[preamble], null);
-            }
-            var preamble$jscomp$0 = request.renderState.preamble,
-              headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-            if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
+            hoistableChunks.length = 0;
+            if (htmlChunks && null === headChunks) {
               var chunk$jscomp$0 = endChunkForTag("head");
               destination.push(chunk$jscomp$0);
             }
-            var bodyChunks = preamble$jscomp$0.bodyChunks;
-            if (bodyChunks)
-              for (
-                completedPreambleSegments = 0;
-                completedPreambleSegments < bodyChunks.length;
-                completedPreambleSegments++
-              )
-                destination.push(bodyChunks[completedPreambleSegments]);
             flushSegment(request, destination, completedRootSegment, null);
             request.completedRootSegment = null;
             writeBootstrap(destination, request.renderState);
@@ -7113,58 +7533,95 @@
           for (i = 0; i < clientRenderedBoundaries.length; i++) {
             var boundary = clientRenderedBoundaries[i];
             renderState$jscomp$0 = destination;
-            var resumableState = request.resumableState,
+            var resumableState$jscomp$0 = request.resumableState,
               renderState$jscomp$1 = request.renderState,
               id = boundary.rootSegmentID,
               errorDigest = boundary.errorDigest,
               errorMessage = boundary.errorMessage,
               errorStack = boundary.errorStack,
-              errorComponentStack = boundary.errorComponentStack;
-            renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);
-            (resumableState.instructions & SentClientRenderFunction) ===
-            NothingSent
-              ? ((resumableState.instructions |= SentClientRenderFunction),
-                renderState$jscomp$0.push(clientRenderScript1Full))
-              : renderState$jscomp$0.push(clientRenderScript1Partial);
+              errorComponentStack = boundary.errorComponentStack,
+              scriptFormat =
+                resumableState$jscomp$0.streamingFormat ===
+                ScriptStreamingFormat;
+            scriptFormat
+              ? (renderState$jscomp$0.push(
+                  renderState$jscomp$1.startInlineScript
+                ),
+                (resumableState$jscomp$0.instructions &
+                  SentClientRenderFunction) ===
+                NothingSent
+                  ? ((resumableState$jscomp$0.instructions |=
+                      SentClientRenderFunction),
+                    renderState$jscomp$0.push(clientRenderScript1Full))
+                  : renderState$jscomp$0.push(clientRenderScript1Partial))
+              : renderState$jscomp$0.push(clientRenderData1);
             renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);
             var chunk$jscomp$1 = id.toString(16);
             renderState$jscomp$0.push(chunk$jscomp$1);
-            renderState$jscomp$0.push(clientRenderScript1A);
+            scriptFormat && renderState$jscomp$0.push(clientRenderScript1A);
             if (
               errorDigest ||
               errorMessage ||
               errorStack ||
               errorComponentStack
-            ) {
-              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
-              var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
-                errorDigest || ""
-              );
-              renderState$jscomp$0.push(chunk$jscomp$2);
-            }
-            if (errorMessage || errorStack || errorComponentStack) {
-              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
-              var chunk$jscomp$3 = escapeJSStringsForInstructionScripts(
-                errorMessage || ""
-              );
-              renderState$jscomp$0.push(chunk$jscomp$3);
-            }
-            if (errorStack || errorComponentStack) {
-              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
-              var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(
-                errorStack || ""
-              );
-              renderState$jscomp$0.push(chunk$jscomp$4);
-            }
-            if (errorComponentStack) {
-              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
-              var chunk$jscomp$5 =
-                escapeJSStringsForInstructionScripts(errorComponentStack);
-              renderState$jscomp$0.push(chunk$jscomp$5);
-            }
-            var JSCompiler_inline_result = renderState$jscomp$0.push(
-              clientRenderScriptEnd
-            );
+            )
+              if (scriptFormat) {
+                renderState$jscomp$0.push(
+                  clientRenderErrorScriptArgInterstitial
+                );
+                var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
+                  errorDigest || ""
+                );
+                renderState$jscomp$0.push(chunk$jscomp$2);
+              } else {
+                renderState$jscomp$0.push(clientRenderData2);
+                var chunk$jscomp$3 = escapeTextForBrowser(errorDigest || "");
+                renderState$jscomp$0.push(chunk$jscomp$3);
+              }
+            if (errorMessage || errorStack || errorComponentStack)
+              if (scriptFormat) {
+                renderState$jscomp$0.push(
+                  clientRenderErrorScriptArgInterstitial
+                );
+                var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(
+                  errorMessage || ""
+                );
+                renderState$jscomp$0.push(chunk$jscomp$4);
+              } else {
+                renderState$jscomp$0.push(clientRenderData3);
+                var chunk$jscomp$5 = escapeTextForBrowser(errorMessage || "");
+                renderState$jscomp$0.push(chunk$jscomp$5);
+              }
+            if (errorStack || errorComponentStack)
+              if (scriptFormat) {
+                renderState$jscomp$0.push(
+                  clientRenderErrorScriptArgInterstitial
+                );
+                var chunk$jscomp$6 = escapeJSStringsForInstructionScripts(
+                  errorStack || ""
+                );
+                renderState$jscomp$0.push(chunk$jscomp$6);
+              } else {
+                renderState$jscomp$0.push(clientRenderData4);
+                var chunk$jscomp$7 = escapeTextForBrowser(errorStack || "");
+                renderState$jscomp$0.push(chunk$jscomp$7);
+              }
+            if (errorComponentStack)
+              if (scriptFormat) {
+                renderState$jscomp$0.push(
+                  clientRenderErrorScriptArgInterstitial
+                );
+                var chunk$jscomp$8 =
+                  escapeJSStringsForInstructionScripts(errorComponentStack);
+                renderState$jscomp$0.push(chunk$jscomp$8);
+              } else {
+                renderState$jscomp$0.push(clientRenderData5);
+                var chunk$jscomp$9 = escapeTextForBrowser(errorComponentStack);
+                renderState$jscomp$0.push(chunk$jscomp$9);
+              }
+            var JSCompiler_inline_result = scriptFormat
+              ? renderState$jscomp$0.push(clientRenderScriptEnd)
+              : renderState$jscomp$0.push(clientRenderDataEnd);
             if (!JSCompiler_inline_result) {
               request.destination = null;
               i++;
@@ -7246,11 +7703,12 @@
           0 === request.clientRenderedBoundaries.length &&
           0 === request.completedBoundaries.length &&
           ((request.flushScheduled = !1),
-          (i = request.resumableState),
-          i.hasBody &&
-            ((partialBoundaries = endChunkForTag("body")),
-            destination.push(partialBoundaries)),
-          i.hasHtml && ((i = endChunkForTag("html")), destination.push(i)),
+          null === request.trackedPostpones &&
+            ((i = request.resumableState),
+            i.hasBody &&
+              ((partialBoundaries = endChunkForTag("body")),
+              destination.push(partialBoundaries)),
+            i.hasHtml && ((i = endChunkForTag("html")), destination.push(i))),
           0 !== request.abortableTasks.size &&
             console.error(
               "There was still abortable task at the root when we closed. This is a bug in React."
@@ -7288,7 +7746,9 @@
         try {
           flushCompletedQueues(request, destination);
         } catch (error) {
-          logRecoverableError(request, error, {}), fatalError(request, error);
+          (destination = {}),
+            logRecoverableError(request, error, destination, null),
+            fatalError(request, error, destination, null);
         }
       }
     }
@@ -7314,7 +7774,21 @@
         null !== request.destination &&
           flushCompletedQueues(request, request.destination);
       } catch (error$4) {
-        logRecoverableError(request, error$4, {}), fatalError(request, error$4);
+        (reason = {}),
+          logRecoverableError(request, error$4, reason, null),
+          fatalError(request, error$4, reason, null);
+      }
+    }
+    function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+      if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+      else {
+        var workingMap = trackedPostpones.workingMap,
+          parentNode = workingMap.get(parentKeyPath);
+        void 0 === parentNode &&
+          ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+          workingMap.set(parentKeyPath, parentNode),
+          addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+        parentNode[2].push(node);
       }
     }
     function onError() {}
@@ -7329,7 +7803,8 @@
         result = "",
         readyToStream = !1;
       options = createResumableState(
-        options ? options.identifierPrefix : void 0
+        options ? options.identifierPrefix : void 0,
+        void 0
       );
       children = createRequest(
         children,
@@ -7383,9 +7858,10 @@
       REACT_SCOPE_TYPE = Symbol.for("react.scope"),
       REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
       REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-      REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+      REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
       REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
       MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+      ASYNC_ITERATOR = Symbol.asyncIterator,
       isArrayImpl = Array.isArray,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
@@ -8427,7 +8903,8 @@
         } else previousDispatcher.M(src, options);
       }
     };
-    var NothingSent = 0,
+    var ScriptStreamingFormat = 0,
+      NothingSent = 0,
       SentCompleteSegmentFunction = 1,
       SentCompleteBoundaryFunction = 2,
       SentClientRenderFunction = 4,
@@ -8440,13 +8917,12 @@
     var ROOT_HTML_MODE = 0,
       HTML_HTML_MODE = 1,
       HTML_MODE = 2,
-      HTML_HEAD_MODE = 3,
-      SVG_MODE = 4,
-      MATHML_MODE = 5,
-      HTML_TABLE_MODE = 6,
-      HTML_TABLE_BODY_MODE = 7,
-      HTML_TABLE_ROW_MODE = 8,
-      HTML_COLGROUP_MODE = 9,
+      SVG_MODE = 3,
+      MATHML_MODE = 4,
+      HTML_TABLE_MODE = 5,
+      HTML_TABLE_BODY_MODE = 6,
+      HTML_TABLE_ROW_MODE = 7,
+      HTML_COLGROUP_MODE = 8,
       styleNameCache = new Map(),
       styleAttributeStart = ' style="',
       styleAssign = ":",
@@ -8518,6 +8994,9 @@
       completeSegmentScript1Partial = '$RS("',
       completeSegmentScript2 = '","',
       completeSegmentScriptEnd = '")\x3c/script>',
+      completeSegmentData1 = '<template data-rsi="" data-sid="',
+      completeSegmentData2 = '" data-pid="',
+      completeSegmentDataEnd = '"></template>',
       completeBoundaryScript1Full =
         '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("',
       completeBoundaryScript1Partial = '$RC("',
@@ -8530,12 +9009,23 @@
       completeBoundaryScript3a = '",',
       completeBoundaryScript3b = '"',
       completeBoundaryScriptEnd = ")\x3c/script>",
+      completeBoundaryData1 = '<template data-rci="" data-bid="',
+      completeBoundaryWithStylesData1 = '<template data-rri="" data-bid="',
+      completeBoundaryData2 = '" data-sid="',
+      completeBoundaryData3a = '" data-sty="',
+      completeBoundaryDataEnd = '"></template>',
       clientRenderScript1Full =
         '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("',
       clientRenderScript1Partial = '$RX("',
       clientRenderScript1A = '"',
       clientRenderErrorScriptArgInterstitial = ",",
       clientRenderScriptEnd = ")\x3c/script>",
+      clientRenderData1 = '<template data-rxi="" data-bid="',
+      clientRenderData2 = '" data-dgst="',
+      clientRenderData3 = '" data-msg="',
+      clientRenderData4 = '" data-stck="',
+      clientRenderData5 = '" data-cstck="',
+      clientRenderDataEnd = '"></template>',
       regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g,
       regexForJSStringsInScripts = /[&><\u2028\u2029]/g,
       lateStyleTagResourceOpen1 = '<style media="not all" data-precedence="',
@@ -8719,13 +9209,8 @@
           resolveCurrentlyRenderingComponent();
           return NotPending;
         },
-        useMemoCache: function (size) {
-          for (var data = Array(size), i = 0; i < size; i++)
-            data[i] = REACT_MEMO_CACHE_SENTINEL;
-          return data;
-        },
-        useCacheRefresh: function () {
-          return unsupportedRefresh;
+        useEffectEvent: function () {
+          return throwOnUseEffectEventCall;
         }
       },
       currentResumableState = null,
@@ -8806,5 +9291,5 @@
         'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server'
       );
     };
-    exports.version = "19.1.0-canary-c492f975-20250128";
+    exports.version = "19.1.0-experimental-b3a95caf-20250113";
   })();
diff --git a/node_modules/react-dom/cjs/react-dom-server-legacy.node.production.js b/node_modules/react-dom/cjs/react-dom-server-legacy.node.production.js
index f36cb74..4e86876 100644
--- a/node_modules/react-dom/cjs/react-dom-server-legacy.node.production.js
+++ b/node_modules/react-dom/cjs/react-dom-server-legacy.node.production.js
@@ -51,9 +51,10 @@ var React = require("react"),
   REACT_SCOPE_TYPE = Symbol.for("react.scope"),
   REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
   REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
   REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
   MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+  ASYNC_ITERATOR = Symbol.asyncIterator,
   isArrayImpl = Array.isArray;
 function murmurhash3_32_gc(key, seed) {
   var remainder = key.length & 3;
@@ -294,10 +295,12 @@ function createResumableState(
   bootstrapScripts,
   bootstrapModules
 ) {
+  var streamingFormat = 0;
+  void 0 !== externalRuntimeConfig && (streamingFormat = 1);
   return {
     idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
     nextFormID: 0,
-    streamingFormat: 0,
+    streamingFormat: streamingFormat,
     bootstrapScriptContent: bootstrapScriptContent,
     bootstrapScripts: bootstrapScripts,
     bootstrapModules: bootstrapModules,
@@ -314,9 +317,6 @@ function createResumableState(
     moduleScriptResources: {}
   };
 }
-function createPreambleState() {
-  return { htmlChunks: null, headChunks: null, bodyChunks: null };
-}
 function createFormatContext(insertionMode, selectedValue, tagScope) {
   return {
     insertionMode: insertionMode,
@@ -335,34 +335,33 @@ function getChildFormatContext(parentContext, type, props) {
         parentContext.tagScope
       );
     case "svg":
-      return createFormatContext(4, null, parentContext.tagScope);
+      return createFormatContext(3, null, parentContext.tagScope);
     case "picture":
       return createFormatContext(2, null, parentContext.tagScope | 2);
     case "math":
-      return createFormatContext(5, null, parentContext.tagScope);
+      return createFormatContext(4, null, parentContext.tagScope);
     case "foreignObject":
       return createFormatContext(2, null, parentContext.tagScope);
     case "table":
-      return createFormatContext(6, null, parentContext.tagScope);
+      return createFormatContext(5, null, parentContext.tagScope);
     case "thead":
     case "tbody":
     case "tfoot":
-      return createFormatContext(7, null, parentContext.tagScope);
+      return createFormatContext(6, null, parentContext.tagScope);
     case "colgroup":
-      return createFormatContext(9, null, parentContext.tagScope);
-    case "tr":
       return createFormatContext(8, null, parentContext.tagScope);
-    case "head":
-      if (2 > parentContext.insertionMode)
-        return createFormatContext(3, null, parentContext.tagScope);
-      break;
-    case "html":
-      if (0 === parentContext.insertionMode)
-        return createFormatContext(1, null, parentContext.tagScope);
+    case "tr":
+      return createFormatContext(7, null, parentContext.tagScope);
   }
-  return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode
+  return 5 <= parentContext.insertionMode
     ? createFormatContext(2, null, parentContext.tagScope)
-    : parentContext;
+    : 0 === parentContext.insertionMode
+      ? "html" === type
+        ? createFormatContext(1, null, parentContext.tagScope)
+        : createFormatContext(2, null, parentContext.tagScope)
+      : 1 === parentContext.insertionMode
+        ? createFormatContext(2, null, parentContext.tagScope)
+        : parentContext;
 }
 var styleNameCache = new Map();
 function pushStyleAttribute(target, style) {
@@ -673,7 +672,8 @@ function flattenOptionChildren(children) {
   return content;
 }
 function injectFormReplayingRuntime(resumableState, renderState) {
-  0 === (resumableState.instructions & 16) &&
+  0 !== (resumableState.instructions & 16) ||
+    renderState.externalRuntimeScript ||
     ((resumableState.instructions |= 16),
     renderState.bootstrapChunks.unshift(
       renderState.startInlineScript,
@@ -828,7 +828,6 @@ function pushStartInstance(
   props,
   resumableState,
   renderState,
-  preambleState,
   hoistableState,
   formatContext,
   textEmbedded,
@@ -1308,7 +1307,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$2;
     case "title":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1327,7 +1326,7 @@ function pushStartInstance(
         href = props.href,
         precedence = props.precedence;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof rel ||
@@ -1409,7 +1408,7 @@ function pushStartInstance(
         "symbol" === typeof asyncProp ||
         props.onLoad ||
         props.onError ||
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1450,7 +1449,7 @@ function pushStartInstance(
       var precedence$jscomp$0 = props.precedence,
         href$jscomp$0 = props.href;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof precedence$jscomp$0 ||
@@ -1553,7 +1552,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$6;
     case "meta":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1731,13 +1730,10 @@ function pushStartInstance(
     case "missing-glyph":
       break;
     case "head":
-      if (2 > formatContext.insertionMode) {
-        var preamble = preambleState || renderState.preamble;
-        if (preamble.headChunks)
-          throw Error("The `<head>` tag may only be rendered once.");
-        preamble.headChunks = [];
+      if (2 > formatContext.insertionMode && null === renderState.headChunks) {
+        renderState.headChunks = [];
         var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-          preamble.headChunks,
+          renderState.headChunks,
           props,
           "head"
         );
@@ -1748,42 +1744,24 @@ function pushStartInstance(
           "head"
         );
       return JSCompiler_inline_result$jscomp$9;
-    case "body":
-      if (2 > formatContext.insertionMode) {
-        var preamble$jscomp$0 = preambleState || renderState.preamble;
-        if (preamble$jscomp$0.bodyChunks)
-          throw Error("The `<body>` tag may only be rendered once.");
-        preamble$jscomp$0.bodyChunks = [];
-        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          preamble$jscomp$0.bodyChunks,
-          props,
-          "body"
-        );
-      } else
-        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          target$jscomp$0,
-          props,
-          "body"
-        );
-      return JSCompiler_inline_result$jscomp$10;
     case "html":
-      if (0 === formatContext.insertionMode) {
-        var preamble$jscomp$1 = preambleState || renderState.preamble;
-        if (preamble$jscomp$1.htmlChunks)
-          throw Error("The `<html>` tag may only be rendered once.");
-        preamble$jscomp$1.htmlChunks = [""];
-        var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-          preamble$jscomp$1.htmlChunks,
+      if (
+        0 === formatContext.insertionMode &&
+        null === renderState.htmlChunks
+      ) {
+        renderState.htmlChunks = [""];
+        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+          renderState.htmlChunks,
           props,
           "html"
         );
       } else
-        JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
           target$jscomp$0,
           props,
           "html"
         );
-      return JSCompiler_inline_result$jscomp$11;
+      return JSCompiler_inline_result$jscomp$10;
     default:
       if (-1 !== type.indexOf("-")) {
         target$jscomp$0.push(startChunkForTag(type));
@@ -1844,15 +1822,6 @@ function endChunkForTag(tag) {
   void 0 === chunk && ((chunk = "</" + tag + ">"), endTagCache.set(tag, chunk));
   return chunk;
 }
-function hoistPreambleState(renderState, preambleState) {
-  renderState = renderState.preamble;
-  null === renderState.htmlChunks &&
-    (renderState.htmlChunks = preambleState.htmlChunks);
-  null === renderState.headChunks &&
-    (renderState.headChunks = preambleState.headChunks);
-  null === renderState.bodyChunks &&
-    (renderState.bodyChunks = preambleState.bodyChunks);
-}
 function writeBootstrap(destination, renderState) {
   renderState = renderState.bootstrapChunks;
   for (var i = 0; i < renderState.length - 1; i++)
@@ -1876,7 +1845,6 @@ function writeStartSegment(destination, renderState, formatContext, id) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return (
         destination.push('<div hidden id="'),
@@ -1885,7 +1853,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 4:
+    case 3:
       return (
         destination.push('<svg aria-hidden="true" style="display:none" id="'),
         destination.push(renderState.segmentPrefix),
@@ -1893,7 +1861,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 5:
+    case 4:
       return (
         destination.push('<math aria-hidden="true" style="display:none" id="'),
         destination.push(renderState.segmentPrefix),
@@ -1901,7 +1869,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 6:
+    case 5:
       return (
         destination.push('<table hidden id="'),
         destination.push(renderState.segmentPrefix),
@@ -1909,7 +1877,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 7:
+    case 6:
       return (
         destination.push('<table hidden><tbody id="'),
         destination.push(renderState.segmentPrefix),
@@ -1917,7 +1885,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 8:
+    case 7:
       return (
         destination.push('<table hidden><tr id="'),
         destination.push(renderState.segmentPrefix),
@@ -1925,7 +1893,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         destination.push(renderState),
         destination.push('">')
       );
-    case 9:
+    case 8:
       return (
         destination.push('<table hidden><colgroup id="'),
         destination.push(renderState.segmentPrefix),
@@ -1941,20 +1909,19 @@ function writeEndSegment(destination, formatContext) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return destination.push("</div>");
-    case 4:
+    case 3:
       return destination.push("</svg>");
-    case 5:
+    case 4:
       return destination.push("</math>");
-    case 6:
+    case 5:
       return destination.push("</table>");
-    case 7:
+    case 6:
       return destination.push("</tbody></table>");
-    case 8:
+    case 7:
       return destination.push("</tr></table>");
-    case 9:
+    case 8:
       return destination.push("</colgroup></table>");
     default:
       throw Error("Unknown insertion mode. This is a bug in React.");
@@ -2204,6 +2171,105 @@ function writeStyleResourceAttributeInJS(destination, name, value) {
   attributeName = escapeJSObjectForInstructionScripts(name);
   destination.push(attributeName);
 }
+function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+  destination.push("[");
+  var nextArrayOpenBrackChunk = "[";
+  hoistableState.stylesheets.forEach(function (resource) {
+    if (2 !== resource.state)
+      if (3 === resource.state)
+        destination.push(nextArrayOpenBrackChunk),
+          (resource = escapeTextForBrowser(
+            JSON.stringify("" + resource.props.href)
+          )),
+          destination.push(resource),
+          destination.push("]"),
+          (nextArrayOpenBrackChunk = ",[");
+      else {
+        destination.push(nextArrayOpenBrackChunk);
+        var precedence = resource.props["data-precedence"],
+          props = resource.props,
+          coercedHref = sanitizeURL("" + resource.props.href);
+        coercedHref = escapeTextForBrowser(JSON.stringify(coercedHref));
+        destination.push(coercedHref);
+        precedence = "" + precedence;
+        destination.push(",");
+        precedence = escapeTextForBrowser(JSON.stringify(precedence));
+        destination.push(precedence);
+        for (var propKey in props)
+          if (
+            hasOwnProperty.call(props, propKey) &&
+            ((precedence = props[propKey]), null != precedence)
+          )
+            switch (propKey) {
+              case "href":
+              case "rel":
+              case "precedence":
+              case "data-precedence":
+                break;
+              case "children":
+              case "dangerouslySetInnerHTML":
+                throw Error(
+                  "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                );
+              default:
+                writeStyleResourceAttributeInAttr(
+                  destination,
+                  propKey,
+                  precedence
+                );
+            }
+        destination.push("]");
+        nextArrayOpenBrackChunk = ",[";
+        resource.state = 3;
+      }
+  });
+  destination.push("]");
+}
+function writeStyleResourceAttributeInAttr(destination, name, value) {
+  var attributeName = name.toLowerCase();
+  switch (typeof value) {
+    case "function":
+    case "symbol":
+      return;
+  }
+  switch (name) {
+    case "innerHTML":
+    case "dangerouslySetInnerHTML":
+    case "suppressContentEditableWarning":
+    case "suppressHydrationWarning":
+    case "style":
+    case "ref":
+      return;
+    case "className":
+      attributeName = "class";
+      name = "" + value;
+      break;
+    case "hidden":
+      if (!1 === value) return;
+      name = "";
+      break;
+    case "src":
+    case "href":
+      value = sanitizeURL(value);
+      name = "" + value;
+      break;
+    default:
+      if (
+        (2 < name.length &&
+          ("o" === name[0] || "O" === name[0]) &&
+          ("n" === name[1] || "N" === name[1])) ||
+        !isAttributeNameSafe(name)
+      )
+        return;
+      name = "" + value;
+  }
+  destination.push(",");
+  attributeName = escapeTextForBrowser(JSON.stringify(attributeName));
+  destination.push(attributeName);
+  destination.push(",");
+  attributeName = escapeTextForBrowser(JSON.stringify(name));
+  destination.push(attributeName);
+}
 function createHoistableState() {
   return { styles: new Set(), stylesheets: new Set() };
 }
@@ -2622,17 +2688,16 @@ function createRenderState(resumableState, generateStaticMarkup) {
       "\x3c/script>"
     );
   bootstrapScriptContent = idPrefix + "P:";
-  var JSCompiler_object_inline_segmentPrefix_1521 = idPrefix + "S:";
+  var JSCompiler_object_inline_segmentPrefix_1641 = idPrefix + "S:";
   idPrefix += "B:";
-  var JSCompiler_object_inline_preamble_1524 = createPreambleState(),
-    JSCompiler_object_inline_preconnects_1534 = new Set(),
-    JSCompiler_object_inline_fontPreloads_1535 = new Set(),
-    JSCompiler_object_inline_highImagePreloads_1536 = new Set(),
-    JSCompiler_object_inline_styles_1537 = new Map(),
-    JSCompiler_object_inline_bootstrapScripts_1538 = new Set(),
-    JSCompiler_object_inline_scripts_1539 = new Set(),
-    JSCompiler_object_inline_bulkPreloads_1540 = new Set(),
-    JSCompiler_object_inline_preloads_1541 = {
+  var JSCompiler_object_inline_preconnects_1655 = new Set(),
+    JSCompiler_object_inline_fontPreloads_1656 = new Set(),
+    JSCompiler_object_inline_highImagePreloads_1657 = new Set(),
+    JSCompiler_object_inline_styles_1658 = new Map(),
+    JSCompiler_object_inline_bootstrapScripts_1659 = new Set(),
+    JSCompiler_object_inline_scripts_1660 = new Set(),
+    JSCompiler_object_inline_bulkPreloads_1661 = new Set(),
+    JSCompiler_object_inline_preloads_1662 = {
       images: new Map(),
       stylesheets: new Map(),
       scripts: new Map(),
@@ -2669,7 +2734,7 @@ function createRenderState(resumableState, generateStaticMarkup) {
       scriptConfig.moduleScriptResources[href] = null;
       scriptConfig = [];
       pushLinkImpl(scriptConfig, props);
-      JSCompiler_object_inline_bootstrapScripts_1538.add(scriptConfig);
+      JSCompiler_object_inline_bootstrapScripts_1659.add(scriptConfig);
       bootstrapChunks.push('<script src="', escapeTextForBrowser(src));
       "string" === typeof integrity &&
         bootstrapChunks.push('" integrity="', escapeTextForBrowser(integrity));
@@ -2710,7 +2775,7 @@ function createRenderState(resumableState, generateStaticMarkup) {
         (props.moduleScriptResources[scriptConfig] = null),
         (props = []),
         pushLinkImpl(props, integrity),
-        JSCompiler_object_inline_bootstrapScripts_1538.add(props),
+        JSCompiler_object_inline_bootstrapScripts_1659.add(props),
         bootstrapChunks.push(
           '<script type="module" src="',
           escapeTextForBrowser(i)
@@ -2725,10 +2790,11 @@ function createRenderState(resumableState, generateStaticMarkup) {
         bootstrapChunks.push('" async="">\x3c/script>');
   return {
     placeholderPrefix: bootstrapScriptContent,
-    segmentPrefix: JSCompiler_object_inline_segmentPrefix_1521,
+    segmentPrefix: JSCompiler_object_inline_segmentPrefix_1641,
     boundaryPrefix: idPrefix,
     startInlineScript: "<script>",
-    preamble: JSCompiler_object_inline_preamble_1524,
+    htmlChunks: null,
+    headChunks: null,
     externalRuntimeScript: null,
     bootstrapChunks: bootstrapChunks,
     importMapChunks: [],
@@ -2744,14 +2810,14 @@ function createRenderState(resumableState, generateStaticMarkup) {
     charsetChunks: [],
     viewportChunks: [],
     hoistableChunks: [],
-    preconnects: JSCompiler_object_inline_preconnects_1534,
-    fontPreloads: JSCompiler_object_inline_fontPreloads_1535,
-    highImagePreloads: JSCompiler_object_inline_highImagePreloads_1536,
-    styles: JSCompiler_object_inline_styles_1537,
-    bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1538,
-    scripts: JSCompiler_object_inline_scripts_1539,
-    bulkPreloads: JSCompiler_object_inline_bulkPreloads_1540,
-    preloads: JSCompiler_object_inline_preloads_1541,
+    preconnects: JSCompiler_object_inline_preconnects_1655,
+    fontPreloads: JSCompiler_object_inline_fontPreloads_1656,
+    highImagePreloads: JSCompiler_object_inline_highImagePreloads_1657,
+    styles: JSCompiler_object_inline_styles_1658,
+    bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1659,
+    scripts: JSCompiler_object_inline_scripts_1660,
+    bulkPreloads: JSCompiler_object_inline_bulkPreloads_1661,
+    preloads: JSCompiler_object_inline_preloads_1662,
     stylesToHoist: !1,
     generateStaticMarkup: generateStaticMarkup
   };
@@ -2792,6 +2858,8 @@ function getComponentNameFromType(type) {
       return "Suspense";
     case REACT_SUSPENSE_LIST_TYPE:
       return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
   }
   if ("object" === typeof type)
     switch (type.$$typeof) {
@@ -3134,6 +3202,11 @@ function dispatchAction(componentIdentity, queue, action) {
       queue.next = componentIdentity;
     }
 }
+function throwOnUseEffectEventCall() {
+  throw Error(
+    "A function wrapped in useEffectEvent can't be called during rendering."
+  );
+}
 function unsupportedStartTransition() {
   throw Error("startTransition cannot be called during server rendering.");
 }
@@ -3208,8 +3281,15 @@ function unwrapThenable(thenable) {
   null === thenableState && (thenableState = []);
   return trackUsedThenable(thenableState, thenable, index);
 }
-function unsupportedRefresh() {
-  throw Error("Cache cannot be refreshed during server rendering.");
+function readPreviousThenableFromState() {
+  var index = thenableIndexCounter;
+  thenableIndexCounter += 1;
+  if (null !== thenableState)
+    return (
+      (index = thenableState[index]),
+      (index = void 0 === index ? void 0 : index.value),
+      index
+    );
 }
 function noop$1() {}
 var HooksDispatcher = {
@@ -3297,13 +3377,8 @@ var HooksDispatcher = {
       resolveCurrentlyRenderingComponent();
       return sharedNotPendingObject;
     },
-    useMemoCache: function (size) {
-      for (var data = Array(size), i = 0; i < size; i++)
-        data[i] = REACT_MEMO_CACHE_SENTINEL;
-      return data;
-    },
-    useCacheRefresh: function () {
-      return unsupportedRefresh;
+    useEffectEvent: function () {
+      return throwOnUseEffectEventCall;
     }
   },
   currentResumableState = null,
@@ -3500,6 +3575,8 @@ function describeComponentStackByType(type) {
       return describeBuiltInComponentFrame("SuspenseList");
     case REACT_SUSPENSE_TYPE:
       return describeBuiltInComponentFrame("Suspense");
+    case REACT_VIEW_TRANSITION_TYPE:
+      return describeBuiltInComponentFrame("ViewTransition");
   }
   return "";
 }
@@ -3550,7 +3627,7 @@ function RequestInstance(
   this.status = 10;
   this.fatalError = null;
   this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-  this.completedPreambleSegments = this.completedRootSegment = null;
+  this.completedRootSegment = null;
   this.abortableTasks = abortSet;
   this.pingedTasks = [];
   this.clientRenderedBoundaries = [];
@@ -3609,7 +3686,6 @@ function createRequest(
     null,
     renderState,
     null,
-    null,
     resumableState.abortableTasks,
     null,
     rootFormatContext,
@@ -3629,12 +3705,7 @@ function pingTask(request, task) {
     ((request.flushScheduled = null !== request.destination),
     performWork(request));
 }
-function createSuspenseBoundary(
-  request,
-  fallbackAbortableTasks,
-  contentPreamble,
-  fallbackPreamble
-) {
+function createSuspenseBoundary(request, fallbackAbortableTasks) {
   return {
     status: 0,
     rootSegmentID: -1,
@@ -3646,8 +3717,6 @@ function createSuspenseBoundary(
     errorDigest: null,
     contentState: createHoistableState(),
     fallbackState: createHoistableState(),
-    contentPreamble: contentPreamble,
-    fallbackPreamble: fallbackPreamble,
     trackedContentKeyPath: null,
     trackedFallbackNode: null
   };
@@ -3659,7 +3728,6 @@ function createRenderTask(
   childIndex,
   blockedBoundary,
   blockedSegment,
-  blockedPreamble,
   hoistableState,
   abortSet,
   keyPath,
@@ -3682,7 +3750,6 @@ function createRenderTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: blockedSegment,
-    blockedPreamble: blockedPreamble,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -3726,7 +3793,6 @@ function createReplayTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: null,
-    blockedPreamble: null,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -3750,12 +3816,11 @@ function createPendingSegment(
 ) {
   return {
     status: 0,
-    parentFlushed: !1,
     id: -1,
     index: index,
+    parentFlushed: !1,
     chunks: [],
     children: [],
-    preambleChildren: [],
     parentFormatContext: parentFormatContext,
     boundary: boundary,
     lastPushedText: lastPushedText,
@@ -3797,6 +3862,10 @@ function getThrownInfo(node$jscomp$0) {
     });
   return errorInfo;
 }
+function logPostpone(request, reason, postponeInfo) {
+  request = request.onPostpone;
+  request(reason, postponeInfo);
+}
 function logRecoverableError(request, error, errorInfo) {
   request = request.onError;
   error = request(error, errorInfo);
@@ -3983,13 +4052,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
         (task.formatContext = defaultProps),
         (task.keyPath = initialState);
     else {
-      ref = pushStartInstance(
+      initialState = pushStartInstance(
         newProps.chunks,
         type,
         props,
         request.resumableState,
         request.renderState,
-        task.blockedPreamble,
         task.hoistableState,
         task.formatContext,
         newProps.lastPushedText,
@@ -3997,42 +4065,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
       );
       newProps.lastPushedText = !1;
       defaultProps = task.formatContext;
-      initialState = task.keyPath;
+      ref = task.keyPath;
+      task.formatContext = getChildFormatContext(defaultProps, type, props);
       task.keyPath = keyPath;
-      3 ===
-      (task.formatContext = getChildFormatContext(defaultProps, type, props))
-        .insertionMode
-        ? ((keyPath = createPendingSegment(
-            request,
-            0,
-            null,
-            task.formatContext,
-            !1,
-            !1
-          )),
-          newProps.preambleChildren.push(keyPath),
-          (keyPath = createRenderTask(
-            request,
-            null,
-            ref,
-            -1,
-            task.blockedBoundary,
-            keyPath,
-            task.blockedPreamble,
-            task.hoistableState,
-            request.abortableTasks,
-            task.keyPath,
-            task.formatContext,
-            task.context,
-            task.treeContext,
-            task.componentStack,
-            task.isFallback
-          )),
-          pushComponentStack(keyPath),
-          request.pingedTasks.push(keyPath))
-        : renderNode(request, task, ref, -1);
+      renderNode(request, task, initialState, -1);
       task.formatContext = defaultProps;
-      task.keyPath = initialState;
+      task.keyPath = ref;
       a: {
         task = newProps.chunks;
         request = request.resumableState;
@@ -4067,9 +4105,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
               request.hasHtml = !0;
               break a;
             }
-            break;
-          case "head":
-            if (1 >= defaultProps.insertionMode) break a;
         }
         task.push(endChunkForTag(type));
       }
@@ -4100,6 +4135,11 @@ function renderElement(request, task, keyPath, type, props, ref) {
         task.keyPath = type;
         return;
       case REACT_VIEW_TRANSITION_TYPE:
+        type = task.keyPath;
+        task.keyPath = keyPath;
+        renderNodeDestructive(request, task, props.children, -1);
+        task.keyPath = type;
+        return;
       case REACT_SCOPE_TYPE:
         throw Error("ReactDOMServer does not yet support scope components.");
       case REACT_SUSPENSE_TYPE:
@@ -4114,34 +4154,25 @@ function renderElement(request, task, keyPath, type, props, ref) {
           }
         } else {
           type = task.keyPath;
-          var parentBoundary = task.blockedBoundary;
-          ref = task.blockedPreamble;
-          var parentHoistableState = task.hoistableState;
-          propName$33 = task.blockedSegment;
-          propName = props.fallback;
+          var parentBoundary = task.blockedBoundary,
+            parentHoistableState = task.hoistableState;
+          ref = task.blockedSegment;
+          propName$33 = props.fallback;
           props = props.children;
           var fallbackAbortSet = new Set();
-          var newBoundary =
-            2 > task.formatContext.insertionMode
-              ? createSuspenseBoundary(
-                  request,
-                  fallbackAbortSet,
-                  createPreambleState(),
-                  createPreambleState()
-                )
-              : createSuspenseBoundary(request, fallbackAbortSet, null, null);
+          propName = createSuspenseBoundary(request, fallbackAbortSet);
           null !== request.trackedPostpones &&
-            (newBoundary.trackedContentKeyPath = keyPath);
+            (propName.trackedContentKeyPath = keyPath);
           var boundarySegment = createPendingSegment(
             request,
-            propName$33.chunks.length,
-            newBoundary,
+            ref.chunks.length,
+            propName,
             task.formatContext,
             !1,
             !1
           );
-          propName$33.children.push(boundarySegment);
-          propName$33.lastPushedText = !1;
+          ref.children.push(boundarySegment);
+          ref.lastPushedText = !1;
           var contentRootSegment = createPendingSegment(
             request,
             0,
@@ -4155,13 +4186,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
             newProps = [keyPath[0], "Suspense Fallback", keyPath[2]];
             defaultProps = [newProps[1], newProps[2], [], null];
             request.trackedPostpones.workingMap.set(newProps, defaultProps);
-            newBoundary.trackedFallbackNode = defaultProps;
+            propName.trackedFallbackNode = defaultProps;
             task.blockedSegment = boundarySegment;
-            task.blockedPreamble = newBoundary.fallbackPreamble;
             task.keyPath = newProps;
             boundarySegment.status = 6;
             try {
-              renderNode(request, task, propName, -1),
+              renderNode(request, task, propName$33, -1),
                 pushSegmentFinale(
                   boundarySegment.chunks,
                   request.renderState,
@@ -4175,19 +4205,16 @@ function renderElement(request, task, keyPath, type, props, ref) {
                 thrownValue)
               );
             } finally {
-              (task.blockedSegment = propName$33),
-                (task.blockedPreamble = ref),
-                (task.keyPath = type);
+              (task.blockedSegment = ref), (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
               props,
               -1,
-              newBoundary,
+              propName,
               contentRootSegment,
-              newBoundary.contentPreamble,
-              newBoundary.contentState,
+              propName.contentState,
               task.abortSet,
               keyPath,
               task.formatContext,
@@ -4199,9 +4226,8 @@ function renderElement(request, task, keyPath, type, props, ref) {
             pushComponentStack(task);
             request.pingedTasks.push(task);
           } else {
-            task.blockedBoundary = newBoundary;
-            task.blockedPreamble = newBoundary.contentPreamble;
-            task.hoistableState = newBoundary.contentState;
+            task.blockedBoundary = propName;
+            task.hoistableState = propName.contentState;
             task.blockedSegment = contentRootSegment;
             task.keyPath = keyPath;
             contentRootSegment.status = 6;
@@ -4215,46 +4241,46 @@ function renderElement(request, task, keyPath, type, props, ref) {
                   contentRootSegment.textEmbedded
                 ),
                 (contentRootSegment.status = 1),
-                queueCompletedSegment(newBoundary, contentRootSegment),
-                0 === newBoundary.pendingTasks && 0 === newBoundary.status)
+                queueCompletedSegment(propName, contentRootSegment),
+                0 === propName.pendingTasks && 0 === propName.status)
               ) {
-                newBoundary.status = 1;
-                0 === request.pendingRootTasks &&
-                  task.blockedPreamble &&
-                  preparePreamble(request);
+                propName.status = 1;
                 break a;
               }
             } catch (thrownValue$28) {
-              (newBoundary.status = 4),
+              (propName.status = 4),
                 12 === request.status
                   ? ((contentRootSegment.status = 3),
                     (newProps = request.fatalError))
                   : ((contentRootSegment.status = 4),
                     (newProps = thrownValue$28)),
                 (defaultProps = getThrownInfo(task.componentStack)),
-                (initialState = logRecoverableError(
-                  request,
-                  newProps,
-                  defaultProps
-                )),
-                (newBoundary.errorDigest = initialState),
-                untrackBoundary(request, newBoundary);
+                "object" === typeof newProps &&
+                null !== newProps &&
+                newProps.$$typeof === REACT_POSTPONE_TYPE
+                  ? (logPostpone(request, newProps.message, defaultProps),
+                    (initialState = "POSTPONE"))
+                  : (initialState = logRecoverableError(
+                      request,
+                      newProps,
+                      defaultProps
+                    )),
+                (propName.errorDigest = initialState),
+                untrackBoundary(request, propName);
             } finally {
               (task.blockedBoundary = parentBoundary),
-                (task.blockedPreamble = ref),
                 (task.hoistableState = parentHoistableState),
-                (task.blockedSegment = propName$33),
+                (task.blockedSegment = ref),
                 (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
-              propName,
+              propName$33,
               -1,
               parentBoundary,
               boundarySegment,
-              newBoundary.fallbackPreamble,
-              newBoundary.fallbackState,
+              propName.fallbackState,
               fallbackAbortSet,
               [keyPath[0], "Suspense Fallback", keyPath[2]],
               task.formatContext,
@@ -4273,9 +4299,9 @@ function renderElement(request, task, keyPath, type, props, ref) {
       switch (type.$$typeof) {
         case REACT_FORWARD_REF_TYPE:
           if ("ref" in props)
-            for (newBoundary in ((newProps = {}), props))
-              "ref" !== newBoundary &&
-                (newProps[newBoundary] = props[newBoundary]);
+            for (boundarySegment in ((newProps = {}), props))
+              "ref" !== boundarySegment &&
+                (newProps[boundarySegment] = props[boundarySegment]);
           else newProps = props;
           type = renderWithHooks(
             request,
@@ -4447,16 +4473,13 @@ function retryNode(request, task) {
                         );
                       task.replay.pendingTasks--;
                       props = getThrownInfo(task.componentStack);
-                      key = task.blockedBoundary;
-                      type = x;
-                      props = logRecoverableError(request, type, props);
-                      abortRemainingReplayNodes(
+                      erroredReplay(
                         request,
-                        key,
+                        task.blockedBoundary,
+                        x,
+                        props,
                         childNodes,
-                        name,
-                        type,
-                        props
+                        name
                       );
                     }
                     task.replay = replay;
@@ -4468,9 +4491,9 @@ function retryNode(request, task) {
                           ">. The tree doesn't match so React will fallback to client rendering."
                       );
                     b: {
-                      replay = void 0;
-                      type = node$jscomp$0[5];
-                      ref = node$jscomp$0[2];
+                      type = void 0;
+                      ref = node$jscomp$0[5];
+                      replay = node$jscomp$0[2];
                       name = node$jscomp$0[3];
                       keyOrIndex =
                         null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
@@ -4480,30 +4503,20 @@ function retryNode(request, task) {
                         previousReplaySet = task.replay,
                         parentBoundary = task.blockedBoundary,
                         parentHoistableState = task.hoistableState,
-                        content = props.children,
-                        fallback = props.fallback,
-                        fallbackAbortSet = new Set();
-                      props =
-                        2 > task.formatContext.insertionMode
-                          ? createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              createPreambleState(),
-                              createPreambleState()
-                            )
-                          : createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              null,
-                              null
-                            );
-                      props.parentFlushed = !0;
-                      props.rootSegmentID = type;
-                      task.blockedBoundary = props;
-                      task.hoistableState = props.contentState;
+                        content = props.children;
+                      props = props.fallback;
+                      var fallbackAbortSet = new Set(),
+                        resumedBoundary = createSuspenseBoundary(
+                          request,
+                          fallbackAbortSet
+                        );
+                      resumedBoundary.parentFlushed = !0;
+                      resumedBoundary.rootSegmentID = ref;
+                      task.blockedBoundary = resumedBoundary;
+                      task.hoistableState = resumedBoundary.contentState;
                       task.keyPath = key;
                       task.replay = {
-                        nodes: ref,
+                        nodes: replay,
                         slots: name,
                         pendingTasks: 1
                       };
@@ -4517,22 +4530,32 @@ function retryNode(request, task) {
                             "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                           );
                         task.replay.pendingTasks--;
-                        if (0 === props.pendingTasks && 0 === props.status) {
-                          props.status = 1;
-                          request.completedBoundaries.push(props);
+                        if (
+                          0 === resumedBoundary.pendingTasks &&
+                          0 === resumedBoundary.status
+                        ) {
+                          resumedBoundary.status = 1;
+                          request.completedBoundaries.push(resumedBoundary);
                           break b;
                         }
                       } catch (error) {
-                        (props.status = 4),
+                        (resumedBoundary.status = 4),
                           (childNodes = getThrownInfo(task.componentStack)),
-                          (replay = logRecoverableError(
-                            request,
-                            error,
-                            childNodes
-                          )),
-                          (props.errorDigest = replay),
+                          "object" === typeof error &&
+                          null !== error &&
+                          error.$$typeof === REACT_POSTPONE_TYPE
+                            ? (logPostpone(request, error.message, childNodes),
+                              (type = "POSTPONE"))
+                            : (type = logRecoverableError(
+                                request,
+                                error,
+                                childNodes
+                              )),
+                          (resumedBoundary.errorDigest = type),
                           task.replay.pendingTasks--,
-                          request.clientRenderedBoundaries.push(props);
+                          request.clientRenderedBoundaries.push(
+                            resumedBoundary
+                          );
                       } finally {
                         (task.blockedBoundary = parentBoundary),
                           (task.hoistableState = parentHoistableState),
@@ -4547,10 +4570,10 @@ function retryNode(request, task) {
                           slots: node$jscomp$0,
                           pendingTasks: 0
                         },
-                        fallback,
+                        props,
                         -1,
                         parentBoundary,
-                        props.fallbackState,
+                        resumedBoundary.fallbackState,
                         fallbackAbortSet,
                         [key[0], "Suspense Fallback", key[2]],
                         task.formatContext,
@@ -4601,6 +4624,31 @@ function retryNode(request, task) {
         }
         return;
       }
+      if (
+        "function" === typeof node[ASYNC_ITERATOR] &&
+        (childNodes = node[ASYNC_ITERATOR]())
+      ) {
+        props = task.thenableState;
+        task.thenableState = null;
+        thenableIndexCounter = 0;
+        thenableState = props;
+        props = [];
+        key = !1;
+        if (childNodes === node)
+          for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+            if (node.done) {
+              key = !0;
+              break;
+            }
+            props.push(node.value);
+            node = readPreviousThenableFromState();
+          }
+        if (!key)
+          for (node = unwrapThenable(childNodes.next()); !node.done; )
+            props.push(node.value), (node = unwrapThenable(childNodes.next()));
+        renderChildrenArray(request, task, props, childIndex);
+        return;
+      }
       if ("function" === typeof node.then)
         return (
           (task.thenableState = null),
@@ -4613,32 +4661,32 @@ function retryNode(request, task) {
           node._currentValue2,
           childIndex
         );
-      childIndex = Object.prototype.toString.call(node);
+      request = Object.prototype.toString.call(node);
       throw Error(
         "Objects are not valid as a React child (found: " +
-          ("[object Object]" === childIndex
+          ("[object Object]" === request
             ? "object with keys {" + Object.keys(node).join(", ") + "}"
-            : childIndex) +
+            : request) +
           "). If you meant to render a collection of children, use an array instead."
       );
     }
     if ("string" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
     else if ("number" === typeof node || "bigint" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             "" + node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
   }
 }
@@ -4675,16 +4723,13 @@ function renderChildrenArray(request, task, children, childIndex) {
             throw x;
           task.replay.pendingTasks--;
           children = getThrownInfo(task.componentStack);
-          var boundary = task.blockedBoundary,
-            error = x;
-          children = logRecoverableError(request, error, children);
-          abortRemainingReplayNodes(
+          erroredReplay(
             request,
-            boundary,
+            task.blockedBoundary,
+            x,
+            children,
             childIndex,
-            node,
-            error,
-            children
+            node
           );
         }
         task.replay = replay;
@@ -4701,14 +4746,15 @@ function renderChildrenArray(request, task, children, childIndex) {
     null !== task.replay &&
     ((j = task.replay.slots), null !== j && "object" === typeof j)
   ) {
-    for (childIndex = 0; childIndex < replayNodes; childIndex++)
-      (node = children[childIndex]),
-        (task.treeContext = pushTreeContext(replay, replayNodes, childIndex)),
-        (boundary = j[childIndex]),
-        "number" === typeof boundary
-          ? (resumeNode(request, task, boundary, node, childIndex),
-            delete j[childIndex])
-          : renderNode(request, task, node, childIndex);
+    for (childIndex = 0; childIndex < replayNodes; childIndex++) {
+      node = children[childIndex];
+      task.treeContext = pushTreeContext(replay, replayNodes, childIndex);
+      var resumeSegmentID = j[childIndex];
+      "number" === typeof resumeSegmentID
+        ? (resumeNode(request, task, resumeSegmentID, node, childIndex),
+          delete j[childIndex])
+        : renderNode(request, task, node, childIndex);
+    }
     task.treeContext = replay;
     task.keyPath = prevKeyPath;
     return;
@@ -4720,6 +4766,105 @@ function renderChildrenArray(request, task, children, childIndex) {
   task.treeContext = replay;
   task.keyPath = prevKeyPath;
 }
+function trackPostpone(request, trackedPostpones, task, segment) {
+  segment.status = 5;
+  var keyPath = task.keyPath,
+    boundary = task.blockedBoundary;
+  if (null === boundary)
+    (segment.id = request.nextSegmentId++),
+      (trackedPostpones.rootSlots = segment.id),
+      null !== request.completedRootSegment &&
+        (request.completedRootSegment.status = 5);
+  else {
+    if (null !== boundary && 0 === boundary.status) {
+      boundary.status = 5;
+      boundary.rootSegmentID = request.nextSegmentId++;
+      var boundaryKeyPath = boundary.trackedContentKeyPath;
+      if (null === boundaryKeyPath)
+        throw Error(
+          "It should not be possible to postpone at the root. This is a bug in React."
+        );
+      var fallbackReplayNode = boundary.trackedFallbackNode,
+        children = [];
+      if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+        -1 === segment.id &&
+          (segment.id = segment.parentFlushed
+            ? boundary.rootSegmentID
+            : request.nextSegmentId++);
+        segment = [
+          boundaryKeyPath[1],
+          boundaryKeyPath[2],
+          children,
+          segment.id,
+          fallbackReplayNode,
+          boundary.rootSegmentID
+        ];
+        trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+        addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+        return;
+      }
+      var boundaryNode$44 = trackedPostpones.workingMap.get(boundaryKeyPath);
+      void 0 === boundaryNode$44
+        ? ((boundaryNode$44 = [
+            boundaryKeyPath[1],
+            boundaryKeyPath[2],
+            children,
+            null,
+            fallbackReplayNode,
+            boundary.rootSegmentID
+          ]),
+          trackedPostpones.workingMap.set(boundaryKeyPath, boundaryNode$44),
+          addToReplayParent(
+            boundaryNode$44,
+            boundaryKeyPath[0],
+            trackedPostpones
+          ))
+        : ((boundaryKeyPath = boundaryNode$44),
+          (boundaryKeyPath[4] = fallbackReplayNode),
+          (boundaryKeyPath[5] = boundary.rootSegmentID));
+    }
+    -1 === segment.id &&
+      (segment.id =
+        segment.parentFlushed && null !== boundary
+          ? boundary.rootSegmentID
+          : request.nextSegmentId++);
+    if (-1 === task.childIndex)
+      null === keyPath
+        ? (trackedPostpones.rootSlots = segment.id)
+        : ((task = trackedPostpones.workingMap.get(keyPath)),
+          void 0 === task
+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+              addToReplayParent(task, keyPath[0], trackedPostpones))
+            : (task[3] = segment.id));
+    else {
+      if (null === keyPath)
+        if (((request = trackedPostpones.rootSlots), null === request))
+          request = trackedPostpones.rootSlots = {};
+        else {
+          if ("number" === typeof request)
+            throw Error(
+              "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+            );
+        }
+      else if (
+        ((boundary = trackedPostpones.workingMap),
+        (boundaryKeyPath = boundary.get(keyPath)),
+        void 0 === boundaryKeyPath)
+      )
+        (request = {}),
+          (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+          boundary.set(keyPath, boundaryKeyPath),
+          addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+      else if (((request = boundaryKeyPath[3]), null === request))
+        request = boundaryKeyPath[3] = {};
+      else if ("number" === typeof request)
+        throw Error(
+          "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+        );
+      request[task.childIndex] = segment.id;
+    }
+  }
+}
 function untrackBoundary(request, boundary) {
   request = request.trackedPostpones;
   null !== request &&
@@ -4766,7 +4911,6 @@ function spawnNewSuspendedRenderTask(request, task, thenableState) {
     task.childIndex,
     task.blockedBoundary,
     newSegment,
-    task.blockedPreamble,
     task.hoistableState,
     task.abortSet,
     task.keyPath,
@@ -4790,13 +4934,14 @@ function renderNode(request, task, node, childIndex) {
     } catch (thrownValue) {
       if (
         (resetHooksState(),
-        (node =
+        (childIndex =
           thrownValue === SuspenseException
             ? getSuspendedThenable()
             : thrownValue),
-        "object" === typeof node && null !== node)
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -4808,7 +4953,7 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedReplayTask(request, task, node);
           request.pingedTasks.push(node);
@@ -4827,18 +4972,19 @@ function renderNode(request, task, node, childIndex) {
       chunkLength = segment.chunks.length;
     try {
       return renderNodeDestructive(request, task, node, childIndex);
-    } catch (thrownValue$48) {
+    } catch (thrownValue$56) {
       if (
         (resetHooksState(),
         (segment.children.length = childrenLength),
         (segment.chunks.length = chunkLength),
-        (node =
-          thrownValue$48 === SuspenseException
+        (childIndex =
+          thrownValue$56 === SuspenseException
             ? getSuspendedThenable()
-            : thrownValue$48),
-        "object" === typeof node && null !== node)
+            : thrownValue$56),
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -4850,7 +4996,35 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if (
+          childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+          null !== request.trackedPostpones &&
+          null !== task.blockedBoundary
+        ) {
+          node = request.trackedPostpones;
+          segment = getThrownInfo(task.componentStack);
+          logPostpone(request, childIndex.message, segment);
+          childIndex = task.blockedSegment;
+          segment = createPendingSegment(
+            request,
+            childIndex.chunks.length,
+            null,
+            task.formatContext,
+            childIndex.lastPushedText,
+            !0
+          );
+          childIndex.children.push(segment);
+          childIndex.lastPushedText = !1;
+          trackPostpone(request, node, task, segment);
+          task.formatContext = previousFormatContext;
+          task.context = previousContext;
+          task.keyPath = previousKeyPath;
+          task.treeContext = previousTreeContext;
+          task.componentStack = previousComponentStack;
+          switchContext(previousContext);
+          return;
+        }
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedRenderTask(request, task, node);
           request.pingedTasks.push(node);
@@ -4870,7 +5044,29 @@ function renderNode(request, task, node, childIndex) {
   task.keyPath = previousKeyPath;
   task.treeContext = previousTreeContext;
   switchContext(previousContext);
-  throw node;
+  throw childIndex;
+}
+function erroredReplay(
+  request,
+  boundary,
+  error,
+  errorInfo,
+  replayNodes,
+  resumeSlots
+) {
+  "object" === typeof error &&
+  null !== error &&
+  error.$$typeof === REACT_POSTPONE_TYPE
+    ? (logPostpone(request, error.message, errorInfo), (errorInfo = "POSTPONE"))
+    : (errorInfo = logRecoverableError(request, error, errorInfo));
+  abortRemainingReplayNodes(
+    request,
+    boundary,
+    replayNodes,
+    resumeSlots,
+    error,
+    errorInfo
+  );
 }
 function abortTaskSoft(task) {
   var boundary = task.blockedBoundary;
@@ -4900,12 +5096,7 @@ function abortRemainingReplayNodes(
       node = node[5];
       var request = request$jscomp$0,
         errorDigest = errorDigest$jscomp$0,
-        resumedBoundary = createSuspenseBoundary(
-          request,
-          new Set(),
-          null,
-          null
-        );
+        resumedBoundary = createSuspenseBoundary(request, new Set());
       resumedBoundary.parentFlushed = !0;
       resumedBoundary.rootSegmentID = node;
       resumedBoundary.status = 4;
@@ -4935,44 +5126,100 @@ function abortTask(task, request, error) {
     if (6 === segment.status) return;
     segment.status = 3;
   }
-  segment = getThrownInfo(task.componentStack);
+  var errorInfo = getThrownInfo(task.componentStack);
   if (null === boundary) {
     if (13 !== request.status && 14 !== request.status) {
       boundary = task.replay;
       if (null === boundary) {
-        logRecoverableError(request, error, segment);
-        fatalError(request, error);
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? ((boundary = request.trackedPostpones),
+            null !== boundary && null !== segment
+              ? (logPostpone(request, error.message, errorInfo),
+                trackPostpone(request, boundary, task, segment),
+                finishedTask(request, null, segment))
+              : ((task = Error(
+                  "The render was aborted with postpone when the shell is incomplete. Reason: " +
+                    error.message
+                )),
+                logRecoverableError(request, task, errorInfo),
+                fatalError(request, task)))
+          : null !== request.trackedPostpones && null !== segment
+            ? ((boundary = request.trackedPostpones),
+              logRecoverableError(request, error, errorInfo),
+              trackPostpone(request, boundary, task, segment),
+              finishedTask(request, null, segment))
+            : (logRecoverableError(request, error, errorInfo),
+              fatalError(request, error));
         return;
       }
       boundary.pendingTasks--;
       0 === boundary.pendingTasks &&
         0 < boundary.nodes.length &&
-        ((task = logRecoverableError(request, error, segment)),
+        ("object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? (logPostpone(request, error.message, errorInfo),
+            (errorInfo = "POSTPONE"))
+          : (errorInfo = logRecoverableError(request, error, errorInfo)),
         abortRemainingReplayNodes(
           request,
           null,
           boundary.nodes,
           boundary.slots,
           error,
-          task
+          errorInfo
         ));
       request.pendingRootTasks--;
       0 === request.pendingRootTasks && completeShell(request);
     }
-  } else
-    boundary.pendingTasks--,
-      4 !== boundary.status &&
-        ((boundary.status = 4),
-        (task = logRecoverableError(request, error, segment)),
-        (boundary.status = 4),
-        (boundary.errorDigest = task),
-        untrackBoundary(request, boundary),
-        boundary.parentFlushed &&
-          request.clientRenderedBoundaries.push(boundary)),
-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-        return abortTask(fallbackTask, request, error);
-      }),
-      boundary.fallbackAbortableTasks.clear();
+  } else {
+    boundary.pendingTasks--;
+    var trackedPostpones$59 = request.trackedPostpones;
+    if (4 !== boundary.status) {
+      if (null !== trackedPostpones$59 && null !== segment)
+        return (
+          "object" === typeof error &&
+          null !== error &&
+          error.$$typeof === REACT_POSTPONE_TYPE
+            ? logPostpone(request, error.message, errorInfo)
+            : logRecoverableError(request, error, errorInfo),
+          trackPostpone(request, trackedPostpones$59, task, segment),
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          }),
+          boundary.fallbackAbortableTasks.clear(),
+          finishedTask(request, boundary, segment)
+        );
+      boundary.status = 4;
+      if (
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+      ) {
+        logPostpone(request, error.message, errorInfo);
+        if (null !== request.trackedPostpones && null !== segment) {
+          trackPostpone(request, request.trackedPostpones, task, segment);
+          finishedTask(request, task.blockedBoundary, segment);
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          });
+          boundary.fallbackAbortableTasks.clear();
+          return;
+        }
+        errorInfo = "POSTPONE";
+      } else errorInfo = logRecoverableError(request, error, errorInfo);
+      boundary.status = 4;
+      boundary.errorDigest = errorInfo;
+      untrackBoundary(request, boundary);
+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
+    }
+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+      return abortTask(fallbackTask, request, error);
+    });
+    boundary.fallbackAbortableTasks.clear();
+  }
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
@@ -5039,7 +5286,6 @@ function safelyEmitEarlyPreloads(request, shellComplete) {
 }
 function completeShell(request) {
   null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-  null === request.trackedPostpones && preparePreamble(request);
   request.onShellError = noop;
   request = request.onShellReady;
   request();
@@ -5052,7 +5298,6 @@ function completeAll(request) {
       : null === request.completedRootSegment ||
           5 !== request.completedRootSegment.status
   );
-  preparePreamble(request);
   request = request.onAllReady;
   request();
 }
@@ -5093,11 +5338,7 @@ function finishedTask(request, boundary, segment) {
               request.completedBoundaries.push(boundary),
             1 === boundary.status &&
               (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),
-              boundary.fallbackAbortableTasks.clear(),
-              0 === request.pendingRootTasks &&
-                null === request.trackedPostpones &&
-                null !== boundary.contentPreamble &&
-                preparePreamble(request)))
+              boundary.fallbackAbortableTasks.clear()))
           : null !== segment &&
             segment.parentFlushed &&
             1 === segment.status &&
@@ -5108,23 +5349,23 @@ function finishedTask(request, boundary, segment) {
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
-function performWork(request$jscomp$2) {
-  if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
+function performWork(request$jscomp$1) {
+  if (14 !== request$jscomp$1.status && 13 !== request$jscomp$1.status) {
     var prevContext = currentActiveSnapshot,
       prevDispatcher = ReactSharedInternals.H;
     ReactSharedInternals.H = HooksDispatcher;
     var prevAsyncDispatcher = ReactSharedInternals.A;
     ReactSharedInternals.A = DefaultAsyncDispatcher;
     var prevRequest = currentRequest;
-    currentRequest = request$jscomp$2;
+    currentRequest = request$jscomp$1;
     var prevResumableState = currentResumableState;
-    currentResumableState = request$jscomp$2.resumableState;
+    currentResumableState = request$jscomp$1.resumableState;
     try {
-      var pingedTasks = request$jscomp$2.pingedTasks,
+      var pingedTasks = request$jscomp$1.pingedTasks,
         i;
       for (i = 0; i < pingedTasks.length; i++) {
         var task = pingedTasks[i],
-          request = request$jscomp$2,
+          request = request$jscomp$1,
           segment = task.blockedSegment;
         if (null === segment) {
           var request$jscomp$0 = request;
@@ -5168,27 +5409,15 @@ function performWork(request$jscomp$2) {
                 task.replay.pendingTasks--;
                 task.abortSet.delete(task);
                 var errorInfo = getThrownInfo(task.componentStack);
-                request = void 0;
-                var request$jscomp$1 = request$jscomp$0,
-                  boundary = task.blockedBoundary,
-                  error$jscomp$0 =
-                    12 === request$jscomp$0.status
-                      ? request$jscomp$0.fatalError
-                      : x,
-                  replayNodes = task.replay.nodes,
-                  resumeSlots = task.replay.slots;
-                request = logRecoverableError(
-                  request$jscomp$1,
-                  error$jscomp$0,
-                  errorInfo
-                );
-                abortRemainingReplayNodes(
-                  request$jscomp$1,
-                  boundary,
-                  replayNodes,
-                  resumeSlots,
-                  error$jscomp$0,
-                  request
+                erroredReplay(
+                  request$jscomp$0,
+                  task.blockedBoundary,
+                  12 === request$jscomp$0.status
+                    ? request$jscomp$0.fatalError
+                    : x,
+                  errorInfo,
+                  task.replay.nodes,
+                  task.replay.slots
                 );
                 request$jscomp$0.pendingRootTasks--;
                 0 === request$jscomp$0.pendingRootTasks &&
@@ -5200,81 +5429,127 @@ function performWork(request$jscomp$2) {
             } finally {
             }
           }
-        } else if (
-          ((request$jscomp$0 = void 0),
-          (request$jscomp$1 = segment),
-          0 === request$jscomp$1.status)
-        ) {
-          request$jscomp$1.status = 6;
-          switchContext(task.context);
-          var childrenLength = request$jscomp$1.children.length,
-            chunkLength = request$jscomp$1.chunks.length;
-          try {
-            retryNode(request, task),
-              pushSegmentFinale(
-                request$jscomp$1.chunks,
-                request.renderState,
-                request$jscomp$1.lastPushedText,
-                request$jscomp$1.textEmbedded
-              ),
-              task.abortSet.delete(task),
-              (request$jscomp$1.status = 1),
-              finishedTask(request, task.blockedBoundary, request$jscomp$1);
-          } catch (thrownValue) {
-            resetHooksState();
-            request$jscomp$1.children.length = childrenLength;
-            request$jscomp$1.chunks.length = chunkLength;
-            var x$jscomp$0 =
-              thrownValue === SuspenseException
-                ? getSuspendedThenable()
-                : 12 === request.status
-                  ? request.fatalError
-                  : thrownValue;
-            if (
-              "object" === typeof x$jscomp$0 &&
-              null !== x$jscomp$0 &&
-              "function" === typeof x$jscomp$0.then
-            ) {
-              request$jscomp$1.status = 0;
-              task.thenableState = getThenableStateAfterSuspending();
-              var ping$jscomp$0 = task.ping;
-              x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-            } else {
-              var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
-              task.abortSet.delete(task);
-              request$jscomp$1.status = 4;
-              var boundary$jscomp$0 = task.blockedBoundary;
-              request$jscomp$0 = logRecoverableError(
-                request,
-                x$jscomp$0,
-                errorInfo$jscomp$0
-              );
-              null === boundary$jscomp$0
-                ? fatalError(request, x$jscomp$0)
-                : (boundary$jscomp$0.pendingTasks--,
-                  4 !== boundary$jscomp$0.status &&
-                    ((boundary$jscomp$0.status = 4),
-                    (boundary$jscomp$0.errorDigest = request$jscomp$0),
-                    untrackBoundary(request, boundary$jscomp$0),
-                    boundary$jscomp$0.parentFlushed &&
-                      request.clientRenderedBoundaries.push(boundary$jscomp$0),
-                    0 === request.pendingRootTasks &&
-                      null === request.trackedPostpones &&
-                      null !== boundary$jscomp$0.contentPreamble &&
-                      preparePreamble(request)));
-              request.allPendingTasks--;
-              0 === request.allPendingTasks && completeAll(request);
+        } else
+          a: {
+            request$jscomp$0 = void 0;
+            var segment$jscomp$0 = segment;
+            if (0 === segment$jscomp$0.status) {
+              segment$jscomp$0.status = 6;
+              switchContext(task.context);
+              var childrenLength = segment$jscomp$0.children.length,
+                chunkLength = segment$jscomp$0.chunks.length;
+              try {
+                retryNode(request, task),
+                  pushSegmentFinale(
+                    segment$jscomp$0.chunks,
+                    request.renderState,
+                    segment$jscomp$0.lastPushedText,
+                    segment$jscomp$0.textEmbedded
+                  ),
+                  task.abortSet.delete(task),
+                  (segment$jscomp$0.status = 1),
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+              } catch (thrownValue) {
+                resetHooksState();
+                segment$jscomp$0.children.length = childrenLength;
+                segment$jscomp$0.chunks.length = chunkLength;
+                var x$jscomp$0 =
+                  thrownValue === SuspenseException
+                    ? getSuspendedThenable()
+                    : 12 === request.status
+                      ? request.fatalError
+                      : thrownValue;
+                if (
+                  12 === request.status &&
+                  null !== request.trackedPostpones
+                ) {
+                  var trackedPostpones = request.trackedPostpones,
+                    thrownInfo = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? logPostpone(request, x$jscomp$0.message, thrownInfo)
+                    : logRecoverableError(request, x$jscomp$0, thrownInfo);
+                  trackPostpone(
+                    request,
+                    trackedPostpones,
+                    task,
+                    segment$jscomp$0
+                  );
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+                } else {
+                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0) {
+                    if ("function" === typeof x$jscomp$0.then) {
+                      segment$jscomp$0.status = 0;
+                      task.thenableState = getThenableStateAfterSuspending();
+                      var ping$jscomp$0 = task.ping;
+                      x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                      break a;
+                    }
+                    if (
+                      null !== request.trackedPostpones &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ) {
+                      var trackedPostpones$63 = request.trackedPostpones;
+                      task.abortSet.delete(task);
+                      var postponeInfo = getThrownInfo(task.componentStack);
+                      logPostpone(request, x$jscomp$0.message, postponeInfo);
+                      trackPostpone(
+                        request,
+                        trackedPostpones$63,
+                        task,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                      break a;
+                    }
+                  }
+                  var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  segment$jscomp$0.status = 4;
+                  var boundary = task.blockedBoundary;
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        x$jscomp$0.message,
+                        errorInfo$jscomp$0
+                      ),
+                      (request$jscomp$0 = "POSTPONE"))
+                    : (request$jscomp$0 = logRecoverableError(
+                        request,
+                        x$jscomp$0,
+                        errorInfo$jscomp$0
+                      ));
+                  null === boundary
+                    ? fatalError(request, x$jscomp$0)
+                    : (boundary.pendingTasks--,
+                      4 !== boundary.status &&
+                        ((boundary.status = 4),
+                        (boundary.errorDigest = request$jscomp$0),
+                        untrackBoundary(request, boundary),
+                        boundary.parentFlushed &&
+                          request.clientRenderedBoundaries.push(boundary)));
+                  request.allPendingTasks--;
+                  0 === request.allPendingTasks && completeAll(request);
+                }
+              } finally {
+              }
             }
-          } finally {
           }
-        }
       }
       pingedTasks.splice(0, i);
-      null !== request$jscomp$2.destination &&
-        flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
+      null !== request$jscomp$1.destination &&
+        flushCompletedQueues(request$jscomp$1, request$jscomp$1.destination);
     } catch (error) {
-      logRecoverableError(request$jscomp$2, error, {}),
-        fatalError(request$jscomp$2, error);
+      logRecoverableError(request$jscomp$1, error, {}),
+        fatalError(request$jscomp$1, error);
     } finally {
       (currentResumableState = prevResumableState),
         (ReactSharedInternals.H = prevDispatcher),
@@ -5284,85 +5559,6 @@ function performWork(request$jscomp$2) {
     }
   }
 }
-function preparePreambleFromSubtree(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  segment.preambleChildren.length &&
-    collectedPreambleSegments.push(segment.preambleChildren);
-  for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-    pendingPreambles =
-      preparePreambleFromSegment(
-        request,
-        segment.children[i],
-        collectedPreambleSegments
-      ) || pendingPreambles;
-  return pendingPreambles;
-}
-function preparePreambleFromSegment(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  var boundary = segment.boundary;
-  if (null === boundary)
-    return preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    );
-  var preamble = boundary.contentPreamble,
-    fallbackPreamble = boundary.fallbackPreamble;
-  if (null === preamble || null === fallbackPreamble) return !1;
-  switch (boundary.status) {
-    case 1:
-      hoistPreambleState(request.renderState, preamble);
-      segment = boundary.completedSegments[0];
-      if (!segment)
-        throw Error(
-          "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
-        );
-      return preparePreambleFromSubtree(
-        request,
-        segment,
-        collectedPreambleSegments
-      );
-    case 5:
-      if (null !== request.trackedPostpones) return !0;
-    case 4:
-      if (1 === segment.status)
-        return (
-          hoistPreambleState(request.renderState, fallbackPreamble),
-          preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          )
-        );
-    default:
-      return !0;
-  }
-}
-function preparePreamble(request) {
-  if (
-    request.completedRootSegment &&
-    null === request.completedPreambleSegments
-  ) {
-    var collectedPreambleSegments = [],
-      hasPendingPreambles = preparePreambleFromSegment(
-        request,
-        request.completedRootSegment,
-        collectedPreambleSegments
-      ),
-      preamble = request.renderState.preamble;
-    if (
-      !1 === hasPendingPreambles ||
-      (preamble.headChunks && preamble.bodyChunks)
-    )
-      request.completedPreambleSegments = collectedPreambleSegments;
-  }
-}
 function flushSubtree(request, destination, segment, hoistableState) {
   segment.parentFlushed = !0;
   switch (segment.status) {
@@ -5508,37 +5704,47 @@ function flushCompletedBoundary(request, destination, boundary) {
   boundary = boundary.contentState;
   var requiresStyleInsertion = request.stylesToHoist;
   request.stylesToHoist = !1;
-  destination.push(request.startInlineScript);
-  requiresStyleInsertion
-    ? 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 10),
-        destination.push(
-          '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
-        ))
-      : 0 === (completedSegments.instructions & 8)
-        ? ((completedSegments.instructions |= 8),
-          destination.push(
-            '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
-          ))
-        : destination.push('$RR("')
-    : 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 2),
-        destination.push(
-          '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
-        ))
-      : destination.push('$RC("');
+  var scriptFormat = 0 === completedSegments.streamingFormat;
+  scriptFormat
+    ? (destination.push(request.startInlineScript),
+      requiresStyleInsertion
+        ? 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 10),
+            destination.push(
+              '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
+            ))
+          : 0 === (completedSegments.instructions & 8)
+            ? ((completedSegments.instructions |= 8),
+              destination.push(
+                '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
+              ))
+            : destination.push('$RR("')
+        : 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 2),
+            destination.push(
+              '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
+            ))
+          : destination.push('$RC("'))
+    : requiresStyleInsertion
+      ? destination.push('<template data-rri="" data-bid="')
+      : destination.push('<template data-rci="" data-bid="');
   completedSegments = i.toString(16);
   destination.push(request.boundaryPrefix);
   destination.push(completedSegments);
-  destination.push('","');
+  scriptFormat ? destination.push('","') : destination.push('" data-sid="');
   destination.push(request.segmentPrefix);
   destination.push(completedSegments);
   requiresStyleInsertion
-    ? (destination.push('",'),
-      writeStyleResourceDependenciesInJS(destination, boundary))
-    : destination.push('"');
-  boundary = destination.push(")\x3c/script>");
-  return writeBootstrap(destination, request) && boundary;
+    ? scriptFormat
+      ? (destination.push('",'),
+        writeStyleResourceDependenciesInJS(destination, boundary))
+      : (destination.push('" data-sty="'),
+        writeStyleResourceDependenciesInAttr(destination, boundary))
+    : scriptFormat && destination.push('"');
+  completedSegments = scriptFormat
+    ? destination.push(")\x3c/script>")
+    : destination.push('"></template>');
+  return writeBootstrap(destination, request) && completedSegments;
 }
 function flushPartiallyCompletedSegment(
   request,
@@ -5561,20 +5767,24 @@ function flushPartiallyCompletedSegment(
   flushSegmentContainer(request, destination, segment, hoistableState);
   boundary = request.resumableState;
   request = request.renderState;
-  destination.push(request.startInlineScript);
-  0 === (boundary.instructions & 1)
-    ? ((boundary.instructions |= 1),
-      destination.push(
-        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
-      ))
-    : destination.push('$RS("');
+  (segment = 0 === boundary.streamingFormat)
+    ? (destination.push(request.startInlineScript),
+      0 === (boundary.instructions & 1)
+        ? ((boundary.instructions |= 1),
+          destination.push(
+            '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
+          ))
+        : destination.push('$RS("'))
+    : destination.push('<template data-rsi="" data-sid="');
   destination.push(request.segmentPrefix);
   segmentID = segmentID.toString(16);
   destination.push(segmentID);
-  destination.push('","');
+  segment ? destination.push('","') : destination.push('" data-pid="');
   destination.push(request.placeholderPrefix);
   destination.push(segmentID);
-  destination = destination.push('")\x3c/script>');
+  destination = segment
+    ? destination.push('")\x3c/script>')
+    : destination.push('"></template>');
   return destination;
 }
 function flushCompletedQueues(request, destination) {
@@ -5584,12 +5794,22 @@ function flushCompletedQueues(request, destination) {
         completedRootSegment = request.completedRootSegment;
       if (null !== completedRootSegment) {
         if (5 === completedRootSegment.status) return;
-        var completedPreambleSegments = request.completedPreambleSegments;
-        if (null === completedPreambleSegments) return;
-        var renderState = request.renderState,
-          preamble = renderState.preamble,
-          htmlChunks = preamble.htmlChunks,
-          headChunks = preamble.headChunks,
+        var renderState = request.renderState;
+        if (
+          (0 !== request.allPendingTasks ||
+            null !== request.trackedPostpones) &&
+          renderState.externalRuntimeScript
+        ) {
+          var _renderState$external = renderState.externalRuntimeScript,
+            resumableState = request.resumableState,
+            src = _renderState$external.src,
+            chunks = _renderState$external.chunks;
+          resumableState.scriptResources.hasOwnProperty(src) ||
+            ((resumableState.scriptResources[src] = null),
+            renderState.scripts.add(chunks));
+        }
+        var htmlChunks = renderState.htmlChunks,
+          headChunks = renderState.headChunks,
           i$jscomp$0;
         if (htmlChunks) {
           for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -5632,29 +5852,11 @@ function flushCompletedQueues(request, destination) {
         var hoistableChunks = renderState.hoistableChunks;
         for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
           destination.push(hoistableChunks[i$jscomp$0]);
-        for (
-          renderState = hoistableChunks.length = 0;
-          renderState < completedPreambleSegments.length;
-          renderState++
-        ) {
-          var segments = completedPreambleSegments[renderState];
-          for (preamble = 0; preamble < segments.length; preamble++)
-            flushSegment(request, destination, segments[preamble], null);
-        }
-        var preamble$jscomp$0 = request.renderState.preamble,
-          headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-        if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
+        hoistableChunks.length = 0;
+        if (htmlChunks && null === headChunks) {
           var chunk$jscomp$0 = endChunkForTag("head");
           destination.push(chunk$jscomp$0);
         }
-        var bodyChunks = preamble$jscomp$0.bodyChunks;
-        if (bodyChunks)
-          for (
-            completedPreambleSegments = 0;
-            completedPreambleSegments < bodyChunks.length;
-            completedPreambleSegments++
-          )
-            destination.push(bodyChunks[completedPreambleSegments]);
         flushSegment(request, destination, completedRootSegment, null);
         request.completedRootSegment = null;
         writeBootstrap(destination, request.renderState);
@@ -5695,30 +5897,39 @@ function flushCompletedQueues(request, destination) {
       for (i = 0; i < clientRenderedBoundaries.length; i++) {
         var boundary = clientRenderedBoundaries[i];
         renderState$jscomp$0 = destination;
-        var resumableState = request.resumableState,
+        var resumableState$jscomp$0 = request.resumableState,
           renderState$jscomp$1 = request.renderState,
           id = boundary.rootSegmentID,
-          errorDigest = boundary.errorDigest;
-        renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);
-        0 === (resumableState.instructions & 4)
-          ? ((resumableState.instructions |= 4),
-            renderState$jscomp$0.push(
-              '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
-            ))
-          : renderState$jscomp$0.push('$RX("');
+          errorDigest = boundary.errorDigest,
+          scriptFormat = 0 === resumableState$jscomp$0.streamingFormat;
+        scriptFormat
+          ? (renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript),
+            0 === (resumableState$jscomp$0.instructions & 4)
+              ? ((resumableState$jscomp$0.instructions |= 4),
+                renderState$jscomp$0.push(
+                  '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
+                ))
+              : renderState$jscomp$0.push('$RX("'))
+          : renderState$jscomp$0.push('<template data-rxi="" data-bid="');
         renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);
         var chunk$jscomp$1 = id.toString(16);
         renderState$jscomp$0.push(chunk$jscomp$1);
-        renderState$jscomp$0.push('"');
-        if (errorDigest) {
-          renderState$jscomp$0.push(",");
-          var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
-            errorDigest || ""
-          );
-          renderState$jscomp$0.push(chunk$jscomp$2);
-        }
-        var JSCompiler_inline_result =
-          renderState$jscomp$0.push(")\x3c/script>");
+        scriptFormat && renderState$jscomp$0.push('"');
+        if (errorDigest)
+          if (scriptFormat) {
+            renderState$jscomp$0.push(",");
+            var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
+              errorDigest || ""
+            );
+            renderState$jscomp$0.push(chunk$jscomp$2);
+          } else {
+            renderState$jscomp$0.push('" data-dgst="');
+            var chunk$jscomp$3 = escapeTextForBrowser(errorDigest || "");
+            renderState$jscomp$0.push(chunk$jscomp$3);
+          }
+        var JSCompiler_inline_result = scriptFormat
+          ? renderState$jscomp$0.push(")\x3c/script>")
+          : renderState$jscomp$0.push('"></template>');
         if (!JSCompiler_inline_result) {
           request.destination = null;
           i++;
@@ -5740,11 +5951,11 @@ function flushCompletedQueues(request, destination) {
       completedBoundaries.splice(0, i);
       var partialBoundaries = request.partialBoundaries;
       for (i = 0; i < partialBoundaries.length; i++) {
-        var boundary$51 = partialBoundaries[i];
+        var boundary$66 = partialBoundaries[i];
         a: {
           clientRenderedBoundaries = request;
           boundary = destination;
-          var completedSegments = boundary$51.completedSegments;
+          var completedSegments = boundary$66.completedSegments;
           for (
             JSCompiler_inline_result = 0;
             JSCompiler_inline_result < completedSegments.length;
@@ -5754,7 +5965,7 @@ function flushCompletedQueues(request, destination) {
               !flushPartiallyCompletedSegment(
                 clientRenderedBoundaries,
                 boundary,
-                boundary$51,
+                boundary$66,
                 completedSegments[JSCompiler_inline_result]
               )
             ) {
@@ -5766,7 +5977,7 @@ function flushCompletedQueues(request, destination) {
           completedSegments.splice(0, JSCompiler_inline_result);
           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
             boundary,
-            boundary$51.contentState,
+            boundary$66.contentState,
             clientRenderedBoundaries.renderState
           );
         }
@@ -5794,11 +6005,12 @@ function flushCompletedQueues(request, destination) {
       0 === request.clientRenderedBoundaries.length &&
       0 === request.completedBoundaries.length &&
       ((request.flushScheduled = !1),
-      (i = request.resumableState),
-      i.hasBody &&
-        ((partialBoundaries = endChunkForTag("body")),
-        destination.push(partialBoundaries)),
-      i.hasHtml && ((i = endChunkForTag("html")), destination.push(i)),
+      null === request.trackedPostpones &&
+        ((i = request.resumableState),
+        i.hasBody &&
+          ((partialBoundaries = endChunkForTag("body")),
+          destination.push(partialBoundaries)),
+        i.hasHtml && ((i = endChunkForTag("html")), destination.push(i))),
       (request.status = 14),
       destination.push(null),
       (request.destination = null));
@@ -5850,8 +6062,20 @@ function abort(request, reason) {
     }
     null !== request.destination &&
       flushCompletedQueues(request, request.destination);
-  } catch (error$53) {
-    logRecoverableError(request, error$53, {}), fatalError(request, error$53);
+  } catch (error$68) {
+    logRecoverableError(request, error$68, {}), fatalError(request, error$68);
+  }
+}
+function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+  if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+  else {
+    var workingMap = trackedPostpones.workingMap,
+      parentNode = workingMap.get(parentKeyPath);
+    void 0 === parentNode &&
+      ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+      workingMap.set(parentKeyPath, parentNode),
+      addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+    parentNode[2].push(node);
   }
 }
 function onError() {}
@@ -5865,7 +6089,10 @@ function renderToStringImpl(
     fatalError = null,
     result = "",
     readyToStream = !1;
-  options = createResumableState(options ? options.identifierPrefix : void 0);
+  options = createResumableState(
+    options ? options.identifierPrefix : void 0,
+    void 0
+  );
   children = createRequest(
     children,
     options,
@@ -5920,4 +6147,4 @@ exports.renderToString = function (children, options) {
     'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server'
   );
 };
-exports.version = "19.1.0-canary-c492f975-20250128";
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
diff --git a/node_modules/react-dom/cjs/react-dom-server.browser.development.js b/node_modules/react-dom/cjs/react-dom-server.browser.development.js
index de8e092..530298b 100644
--- a/node_modules/react-dom/cjs/react-dom-server.browser.development.js
+++ b/node_modules/react-dom/cjs/react-dom-server.browser.development.js
@@ -81,6 +81,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (type.$$typeof) {
@@ -810,28 +812,51 @@
             : stringToPrecomputedChunk(
                 '<script nonce="' + escapeTextForBrowser(nonce) + '">'
               ),
-        idPrefix = resumableState.idPrefix;
-      externalRuntimeConfig = [];
-      var bootstrapScriptContent = resumableState.bootstrapScriptContent,
+        idPrefix = resumableState.idPrefix,
+        bootstrapChunks = [],
+        externalRuntimeScript = null,
+        bootstrapScriptContent = resumableState.bootstrapScriptContent,
         bootstrapScripts = resumableState.bootstrapScripts,
         bootstrapModules = resumableState.bootstrapModules;
       void 0 !== bootstrapScriptContent &&
-        externalRuntimeConfig.push(
+        bootstrapChunks.push(
           inlineScriptWithNonce,
           stringToChunk(
             escapeEntireInlineScriptContent(bootstrapScriptContent)
           ),
           endInlineScript
         );
-      bootstrapScriptContent = [];
+      void 0 !== externalRuntimeConfig &&
+        ("string" === typeof externalRuntimeConfig
+          ? ((externalRuntimeScript = {
+              src: externalRuntimeConfig,
+              chunks: []
+            }),
+            pushScriptImpl(externalRuntimeScript.chunks, {
+              src: externalRuntimeConfig,
+              async: !0,
+              integrity: void 0,
+              nonce: nonce
+            }))
+          : ((externalRuntimeScript = {
+              src: externalRuntimeConfig.src,
+              chunks: []
+            }),
+            pushScriptImpl(externalRuntimeScript.chunks, {
+              src: externalRuntimeConfig.src,
+              async: !0,
+              integrity: externalRuntimeConfig.integrity,
+              nonce: nonce
+            })));
+      externalRuntimeConfig = [];
       void 0 !== importMap &&
-        (bootstrapScriptContent.push(importMapScriptStart),
-        bootstrapScriptContent.push(
+        (externalRuntimeConfig.push(importMapScriptStart),
+        externalRuntimeConfig.push(
           stringToChunk(
             escapeEntireInlineScriptContent(JSON.stringify(importMap))
           )
         ),
-        bootstrapScriptContent.push(importMapScriptEnd));
+        externalRuntimeConfig.push(importMapScriptEnd));
       onHeaders &&
         "number" === typeof maxHeadersLength &&
         0 >= maxHeadersLength &&
@@ -854,10 +879,11 @@
         segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
         boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
         startInlineScript: inlineScriptWithNonce,
-        preamble: createPreambleState(),
-        externalRuntimeScript: null,
-        bootstrapChunks: externalRuntimeConfig,
-        importMapChunks: bootstrapScriptContent,
+        htmlChunks: null,
+        headChunks: null,
+        externalRuntimeScript: externalRuntimeScript,
+        bootstrapChunks: bootstrapChunks,
+        importMapChunks: externalRuntimeConfig,
         onHeaders: onHeaders,
         headers: importMap,
         resets: {
@@ -888,109 +914,112 @@
         stylesToHoist: !1
       };
       if (void 0 !== bootstrapScripts)
-        for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
-          maxHeadersLength = bootstrapScripts[importMap];
-          bootstrapScriptContent = idPrefix = void 0;
-          var props = {
-            rel: "preload",
-            as: "script",
-            fetchPriority: "low",
-            nonce: nonce
-          };
-          "string" === typeof maxHeadersLength
-            ? (props.href = inlineScriptWithNonce = maxHeadersLength)
-            : ((props.href = inlineScriptWithNonce = maxHeadersLength.src),
-              (props.integrity = bootstrapScriptContent =
-                "string" === typeof maxHeadersLength.integrity
-                  ? maxHeadersLength.integrity
-                  : void 0),
-              (props.crossOrigin = idPrefix =
-                "string" === typeof maxHeadersLength ||
-                null == maxHeadersLength.crossOrigin
-                  ? void 0
-                  : "use-credentials" === maxHeadersLength.crossOrigin
-                    ? "use-credentials"
-                    : ""));
-          preloadBootstrapScriptOrModule(
-            resumableState,
-            onHeaders,
-            inlineScriptWithNonce,
-            props
-          );
-          externalRuntimeConfig.push(
-            startScriptSrc,
-            stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
-          );
-          nonce &&
-            externalRuntimeConfig.push(
-              scriptNonce,
-              stringToChunk(escapeTextForBrowser(nonce))
-            );
-          "string" === typeof bootstrapScriptContent &&
-            externalRuntimeConfig.push(
-              scriptIntegirty,
-              stringToChunk(escapeTextForBrowser(bootstrapScriptContent))
-            );
-          "string" === typeof idPrefix &&
-            externalRuntimeConfig.push(
-              scriptCrossOrigin,
-              stringToChunk(escapeTextForBrowser(idPrefix))
-            );
-          externalRuntimeConfig.push(endAsyncScript);
-        }
+        for (
+          inlineScriptWithNonce = 0;
+          inlineScriptWithNonce < bootstrapScripts.length;
+          inlineScriptWithNonce++
+        )
+          (idPrefix = bootstrapScripts[inlineScriptWithNonce]),
+            (maxHeadersLength = importMap = void 0),
+            (externalRuntimeConfig = {
+              rel: "preload",
+              as: "script",
+              fetchPriority: "low",
+              nonce: nonce
+            }),
+            "string" === typeof idPrefix
+              ? (externalRuntimeConfig.href = externalRuntimeScript = idPrefix)
+              : ((externalRuntimeConfig.href = externalRuntimeScript =
+                  idPrefix.src),
+                (externalRuntimeConfig.integrity = maxHeadersLength =
+                  "string" === typeof idPrefix.integrity
+                    ? idPrefix.integrity
+                    : void 0),
+                (externalRuntimeConfig.crossOrigin = importMap =
+                  "string" === typeof idPrefix || null == idPrefix.crossOrigin
+                    ? void 0
+                    : "use-credentials" === idPrefix.crossOrigin
+                      ? "use-credentials"
+                      : "")),
+            preloadBootstrapScriptOrModule(
+              resumableState,
+              onHeaders,
+              externalRuntimeScript,
+              externalRuntimeConfig
+            ),
+            bootstrapChunks.push(
+              startScriptSrc,
+              stringToChunk(escapeTextForBrowser(externalRuntimeScript))
+            ),
+            nonce &&
+              bootstrapChunks.push(
+                scriptNonce,
+                stringToChunk(escapeTextForBrowser(nonce))
+              ),
+            "string" === typeof maxHeadersLength &&
+              bootstrapChunks.push(
+                scriptIntegirty,
+                stringToChunk(escapeTextForBrowser(maxHeadersLength))
+              ),
+            "string" === typeof importMap &&
+              bootstrapChunks.push(
+                scriptCrossOrigin,
+                stringToChunk(escapeTextForBrowser(importMap))
+              ),
+            bootstrapChunks.push(endAsyncScript);
       if (void 0 !== bootstrapModules)
         for (
           bootstrapScripts = 0;
           bootstrapScripts < bootstrapModules.length;
           bootstrapScripts++
         )
-          (importMap = bootstrapModules[bootstrapScripts]),
-            (idPrefix = inlineScriptWithNonce = void 0),
-            (bootstrapScriptContent = {
+          (inlineScriptWithNonce = bootstrapModules[bootstrapScripts]),
+            (importMap = externalRuntimeScript = void 0),
+            (maxHeadersLength = {
               rel: "modulepreload",
               fetchPriority: "low",
               nonce: nonce
             }),
-            "string" === typeof importMap
-              ? (bootstrapScriptContent.href = maxHeadersLength = importMap)
-              : ((bootstrapScriptContent.href = maxHeadersLength =
-                  importMap.src),
-                (bootstrapScriptContent.integrity = idPrefix =
-                  "string" === typeof importMap.integrity
-                    ? importMap.integrity
+            "string" === typeof inlineScriptWithNonce
+              ? (maxHeadersLength.href = idPrefix = inlineScriptWithNonce)
+              : ((maxHeadersLength.href = idPrefix = inlineScriptWithNonce.src),
+                (maxHeadersLength.integrity = importMap =
+                  "string" === typeof inlineScriptWithNonce.integrity
+                    ? inlineScriptWithNonce.integrity
                     : void 0),
-                (bootstrapScriptContent.crossOrigin = inlineScriptWithNonce =
-                  "string" === typeof importMap || null == importMap.crossOrigin
+                (maxHeadersLength.crossOrigin = externalRuntimeScript =
+                  "string" === typeof inlineScriptWithNonce ||
+                  null == inlineScriptWithNonce.crossOrigin
                     ? void 0
-                    : "use-credentials" === importMap.crossOrigin
+                    : "use-credentials" === inlineScriptWithNonce.crossOrigin
                       ? "use-credentials"
                       : "")),
             preloadBootstrapScriptOrModule(
               resumableState,
               onHeaders,
-              maxHeadersLength,
-              bootstrapScriptContent
+              idPrefix,
+              maxHeadersLength
             ),
-            externalRuntimeConfig.push(
+            bootstrapChunks.push(
               startModuleSrc,
-              stringToChunk(escapeTextForBrowser(maxHeadersLength))
+              stringToChunk(escapeTextForBrowser(idPrefix))
             ),
             nonce &&
-              externalRuntimeConfig.push(
+              bootstrapChunks.push(
                 scriptNonce,
                 stringToChunk(escapeTextForBrowser(nonce))
               ),
-            "string" === typeof idPrefix &&
-              externalRuntimeConfig.push(
+            "string" === typeof importMap &&
+              bootstrapChunks.push(
                 scriptIntegirty,
-                stringToChunk(escapeTextForBrowser(idPrefix))
+                stringToChunk(escapeTextForBrowser(importMap))
               ),
-            "string" === typeof inlineScriptWithNonce &&
-              externalRuntimeConfig.push(
+            "string" === typeof externalRuntimeScript &&
+              bootstrapChunks.push(
                 scriptCrossOrigin,
-                stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
+                stringToChunk(escapeTextForBrowser(externalRuntimeScript))
               ),
-            externalRuntimeConfig.push(endAsyncScript);
+            bootstrapChunks.push(endAsyncScript);
       return onHeaders;
     }
     function createResumableState(
@@ -1000,10 +1029,12 @@
       bootstrapScripts,
       bootstrapModules
     ) {
+      var streamingFormat = ScriptStreamingFormat;
+      void 0 !== externalRuntimeConfig && (streamingFormat = 1);
       return {
         idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
         nextFormID: 0,
-        streamingFormat: 0,
+        streamingFormat: streamingFormat,
         bootstrapScriptContent: bootstrapScriptContent,
         bootstrapScripts: bootstrapScripts,
         bootstrapModules: bootstrapModules,
@@ -1020,9 +1051,6 @@
         moduleScriptResources: {}
       };
     }
-    function createPreambleState() {
-      return { htmlChunks: null, headChunks: null, bodyChunks: null };
-    }
     function createFormatContext(insertionMode, selectedValue, tagScope) {
       return {
         insertionMode: insertionMode,
@@ -1093,26 +1121,16 @@
             null,
             parentContext.tagScope
           );
-        case "head":
-          if (parentContext.insertionMode < HTML_MODE)
-            return createFormatContext(
-              HTML_HEAD_MODE,
-              null,
-              parentContext.tagScope
-            );
-          break;
-        case "html":
-          if (parentContext.insertionMode === ROOT_HTML_MODE)
-            return createFormatContext(
-              HTML_HTML_MODE,
-              null,
-              parentContext.tagScope
-            );
       }
-      return parentContext.insertionMode >= HTML_TABLE_MODE ||
-        parentContext.insertionMode < HTML_MODE
+      return parentContext.insertionMode >= HTML_TABLE_MODE
         ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
-        : parentContext;
+        : parentContext.insertionMode === ROOT_HTML_MODE
+          ? "html" === type
+            ? createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope)
+            : createFormatContext(HTML_MODE, null, parentContext.tagScope)
+          : parentContext.insertionMode === HTML_HTML_MODE
+            ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
+            : parentContext;
     }
     function pushTextInstance(target, text, renderState, textEmbedded) {
       if ("" === text) return textEmbedded;
@@ -1638,7 +1656,8 @@
       return content;
     }
     function injectFormReplayingRuntime(resumableState, renderState) {
-      (resumableState.instructions & 16) === NothingSent &&
+      (resumableState.instructions & 16) !== NothingSent ||
+        renderState.externalRuntimeScript ||
         ((resumableState.instructions |= 16),
         renderState.bootstrapChunks.unshift(
           renderState.startInlineScript,
@@ -1803,7 +1822,6 @@
       props,
       resumableState,
       renderState,
-      preambleState,
       hoistableState,
       formatContext,
       textEmbedded,
@@ -2972,13 +2990,13 @@
         case "missing-glyph":
           break;
         case "head":
-          if (formatContext.insertionMode < HTML_MODE) {
-            var preamble = preambleState || renderState.preamble;
-            if (preamble.headChunks)
-              throw Error("The `<head>` tag may only be rendered once.");
-            preamble.headChunks = [];
+          if (
+            formatContext.insertionMode < HTML_MODE &&
+            null === renderState.headChunks
+          ) {
+            renderState.headChunks = [];
             var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-              preamble.headChunks,
+              renderState.headChunks,
               props,
               "head"
             );
@@ -2989,42 +3007,24 @@
               "head"
             );
           return JSCompiler_inline_result$jscomp$9;
-        case "body":
-          if (formatContext.insertionMode < HTML_MODE) {
-            var preamble$jscomp$0 = preambleState || renderState.preamble;
-            if (preamble$jscomp$0.bodyChunks)
-              throw Error("The `<body>` tag may only be rendered once.");
-            preamble$jscomp$0.bodyChunks = [];
-            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-              preamble$jscomp$0.bodyChunks,
-              props,
-              "body"
-            );
-          } else
-            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-              target$jscomp$0,
-              props,
-              "body"
-            );
-          return JSCompiler_inline_result$jscomp$10;
         case "html":
-          if (formatContext.insertionMode === ROOT_HTML_MODE) {
-            var preamble$jscomp$1 = preambleState || renderState.preamble;
-            if (preamble$jscomp$1.htmlChunks)
-              throw Error("The `<html>` tag may only be rendered once.");
-            preamble$jscomp$1.htmlChunks = [doctypeChunk];
-            var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-              preamble$jscomp$1.htmlChunks,
+          if (
+            formatContext.insertionMode === ROOT_HTML_MODE &&
+            null === renderState.htmlChunks
+          ) {
+            renderState.htmlChunks = [doctypeChunk];
+            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+              renderState.htmlChunks,
               props,
               "html"
             );
           } else
-            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
               target$jscomp$0,
               props,
               "html"
             );
-          return JSCompiler_inline_result$jscomp$11;
+          return JSCompiler_inline_result$jscomp$10;
         default:
           if (-1 !== type.indexOf("-")) {
             target$jscomp$0.push(startChunkForTag(type));
@@ -3094,15 +3094,6 @@
         endTagCache.set(tag, chunk));
       return chunk;
     }
-    function hoistPreambleState(renderState, preambleState) {
-      renderState = renderState.preamble;
-      null === renderState.htmlChunks &&
-        (renderState.htmlChunks = preambleState.htmlChunks);
-      null === renderState.headChunks &&
-        (renderState.headChunks = preambleState.headChunks);
-      null === renderState.bodyChunks &&
-        (renderState.bodyChunks = preambleState.bodyChunks);
-    }
     function writeBootstrap(destination, renderState) {
       renderState = renderState.bootstrapChunks;
       for (var i = 0; i < renderState.length - 1; i++)
@@ -3127,7 +3118,6 @@
       switch (formatContext.insertionMode) {
         case ROOT_HTML_MODE:
         case HTML_HTML_MODE:
-        case HTML_HEAD_MODE:
         case HTML_MODE:
           return (
             writeChunk(destination, startSegmentHTML),
@@ -3185,7 +3175,6 @@
       switch (formatContext.insertionMode) {
         case ROOT_HTML_MODE:
         case HTML_HTML_MODE:
-        case HTML_HEAD_MODE:
         case HTML_MODE:
           return writeChunkAndReturn(destination, endSegmentHTML);
         case SVG_MODE:
@@ -3476,6 +3465,121 @@
         stringToChunk(escapeJSObjectForInstructionScripts(name))
       );
     }
+    function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+      writeChunk(destination, arrayFirstOpenBracket);
+      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
+      hoistableState.stylesheets.forEach(function (resource) {
+        if (resource.state !== PREAMBLE)
+          if (resource.state === LATE)
+            writeChunk(destination, nextArrayOpenBrackChunk),
+              (resource = resource.props.href),
+              checkAttributeStringCoercion(resource, "href"),
+              writeChunk(
+                destination,
+                stringToChunk(
+                  escapeTextForBrowser(JSON.stringify("" + resource))
+                )
+              ),
+              writeChunk(destination, arrayCloseBracket),
+              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);
+          else {
+            writeChunk(destination, nextArrayOpenBrackChunk);
+            var precedence = resource.props["data-precedence"],
+              props = resource.props,
+              coercedHref = sanitizeURL("" + resource.props.href);
+            writeChunk(
+              destination,
+              stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref)))
+            );
+            checkAttributeStringCoercion(precedence, "precedence");
+            precedence = "" + precedence;
+            writeChunk(destination, arrayInterstitial);
+            writeChunk(
+              destination,
+              stringToChunk(escapeTextForBrowser(JSON.stringify(precedence)))
+            );
+            for (var propKey in props)
+              if (
+                hasOwnProperty.call(props, propKey) &&
+                ((precedence = props[propKey]), null != precedence)
+              )
+                switch (propKey) {
+                  case "href":
+                  case "rel":
+                  case "precedence":
+                  case "data-precedence":
+                    break;
+                  case "children":
+                  case "dangerouslySetInnerHTML":
+                    throw Error(
+                      "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                    );
+                  default:
+                    writeStyleResourceAttributeInAttr(
+                      destination,
+                      propKey,
+                      precedence
+                    );
+                }
+            writeChunk(destination, arrayCloseBracket);
+            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
+            resource.state = LATE;
+          }
+      });
+      writeChunk(destination, arrayCloseBracket);
+    }
+    function writeStyleResourceAttributeInAttr(destination, name, value) {
+      var attributeName = name.toLowerCase();
+      switch (typeof value) {
+        case "function":
+        case "symbol":
+          return;
+      }
+      switch (name) {
+        case "innerHTML":
+        case "dangerouslySetInnerHTML":
+        case "suppressContentEditableWarning":
+        case "suppressHydrationWarning":
+        case "style":
+        case "ref":
+          return;
+        case "className":
+          attributeName = "class";
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+          break;
+        case "hidden":
+          if (!1 === value) return;
+          name = "";
+          break;
+        case "src":
+        case "href":
+          value = sanitizeURL(value);
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+          break;
+        default:
+          if (
+            (2 < name.length &&
+              ("o" === name[0] || "O" === name[0]) &&
+              ("n" === name[1] || "N" === name[1])) ||
+            !isAttributeNameSafe(name)
+          )
+            return;
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+      }
+      writeChunk(destination, arrayInterstitial);
+      writeChunk(
+        destination,
+        stringToChunk(escapeTextForBrowser(JSON.stringify(attributeName)))
+      );
+      writeChunk(destination, arrayInterstitial);
+      writeChunk(
+        destination,
+        stringToChunk(escapeTextForBrowser(JSON.stringify(name)))
+      );
+    }
     function createHoistableState() {
       return { styles: new Set(), stylesheets: new Set() };
     }
@@ -3602,6 +3706,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (
@@ -3978,6 +4084,11 @@
           queue.next = componentIdentity;
         }
     }
+    function throwOnUseEffectEventCall() {
+      throw Error(
+        "A function wrapped in useEffectEvent can't be called during rendering."
+      );
+    }
     function unsupportedStartTransition() {
       throw Error("startTransition cannot be called during server rendering.");
     }
@@ -4058,8 +4169,15 @@
       null === thenableState && (thenableState = []);
       return trackUsedThenable(thenableState, thenable, index);
     }
-    function unsupportedRefresh() {
-      throw Error("Cache cannot be refreshed during server rendering.");
+    function readPreviousThenableFromState() {
+      var index = thenableIndexCounter;
+      thenableIndexCounter += 1;
+      if (null !== thenableState)
+        return (
+          (index = thenableState[index]),
+          (index = void 0 === index ? void 0 : index.value),
+          index
+        );
     }
     function noop$1() {}
     function disabledLog() {}
@@ -4281,6 +4399,27 @@
       "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
       return sampleLines;
     }
+    function formatOwnerStack(error) {
+      var prevPrepareStackTrace = Error.prepareStackTrace;
+      Error.prepareStackTrace = void 0;
+      error = error.stack;
+      Error.prepareStackTrace = prevPrepareStackTrace;
+      error.startsWith("Error: react-stack-top-frame\n") &&
+        (error = error.slice(29));
+      prevPrepareStackTrace = error.indexOf("\n");
+      -1 !== prevPrepareStackTrace &&
+        (error = error.slice(prevPrepareStackTrace + 1));
+      prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
+      -1 !== prevPrepareStackTrace &&
+        (prevPrepareStackTrace = error.lastIndexOf(
+          "\n",
+          prevPrepareStackTrace
+        ));
+      if (-1 !== prevPrepareStackTrace)
+        error = error.slice(0, prevPrepareStackTrace);
+      else return "";
+      return error;
+    }
     function describeComponentStackByType(type) {
       if ("string" === typeof type) return describeBuiltInComponentFrame(type);
       if ("function" === typeof type)
@@ -4317,21 +4456,11 @@
           return describeBuiltInComponentFrame("SuspenseList");
         case REACT_SUSPENSE_TYPE:
           return describeBuiltInComponentFrame("Suspense");
+        case REACT_VIEW_TRANSITION_TYPE:
+          return describeBuiltInComponentFrame("ViewTransition");
       }
       return "";
     }
-    function getStackByComponentStackNode(componentStack) {
-      try {
-        var info = "";
-        do
-          (info += describeComponentStackByType(componentStack.type)),
-            (componentStack = componentStack.parent);
-        while (componentStack);
-        return info;
-      } catch (x) {
-        return "\nError generating stack: " + x.message + "\n" + x.stack;
-      }
-    }
     function defaultErrorHandler(error) {
       if (
         "object" === typeof error &&
@@ -4388,7 +4517,7 @@
       this.status = 10;
       this.fatalError = null;
       this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-      this.completedPreambleSegments = this.completedRootSegment = null;
+      this.completedRootSegment = null;
       this.abortableTasks = abortSet;
       this.pingedTasks = [];
       this.clientRenderedBoundaries = [];
@@ -4448,14 +4577,15 @@
         null,
         renderState,
         null,
-        null,
         resumableState.abortableTasks,
         null,
         rootFormatContext,
         null,
         emptyTreeContext,
         null,
-        !1
+        !1,
+        emptyContextObject,
+        null
       );
       pushComponentStack(children);
       resumableState.pingedTasks.push(children);
@@ -4495,28 +4625,138 @@
       };
       return children;
     }
-    function pingTask(request, task) {
-      request.pingedTasks.push(task);
-      1 === request.pingedTasks.length &&
-        ((request.flushScheduled = null !== request.destination),
-        null !== request.trackedPostpones || 10 === request.status
-          ? scheduleMicrotask(function () {
-              return performWork(request);
-            })
-          : scheduleWork(function () {
-              return performWork(request);
-            }));
+    function resumeRequest(
+      children,
+      postponedState,
+      renderState,
+      onError,
+      onAllReady,
+      onShellReady,
+      onShellError,
+      onFatalError,
+      onPostpone
+    ) {
+      renderState = new RequestInstance(
+        postponedState.resumableState,
+        renderState,
+        postponedState.rootFormatContext,
+        postponedState.progressiveChunkSize,
+        onError,
+        onAllReady,
+        onShellReady,
+        onShellError,
+        onFatalError,
+        onPostpone,
+        null
+      );
+      renderState.nextSegmentId = postponedState.nextSegmentId;
+      if ("number" === typeof postponedState.replaySlots)
+        return (
+          (onError = postponedState.replaySlots),
+          (onAllReady = createPendingSegment(
+            renderState,
+            0,
+            null,
+            postponedState.rootFormatContext,
+            !1,
+            !1
+          )),
+          (onAllReady.id = onError),
+          (onAllReady.parentFlushed = !0),
+          (children = createRenderTask(
+            renderState,
+            null,
+            children,
+            -1,
+            null,
+            onAllReady,
+            null,
+            renderState.abortableTasks,
+            null,
+            postponedState.rootFormatContext,
+            null,
+            emptyTreeContext,
+            null,
+            !1,
+            emptyContextObject,
+            null
+          )),
+          pushComponentStack(children),
+          renderState.pingedTasks.push(children),
+          renderState
+        );
+      children = createReplayTask(
+        renderState,
+        null,
+        {
+          nodes: postponedState.replayNodes,
+          slots: postponedState.replaySlots,
+          pendingTasks: 0
+        },
+        children,
+        -1,
+        null,
+        null,
+        renderState.abortableTasks,
+        null,
+        postponedState.rootFormatContext,
+        null,
+        emptyTreeContext,
+        null,
+        !1,
+        emptyContextObject,
+        null
+      );
+      pushComponentStack(children);
+      renderState.pingedTasks.push(children);
+      return renderState;
     }
-    function createSuspenseBoundary(
-      request,
-      fallbackAbortableTasks,
-      contentPreamble,
-      fallbackPreamble
+    function resumeAndPrerenderRequest(
+      children,
+      postponedState,
+      renderState,
+      onError,
+      onAllReady,
+      onShellReady,
+      onShellError,
+      onFatalError,
+      onPostpone
     ) {
-      return {
-        status: PENDING,
-        rootSegmentID: -1,
-        parentFlushed: !1,
+      children = resumeRequest(
+        children,
+        postponedState,
+        renderState,
+        onError,
+        onAllReady,
+        onShellReady,
+        onShellError,
+        onFatalError,
+        onPostpone
+      );
+      children.trackedPostpones = {
+        workingMap: new Map(),
+        rootNodes: [],
+        rootSlots: null
+      };
+      return children;
+    }
+    function pingTask(request, task) {
+      request.pingedTasks.push(task);
+      1 === request.pingedTasks.length &&
+        ((request.flushScheduled = null !== request.destination),
+        null !== request.trackedPostpones || 10 === request.status
+          ? scheduleMicrotask(function () {
+              return performWork(request);
+            })
+          : scheduleWork(function () {
+              return performWork(request);
+            }));
+    }
+    function createSuspenseBoundary(request, fallbackAbortableTasks) {
+      return {
+        status: PENDING,
+        rootSegmentID: -1,
+        parentFlushed: !1,
         pendingTasks: 0,
         completedSegments: [],
         byteSize: 0,
@@ -4524,8 +4764,6 @@
         errorDigest: null,
         contentState: createHoistableState(),
         fallbackState: createHoistableState(),
-        contentPreamble: contentPreamble,
-        fallbackPreamble: fallbackPreamble,
         trackedContentKeyPath: null,
         trackedFallbackNode: null,
         errorMessage: null,
@@ -4540,7 +4778,6 @@
       childIndex,
       blockedBoundary,
       blockedSegment,
-      blockedPreamble,
       hoistableState,
       abortSet,
       keyPath,
@@ -4548,7 +4785,9 @@
       context,
       treeContext,
       componentStack,
-      isFallback
+      isFallback,
+      legacyContext,
+      debugTask
     ) {
       request.allPendingTasks++;
       null === blockedBoundary
@@ -4563,7 +4802,6 @@
         },
         blockedBoundary: blockedBoundary,
         blockedSegment: blockedSegment,
-        blockedPreamble: blockedPreamble,
         hoistableState: hoistableState,
         abortSet: abortSet,
         keyPath: keyPath,
@@ -4574,6 +4812,7 @@
         thenableState: thenableState,
         isFallback: isFallback
       };
+      task.debugTask = debugTask;
       abortSet.add(task);
       return task;
     }
@@ -4591,7 +4830,9 @@
       context,
       treeContext,
       componentStack,
-      isFallback
+      isFallback,
+      legacyContext,
+      debugTask
     ) {
       request.allPendingTasks++;
       null === blockedBoundary
@@ -4607,7 +4848,6 @@
         },
         blockedBoundary: blockedBoundary,
         blockedSegment: null,
-        blockedPreamble: null,
         hoistableState: hoistableState,
         abortSet: abortSet,
         keyPath: keyPath,
@@ -4618,6 +4858,7 @@
         thenableState: thenableState,
         isFallback: isFallback
       };
+      task.debugTask = debugTask;
       abortSet.add(task);
       return task;
     }
@@ -4631,12 +4872,11 @@
     ) {
       return {
         status: PENDING,
-        parentFlushed: !1,
         id: -1,
         index: index,
+        parentFlushed: !1,
         chunks: [],
         children: [],
-        preambleChildren: [],
         parentFormatContext: parentFormatContext,
         boundary: boundary,
         lastPushedText: lastPushedText,
@@ -4644,22 +4884,63 @@
       };
     }
     function getCurrentStackInDEV() {
-      return null === currentTaskInDEV ||
-        null === currentTaskInDEV.componentStack
-        ? ""
-        : getStackByComponentStackNode(currentTaskInDEV.componentStack);
+      if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
+        return "";
+      var componentStack = currentTaskInDEV.componentStack;
+      try {
+        var info = "";
+        if ("string" === typeof componentStack.type)
+          info += describeBuiltInComponentFrame(componentStack.type);
+        else if ("function" === typeof componentStack.type) {
+          if (!componentStack.owner) {
+            var JSCompiler_temp_const = info,
+              fn = componentStack.type,
+              name = fn ? fn.displayName || fn.name : "";
+            var JSCompiler_inline_result = name
+              ? describeBuiltInComponentFrame(name)
+              : "";
+            info = JSCompiler_temp_const + JSCompiler_inline_result;
+          }
+        } else
+          componentStack.owner ||
+            (info += describeComponentStackByType(componentStack.type));
+        for (; componentStack; )
+          (JSCompiler_temp_const = null),
+            null != componentStack.debugStack
+              ? (JSCompiler_temp_const = formatOwnerStack(
+                  componentStack.debugStack
+                ))
+              : ((JSCompiler_inline_result = componentStack),
+                null != JSCompiler_inline_result.stack &&
+                  (JSCompiler_temp_const =
+                    "string" !== typeof JSCompiler_inline_result.stack
+                      ? (JSCompiler_inline_result.stack = formatOwnerStack(
+                          JSCompiler_inline_result.stack
+                        ))
+                      : JSCompiler_inline_result.stack)),
+            (componentStack = componentStack.owner) &&
+              JSCompiler_temp_const &&
+              (info += "\n" + JSCompiler_temp_const);
+        var JSCompiler_inline_result$jscomp$0 = info;
+      } catch (x) {
+        JSCompiler_inline_result$jscomp$0 =
+          "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+      return JSCompiler_inline_result$jscomp$0;
     }
     function pushServerComponentStack(task, debugInfo) {
       if (null != debugInfo)
         for (var i = 0; i < debugInfo.length; i++) {
           var componentInfo = debugInfo[i];
           "string" === typeof componentInfo.name &&
-            (task.componentStack = {
+            void 0 !== componentInfo.debugStack &&
+            ((task.componentStack = {
               parent: task.componentStack,
               type: componentInfo,
               owner: componentInfo.owner,
-              stack: null
-            });
+              stack: componentInfo.debugStack
+            }),
+            (task.debugTask = componentInfo.debugTask));
         }
     }
     function pushComponentStack(task) {
@@ -4668,13 +4949,15 @@
         switch (node.$$typeof) {
           case REACT_ELEMENT_TYPE:
             var type = node.type,
-              owner = node._owner;
+              owner = node._owner,
+              stack = node._debugStack;
             pushServerComponentStack(task, node._debugInfo);
+            task.debugTask = node._debugTask;
             task.componentStack = {
               parent: task.componentStack,
               type: type,
               owner: owner,
-              stack: null
+              stack: stack
             };
             break;
           case REACT_LAZY_TYPE:
@@ -4685,14 +4968,24 @@
               pushServerComponentStack(task, node._debugInfo);
         }
     }
-    function getThrownInfo(node) {
+    function getThrownInfo(node$jscomp$0) {
       var errorInfo = {};
-      node &&
+      node$jscomp$0 &&
         Object.defineProperty(errorInfo, "componentStack", {
           configurable: !0,
           enumerable: !0,
           get: function () {
-            var stack = getStackByComponentStackNode(node);
+            try {
+              var info = "",
+                node = node$jscomp$0;
+              do
+                (info += describeComponentStackByType(node.type)),
+                  (node = node.parent);
+              while (node);
+              var stack = info;
+            } catch (x) {
+              stack = "\nError generating stack: " + x.message + "\n" + x.stack;
+            }
             Object.defineProperty(errorInfo, "componentStack", {
               value: stack
             });
@@ -4723,9 +5016,17 @@
       boundary.errorStack = null !== error ? wasAborted + error : null;
       boundary.errorComponentStack = thrownInfo.componentStack;
     }
-    function logRecoverableError(request, error, errorInfo) {
+    function logPostpone(request, reason, postponeInfo, debugTask) {
+      request = request.onPostpone;
+      debugTask
+        ? debugTask.run(request.bind(null, reason, postponeInfo))
+        : request(reason, postponeInfo);
+    }
+    function logRecoverableError(request, error, errorInfo, debugTask) {
       request = request.onError;
-      error = request(error, errorInfo);
+      error = debugTask
+        ? debugTask.run(request.bind(null, error, errorInfo))
+        : request(error, errorInfo);
       if (null != error && "string" !== typeof error)
         console.error(
           'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
@@ -4733,11 +5034,13 @@
         );
       else return error;
     }
-    function fatalError(request, error) {
-      var onShellError = request.onShellError,
-        onFatalError = request.onFatalError;
-      onShellError(error);
-      onFatalError(error);
+    function fatalError(request, error, errorInfo, debugTask) {
+      errorInfo = request.onShellError;
+      var onFatalError = request.onFatalError;
+      debugTask
+        ? (debugTask.run(errorInfo.bind(null, error)),
+          debugTask.run(onFatalError.bind(null, error)))
+        : (errorInfo(error), onFatalError(error));
       null !== request.destination
         ? ((request.status = CLOSED),
           closeWithError(request.destination, error))
@@ -5277,7 +5580,6 @@
             props,
             request.resumableState,
             request.renderState,
-            task.blockedPreamble,
             task.hoistableState,
             task.formatContext,
             segment.lastPushedText,
@@ -5286,43 +5588,9 @@
           segment.lastPushedText = !1;
           var _prevContext = task.formatContext,
             _prevKeyPath2 = task.keyPath;
+          task.formatContext = getChildFormatContext(_prevContext, type, props);
           task.keyPath = keyPath;
-          if (
-            (task.formatContext = getChildFormatContext(
-              _prevContext,
-              type,
-              props
-            )).insertionMode === HTML_HEAD_MODE
-          ) {
-            var preambleSegment = createPendingSegment(
-              request,
-              0,
-              null,
-              task.formatContext,
-              !1,
-              !1
-            );
-            segment.preambleChildren.push(preambleSegment);
-            var preambleTask = createRenderTask(
-              request,
-              null,
-              _children,
-              -1,
-              task.blockedBoundary,
-              preambleSegment,
-              task.blockedPreamble,
-              task.hoistableState,
-              request.abortableTasks,
-              task.keyPath,
-              task.formatContext,
-              task.context,
-              task.treeContext,
-              task.componentStack,
-              task.isFallback
-            );
-            pushComponentStack(preambleTask);
-            request.pingedTasks.push(preambleTask);
-          } else renderNode(request, task, _children, -1);
+          renderNode(request, task, _children, -1);
           task.formatContext = _prevContext;
           task.keyPath = _prevKeyPath2;
           a: {
@@ -5359,9 +5627,6 @@
                   resumableState.hasHtml = !0;
                   break a;
                 }
-                break;
-              case "head":
-                if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;
             }
             target.push(endChunkForTag(type));
           }
@@ -5393,6 +5658,11 @@
             task.keyPath = _prevKeyPath3;
             return;
           case REACT_VIEW_TRANSITION_TYPE:
+            var _prevKeyPath4 = task.keyPath;
+            task.keyPath = keyPath;
+            renderNodeDestructive(request, task, props.children, -1);
+            task.keyPath = _prevKeyPath4;
+            return;
           case REACT_SCOPE_TYPE:
             throw Error(
               "ReactDOMServer does not yet support scope components."
@@ -5410,26 +5680,12 @@
             } else {
               var prevKeyPath$jscomp$3 = task.keyPath,
                 parentBoundary = task.blockedBoundary,
-                parentPreamble = task.blockedPreamble,
                 parentHoistableState = task.hoistableState,
                 parentSegment = task.blockedSegment,
                 fallback = props.fallback,
                 content = props.children,
-                fallbackAbortSet = new Set();
-              var newBoundary =
-                task.formatContext.insertionMode < HTML_MODE
-                  ? createSuspenseBoundary(
-                      request,
-                      fallbackAbortSet,
-                      createPreambleState(),
-                      createPreambleState()
-                    )
-                  : createSuspenseBoundary(
-                      request,
-                      fallbackAbortSet,
-                      null,
-                      null
-                    );
+                fallbackAbortSet = new Set(),
+                newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
               null !== request.trackedPostpones &&
                 (newBoundary.trackedContentKeyPath = keyPath);
               var boundarySegment = createPendingSegment(
@@ -5469,7 +5725,6 @@
                 );
                 newBoundary.trackedFallbackNode = fallbackReplayNode;
                 task.blockedSegment = boundarySegment;
-                task.blockedPreamble = newBoundary.fallbackPreamble;
                 task.keyPath = fallbackKeyPath;
                 boundarySegment.status = 6;
                 try {
@@ -5485,7 +5740,6 @@
                   );
                 } finally {
                   (task.blockedSegment = parentSegment),
-                    (task.blockedPreamble = parentPreamble),
                     (task.keyPath = prevKeyPath$jscomp$3);
                 }
                 var suspendedPrimaryTask = createRenderTask(
@@ -5495,7 +5749,6 @@
                   -1,
                   newBoundary,
                   contentRootSegment,
-                  newBoundary.contentPreamble,
                   newBoundary.contentState,
                   task.abortSet,
                   keyPath,
@@ -5503,13 +5756,14 @@
                   task.context,
                   task.treeContext,
                   task.componentStack,
-                  task.isFallback
+                  task.isFallback,
+                  emptyContextObject,
+                  task.debugTask
                 );
                 pushComponentStack(suspendedPrimaryTask);
                 request.pingedTasks.push(suspendedPrimaryTask);
               } else {
                 task.blockedBoundary = newBoundary;
-                task.blockedPreamble = newBoundary.contentPreamble;
                 task.hoistableState = newBoundary.contentState;
                 task.blockedSegment = contentRootSegment;
                 task.keyPath = keyPath;
@@ -5526,9 +5780,6 @@
                       newBoundary.status === PENDING)
                   ) {
                     newBoundary.status = COMPLETED;
-                    0 === request.pendingRootTasks &&
-                      task.blockedPreamble &&
-                      preparePreamble(request);
                     break a;
                   }
                 } catch (thrownValue$2) {
@@ -5539,11 +5790,25 @@
                   } else
                     (contentRootSegment.status = 4), (error = thrownValue$2);
                   var thrownInfo = getThrownInfo(task.componentStack);
-                  var errorDigest = logRecoverableError(
-                    request,
-                    error,
-                    thrownInfo
-                  );
+                  if (
+                    "object" === typeof error &&
+                    null !== error &&
+                    error.$$typeof === REACT_POSTPONE_TYPE
+                  ) {
+                    logPostpone(
+                      request,
+                      error.message,
+                      thrownInfo,
+                      task.debugTask
+                    );
+                    var errorDigest = "POSTPONE";
+                  } else
+                    errorDigest = logRecoverableError(
+                      request,
+                      error,
+                      thrownInfo,
+                      task.debugTask
+                    );
                   encodeErrorForBoundary(
                     newBoundary,
                     errorDigest,
@@ -5554,7 +5819,6 @@
                   untrackBoundary(request, newBoundary);
                 } finally {
                   (task.blockedBoundary = parentBoundary),
-                    (task.blockedPreamble = parentPreamble),
                     (task.hoistableState = parentHoistableState),
                     (task.blockedSegment = parentSegment),
                     (task.keyPath = prevKeyPath$jscomp$3);
@@ -5566,7 +5830,6 @@
                   -1,
                   parentBoundary,
                   boundarySegment,
-                  newBoundary.fallbackPreamble,
                   newBoundary.fallbackState,
                   fallbackAbortSet,
                   [keyPath[0], "Suspense Fallback", keyPath[2]],
@@ -5574,7 +5837,9 @@
                   task.context,
                   task.treeContext,
                   task.componentStack,
-                  !0
+                  !0,
+                  emptyContextObject,
+                  task.debugTask
                 );
                 pushComponentStack(suspendedFallbackTask);
                 request.pingedTasks.push(suspendedFallbackTask);
@@ -5726,15 +5991,186 @@
         (task.replay = prevReplay), (task.blockedSegment = null);
       }
     }
+    function replayElement(
+      request,
+      task,
+      keyPath,
+      name,
+      keyOrIndex,
+      childIndex,
+      type,
+      props,
+      ref,
+      replay
+    ) {
+      childIndex = replay.nodes;
+      for (var i = 0; i < childIndex.length; i++) {
+        var node = childIndex[i];
+        if (keyOrIndex === node[1]) {
+          if (4 === node.length) {
+            if (null !== name && name !== node[0])
+              throw Error(
+                "Expected the resume to render <" +
+                  node[0] +
+                  "> in this slot but instead it rendered <" +
+                  name +
+                  ">. The tree doesn't match so React will fallback to client rendering."
+              );
+            var childNodes = node[2];
+            node = node[3];
+            name = task.node;
+            task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
+            try {
+              renderElement(request, task, keyPath, type, props, ref);
+              if (
+                1 === task.replay.pendingTasks &&
+                0 < task.replay.nodes.length
+              )
+                throw Error(
+                  "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+                );
+              task.replay.pendingTasks--;
+            } catch (x) {
+              if (
+                "object" === typeof x &&
+                null !== x &&
+                (x === SuspenseException || "function" === typeof x.then)
+              )
+                throw (task.node === name && (task.replay = replay), x);
+              task.replay.pendingTasks--;
+              props = getThrownInfo(task.componentStack);
+              erroredReplay(
+                request,
+                task.blockedBoundary,
+                x,
+                props,
+                childNodes,
+                node,
+                task.debugTask
+              );
+            }
+            task.replay = replay;
+          } else {
+            if (type !== REACT_SUSPENSE_TYPE)
+              throw Error(
+                "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
+                  (getComponentNameFromType(type) || "Unknown") +
+                  ">. The tree doesn't match so React will fallback to client rendering."
+              );
+            a: {
+              replay = void 0;
+              type = node[5];
+              ref = node[2];
+              name = node[3];
+              keyOrIndex = null === node[4] ? [] : node[4][2];
+              node = null === node[4] ? null : node[4][3];
+              var prevKeyPath = task.keyPath,
+                previousReplaySet = task.replay,
+                parentBoundary = task.blockedBoundary,
+                parentHoistableState = task.hoistableState,
+                content = props.children;
+              props = props.fallback;
+              var fallbackAbortSet = new Set(),
+                resumedBoundary = createSuspenseBoundary(
+                  request,
+                  fallbackAbortSet
+                );
+              resumedBoundary.parentFlushed = !0;
+              resumedBoundary.rootSegmentID = type;
+              task.blockedBoundary = resumedBoundary;
+              task.hoistableState = resumedBoundary.contentState;
+              task.keyPath = keyPath;
+              task.replay = { nodes: ref, slots: name, pendingTasks: 1 };
+              try {
+                renderNode(request, task, content, -1);
+                if (
+                  1 === task.replay.pendingTasks &&
+                  0 < task.replay.nodes.length
+                )
+                  throw Error(
+                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+                  );
+                task.replay.pendingTasks--;
+                if (
+                  0 === resumedBoundary.pendingTasks &&
+                  resumedBoundary.status === PENDING
+                ) {
+                  resumedBoundary.status = COMPLETED;
+                  request.completedBoundaries.push(resumedBoundary);
+                  break a;
+                }
+              } catch (error) {
+                (resumedBoundary.status = CLIENT_RENDERED),
+                  (childNodes = getThrownInfo(task.componentStack)),
+                  "object" === typeof error &&
+                  null !== error &&
+                  error.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        error.message,
+                        childNodes,
+                        task.debugTask
+                      ),
+                      (replay = "POSTPONE"))
+                    : (replay = logRecoverableError(
+                        request,
+                        error,
+                        childNodes,
+                        task.debugTask
+                      )),
+                  encodeErrorForBoundary(
+                    resumedBoundary,
+                    replay,
+                    error,
+                    childNodes,
+                    !1
+                  ),
+                  task.replay.pendingTasks--,
+                  request.clientRenderedBoundaries.push(resumedBoundary);
+              } finally {
+                (task.blockedBoundary = parentBoundary),
+                  (task.hoistableState = parentHoistableState),
+                  (task.replay = previousReplaySet),
+                  (task.keyPath = prevKeyPath);
+              }
+              props = createReplayTask(
+                request,
+                null,
+                { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
+                props,
+                -1,
+                parentBoundary,
+                resumedBoundary.fallbackState,
+                fallbackAbortSet,
+                [keyPath[0], "Suspense Fallback", keyPath[2]],
+                task.formatContext,
+                task.context,
+                task.treeContext,
+                task.componentStack,
+                !0,
+                emptyContextObject,
+                task.debugTask
+              );
+              pushComponentStack(props);
+              request.pingedTasks.push(props);
+            }
+          }
+          childIndex.splice(i, 1);
+          break;
+        }
+      }
+    }
     function renderNodeDestructive(request, task, node, childIndex) {
       null !== task.replay && "number" === typeof task.replay.slots
         ? resumeNode(request, task, task.replay.slots, node, childIndex)
         : ((task.node = node),
           (task.childIndex = childIndex),
           (node = task.componentStack),
+          (childIndex = task.debugTask),
           pushComponentStack(task),
           retryNode(request, task),
-          (task.componentStack = node));
+          (task.componentStack = node),
+          (task.debugTask = childIndex));
     }
     function retryNode(request, task) {
       var node = task.node,
@@ -5744,178 +6180,56 @@
           switch (node.$$typeof) {
             case REACT_ELEMENT_TYPE:
               var type = node.type,
-                key = node.key,
-                props = node.props;
-              node = props.ref;
-              var ref = void 0 !== node ? node : null,
-                name = getComponentNameFromType(type),
-                keyOrIndex =
-                  null == key ? (-1 === childIndex ? 0 : childIndex) : key,
-                keyPath = [task.keyPath, name, keyOrIndex];
-              if (null !== task.replay) {
-                var replay = task.replay;
-                childIndex = replay.nodes;
-                for (node = 0; node < childIndex.length; node++)
-                  if (((key = childIndex[node]), keyOrIndex === key[1])) {
-                    if (4 === key.length) {
-                      if (null !== name && name !== key[0])
-                        throw Error(
-                          "Expected the resume to render <" +
-                            key[0] +
-                            "> in this slot but instead it rendered <" +
-                            name +
-                            ">. The tree doesn't match so React will fallback to client rendering."
-                        );
-                      var childNodes = key[2];
-                      key = key[3];
-                      name = task.node;
-                      task.replay = {
-                        nodes: childNodes,
-                        slots: key,
-                        pendingTasks: 1
-                      };
-                      try {
-                        renderElement(request, task, keyPath, type, props, ref);
-                        if (
-                          1 === task.replay.pendingTasks &&
-                          0 < task.replay.nodes.length
-                        )
-                          throw Error(
-                            "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                          );
-                        task.replay.pendingTasks--;
-                      } catch (x) {
-                        if (
-                          "object" === typeof x &&
-                          null !== x &&
-                          (x === SuspenseException ||
-                            "function" === typeof x.then)
-                        )
-                          throw (
-                            (task.node === name && (task.replay = replay), x)
-                          );
-                        task.replay.pendingTasks--;
-                        props = getThrownInfo(task.componentStack);
-                        erroredReplay(
-                          request,
-                          task.blockedBoundary,
-                          x,
-                          props,
-                          childNodes,
-                          key
-                        );
-                      }
-                      task.replay = replay;
-                    } else {
-                      if (type !== REACT_SUSPENSE_TYPE)
-                        throw Error(
-                          "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
-                            (getComponentNameFromType(type) || "Unknown") +
-                            ">. The tree doesn't match so React will fallback to client rendering."
-                        );
-                      a: {
-                        type = void 0;
-                        ref = key[5];
-                        replay = key[2];
-                        name = key[3];
-                        keyOrIndex = null === key[4] ? [] : key[4][2];
-                        key = null === key[4] ? null : key[4][3];
-                        var prevKeyPath = task.keyPath,
-                          previousReplaySet = task.replay,
-                          parentBoundary = task.blockedBoundary,
-                          parentHoistableState = task.hoistableState,
-                          content = props.children,
-                          fallback = props.fallback,
-                          fallbackAbortSet = new Set();
-                        props =
-                          task.formatContext.insertionMode < HTML_MODE
-                            ? createSuspenseBoundary(
-                                request,
-                                fallbackAbortSet,
-                                createPreambleState(),
-                                createPreambleState()
-                              )
-                            : createSuspenseBoundary(
-                                request,
-                                fallbackAbortSet,
-                                null,
-                                null
-                              );
-                        props.parentFlushed = !0;
-                        props.rootSegmentID = ref;
-                        task.blockedBoundary = props;
-                        task.hoistableState = props.contentState;
-                        task.keyPath = keyPath;
-                        task.replay = {
-                          nodes: replay,
-                          slots: name,
-                          pendingTasks: 1
-                        };
-                        try {
-                          renderNode(request, task, content, -1);
-                          if (
-                            1 === task.replay.pendingTasks &&
-                            0 < task.replay.nodes.length
-                          )
-                            throw Error(
-                              "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                            );
-                          task.replay.pendingTasks--;
-                          if (
-                            0 === props.pendingTasks &&
-                            props.status === PENDING
-                          ) {
-                            props.status = COMPLETED;
-                            request.completedBoundaries.push(props);
-                            break a;
-                          }
-                        } catch (error) {
-                          (props.status = CLIENT_RENDERED),
-                            (childNodes = getThrownInfo(task.componentStack)),
-                            (type = logRecoverableError(
-                              request,
-                              error,
-                              childNodes
-                            )),
-                            encodeErrorForBoundary(
-                              props,
-                              type,
-                              error,
-                              childNodes,
-                              !1
-                            ),
-                            task.replay.pendingTasks--,
-                            request.clientRenderedBoundaries.push(props);
-                        } finally {
-                          (task.blockedBoundary = parentBoundary),
-                            (task.hoistableState = parentHoistableState),
-                            (task.replay = previousReplaySet),
-                            (task.keyPath = prevKeyPath);
-                        }
-                        childNodes = createReplayTask(
-                          request,
-                          null,
-                          { nodes: keyOrIndex, slots: key, pendingTasks: 0 },
-                          fallback,
-                          -1,
-                          parentBoundary,
-                          props.fallbackState,
-                          fallbackAbortSet,
-                          [keyPath[0], "Suspense Fallback", keyPath[2]],
-                          task.formatContext,
-                          task.context,
-                          task.treeContext,
-                          task.componentStack,
-                          !0
-                        );
-                        pushComponentStack(childNodes);
-                        request.pingedTasks.push(childNodes);
-                      }
-                    }
-                    childIndex.splice(node, 1);
-                    break;
-                  }
-              } else renderElement(request, task, keyPath, type, props, ref);
+                key = node.key;
+              node = node.props;
+              var refProp = node.ref;
+              refProp = void 0 !== refProp ? refProp : null;
+              var debugTask = task.debugTask,
+                name = getComponentNameFromType(type);
+              key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;
+              var keyPath = [task.keyPath, name, key];
+              null !== task.replay
+                ? debugTask
+                  ? debugTask.run(
+                      replayElement.bind(
+                        null,
+                        request,
+                        task,
+                        keyPath,
+                        name,
+                        key,
+                        childIndex,
+                        type,
+                        node,
+                        refProp,
+                        task.replay
+                      )
+                    )
+                  : replayElement(
+                      request,
+                      task,
+                      keyPath,
+                      name,
+                      key,
+                      childIndex,
+                      type,
+                      node,
+                      refProp,
+                      task.replay
+                    )
+                : debugTask
+                  ? debugTask.run(
+                      renderElement.bind(
+                        null,
+                        request,
+                        task,
+                        keyPath,
+                        type,
+                        node,
+                        refProp
+                      )
+                    )
+                  : renderElement(request, task, keyPath, type, node, refProp);
               return;
             case REACT_PORTAL_TYPE:
               throw Error(
@@ -5932,21 +6246,20 @@
             return;
           }
           null === node || "object" !== typeof node
-            ? (props = null)
-            : ((childNodes =
+            ? (key = null)
+            : ((type =
                 (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||
                 node["@@iterator"]),
-              (props = "function" === typeof childNodes ? childNodes : null));
-          if (props && (childNodes = props.call(node))) {
-            if (childNodes === node) {
+              (key = "function" === typeof type ? type : null));
+          if (key && (type = key.call(node))) {
+            if (type === node) {
               if (
                 -1 !== childIndex ||
                 null === task.componentStack ||
                 "function" !== typeof task.componentStack.type ||
                 "[object GeneratorFunction]" !==
                   Object.prototype.toString.call(task.componentStack.type) ||
-                "[object Generator]" !==
-                  Object.prototype.toString.call(childNodes)
+                "[object Generator]" !== Object.prototype.toString.call(type)
               )
                 didWarnAboutGenerators ||
                   console.error(
@@ -5954,21 +6267,59 @@
                   ),
                   (didWarnAboutGenerators = !0);
             } else
-              node.entries !== props ||
+              node.entries !== key ||
                 didWarnAboutMaps ||
                 (console.error(
                   "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                 ),
                 (didWarnAboutMaps = !0));
-            node = childNodes.next();
+            node = type.next();
             if (!node.done) {
-              props = [];
-              do props.push(node.value), (node = childNodes.next());
+              key = [];
+              do key.push(node.value), (node = type.next());
               while (!node.done);
-              renderChildrenArray(request, task, props, childIndex);
+              renderChildrenArray(request, task, key, childIndex);
             }
             return;
           }
+          if (
+            "function" === typeof node[ASYNC_ITERATOR] &&
+            (type = node[ASYNC_ITERATOR]())
+          ) {
+            type !== node ||
+              (-1 === childIndex &&
+                null !== task.componentStack &&
+                "function" === typeof task.componentStack.type &&
+                "[object AsyncGeneratorFunction]" ===
+                  Object.prototype.toString.call(task.componentStack.type) &&
+                "[object AsyncGenerator]" ===
+                  Object.prototype.toString.call(type)) ||
+              (didWarnAboutGenerators ||
+                console.error(
+                  "Using AsyncIterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You can use an AsyncIterable that can iterate multiple times over the same items."
+                ),
+              (didWarnAboutGenerators = !0));
+            key = task.thenableState;
+            task.thenableState = null;
+            thenableIndexCounter = 0;
+            thenableState = key;
+            key = [];
+            refProp = !1;
+            if (type === node)
+              for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+                if (node.done) {
+                  refProp = !0;
+                  break;
+                }
+                key.push(node.value);
+                node = readPreviousThenableFromState();
+              }
+            if (!refProp)
+              for (node = unwrapThenable(type.next()); !node.done; )
+                key.push(node.value), (node = unwrapThenable(type.next()));
+            renderChildrenArray(request, task, key, childIndex);
+            return;
+          }
           if ("function" === typeof node.then)
             return (
               (task.thenableState = null),
@@ -5986,39 +6337,39 @@
               node._currentValue,
               childIndex
             );
-          childIndex = Object.prototype.toString.call(node);
+          request = Object.prototype.toString.call(node);
           throw Error(
             "Objects are not valid as a React child (found: " +
-              ("[object Object]" === childIndex
+              ("[object Object]" === request
                 ? "object with keys {" + Object.keys(node).join(", ") + "}"
-                : childIndex) +
+                : request) +
               "). If you meant to render a collection of children, use an array instead."
           );
         }
         "string" === typeof node
-          ? ((childIndex = task.blockedSegment),
-            null !== childIndex &&
-              (childIndex.lastPushedText = pushTextInstance(
-                childIndex.chunks,
+          ? ((task = task.blockedSegment),
+            null !== task &&
+              (task.lastPushedText = pushTextInstance(
+                task.chunks,
                 node,
                 request.renderState,
-                childIndex.lastPushedText
+                task.lastPushedText
               )))
           : "number" === typeof node || "bigint" === typeof node
-            ? ((childIndex = task.blockedSegment),
-              null !== childIndex &&
-                (childIndex.lastPushedText = pushTextInstance(
-                  childIndex.chunks,
+            ? ((task = task.blockedSegment),
+              null !== task &&
+                (task.lastPushedText = pushTextInstance(
+                  task.chunks,
                   "" + node,
                   request.renderState,
-                  childIndex.lastPushedText
+                  task.lastPushedText
                 )))
             : ("function" === typeof node &&
-                ((childIndex = node.displayName || node.name || "Component"),
+                ((request = node.displayName || node.name || "Component"),
                 console.error(
                   "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
-                  childIndex,
-                  childIndex
+                  request,
+                  request
                 )),
               "symbol" === typeof node &&
                 console.error(
@@ -6030,6 +6381,7 @@
     function renderChildrenArray(request$jscomp$0, task, children, childIndex) {
       var prevKeyPath = task.keyPath,
         previousComponentStack = task.componentStack;
+      var previousDebugTask = task.debugTask;
       pushServerComponentStack(task, task.node._debugInfo);
       if (
         -1 !== childIndex &&
@@ -6071,7 +6423,8 @@
                 x,
                 children,
                 childIndex,
-                node
+                node,
+                task.debugTask
               );
             }
             task.replay = replay;
@@ -6081,6 +6434,7 @@
         }
         task.keyPath = prevKeyPath;
         task.componentStack = previousComponentStack;
+        task.debugTask = previousDebugTask;
         return;
       }
       replay = task.treeContext;
@@ -6107,6 +6461,7 @@
         task.treeContext = replay;
         task.keyPath = prevKeyPath;
         task.componentStack = previousComponentStack;
+        task.debugTask = previousDebugTask;
         return;
       }
       for (j = 0; j < replayNodes; j++) {
@@ -6165,7 +6520,7 @@
               parent: node.componentStack,
               type: resumeSegmentID.type,
               owner: resumeSegmentID._owner,
-              stack: null
+              stack: resumeSegmentID._debugStack
             };
             console.error(
               'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
@@ -6181,6 +6536,106 @@
       task.treeContext = replay;
       task.keyPath = prevKeyPath;
       task.componentStack = previousComponentStack;
+      task.debugTask = previousDebugTask;
+    }
+    function trackPostpone(request, trackedPostpones, task, segment) {
+      segment.status = POSTPONED;
+      var keyPath = task.keyPath,
+        boundary = task.blockedBoundary;
+      if (null === boundary)
+        (segment.id = request.nextSegmentId++),
+          (trackedPostpones.rootSlots = segment.id),
+          null !== request.completedRootSegment &&
+            (request.completedRootSegment.status = POSTPONED);
+      else {
+        if (null !== boundary && boundary.status === PENDING) {
+          boundary.status = POSTPONED;
+          boundary.rootSegmentID = request.nextSegmentId++;
+          var boundaryKeyPath = boundary.trackedContentKeyPath;
+          if (null === boundaryKeyPath)
+            throw Error(
+              "It should not be possible to postpone at the root. This is a bug in React."
+            );
+          var fallbackReplayNode = boundary.trackedFallbackNode,
+            children = [];
+          if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+            -1 === segment.id &&
+              (segment.id = segment.parentFlushed
+                ? boundary.rootSegmentID
+                : request.nextSegmentId++);
+            segment = [
+              boundaryKeyPath[1],
+              boundaryKeyPath[2],
+              children,
+              segment.id,
+              fallbackReplayNode,
+              boundary.rootSegmentID
+            ];
+            trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+            addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+            return;
+          }
+          var _boundaryNode = trackedPostpones.workingMap.get(boundaryKeyPath);
+          void 0 === _boundaryNode
+            ? ((_boundaryNode = [
+                boundaryKeyPath[1],
+                boundaryKeyPath[2],
+                children,
+                null,
+                fallbackReplayNode,
+                boundary.rootSegmentID
+              ]),
+              trackedPostpones.workingMap.set(boundaryKeyPath, _boundaryNode),
+              addToReplayParent(
+                _boundaryNode,
+                boundaryKeyPath[0],
+                trackedPostpones
+              ))
+            : ((boundaryKeyPath = _boundaryNode),
+              (boundaryKeyPath[4] = fallbackReplayNode),
+              (boundaryKeyPath[5] = boundary.rootSegmentID));
+        }
+        -1 === segment.id &&
+          (segment.id =
+            segment.parentFlushed && null !== boundary
+              ? boundary.rootSegmentID
+              : request.nextSegmentId++);
+        if (-1 === task.childIndex)
+          null === keyPath
+            ? (trackedPostpones.rootSlots = segment.id)
+            : ((task = trackedPostpones.workingMap.get(keyPath)),
+              void 0 === task
+                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+                  addToReplayParent(task, keyPath[0], trackedPostpones))
+                : (task[3] = segment.id));
+        else {
+          if (null === keyPath)
+            if (((request = trackedPostpones.rootSlots), null === request))
+              request = trackedPostpones.rootSlots = {};
+            else {
+              if ("number" === typeof request)
+                throw Error(
+                  "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+                );
+            }
+          else if (
+            ((boundary = trackedPostpones.workingMap),
+            (boundaryKeyPath = boundary.get(keyPath)),
+            void 0 === boundaryKeyPath)
+          )
+            (request = {}),
+              (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+              boundary.set(keyPath, boundaryKeyPath),
+              addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+          else if (((request = boundaryKeyPath[3]), null === request))
+            request = boundaryKeyPath[3] = {};
+          else if ("number" === typeof request)
+            throw Error(
+              "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+            );
+          request[task.childIndex] = segment.id;
+        }
+      }
     }
     function untrackBoundary(request, boundary) {
       request = request.trackedPostpones;
@@ -6206,7 +6661,9 @@
         task.context,
         task.treeContext,
         task.componentStack,
-        task.isFallback
+        task.isFallback,
+        emptyContextObject,
+        task.debugTask
       );
     }
     function spawnNewSuspendedRenderTask(request, task, thenableState) {
@@ -6228,7 +6685,6 @@
         task.childIndex,
         task.blockedBoundary,
         newSegment,
-        task.blockedPreamble,
         task.hoistableState,
         task.abortSet,
         task.keyPath,
@@ -6236,7 +6692,9 @@
         task.context,
         task.treeContext,
         task.componentStack,
-        task.isFallback
+        task.isFallback,
+        emptyContextObject,
+        task.debugTask
       );
     }
     function renderNode(request, task, node, childIndex) {
@@ -6245,6 +6703,7 @@
         previousKeyPath = task.keyPath,
         previousTreeContext = task.treeContext,
         previousComponentStack = task.componentStack,
+        previousDebugTask = task.debugTask,
         segment = task.blockedSegment;
       if (null === segment)
         try {
@@ -6252,13 +6711,14 @@
         } catch (thrownValue) {
           if (
             (resetHooksState(),
-            (node =
+            (childIndex =
               thrownValue === SuspenseException
                 ? getSuspendedThenable()
                 : thrownValue),
-            "object" === typeof node && null !== node)
+            "object" === typeof childIndex && null !== childIndex)
           ) {
-            if ("function" === typeof node.then) {
+            if ("function" === typeof childIndex.then) {
+              node = childIndex;
               childIndex = getThenableStateAfterSuspending();
               request = spawnNewSuspendedReplayTask(
                 request,
@@ -6271,10 +6731,11 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
-            if ("Maximum call stack size exceeded" === node.message) {
+            if ("Maximum call stack size exceeded" === childIndex.message) {
               node = getThenableStateAfterSuspending();
               node = spawnNewSuspendedReplayTask(request, task, node);
               request.pingedTasks.push(node);
@@ -6283,6 +6744,7 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
@@ -6298,13 +6760,14 @@
             (resetHooksState(),
             (segment.children.length = childrenLength),
             (segment.chunks.length = chunkLength),
-            (node =
+            (childIndex =
               thrownValue$3 === SuspenseException
                 ? getSuspendedThenable()
                 : thrownValue$3),
-            "object" === typeof node && null !== node)
+            "object" === typeof childIndex && null !== childIndex)
           ) {
-            if ("function" === typeof node.then) {
+            if ("function" === typeof childIndex.then) {
+              node = childIndex;
               childIndex = getThenableStateAfterSuspending();
               request = spawnNewSuspendedRenderTask(
                 request,
@@ -6317,10 +6780,40 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
+              switchContext(previousContext);
+              return;
+            }
+            if (
+              childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+              null !== request.trackedPostpones &&
+              null !== task.blockedBoundary
+            ) {
+              node = request.trackedPostpones;
+              segment = getThrownInfo(task.componentStack);
+              logPostpone(request, childIndex.message, segment, task.debugTask);
+              childIndex = task.blockedSegment;
+              segment = createPendingSegment(
+                request,
+                childIndex.chunks.length,
+                null,
+                task.formatContext,
+                childIndex.lastPushedText,
+                !0
+              );
+              childIndex.children.push(segment);
+              childIndex.lastPushedText = !1;
+              trackPostpone(request, node, task, segment);
+              task.formatContext = previousFormatContext;
+              task.context = previousContext;
+              task.keyPath = previousKeyPath;
+              task.treeContext = previousTreeContext;
+              task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
-            if ("Maximum call stack size exceeded" === node.message) {
+            if ("Maximum call stack size exceeded" === childIndex.message) {
               node = getThenableStateAfterSuspending();
               node = spawnNewSuspendedRenderTask(request, task, node);
               request.pingedTasks.push(node);
@@ -6329,6 +6822,7 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
@@ -6340,7 +6834,7 @@
       task.keyPath = previousKeyPath;
       task.treeContext = previousTreeContext;
       switchContext(previousContext);
-      throw node;
+      throw childIndex;
     }
     function erroredReplay(
       request,
@@ -6348,16 +6842,27 @@
       error,
       errorInfo,
       replayNodes,
-      resumeSlots
+      resumeSlots,
+      debugTask
     ) {
-      var errorDigest = logRecoverableError(request, error, errorInfo);
+      "object" === typeof error &&
+      null !== error &&
+      error.$$typeof === REACT_POSTPONE_TYPE
+        ? (logPostpone(request, error.message, errorInfo, debugTask),
+          (debugTask = "POSTPONE"))
+        : (debugTask = logRecoverableError(
+            request,
+            error,
+            errorInfo,
+            debugTask
+          ));
       abortRemainingReplayNodes(
         request,
         boundary,
         replayNodes,
         resumeSlots,
         error,
-        errorDigest,
+        debugTask,
         errorInfo,
         !1
       );
@@ -6397,12 +6902,7 @@
             errorDigest = errorDigest$jscomp$0,
             errorInfo = errorInfo$jscomp$0,
             wasAborted = aborted,
-            resumedBoundary = createSuspenseBoundary(
-              request,
-              new Set(),
-              null,
-              null
-            );
+            resumedBoundary = createSuspenseBoundary(request, new Set());
           resumedBoundary.parentFlushed = !0;
           resumedBoundary.rootSegmentID = node;
           resumedBoundary.status = CLIENT_RENDERED;
@@ -6445,19 +6945,43 @@
         if (6 === segment.status) return;
         segment.status = 3;
       }
-      segment = getThrownInfo(task.componentStack);
+      var errorInfo = getThrownInfo(task.componentStack);
       if (null === boundary) {
         if (13 !== request.status && request.status !== CLOSED) {
           boundary = task.replay;
           if (null === boundary) {
-            logRecoverableError(request, error, segment);
-            fatalError(request, error);
+            "object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+              ? ((boundary = request.trackedPostpones),
+                null !== boundary && null !== segment
+                  ? (logPostpone(request, error.message, errorInfo, null),
+                    trackPostpone(request, boundary, task, segment),
+                    finishedTask(request, null, segment))
+                  : ((task = Error(
+                      "The render was aborted with postpone when the shell is incomplete. Reason: " +
+                        error.message
+                    )),
+                    logRecoverableError(request, task, errorInfo, null),
+                    fatalError(request, task, errorInfo, null)))
+              : null !== request.trackedPostpones && null !== segment
+                ? ((boundary = request.trackedPostpones),
+                  logRecoverableError(request, error, errorInfo, null),
+                  trackPostpone(request, boundary, task, segment),
+                  finishedTask(request, null, segment))
+                : (logRecoverableError(request, error, errorInfo, null),
+                  fatalError(request, error, errorInfo, null));
             return;
           }
           boundary.pendingTasks--;
           0 === boundary.pendingTasks &&
             0 < boundary.nodes.length &&
-            ((task = logRecoverableError(request, error, segment)),
+            ("object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+              ? (logPostpone(request, error.message, errorInfo, null),
+                (task = "POSTPONE"))
+              : (task = logRecoverableError(request, error, errorInfo, null)),
             abortRemainingReplayNodes(
               request,
               null,
@@ -6465,26 +6989,59 @@
               boundary.slots,
               error,
               task,
-              segment,
+              errorInfo,
               !0
             ));
           request.pendingRootTasks--;
           0 === request.pendingRootTasks && completeShell(request);
         }
-      } else
-        boundary.pendingTasks--,
-          boundary.status !== CLIENT_RENDERED &&
-            ((boundary.status = CLIENT_RENDERED),
-            (task = logRecoverableError(request, error, segment)),
-            (boundary.status = CLIENT_RENDERED),
-            encodeErrorForBoundary(boundary, task, error, segment, !0),
-            untrackBoundary(request, boundary),
-            boundary.parentFlushed &&
-              request.clientRenderedBoundaries.push(boundary)),
-          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-            return abortTask(fallbackTask, request, error);
-          }),
-          boundary.fallbackAbortableTasks.clear();
+      } else {
+        boundary.pendingTasks--;
+        var _trackedPostpones2 = request.trackedPostpones;
+        if (boundary.status !== CLIENT_RENDERED) {
+          if (null !== _trackedPostpones2 && null !== segment)
+            return (
+              "object" === typeof error &&
+              null !== error &&
+              error.$$typeof === REACT_POSTPONE_TYPE
+                ? logPostpone(request, error.message, errorInfo, null)
+                : logRecoverableError(request, error, errorInfo, null),
+              trackPostpone(request, _trackedPostpones2, task, segment),
+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+                return abortTask(fallbackTask, request, error);
+              }),
+              boundary.fallbackAbortableTasks.clear(),
+              finishedTask(request, boundary, segment)
+            );
+          boundary.status = CLIENT_RENDERED;
+          if (
+            "object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+          ) {
+            logPostpone(request, error.message, errorInfo, null);
+            if (null !== request.trackedPostpones && null !== segment) {
+              trackPostpone(request, request.trackedPostpones, task, segment);
+              finishedTask(request, task.blockedBoundary, segment);
+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+                return abortTask(fallbackTask, request, error);
+              });
+              boundary.fallbackAbortableTasks.clear();
+              return;
+            }
+            task = "POSTPONE";
+          } else task = logRecoverableError(request, error, errorInfo, null);
+          boundary.status = CLIENT_RENDERED;
+          encodeErrorForBoundary(boundary, task, error, errorInfo, !0);
+          untrackBoundary(request, boundary);
+          boundary.parentFlushed &&
+            request.clientRenderedBoundaries.push(boundary);
+        }
+        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+          return abortTask(fallbackTask, request, error);
+        });
+        boundary.fallbackAbortableTasks.clear();
+      }
       request.allPendingTasks--;
       0 === request.allPendingTasks && completeAll(request);
     }
@@ -6550,12 +7107,11 @@
           }
         }
       } catch (error) {
-        logRecoverableError(request, error, {});
+        logRecoverableError(request, error, {}, null);
       }
     }
     function completeShell(request) {
       null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-      null === request.trackedPostpones && preparePreamble(request);
       request.onShellError = noop;
       request = request.onShellReady;
       request();
@@ -6568,7 +7124,6 @@
           : null === request.completedRootSegment ||
               request.completedRootSegment.status !== POSTPONED
       );
-      preparePreamble(request);
       request = request.onAllReady;
       request();
     }
@@ -6613,11 +7168,7 @@
                     abortTaskSoft,
                     request
                   ),
-                  boundary.fallbackAbortableTasks.clear(),
-                  0 === request.pendingRootTasks &&
-                    null === request.trackedPostpones &&
-                    null !== boundary.contentPreamble &&
-                    preparePreamble(request)))
+                  boundary.fallbackAbortableTasks.clear()))
               : null !== segment &&
                 segment.parentFlushed &&
                 segment.status === COMPLETED &&
@@ -6705,7 +7256,8 @@
                         : x,
                       errorInfo,
                       request.replay.nodes,
-                      request.replay.slots
+                      request.replay.slots,
+                      request.debugTask
                     );
                     request$jscomp$0.pendingRootTasks--;
                     0 === request$jscomp$0.pendingRootTasks &&
@@ -6718,88 +7270,168 @@
                   currentTaskInDEV = prevTaskInDEV;
                 }
               }
-            } else {
-              request$jscomp$0 = prevTaskInDEV = void 0;
-              var task$jscomp$0 = task,
-                segment$jscomp$0 = segment;
-              if (segment$jscomp$0.status === PENDING) {
-                segment$jscomp$0.status = 6;
-                switchContext(task$jscomp$0.context);
-                request$jscomp$0 = currentTaskInDEV;
-                currentTaskInDEV = task$jscomp$0;
-                var childrenLength = segment$jscomp$0.children.length,
-                  chunkLength = segment$jscomp$0.chunks.length;
-                try {
-                  retryNode(request, task$jscomp$0),
-                    segment$jscomp$0.lastPushedText &&
-                      segment$jscomp$0.textEmbedded &&
-                      segment$jscomp$0.chunks.push(textSeparator),
-                    task$jscomp$0.abortSet.delete(task$jscomp$0),
-                    (segment$jscomp$0.status = COMPLETED),
-                    finishedTask(
-                      request,
-                      task$jscomp$0.blockedBoundary,
-                      segment$jscomp$0
-                    );
-                } catch (thrownValue) {
-                  resetHooksState();
-                  segment$jscomp$0.children.length = childrenLength;
-                  segment$jscomp$0.chunks.length = chunkLength;
-                  var x$jscomp$0 =
-                    thrownValue === SuspenseException
-                      ? getSuspendedThenable()
-                      : 12 === request.status
-                        ? request.fatalError
-                        : thrownValue;
-                  if (
-                    "object" === typeof x$jscomp$0 &&
-                    null !== x$jscomp$0 &&
-                    "function" === typeof x$jscomp$0.then
-                  ) {
-                    segment$jscomp$0.status = PENDING;
-                    task$jscomp$0.thenableState =
-                      getThenableStateAfterSuspending();
-                    var ping$jscomp$0 = task$jscomp$0.ping;
-                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-                  } else {
-                    var errorInfo$jscomp$0 = getThrownInfo(
-                      task$jscomp$0.componentStack
-                    );
-                    task$jscomp$0.abortSet.delete(task$jscomp$0);
-                    segment$jscomp$0.status = 4;
-                    var boundary = task$jscomp$0.blockedBoundary;
-                    prevTaskInDEV = logRecoverableError(
-                      request,
-                      x$jscomp$0,
-                      errorInfo$jscomp$0
-                    );
-                    null === boundary
-                      ? fatalError(request, x$jscomp$0)
-                      : (boundary.pendingTasks--,
-                        boundary.status !== CLIENT_RENDERED &&
-                          ((boundary.status = CLIENT_RENDERED),
-                          encodeErrorForBoundary(
-                            boundary,
-                            prevTaskInDEV,
+            } else
+              a: {
+                request$jscomp$0 = prevTaskInDEV = void 0;
+                var task$jscomp$0 = task,
+                  segment$jscomp$0 = segment;
+                if (segment$jscomp$0.status === PENDING) {
+                  segment$jscomp$0.status = 6;
+                  switchContext(task$jscomp$0.context);
+                  request$jscomp$0 = currentTaskInDEV;
+                  currentTaskInDEV = task$jscomp$0;
+                  var childrenLength = segment$jscomp$0.children.length,
+                    chunkLength = segment$jscomp$0.chunks.length;
+                  try {
+                    retryNode(request, task$jscomp$0),
+                      segment$jscomp$0.lastPushedText &&
+                        segment$jscomp$0.textEmbedded &&
+                        segment$jscomp$0.chunks.push(textSeparator),
+                      task$jscomp$0.abortSet.delete(task$jscomp$0),
+                      (segment$jscomp$0.status = COMPLETED),
+                      finishedTask(
+                        request,
+                        task$jscomp$0.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                  } catch (thrownValue) {
+                    resetHooksState();
+                    segment$jscomp$0.children.length = childrenLength;
+                    segment$jscomp$0.chunks.length = chunkLength;
+                    var x$jscomp$0 =
+                      thrownValue === SuspenseException
+                        ? getSuspendedThenable()
+                        : 12 === request.status
+                          ? request.fatalError
+                          : thrownValue;
+                    if (
+                      12 === request.status &&
+                      null !== request.trackedPostpones
+                    ) {
+                      var trackedPostpones = request.trackedPostpones,
+                        thrownInfo = getThrownInfo(
+                          task$jscomp$0.componentStack
+                        );
+                      task$jscomp$0.abortSet.delete(task$jscomp$0);
+                      "object" === typeof x$jscomp$0 &&
+                      null !== x$jscomp$0 &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ? logPostpone(
+                            request,
+                            x$jscomp$0.message,
+                            thrownInfo,
+                            task$jscomp$0.debugTask
+                          )
+                        : logRecoverableError(
+                            request,
                             x$jscomp$0,
+                            thrownInfo,
+                            task$jscomp$0.debugTask
+                          );
+                      trackPostpone(
+                        request,
+                        trackedPostpones,
+                        task$jscomp$0,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task$jscomp$0.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                    } else {
+                      if (
+                        "object" === typeof x$jscomp$0 &&
+                        null !== x$jscomp$0
+                      ) {
+                        if ("function" === typeof x$jscomp$0.then) {
+                          segment$jscomp$0.status = PENDING;
+                          task$jscomp$0.thenableState =
+                            getThenableStateAfterSuspending();
+                          var ping$jscomp$0 = task$jscomp$0.ping;
+                          x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                          break a;
+                        }
+                        if (
+                          null !== request.trackedPostpones &&
+                          x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ) {
+                          var _trackedPostpones3 = request.trackedPostpones;
+                          task$jscomp$0.abortSet.delete(task$jscomp$0);
+                          var postponeInfo = getThrownInfo(
+                            task$jscomp$0.componentStack
+                          );
+                          logPostpone(
+                            request,
+                            x$jscomp$0.message,
+                            postponeInfo,
+                            task$jscomp$0.debugTask
+                          );
+                          trackPostpone(
+                            request,
+                            _trackedPostpones3,
+                            task$jscomp$0,
+                            segment$jscomp$0
+                          );
+                          finishedTask(
+                            request,
+                            task$jscomp$0.blockedBoundary,
+                            segment$jscomp$0
+                          );
+                          break a;
+                        }
+                      }
+                      var errorInfo$jscomp$0 = getThrownInfo(
+                        task$jscomp$0.componentStack
+                      );
+                      task$jscomp$0.abortSet.delete(task$jscomp$0);
+                      segment$jscomp$0.status = 4;
+                      var boundary = task$jscomp$0.blockedBoundary,
+                        debugTask = task$jscomp$0.debugTask;
+                      "object" === typeof x$jscomp$0 &&
+                      null !== x$jscomp$0 &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ? (logPostpone(
+                            request,
+                            x$jscomp$0.message,
                             errorInfo$jscomp$0,
-                            !1
+                            debugTask
                           ),
-                          untrackBoundary(request, boundary),
-                          boundary.parentFlushed &&
-                            request.clientRenderedBoundaries.push(boundary),
-                          0 === request.pendingRootTasks &&
-                            null === request.trackedPostpones &&
-                            null !== boundary.contentPreamble &&
-                            preparePreamble(request)));
-                    request.allPendingTasks--;
-                    0 === request.allPendingTasks && completeAll(request);
+                          (prevTaskInDEV = "POSTPONE"))
+                        : (prevTaskInDEV = logRecoverableError(
+                            request,
+                            x$jscomp$0,
+                            errorInfo$jscomp$0,
+                            debugTask
+                          ));
+                      null === boundary
+                        ? fatalError(
+                            request,
+                            x$jscomp$0,
+                            errorInfo$jscomp$0,
+                            debugTask
+                          )
+                        : (boundary.pendingTasks--,
+                          boundary.status !== CLIENT_RENDERED &&
+                            ((boundary.status = CLIENT_RENDERED),
+                            encodeErrorForBoundary(
+                              boundary,
+                              prevTaskInDEV,
+                              x$jscomp$0,
+                              errorInfo$jscomp$0,
+                              !1
+                            ),
+                            untrackBoundary(request, boundary),
+                            boundary.parentFlushed &&
+                              request.clientRenderedBoundaries.push(boundary)));
+                      request.allPendingTasks--;
+                      0 === request.allPendingTasks && completeAll(request);
+                    }
+                  } finally {
+                    currentTaskInDEV = request$jscomp$0;
                   }
-                } finally {
-                  currentTaskInDEV = request$jscomp$0;
                 }
               }
-            }
           }
           pingedTasks.splice(0, i);
           null !== request$jscomp$1.destination &&
@@ -6808,8 +7440,9 @@
               request$jscomp$1.destination
             );
         } catch (error) {
-          logRecoverableError(request$jscomp$1, error, {}),
-            fatalError(request$jscomp$1, error);
+          (pingedTasks = {}),
+            logRecoverableError(request$jscomp$1, error, pingedTasks, null),
+            fatalError(request$jscomp$1, error, pingedTasks, null);
         } finally {
           (currentResumableState = prevResumableState),
             (ReactSharedInternals.H = prevDispatcher),
@@ -6820,85 +7453,6 @@
         }
       }
     }
-    function preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    ) {
-      segment.preambleChildren.length &&
-        collectedPreambleSegments.push(segment.preambleChildren);
-      for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-        pendingPreambles =
-          preparePreambleFromSegment(
-            request,
-            segment.children[i],
-            collectedPreambleSegments
-          ) || pendingPreambles;
-      return pendingPreambles;
-    }
-    function preparePreambleFromSegment(
-      request,
-      segment,
-      collectedPreambleSegments
-    ) {
-      var boundary = segment.boundary;
-      if (null === boundary)
-        return preparePreambleFromSubtree(
-          request,
-          segment,
-          collectedPreambleSegments
-        );
-      var preamble = boundary.contentPreamble,
-        fallbackPreamble = boundary.fallbackPreamble;
-      if (null === preamble || null === fallbackPreamble) return !1;
-      switch (boundary.status) {
-        case COMPLETED:
-          hoistPreambleState(request.renderState, preamble);
-          segment = boundary.completedSegments[0];
-          if (!segment)
-            throw Error(
-              "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
-            );
-          return preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          );
-        case POSTPONED:
-          if (null !== request.trackedPostpones) return !0;
-        case CLIENT_RENDERED:
-          if (segment.status === COMPLETED)
-            return (
-              hoistPreambleState(request.renderState, fallbackPreamble),
-              preparePreambleFromSubtree(
-                request,
-                segment,
-                collectedPreambleSegments
-              )
-            );
-        default:
-          return !0;
-      }
-    }
-    function preparePreamble(request) {
-      if (
-        request.completedRootSegment &&
-        null === request.completedPreambleSegments
-      ) {
-        var collectedPreambleSegments = [],
-          hasPendingPreambles = preparePreambleFromSegment(
-            request,
-            request.completedRootSegment,
-            collectedPreambleSegments
-          ),
-          preamble = request.renderState.preamble;
-        if (
-          !1 === hasPendingPreambles ||
-          (preamble.headChunks && preamble.bodyChunks)
-        )
-          request.completedPreambleSegments = collectedPreambleSegments;
-      }
-    }
     function flushSubtree(request, destination, segment, hoistableState) {
       segment.parentFlushed = !0;
       switch (segment.status) {
@@ -7076,40 +7630,64 @@
       boundary = boundary.contentState;
       var requiresStyleInsertion = request.stylesToHoist;
       request.stylesToHoist = !1;
-      writeChunk(destination, request.startInlineScript);
-      requiresStyleInsertion
-        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-          NothingSent
-          ? ((completedSegments.instructions =
-              completedSegments.instructions |
-              SentStyleInsertionFunction |
-              SentCompleteBoundaryFunction),
-            writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))
-          : (completedSegments.instructions & SentStyleInsertionFunction) ===
+      var scriptFormat =
+        completedSegments.streamingFormat === ScriptStreamingFormat;
+      scriptFormat
+        ? (writeChunk(destination, request.startInlineScript),
+          requiresStyleInsertion
+            ? (completedSegments.instructions &
+                SentCompleteBoundaryFunction) ===
               NothingSent
-            ? ((completedSegments.instructions |= SentStyleInsertionFunction),
-              writeChunk(
-                destination,
-                completeBoundaryWithStylesScript1FullPartial
-              ))
-            : writeChunk(destination, completeBoundaryWithStylesScript1Partial)
-        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-            NothingSent
-          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),
-            writeChunk(destination, completeBoundaryScript1Full))
-          : writeChunk(destination, completeBoundaryScript1Partial);
+              ? ((completedSegments.instructions =
+                  completedSegments.instructions |
+                  SentStyleInsertionFunction |
+                  SentCompleteBoundaryFunction),
+                writeChunk(
+                  destination,
+                  completeBoundaryWithStylesScript1FullBoth
+                ))
+              : (completedSegments.instructions &
+                    SentStyleInsertionFunction) ===
+                  NothingSent
+                ? ((completedSegments.instructions |=
+                    SentStyleInsertionFunction),
+                  writeChunk(
+                    destination,
+                    completeBoundaryWithStylesScript1FullPartial
+                  ))
+                : writeChunk(
+                    destination,
+                    completeBoundaryWithStylesScript1Partial
+                  )
+            : (completedSegments.instructions &
+                  SentCompleteBoundaryFunction) ===
+                NothingSent
+              ? ((completedSegments.instructions |=
+                  SentCompleteBoundaryFunction),
+                writeChunk(destination, completeBoundaryScript1Full))
+              : writeChunk(destination, completeBoundaryScript1Partial))
+        : requiresStyleInsertion
+          ? writeChunk(destination, completeBoundaryWithStylesData1)
+          : writeChunk(destination, completeBoundaryData1);
       completedSegments = stringToChunk(i.toString(16));
       writeChunk(destination, request.boundaryPrefix);
       writeChunk(destination, completedSegments);
-      writeChunk(destination, completeBoundaryScript2);
+      scriptFormat
+        ? writeChunk(destination, completeBoundaryScript2)
+        : writeChunk(destination, completeBoundaryData2);
       writeChunk(destination, request.segmentPrefix);
       writeChunk(destination, completedSegments);
       requiresStyleInsertion
-        ? (writeChunk(destination, completeBoundaryScript3a),
-          writeStyleResourceDependenciesInJS(destination, boundary))
-        : writeChunk(destination, completeBoundaryScript3b);
-      boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
-      return writeBootstrap(destination, request) && boundary;
+        ? scriptFormat
+          ? (writeChunk(destination, completeBoundaryScript3a),
+            writeStyleResourceDependenciesInJS(destination, boundary))
+          : (writeChunk(destination, completeBoundaryData3a),
+            writeStyleResourceDependenciesInAttr(destination, boundary))
+        : scriptFormat && writeChunk(destination, completeBoundaryScript3b);
+      completedSegments = scriptFormat
+        ? writeChunkAndReturn(destination, completeBoundaryScriptEnd)
+        : writeChunkAndReturn(destination, completeBoundaryDataEnd);
+      return writeBootstrap(destination, request) && completedSegments;
     }
     function flushPartiallyCompletedSegment(
       request,
@@ -7142,18 +7720,24 @@
       flushSegmentContainer(request, destination, segment, hoistableState);
       boundary = request.resumableState;
       request = request.renderState;
-      writeChunk(destination, request.startInlineScript);
-      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
-        ? ((boundary.instructions |= SentCompleteSegmentFunction),
-          writeChunk(destination, completeSegmentScript1Full))
-        : writeChunk(destination, completeSegmentScript1Partial);
+      (segment = boundary.streamingFormat === ScriptStreamingFormat)
+        ? (writeChunk(destination, request.startInlineScript),
+          (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
+            ? ((boundary.instructions |= SentCompleteSegmentFunction),
+              writeChunk(destination, completeSegmentScript1Full))
+            : writeChunk(destination, completeSegmentScript1Partial))
+        : writeChunk(destination, completeSegmentData1);
       writeChunk(destination, request.segmentPrefix);
       segmentID = stringToChunk(segmentID.toString(16));
       writeChunk(destination, segmentID);
-      writeChunk(destination, completeSegmentScript2);
+      segment
+        ? writeChunk(destination, completeSegmentScript2)
+        : writeChunk(destination, completeSegmentData2);
       writeChunk(destination, request.placeholderPrefix);
       writeChunk(destination, segmentID);
-      destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
+      destination = segment
+        ? writeChunkAndReturn(destination, completeSegmentScriptEnd)
+        : writeChunkAndReturn(destination, completeSegmentDataEnd);
       return destination;
     }
     function flushCompletedQueues(request, destination) {
@@ -7165,12 +7749,22 @@
             completedRootSegment = request.completedRootSegment;
           if (null !== completedRootSegment) {
             if (completedRootSegment.status === POSTPONED) return;
-            var completedPreambleSegments = request.completedPreambleSegments;
-            if (null === completedPreambleSegments) return;
-            var renderState = request.renderState,
-              preamble = renderState.preamble,
-              htmlChunks = preamble.htmlChunks,
-              headChunks = preamble.headChunks,
+            var renderState = request.renderState;
+            if (
+              (0 !== request.allPendingTasks ||
+                null !== request.trackedPostpones) &&
+              renderState.externalRuntimeScript
+            ) {
+              var _renderState$external = renderState.externalRuntimeScript,
+                resumableState = request.resumableState,
+                src = _renderState$external.src,
+                chunks = _renderState$external.chunks;
+              resumableState.scriptResources.hasOwnProperty(src) ||
+                ((resumableState.scriptResources[src] = EXISTS),
+                renderState.scripts.add(chunks));
+            }
+            var htmlChunks = renderState.htmlChunks,
+              headChunks = renderState.headChunks,
               i$jscomp$0;
             if (htmlChunks) {
               for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -7231,27 +7825,10 @@
               i$jscomp$0++
             )
               writeChunk(destination, hoistableChunks[i$jscomp$0]);
-            for (
-              renderState = hoistableChunks.length = 0;
-              renderState < completedPreambleSegments.length;
-              renderState++
-            ) {
-              var segments = completedPreambleSegments[renderState];
-              for (preamble = 0; preamble < segments.length; preamble++)
-                flushSegment(request, destination, segments[preamble], null);
-            }
-            var preamble$jscomp$0 = request.renderState.preamble,
-              headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-            (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) &&
+            hoistableChunks.length = 0;
+            htmlChunks &&
+              null === headChunks &&
               writeChunk(destination, endChunkForTag("head"));
-            var bodyChunks = preamble$jscomp$0.bodyChunks;
-            if (bodyChunks)
-              for (
-                completedPreambleSegments = 0;
-                completedPreambleSegments < bodyChunks.length;
-                completedPreambleSegments++
-              )
-                writeChunk(destination, bodyChunks[completedPreambleSegments]);
             flushSegment(request, destination, completedRootSegment, null);
             request.completedRootSegment = null;
             writeBootstrap(destination, request.renderState);
@@ -7298,81 +7875,115 @@
           for (i = 0; i < clientRenderedBoundaries.length; i++) {
             var boundary = clientRenderedBoundaries[i];
             renderState$jscomp$0 = destination;
-            var resumableState = request.resumableState,
+            var resumableState$jscomp$0 = request.resumableState,
               renderState$jscomp$1 = request.renderState,
               id = boundary.rootSegmentID,
               errorDigest = boundary.errorDigest,
               errorMessage = boundary.errorMessage,
               errorStack = boundary.errorStack,
-              errorComponentStack = boundary.errorComponentStack;
-            writeChunk(
-              renderState$jscomp$0,
-              renderState$jscomp$1.startInlineScript
-            );
-            (resumableState.instructions & SentClientRenderFunction) ===
-            NothingSent
-              ? ((resumableState.instructions |= SentClientRenderFunction),
-                writeChunk(renderState$jscomp$0, clientRenderScript1Full))
-              : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
+              errorComponentStack = boundary.errorComponentStack,
+              scriptFormat =
+                resumableState$jscomp$0.streamingFormat ===
+                ScriptStreamingFormat;
+            scriptFormat
+              ? (writeChunk(
+                  renderState$jscomp$0,
+                  renderState$jscomp$1.startInlineScript
+                ),
+                (resumableState$jscomp$0.instructions &
+                  SentClientRenderFunction) ===
+                NothingSent
+                  ? ((resumableState$jscomp$0.instructions |=
+                      SentClientRenderFunction),
+                    writeChunk(renderState$jscomp$0, clientRenderScript1Full))
+                  : writeChunk(
+                      renderState$jscomp$0,
+                      clientRenderScript1Partial
+                    ))
+              : writeChunk(renderState$jscomp$0, clientRenderData1);
             writeChunk(
               renderState$jscomp$0,
               renderState$jscomp$1.boundaryPrefix
             );
             writeChunk(renderState$jscomp$0, stringToChunk(id.toString(16)));
-            writeChunk(renderState$jscomp$0, clientRenderScript1A);
+            scriptFormat &&
+              writeChunk(renderState$jscomp$0, clientRenderScript1A);
             if (
               errorDigest ||
               errorMessage ||
               errorStack ||
               errorComponentStack
             )
-              writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-                writeChunk(
-                  renderState$jscomp$0,
-                  stringToChunk(
-                    escapeJSStringsForInstructionScripts(errorDigest || "")
-                  )
-                );
+              scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(
+                      escapeJSStringsForInstructionScripts(errorDigest || "")
+                    )
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData2),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(escapeTextForBrowser(errorDigest || ""))
+                  ));
             if (errorMessage || errorStack || errorComponentStack)
-              writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-                writeChunk(
-                  renderState$jscomp$0,
-                  stringToChunk(
-                    escapeJSStringsForInstructionScripts(errorMessage || "")
-                  )
-                );
+              scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(
+                      escapeJSStringsForInstructionScripts(errorMessage || "")
+                    )
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData3),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(escapeTextForBrowser(errorMessage || ""))
+                  ));
             if (errorStack || errorComponentStack)
-              writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-                writeChunk(
-                  renderState$jscomp$0,
-                  stringToChunk(
-                    escapeJSStringsForInstructionScripts(errorStack || "")
-                  )
-                );
+              scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(
+                      escapeJSStringsForInstructionScripts(errorStack || "")
+                    )
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData4),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(escapeTextForBrowser(errorStack || ""))
+                  ));
             errorComponentStack &&
-              (writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-              writeChunk(
-                renderState$jscomp$0,
-                stringToChunk(
-                  escapeJSStringsForInstructionScripts(errorComponentStack)
-                )
-              ));
-            var JSCompiler_inline_result = writeChunkAndReturn(
-              renderState$jscomp$0,
-              clientRenderScriptEnd
-            );
+              (scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(
+                      escapeJSStringsForInstructionScripts(errorComponentStack)
+                    )
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData5),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(escapeTextForBrowser(errorComponentStack))
+                  )));
+            var JSCompiler_inline_result = scriptFormat
+              ? writeChunkAndReturn(renderState$jscomp$0, clientRenderScriptEnd)
+              : writeChunkAndReturn(renderState$jscomp$0, clientRenderDataEnd);
             if (!JSCompiler_inline_result) {
               request.destination = null;
               i++;
@@ -7457,9 +8068,10 @@
         0 === request.clientRenderedBoundaries.length &&
         0 === request.completedBoundaries.length
           ? ((request.flushScheduled = !1),
-            (i = request.resumableState),
-            i.hasBody && writeChunk(destination, endChunkForTag("body")),
-            i.hasHtml && writeChunk(destination, endChunkForTag("html")),
+            null === request.trackedPostpones &&
+              ((i = request.resumableState),
+              i.hasBody && writeChunk(destination, endChunkForTag("body")),
+              i.hasHtml && writeChunk(destination, endChunkForTag("html"))),
             completeWriting(destination),
             0 !== request.abortableTasks.size &&
               console.error(
@@ -7503,7 +8115,9 @@
         try {
           flushCompletedQueues(request, destination);
         } catch (error) {
-          logRecoverableError(request, error, {}), fatalError(request, error);
+          (destination = {}),
+            logRecoverableError(request, error, destination, null),
+            fatalError(request, error, destination, null);
         }
       }
     }
@@ -7529,16 +8143,69 @@
         null !== request.destination &&
           flushCompletedQueues(request, request.destination);
       } catch (error$4) {
-        logRecoverableError(request, error$4, {}), fatalError(request, error$4);
+        (reason = {}),
+          logRecoverableError(request, error$4, reason, null),
+          fatalError(request, error$4, reason, null);
       }
     }
+    function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+      if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+      else {
+        var workingMap = trackedPostpones.workingMap,
+          parentNode = workingMap.get(parentKeyPath);
+        void 0 === parentNode &&
+          ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+          workingMap.set(parentKeyPath, parentNode),
+          addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+        parentNode[2].push(node);
+      }
+    }
+    function getPostponedState(request) {
+      var trackedPostpones = request.trackedPostpones;
+      if (
+        null === trackedPostpones ||
+        (0 === trackedPostpones.rootNodes.length &&
+          null === trackedPostpones.rootSlots)
+      )
+        return (request.trackedPostpones = null);
+      if (
+        null !== request.completedRootSegment &&
+        request.completedRootSegment.status === POSTPONED
+      ) {
+        var resumableState = request.resumableState,
+          renderState = request.renderState;
+        resumableState.nextFormID = 0;
+        resumableState.hasBody = !1;
+        resumableState.hasHtml = !1;
+        resumableState.unknownResources = { font: renderState.resets.font };
+        resumableState.dnsResources = renderState.resets.dns;
+        resumableState.connectResources = renderState.resets.connect;
+        resumableState.imageResources = renderState.resets.image;
+        resumableState.styleResources = renderState.resets.style;
+        resumableState.scriptResources = {};
+        resumableState.moduleUnknownResources = {};
+        resumableState.moduleScriptResources = {};
+      } else
+        (resumableState = request.resumableState),
+          (resumableState.bootstrapScriptContent = void 0),
+          (resumableState.bootstrapScripts = void 0),
+          (resumableState.bootstrapModules = void 0);
+      return {
+        nextSegmentId: request.nextSegmentId,
+        rootFormatContext: request.rootFormatContext,
+        progressiveChunkSize: request.progressiveChunkSize,
+        resumableState: request.resumableState,
+        replayNodes: trackedPostpones.rootNodes,
+        replaySlots: trackedPostpones.rootSlots
+      };
+    }
     function ensureCorrectIsomorphicReactVersion() {
       var isomorphicReactPackageVersion = React.version;
-      if ("19.1.0-canary-c492f975-20250128" !== isomorphicReactPackageVersion)
+      if ("19.1.0-experimental-b3a95caf-20250113" !== isomorphicReactPackageVersion)
         throw Error(
           'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
             (isomorphicReactPackageVersion +
-              "\n  - react-dom:  19.1.0-canary-c492f975-20250128\nLearn more: https://react.dev/warnings/version-mismatch")
+              "\n  - react-dom:  19.1.0-experimental-b3a95caf-20250113\nLearn more: https://react.dev/warnings/version-mismatch")
         );
     }
     var React = require("react"),
@@ -7559,9 +8226,10 @@
       REACT_SCOPE_TYPE = Symbol.for("react.scope"),
       REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
       REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-      REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+      REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
       REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
       MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+      ASYNC_ITERATOR = Symbol.asyncIterator,
       isArrayImpl = Array.isArray,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
@@ -8621,7 +9289,8 @@
         } else previousDispatcher.M(src, options);
       }
     };
-    var NothingSent = 0,
+    var ScriptStreamingFormat = 0,
+      NothingSent = 0,
       SentCompleteSegmentFunction = 1,
       SentCompleteBoundaryFunction = 2,
       SentClientRenderFunction = 4,
@@ -8629,8 +9298,8 @@
       EXISTS = null,
       PRELOAD_NO_CREDS = [];
     Object.freeze(PRELOAD_NO_CREDS);
-    stringToPrecomputedChunk('"></template>');
-    var startInlineScript = stringToPrecomputedChunk("<script>"),
+    var dataElementQuotedEnd = stringToPrecomputedChunk('"></template>'),
+      startInlineScript = stringToPrecomputedChunk("<script>"),
       endInlineScript = stringToPrecomputedChunk("\x3c/script>"),
       startScriptSrc = stringToPrecomputedChunk('<script src="'),
       startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'),
@@ -8647,13 +9316,12 @@
     var ROOT_HTML_MODE = 0,
       HTML_HTML_MODE = 1,
       HTML_MODE = 2,
-      HTML_HEAD_MODE = 3,
-      SVG_MODE = 4,
-      MATHML_MODE = 5,
-      HTML_TABLE_MODE = 6,
-      HTML_TABLE_BODY_MODE = 7,
-      HTML_TABLE_ROW_MODE = 8,
-      HTML_COLGROUP_MODE = 9,
+      SVG_MODE = 3,
+      MATHML_MODE = 4,
+      HTML_TABLE_MODE = 5,
+      HTML_TABLE_BODY_MODE = 6,
+      HTML_TABLE_ROW_MODE = 7,
+      HTML_COLGROUP_MODE = 8,
       textSeparator = stringToPrecomputedChunk("\x3c!-- --\x3e"),
       styleNameCache = new Map(),
       styleAttributeStart = stringToPrecomputedChunk(' style="'),
@@ -8753,10 +9421,13 @@
       ),
       completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'),
       completeSegmentScript2 = stringToPrecomputedChunk('","'),
-      completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>');
-    stringToPrecomputedChunk('<template data-rsi="" data-sid="');
-    stringToPrecomputedChunk('" data-pid="');
-    var completeBoundaryScript1Full = stringToPrecomputedChunk(
+      completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>'),
+      completeSegmentData1 = stringToPrecomputedChunk(
+        '<template data-rsi="" data-sid="'
+      ),
+      completeSegmentData2 = stringToPrecomputedChunk('" data-pid="'),
+      completeSegmentDataEnd = dataElementQuotedEnd,
+      completeBoundaryScript1Full = stringToPrecomputedChunk(
         '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
       ),
       completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'),
@@ -8771,24 +9442,32 @@
       completeBoundaryScript2 = stringToPrecomputedChunk('","'),
       completeBoundaryScript3a = stringToPrecomputedChunk('",'),
       completeBoundaryScript3b = stringToPrecomputedChunk('"'),
-      completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-    stringToPrecomputedChunk('<template data-rci="" data-bid="');
-    stringToPrecomputedChunk('<template data-rri="" data-bid="');
-    stringToPrecomputedChunk('" data-sid="');
-    stringToPrecomputedChunk('" data-sty="');
-    var clientRenderScript1Full = stringToPrecomputedChunk(
+      completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+      completeBoundaryData1 = stringToPrecomputedChunk(
+        '<template data-rci="" data-bid="'
+      ),
+      completeBoundaryWithStylesData1 = stringToPrecomputedChunk(
+        '<template data-rri="" data-bid="'
+      ),
+      completeBoundaryData2 = stringToPrecomputedChunk('" data-sid="'),
+      completeBoundaryData3a = stringToPrecomputedChunk('" data-sty="'),
+      completeBoundaryDataEnd = dataElementQuotedEnd,
+      clientRenderScript1Full = stringToPrecomputedChunk(
         '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
       ),
       clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'),
       clientRenderScript1A = stringToPrecomputedChunk('"'),
       clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","),
-      clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-    stringToPrecomputedChunk('<template data-rxi="" data-bid="');
-    stringToPrecomputedChunk('" data-dgst="');
-    stringToPrecomputedChunk('" data-msg="');
-    stringToPrecomputedChunk('" data-stck="');
-    stringToPrecomputedChunk('" data-cstck="');
-    var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g,
+      clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+      clientRenderData1 = stringToPrecomputedChunk(
+        '<template data-rxi="" data-bid="'
+      ),
+      clientRenderData2 = stringToPrecomputedChunk('" data-dgst="'),
+      clientRenderData3 = stringToPrecomputedChunk('" data-msg="'),
+      clientRenderData4 = stringToPrecomputedChunk('" data-stck="'),
+      clientRenderData5 = stringToPrecomputedChunk('" data-cstck="'),
+      clientRenderDataEnd = dataElementQuotedEnd,
+      regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g,
       regexForJSStringsInScripts = /[&><\u2028\u2029]/g,
       lateStyleTagResourceOpen1 = stringToPrecomputedChunk(
         '<style media="not all" data-precedence="'
@@ -8974,13 +9653,8 @@
           resolveCurrentlyRenderingComponent();
           return NotPending;
         },
-        useMemoCache: function (size) {
-          for (var data = Array(size), i = 0; i < size; i++)
-            data[i] = REACT_MEMO_CACHE_SENTINEL;
-          return data;
-        },
-        useCacheRefresh: function () {
-          return unsupportedRefresh;
+        useEffectEvent: function () {
+          return throwOnUseEffectEventCall;
         }
       },
       currentResumableState = null,
@@ -9077,22 +9751,24 @@
             options ? options.progressiveChunkSize : void 0,
             options ? options.onError : void 0,
             function () {
-              var result = {
-                prelude: new ReadableStream(
-                  {
-                    type: "bytes",
-                    pull: function (controller) {
-                      startFlowing(request, controller);
-                    },
-                    cancel: function (reason) {
-                      request.destination = null;
-                      abort(request, reason);
-                    }
+              var stream = new ReadableStream(
+                {
+                  type: "bytes",
+                  pull: function (controller) {
+                    startFlowing(request, controller);
                   },
-                  { highWaterMark: 0 }
-                )
+                  cancel: function (reason) {
+                    request.destination = null;
+                    abort(request, reason);
+                  }
+                },
+                { highWaterMark: 0 }
+              );
+              stream = {
+                postponed: getPostponedState(request),
+                prelude: stream
               };
-              resolve(result);
+              resolve(stream);
             },
             void 0,
             void 0,
@@ -9188,5 +9864,114 @@
         startWork(request);
       });
     };
-    exports.version = "19.1.0-canary-c492f975-20250128";
+    exports.resume = function (children, postponedState, options) {
+      return new Promise(function (resolve, reject) {
+        var onFatalError,
+          onAllReady,
+          allReady = new Promise(function (res, rej) {
+            onAllReady = res;
+            onFatalError = rej;
+          }),
+          request = resumeRequest(
+            children,
+            postponedState,
+            createRenderState(
+              postponedState.resumableState,
+              options ? options.nonce : void 0,
+              void 0,
+              void 0,
+              void 0,
+              void 0
+            ),
+            options ? options.onError : void 0,
+            onAllReady,
+            function () {
+              var stream = new ReadableStream(
+                {
+                  type: "bytes",
+                  pull: function (controller) {
+                    startFlowing(request, controller);
+                  },
+                  cancel: function (reason) {
+                    request.destination = null;
+                    abort(request, reason);
+                  }
+                },
+                { highWaterMark: 0 }
+              );
+              stream.allReady = allReady;
+              resolve(stream);
+            },
+            function (error) {
+              allReady.catch(function () {});
+              reject(error);
+            },
+            onFatalError,
+            options ? options.onPostpone : void 0
+          );
+        if (options && options.signal) {
+          var signal = options.signal;
+          if (signal.aborted) abort(request, signal.reason);
+          else {
+            var listener = function () {
+              abort(request, signal.reason);
+              signal.removeEventListener("abort", listener);
+            };
+            signal.addEventListener("abort", listener);
+          }
+        }
+        startWork(request);
+      });
+    };
+    exports.resumeAndPrerender = function (children, postponedState, options) {
+      return new Promise(function (resolve, reject) {
+        var request = resumeAndPrerenderRequest(
+          children,
+          postponedState,
+          createRenderState(
+            postponedState.resumableState,
+            options ? options.nonce : void 0,
+            void 0,
+            void 0,
+            void 0,
+            void 0
+          ),
+          options ? options.onError : void 0,
+          function () {
+            var stream = new ReadableStream(
+              {
+                type: "bytes",
+                pull: function (controller) {
+                  startFlowing(request, controller);
+                },
+                cancel: function (reason) {
+                  request.destination = null;
+                  abort(request, reason);
+                }
+              },
+              { highWaterMark: 0 }
+            );
+            stream = { postponed: getPostponedState(request), prelude: stream };
+            resolve(stream);
+          },
+          void 0,
+          void 0,
+          reject,
+          options ? options.onPostpone : void 0
+        );
+        if (options && options.signal) {
+          var signal = options.signal;
+          if (signal.aborted) abort(request, signal.reason);
+          else {
+            var listener = function () {
+              abort(request, signal.reason);
+              signal.removeEventListener("abort", listener);
+            };
+            signal.addEventListener("abort", listener);
+          }
+        }
+        startWork(request);
+      });
+    };
+    exports.version = "19.1.0-experimental-b3a95caf-20250113";
   })();
diff --git a/node_modules/react-dom/cjs/react-dom-server.browser.production.js b/node_modules/react-dom/cjs/react-dom-server.browser.production.js
index 71f8535..37204c6 100644
--- a/node_modules/react-dom/cjs/react-dom-server.browser.production.js
+++ b/node_modules/react-dom/cjs/react-dom-server.browser.production.js
@@ -66,9 +66,10 @@ var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
   REACT_SCOPE_TYPE = Symbol.for("react.scope"),
   REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
   REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
   REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
   MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+  ASYNC_ITERATOR = Symbol.asyncIterator,
   isArrayImpl = Array.isArray;
 function murmurhash3_32_gc(key, seed) {
   var remainder = key.length & 3;
@@ -370,9 +371,9 @@ ReactDOMSharedInternals.d = {
   S: preinitStyle,
   M: preinitModuleScript
 };
-var PRELOAD_NO_CREDS = [];
-stringToPrecomputedChunk('"></template>');
-var startInlineScript = stringToPrecomputedChunk("<script>"),
+var PRELOAD_NO_CREDS = [],
+  dataElementQuotedEnd = stringToPrecomputedChunk('"></template>'),
+  startInlineScript = stringToPrecomputedChunk("<script>"),
   endInlineScript = stringToPrecomputedChunk("\x3c/script>"),
   startScriptSrc = stringToPrecomputedChunk('<script src="'),
   startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'),
@@ -402,28 +403,48 @@ function createRenderState(
         : stringToPrecomputedChunk(
             '<script nonce="' + escapeTextForBrowser(nonce) + '">'
           ),
-    idPrefix = resumableState.idPrefix;
-  externalRuntimeConfig = [];
-  var bootstrapScriptContent = resumableState.bootstrapScriptContent,
+    idPrefix = resumableState.idPrefix,
+    bootstrapChunks = [],
+    externalRuntimeScript = null,
+    bootstrapScriptContent = resumableState.bootstrapScriptContent,
     bootstrapScripts = resumableState.bootstrapScripts,
     bootstrapModules = resumableState.bootstrapModules;
   void 0 !== bootstrapScriptContent &&
-    externalRuntimeConfig.push(
+    bootstrapChunks.push(
       inlineScriptWithNonce,
       stringToChunk(
         ("" + bootstrapScriptContent).replace(scriptRegex, scriptReplacer)
       ),
       endInlineScript
     );
-  bootstrapScriptContent = [];
+  void 0 !== externalRuntimeConfig &&
+    ("string" === typeof externalRuntimeConfig
+      ? ((externalRuntimeScript = { src: externalRuntimeConfig, chunks: [] }),
+        pushScriptImpl(externalRuntimeScript.chunks, {
+          src: externalRuntimeConfig,
+          async: !0,
+          integrity: void 0,
+          nonce: nonce
+        }))
+      : ((externalRuntimeScript = {
+          src: externalRuntimeConfig.src,
+          chunks: []
+        }),
+        pushScriptImpl(externalRuntimeScript.chunks, {
+          src: externalRuntimeConfig.src,
+          async: !0,
+          integrity: externalRuntimeConfig.integrity,
+          nonce: nonce
+        })));
+  externalRuntimeConfig = [];
   void 0 !== importMap &&
-    (bootstrapScriptContent.push(importMapScriptStart),
-    bootstrapScriptContent.push(
+    (externalRuntimeConfig.push(importMapScriptStart),
+    externalRuntimeConfig.push(
       stringToChunk(
         ("" + JSON.stringify(importMap)).replace(scriptRegex, scriptReplacer)
       )
     ),
-    bootstrapScriptContent.push(importMapScriptEnd));
+    externalRuntimeConfig.push(importMapScriptEnd));
   importMap = onHeaders
     ? {
         preconnects: "",
@@ -438,10 +459,11 @@ function createRenderState(
     segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
     boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
     startInlineScript: inlineScriptWithNonce,
-    preamble: createPreambleState(),
-    externalRuntimeScript: null,
-    bootstrapChunks: externalRuntimeConfig,
-    importMapChunks: bootstrapScriptContent,
+    htmlChunks: null,
+    headChunks: null,
+    externalRuntimeScript: externalRuntimeScript,
+    bootstrapChunks: bootstrapChunks,
+    importMapChunks: externalRuntimeConfig,
     onHeaders: onHeaders,
     headers: importMap,
     resets: {
@@ -472,110 +494,115 @@ function createRenderState(
     stylesToHoist: !1
   };
   if (void 0 !== bootstrapScripts)
-    for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
-      var scriptConfig = bootstrapScripts[importMap];
-      idPrefix = inlineScriptWithNonce = void 0;
-      bootstrapScriptContent = {
-        rel: "preload",
-        as: "script",
-        fetchPriority: "low",
-        nonce: nonce
-      };
-      "string" === typeof scriptConfig
-        ? (bootstrapScriptContent.href = maxHeadersLength = scriptConfig)
-        : ((bootstrapScriptContent.href = maxHeadersLength = scriptConfig.src),
-          (bootstrapScriptContent.integrity = idPrefix =
-            "string" === typeof scriptConfig.integrity
-              ? scriptConfig.integrity
-              : void 0),
-          (bootstrapScriptContent.crossOrigin = inlineScriptWithNonce =
-            "string" === typeof scriptConfig || null == scriptConfig.crossOrigin
-              ? void 0
-              : "use-credentials" === scriptConfig.crossOrigin
-                ? "use-credentials"
-                : ""));
-      scriptConfig = resumableState;
-      var href = maxHeadersLength;
-      scriptConfig.scriptResources[href] = null;
-      scriptConfig.moduleScriptResources[href] = null;
-      scriptConfig = [];
-      pushLinkImpl(scriptConfig, bootstrapScriptContent);
-      onHeaders.bootstrapScripts.add(scriptConfig);
-      externalRuntimeConfig.push(
-        startScriptSrc,
-        stringToChunk(escapeTextForBrowser(maxHeadersLength))
-      );
-      nonce &&
-        externalRuntimeConfig.push(
-          scriptNonce,
-          stringToChunk(escapeTextForBrowser(nonce))
-        );
-      "string" === typeof idPrefix &&
-        externalRuntimeConfig.push(
-          scriptIntegirty,
+    for (
+      inlineScriptWithNonce = 0;
+      inlineScriptWithNonce < bootstrapScripts.length;
+      inlineScriptWithNonce++
+    )
+      (externalRuntimeConfig = bootstrapScripts[inlineScriptWithNonce]),
+        (importMap = externalRuntimeScript = void 0),
+        (maxHeadersLength = {
+          rel: "preload",
+          as: "script",
+          fetchPriority: "low",
+          nonce: nonce
+        }),
+        "string" === typeof externalRuntimeConfig
+          ? (maxHeadersLength.href = idPrefix = externalRuntimeConfig)
+          : ((maxHeadersLength.href = idPrefix = externalRuntimeConfig.src),
+            (maxHeadersLength.integrity = importMap =
+              "string" === typeof externalRuntimeConfig.integrity
+                ? externalRuntimeConfig.integrity
+                : void 0),
+            (maxHeadersLength.crossOrigin = externalRuntimeScript =
+              "string" === typeof externalRuntimeConfig ||
+              null == externalRuntimeConfig.crossOrigin
+                ? void 0
+                : "use-credentials" === externalRuntimeConfig.crossOrigin
+                  ? "use-credentials"
+                  : "")),
+        (externalRuntimeConfig = resumableState),
+        (bootstrapScriptContent = idPrefix),
+        (externalRuntimeConfig.scriptResources[bootstrapScriptContent] = null),
+        (externalRuntimeConfig.moduleScriptResources[bootstrapScriptContent] =
+          null),
+        (externalRuntimeConfig = []),
+        pushLinkImpl(externalRuntimeConfig, maxHeadersLength),
+        onHeaders.bootstrapScripts.add(externalRuntimeConfig),
+        bootstrapChunks.push(
+          startScriptSrc,
           stringToChunk(escapeTextForBrowser(idPrefix))
-        );
-      "string" === typeof inlineScriptWithNonce &&
-        externalRuntimeConfig.push(
-          scriptCrossOrigin,
-          stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
-        );
-      externalRuntimeConfig.push(endAsyncScript);
-    }
+        ),
+        nonce &&
+          bootstrapChunks.push(
+            scriptNonce,
+            stringToChunk(escapeTextForBrowser(nonce))
+          ),
+        "string" === typeof importMap &&
+          bootstrapChunks.push(
+            scriptIntegirty,
+            stringToChunk(escapeTextForBrowser(importMap))
+          ),
+        "string" === typeof externalRuntimeScript &&
+          bootstrapChunks.push(
+            scriptCrossOrigin,
+            stringToChunk(escapeTextForBrowser(externalRuntimeScript))
+          ),
+        bootstrapChunks.push(endAsyncScript);
   if (void 0 !== bootstrapModules)
     for (
       bootstrapScripts = 0;
       bootstrapScripts < bootstrapModules.length;
       bootstrapScripts++
     )
-      (bootstrapScriptContent = bootstrapModules[bootstrapScripts]),
-        (inlineScriptWithNonce = maxHeadersLength = void 0),
-        (idPrefix = {
+      (maxHeadersLength = bootstrapModules[bootstrapScripts]),
+        (externalRuntimeScript = idPrefix = void 0),
+        (importMap = {
           rel: "modulepreload",
           fetchPriority: "low",
           nonce: nonce
         }),
-        "string" === typeof bootstrapScriptContent
-          ? (idPrefix.href = importMap = bootstrapScriptContent)
-          : ((idPrefix.href = importMap = bootstrapScriptContent.src),
-            (idPrefix.integrity = inlineScriptWithNonce =
-              "string" === typeof bootstrapScriptContent.integrity
-                ? bootstrapScriptContent.integrity
+        "string" === typeof maxHeadersLength
+          ? (importMap.href = inlineScriptWithNonce = maxHeadersLength)
+          : ((importMap.href = inlineScriptWithNonce = maxHeadersLength.src),
+            (importMap.integrity = externalRuntimeScript =
+              "string" === typeof maxHeadersLength.integrity
+                ? maxHeadersLength.integrity
                 : void 0),
-            (idPrefix.crossOrigin = maxHeadersLength =
-              "string" === typeof bootstrapScriptContent ||
-              null == bootstrapScriptContent.crossOrigin
+            (importMap.crossOrigin = idPrefix =
+              "string" === typeof maxHeadersLength ||
+              null == maxHeadersLength.crossOrigin
                 ? void 0
-                : "use-credentials" === bootstrapScriptContent.crossOrigin
+                : "use-credentials" === maxHeadersLength.crossOrigin
                   ? "use-credentials"
                   : "")),
-        (bootstrapScriptContent = resumableState),
-        (scriptConfig = importMap),
-        (bootstrapScriptContent.scriptResources[scriptConfig] = null),
-        (bootstrapScriptContent.moduleScriptResources[scriptConfig] = null),
-        (bootstrapScriptContent = []),
-        pushLinkImpl(bootstrapScriptContent, idPrefix),
-        onHeaders.bootstrapScripts.add(bootstrapScriptContent),
-        externalRuntimeConfig.push(
+        (maxHeadersLength = resumableState),
+        (externalRuntimeConfig = inlineScriptWithNonce),
+        (maxHeadersLength.scriptResources[externalRuntimeConfig] = null),
+        (maxHeadersLength.moduleScriptResources[externalRuntimeConfig] = null),
+        (maxHeadersLength = []),
+        pushLinkImpl(maxHeadersLength, importMap),
+        onHeaders.bootstrapScripts.add(maxHeadersLength),
+        bootstrapChunks.push(
           startModuleSrc,
-          stringToChunk(escapeTextForBrowser(importMap))
+          stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
         ),
         nonce &&
-          externalRuntimeConfig.push(
+          bootstrapChunks.push(
             scriptNonce,
             stringToChunk(escapeTextForBrowser(nonce))
           ),
-        "string" === typeof inlineScriptWithNonce &&
-          externalRuntimeConfig.push(
+        "string" === typeof externalRuntimeScript &&
+          bootstrapChunks.push(
             scriptIntegirty,
-            stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
+            stringToChunk(escapeTextForBrowser(externalRuntimeScript))
           ),
-        "string" === typeof maxHeadersLength &&
-          externalRuntimeConfig.push(
+        "string" === typeof idPrefix &&
+          bootstrapChunks.push(
             scriptCrossOrigin,
-            stringToChunk(escapeTextForBrowser(maxHeadersLength))
+            stringToChunk(escapeTextForBrowser(idPrefix))
           ),
-        externalRuntimeConfig.push(endAsyncScript);
+        bootstrapChunks.push(endAsyncScript);
   return onHeaders;
 }
 function createResumableState(
@@ -585,10 +612,12 @@ function createResumableState(
   bootstrapScripts,
   bootstrapModules
 ) {
+  var streamingFormat = 0;
+  void 0 !== externalRuntimeConfig && (streamingFormat = 1);
   return {
     idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
     nextFormID: 0,
-    streamingFormat: 0,
+    streamingFormat: streamingFormat,
     bootstrapScriptContent: bootstrapScriptContent,
     bootstrapScripts: bootstrapScripts,
     bootstrapModules: bootstrapModules,
@@ -605,9 +634,6 @@ function createResumableState(
     moduleScriptResources: {}
   };
 }
-function createPreambleState() {
-  return { htmlChunks: null, headChunks: null, bodyChunks: null };
-}
 function createFormatContext(insertionMode, selectedValue, tagScope) {
   return {
     insertionMode: insertionMode,
@@ -618,9 +644,9 @@ function createFormatContext(insertionMode, selectedValue, tagScope) {
 function createRootFormatContext(namespaceURI) {
   return createFormatContext(
     "http://www.w3.org/2000/svg" === namespaceURI
-      ? 4
+      ? 3
       : "http://www.w3.org/1998/Math/MathML" === namespaceURI
-        ? 5
+        ? 4
         : 0,
     null,
     0
@@ -637,34 +663,33 @@ function getChildFormatContext(parentContext, type, props) {
         parentContext.tagScope
       );
     case "svg":
-      return createFormatContext(4, null, parentContext.tagScope);
+      return createFormatContext(3, null, parentContext.tagScope);
     case "picture":
       return createFormatContext(2, null, parentContext.tagScope | 2);
     case "math":
-      return createFormatContext(5, null, parentContext.tagScope);
+      return createFormatContext(4, null, parentContext.tagScope);
     case "foreignObject":
       return createFormatContext(2, null, parentContext.tagScope);
     case "table":
-      return createFormatContext(6, null, parentContext.tagScope);
+      return createFormatContext(5, null, parentContext.tagScope);
     case "thead":
     case "tbody":
     case "tfoot":
-      return createFormatContext(7, null, parentContext.tagScope);
+      return createFormatContext(6, null, parentContext.tagScope);
     case "colgroup":
-      return createFormatContext(9, null, parentContext.tagScope);
-    case "tr":
       return createFormatContext(8, null, parentContext.tagScope);
-    case "head":
-      if (2 > parentContext.insertionMode)
-        return createFormatContext(3, null, parentContext.tagScope);
-      break;
-    case "html":
-      if (0 === parentContext.insertionMode)
-        return createFormatContext(1, null, parentContext.tagScope);
+    case "tr":
+      return createFormatContext(7, null, parentContext.tagScope);
   }
-  return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode
+  return 5 <= parentContext.insertionMode
     ? createFormatContext(2, null, parentContext.tagScope)
-    : parentContext;
+    : 0 === parentContext.insertionMode
+      ? "html" === type
+        ? createFormatContext(1, null, parentContext.tagScope)
+        : createFormatContext(2, null, parentContext.tagScope)
+      : 1 === parentContext.insertionMode
+        ? createFormatContext(2, null, parentContext.tagScope)
+        : parentContext;
 }
 var textSeparator = stringToPrecomputedChunk("\x3c!-- --\x3e");
 function pushTextInstance(target, text, renderState, textEmbedded) {
@@ -1062,7 +1087,8 @@ var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""'),
     'addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error(\'React form unexpectedly submitted.\')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});'
   );
 function injectFormReplayingRuntime(resumableState, renderState) {
-  0 === (resumableState.instructions & 16) &&
+  0 !== (resumableState.instructions & 16) ||
+    renderState.externalRuntimeScript ||
     ((resumableState.instructions |= 16),
     renderState.bootstrapChunks.unshift(
       renderState.startInlineScript,
@@ -1219,7 +1245,6 @@ function pushStartInstance(
   props,
   resumableState,
   renderState,
-  preambleState,
   hoistableState,
   formatContext,
   textEmbedded,
@@ -1698,7 +1723,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$2;
     case "title":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1717,7 +1742,7 @@ function pushStartInstance(
         href = props.href,
         precedence = props.precedence;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof rel ||
@@ -1799,7 +1824,7 @@ function pushStartInstance(
         "symbol" === typeof asyncProp ||
         props.onLoad ||
         props.onError ||
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1840,7 +1865,7 @@ function pushStartInstance(
       var precedence$jscomp$0 = props.precedence,
         href$jscomp$0 = props.href;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof precedence$jscomp$0 ||
@@ -1949,7 +1974,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$6;
     case "meta":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -2122,13 +2147,10 @@ function pushStartInstance(
     case "missing-glyph":
       break;
     case "head":
-      if (2 > formatContext.insertionMode) {
-        var preamble = preambleState || renderState.preamble;
-        if (preamble.headChunks)
-          throw Error(formatProdErrorMessage(545, "`<head>`"));
-        preamble.headChunks = [];
+      if (2 > formatContext.insertionMode && null === renderState.headChunks) {
+        renderState.headChunks = [];
         var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-          preamble.headChunks,
+          renderState.headChunks,
           props,
           "head"
         );
@@ -2139,42 +2161,24 @@ function pushStartInstance(
           "head"
         );
       return JSCompiler_inline_result$jscomp$9;
-    case "body":
-      if (2 > formatContext.insertionMode) {
-        var preamble$jscomp$0 = preambleState || renderState.preamble;
-        if (preamble$jscomp$0.bodyChunks)
-          throw Error(formatProdErrorMessage(545, "`<body>`"));
-        preamble$jscomp$0.bodyChunks = [];
-        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          preamble$jscomp$0.bodyChunks,
-          props,
-          "body"
-        );
-      } else
-        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          target$jscomp$0,
-          props,
-          "body"
-        );
-      return JSCompiler_inline_result$jscomp$10;
     case "html":
-      if (0 === formatContext.insertionMode) {
-        var preamble$jscomp$1 = preambleState || renderState.preamble;
-        if (preamble$jscomp$1.htmlChunks)
-          throw Error(formatProdErrorMessage(545, "`<html>`"));
-        preamble$jscomp$1.htmlChunks = [doctypeChunk];
-        var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-          preamble$jscomp$1.htmlChunks,
+      if (
+        0 === formatContext.insertionMode &&
+        null === renderState.htmlChunks
+      ) {
+        renderState.htmlChunks = [doctypeChunk];
+        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+          renderState.htmlChunks,
           props,
           "html"
         );
       } else
-        JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
           target$jscomp$0,
           props,
           "html"
         );
-      return JSCompiler_inline_result$jscomp$11;
+      return JSCompiler_inline_result$jscomp$10;
     default:
       if (-1 !== type.indexOf("-")) {
         target$jscomp$0.push(startChunkForTag(type));
@@ -2237,15 +2241,6 @@ function endChunkForTag(tag) {
     endTagCache.set(tag, chunk));
   return chunk;
 }
-function hoistPreambleState(renderState, preambleState) {
-  renderState = renderState.preamble;
-  null === renderState.htmlChunks &&
-    (renderState.htmlChunks = preambleState.htmlChunks);
-  null === renderState.headChunks &&
-    (renderState.headChunks = preambleState.headChunks);
-  null === renderState.bodyChunks &&
-    (renderState.bodyChunks = preambleState.bodyChunks);
-}
 function writeBootstrap(destination, renderState) {
   renderState = renderState.bootstrapChunks;
   for (var i = 0; i < renderState.length - 1; i++)
@@ -2314,7 +2309,6 @@ function writeStartSegment(destination, renderState, formatContext, id) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return (
         writeChunk(destination, startSegmentHTML),
@@ -2322,42 +2316,42 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentHTML2)
       );
-    case 4:
+    case 3:
       return (
         writeChunk(destination, startSegmentSVG),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentSVG2)
       );
-    case 5:
+    case 4:
       return (
         writeChunk(destination, startSegmentMathML),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentMathML2)
       );
-    case 6:
+    case 5:
       return (
         writeChunk(destination, startSegmentTable),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentTable2)
       );
-    case 7:
+    case 6:
       return (
         writeChunk(destination, startSegmentTableBody),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentTableBody2)
       );
-    case 8:
+    case 7:
       return (
         writeChunk(destination, startSegmentTableRow),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentTableRow2)
       );
-    case 9:
+    case 8:
       return (
         writeChunk(destination, startSegmentColGroup),
         writeChunk(destination, renderState.segmentPrefix),
@@ -2372,20 +2366,19 @@ function writeEndSegment(destination, formatContext) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return writeChunkAndReturn(destination, endSegmentHTML);
-    case 4:
+    case 3:
       return writeChunkAndReturn(destination, endSegmentSVG);
-    case 5:
+    case 4:
       return writeChunkAndReturn(destination, endSegmentMathML);
-    case 6:
+    case 5:
       return writeChunkAndReturn(destination, endSegmentTable);
-    case 7:
+    case 6:
       return writeChunkAndReturn(destination, endSegmentTableBody);
-    case 8:
+    case 7:
       return writeChunkAndReturn(destination, endSegmentTableRow);
-    case 9:
+    case 8:
       return writeChunkAndReturn(destination, endSegmentColGroup);
     default:
       throw Error(formatProdErrorMessage(397));
@@ -2396,10 +2389,12 @@ var completeSegmentScript1Full = stringToPrecomputedChunk(
   ),
   completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'),
   completeSegmentScript2 = stringToPrecomputedChunk('","'),
-  completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>');
-stringToPrecomputedChunk('<template data-rsi="" data-sid="');
-stringToPrecomputedChunk('" data-pid="');
-var completeBoundaryScript1Full = stringToPrecomputedChunk(
+  completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>'),
+  completeSegmentData1 = stringToPrecomputedChunk(
+    '<template data-rsi="" data-sid="'
+  ),
+  completeSegmentData2 = stringToPrecomputedChunk('" data-pid="'),
+  completeBoundaryScript1Full = stringToPrecomputedChunk(
     '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
   ),
   completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'),
@@ -2413,20 +2408,26 @@ var completeBoundaryScript1Full = stringToPrecomputedChunk(
   completeBoundaryScript2 = stringToPrecomputedChunk('","'),
   completeBoundaryScript3a = stringToPrecomputedChunk('",'),
   completeBoundaryScript3b = stringToPrecomputedChunk('"'),
-  completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-stringToPrecomputedChunk('<template data-rci="" data-bid="');
-stringToPrecomputedChunk('<template data-rri="" data-bid="');
-stringToPrecomputedChunk('" data-sid="');
-stringToPrecomputedChunk('" data-sty="');
-var clientRenderScript1Full = stringToPrecomputedChunk(
+  completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+  completeBoundaryData1 = stringToPrecomputedChunk(
+    '<template data-rci="" data-bid="'
+  ),
+  completeBoundaryWithStylesData1 = stringToPrecomputedChunk(
+    '<template data-rri="" data-bid="'
+  ),
+  completeBoundaryData2 = stringToPrecomputedChunk('" data-sid="'),
+  completeBoundaryData3a = stringToPrecomputedChunk('" data-sty="'),
+  clientRenderScript1Full = stringToPrecomputedChunk(
     '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
   ),
   clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'),
   clientRenderScript1A = stringToPrecomputedChunk('"'),
   clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","),
-  clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-stringToPrecomputedChunk('<template data-rxi="" data-bid="');
-stringToPrecomputedChunk('" data-dgst="');
+  clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+  clientRenderData1 = stringToPrecomputedChunk(
+    '<template data-rxi="" data-bid="'
+  ),
+  clientRenderData2 = stringToPrecomputedChunk('" data-dgst="');
 stringToPrecomputedChunk('" data-msg="');
 stringToPrecomputedChunk('" data-stck="');
 stringToPrecomputedChunk('" data-cstck="');
@@ -2702,6 +2703,113 @@ function writeStyleResourceAttributeInJS(destination, name, value) {
     stringToChunk(escapeJSObjectForInstructionScripts(name))
   );
 }
+function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+  writeChunk(destination, arrayFirstOpenBracket);
+  var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
+  hoistableState.stylesheets.forEach(function (resource) {
+    if (2 !== resource.state)
+      if (3 === resource.state)
+        writeChunk(destination, nextArrayOpenBrackChunk),
+          writeChunk(
+            destination,
+            stringToChunk(
+              escapeTextForBrowser(JSON.stringify("" + resource.props.href))
+            )
+          ),
+          writeChunk(destination, arrayCloseBracket),
+          (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);
+      else {
+        writeChunk(destination, nextArrayOpenBrackChunk);
+        var precedence = resource.props["data-precedence"],
+          props = resource.props,
+          coercedHref = sanitizeURL("" + resource.props.href);
+        writeChunk(
+          destination,
+          stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref)))
+        );
+        precedence = "" + precedence;
+        writeChunk(destination, arrayInterstitial);
+        writeChunk(
+          destination,
+          stringToChunk(escapeTextForBrowser(JSON.stringify(precedence)))
+        );
+        for (var propKey in props)
+          if (
+            hasOwnProperty.call(props, propKey) &&
+            ((precedence = props[propKey]), null != precedence)
+          )
+            switch (propKey) {
+              case "href":
+              case "rel":
+              case "precedence":
+              case "data-precedence":
+                break;
+              case "children":
+              case "dangerouslySetInnerHTML":
+                throw Error(formatProdErrorMessage(399, "link"));
+              default:
+                writeStyleResourceAttributeInAttr(
+                  destination,
+                  propKey,
+                  precedence
+                );
+            }
+        writeChunk(destination, arrayCloseBracket);
+        nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
+        resource.state = 3;
+      }
+  });
+  writeChunk(destination, arrayCloseBracket);
+}
+function writeStyleResourceAttributeInAttr(destination, name, value) {
+  var attributeName = name.toLowerCase();
+  switch (typeof value) {
+    case "function":
+    case "symbol":
+      return;
+  }
+  switch (name) {
+    case "innerHTML":
+    case "dangerouslySetInnerHTML":
+    case "suppressContentEditableWarning":
+    case "suppressHydrationWarning":
+    case "style":
+    case "ref":
+      return;
+    case "className":
+      attributeName = "class";
+      name = "" + value;
+      break;
+    case "hidden":
+      if (!1 === value) return;
+      name = "";
+      break;
+    case "src":
+    case "href":
+      value = sanitizeURL(value);
+      name = "" + value;
+      break;
+    default:
+      if (
+        (2 < name.length &&
+          ("o" === name[0] || "O" === name[0]) &&
+          ("n" === name[1] || "N" === name[1])) ||
+        !isAttributeNameSafe(name)
+      )
+        return;
+      name = "" + value;
+  }
+  writeChunk(destination, arrayInterstitial);
+  writeChunk(
+    destination,
+    stringToChunk(escapeTextForBrowser(JSON.stringify(attributeName)))
+  );
+  writeChunk(destination, arrayInterstitial);
+  writeChunk(
+    destination,
+    stringToChunk(escapeTextForBrowser(JSON.stringify(name)))
+  );
+}
 function createHoistableState() {
   return { styles: new Set(), stylesheets: new Set() };
 }
@@ -3129,6 +3237,8 @@ function getComponentNameFromType(type) {
       return "Suspense";
     case REACT_SUSPENSE_LIST_TYPE:
       return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
   }
   if ("object" === typeof type)
     switch (type.$$typeof) {
@@ -3448,6 +3558,9 @@ function dispatchAction(componentIdentity, queue, action) {
       queue.next = componentIdentity;
     }
 }
+function throwOnUseEffectEventCall() {
+  throw Error(formatProdErrorMessage(440));
+}
 function unsupportedStartTransition() {
   throw Error(formatProdErrorMessage(394));
 }
@@ -3522,8 +3635,15 @@ function unwrapThenable(thenable) {
   null === thenableState && (thenableState = []);
   return trackUsedThenable(thenableState, thenable, index);
 }
-function unsupportedRefresh() {
-  throw Error(formatProdErrorMessage(393));
+function readPreviousThenableFromState() {
+  var index = thenableIndexCounter;
+  thenableIndexCounter += 1;
+  if (null !== thenableState)
+    return (
+      (index = thenableState[index]),
+      (index = void 0 === index ? void 0 : index.value),
+      index
+    );
 }
 function noop$1() {}
 var HooksDispatcher = {
@@ -3605,13 +3725,8 @@ var HooksDispatcher = {
       resolveCurrentlyRenderingComponent();
       return sharedNotPendingObject;
     },
-    useMemoCache: function (size) {
-      for (var data = Array(size), i = 0; i < size; i++)
-        data[i] = REACT_MEMO_CACHE_SENTINEL;
-      return data;
-    },
-    useCacheRefresh: function () {
-      return unsupportedRefresh;
+    useEffectEvent: function () {
+      return throwOnUseEffectEventCall;
     }
   },
   currentResumableState = null,
@@ -3808,6 +3923,8 @@ function describeComponentStackByType(type) {
       return describeBuiltInComponentFrame("SuspenseList");
     case REACT_SUSPENSE_TYPE:
       return describeBuiltInComponentFrame("Suspense");
+    case REACT_VIEW_TRANSITION_TYPE:
+      return describeBuiltInComponentFrame("ViewTransition");
   }
   return "";
 }
@@ -3867,7 +3984,7 @@ function RequestInstance(
   this.status = 10;
   this.fatalError = null;
   this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-  this.completedPreambleSegments = this.completedRootSegment = null;
+  this.completedRootSegment = null;
   this.abortableTasks = abortSet;
   this.pingedTasks = [];
   this.clientRenderedBoundaries = [];
@@ -3926,7 +4043,6 @@ function createRequest(
     null,
     renderState,
     null,
-    null,
     resumableState.abortableTasks,
     null,
     rootFormatContext,
@@ -3973,6 +4089,117 @@ function createPrerenderRequest(
   };
   return children;
 }
+function resumeRequest(
+  children,
+  postponedState,
+  renderState,
+  onError,
+  onAllReady,
+  onShellReady,
+  onShellError,
+  onFatalError,
+  onPostpone
+) {
+  renderState = new RequestInstance(
+    postponedState.resumableState,
+    renderState,
+    postponedState.rootFormatContext,
+    postponedState.progressiveChunkSize,
+    onError,
+    onAllReady,
+    onShellReady,
+    onShellError,
+    onFatalError,
+    onPostpone,
+    null
+  );
+  renderState.nextSegmentId = postponedState.nextSegmentId;
+  if ("number" === typeof postponedState.replaySlots)
+    return (
+      (onError = postponedState.replaySlots),
+      (onAllReady = createPendingSegment(
+        renderState,
+        0,
+        null,
+        postponedState.rootFormatContext,
+        !1,
+        !1
+      )),
+      (onAllReady.id = onError),
+      (onAllReady.parentFlushed = !0),
+      (children = createRenderTask(
+        renderState,
+        null,
+        children,
+        -1,
+        null,
+        onAllReady,
+        null,
+        renderState.abortableTasks,
+        null,
+        postponedState.rootFormatContext,
+        null,
+        emptyTreeContext,
+        null,
+        !1
+      )),
+      pushComponentStack(children),
+      renderState.pingedTasks.push(children),
+      renderState
+    );
+  children = createReplayTask(
+    renderState,
+    null,
+    {
+      nodes: postponedState.replayNodes,
+      slots: postponedState.replaySlots,
+      pendingTasks: 0
+    },
+    children,
+    -1,
+    null,
+    null,
+    renderState.abortableTasks,
+    null,
+    postponedState.rootFormatContext,
+    null,
+    emptyTreeContext,
+    null,
+    !1
+  );
+  pushComponentStack(children);
+  renderState.pingedTasks.push(children);
+  return renderState;
+}
+function resumeAndPrerenderRequest(
+  children,
+  postponedState,
+  renderState,
+  onError,
+  onAllReady,
+  onShellReady,
+  onShellError,
+  onFatalError,
+  onPostpone
+) {
+  children = resumeRequest(
+    children,
+    postponedState,
+    renderState,
+    onError,
+    onAllReady,
+    onShellReady,
+    onShellError,
+    onFatalError,
+    onPostpone
+  );
+  children.trackedPostpones = {
+    workingMap: new Map(),
+    rootNodes: [],
+    rootSlots: null
+  };
+  return children;
+}
 var currentRequest = null;
 function pingTask(request, task) {
   request.pingedTasks.push(task);
@@ -3986,12 +4213,7 @@ function pingTask(request, task) {
           return performWork(request);
         }));
 }
-function createSuspenseBoundary(
-  request,
-  fallbackAbortableTasks,
-  contentPreamble,
-  fallbackPreamble
-) {
+function createSuspenseBoundary(request, fallbackAbortableTasks) {
   return {
     status: 0,
     rootSegmentID: -1,
@@ -4003,8 +4225,6 @@ function createSuspenseBoundary(
     errorDigest: null,
     contentState: createHoistableState(),
     fallbackState: createHoistableState(),
-    contentPreamble: contentPreamble,
-    fallbackPreamble: fallbackPreamble,
     trackedContentKeyPath: null,
     trackedFallbackNode: null
   };
@@ -4016,7 +4236,6 @@ function createRenderTask(
   childIndex,
   blockedBoundary,
   blockedSegment,
-  blockedPreamble,
   hoistableState,
   abortSet,
   keyPath,
@@ -4039,7 +4258,6 @@ function createRenderTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: blockedSegment,
-    blockedPreamble: blockedPreamble,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -4083,7 +4301,6 @@ function createReplayTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: null,
-    blockedPreamble: null,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -4107,12 +4324,11 @@ function createPendingSegment(
 ) {
   return {
     status: 0,
-    parentFlushed: !1,
     id: -1,
     index: index,
+    parentFlushed: !1,
     chunks: [],
     children: [],
-    preambleChildren: [],
     parentFormatContext: parentFormatContext,
     boundary: boundary,
     lastPushedText: lastPushedText,
@@ -4154,6 +4370,10 @@ function getThrownInfo(node$jscomp$0) {
     });
   return errorInfo;
 }
+function logPostpone(request, reason, postponeInfo) {
+  request = request.onPostpone;
+  request(reason, postponeInfo);
+}
 function logRecoverableError(request, error, errorInfo) {
   request = request.onError;
   error = request(error, errorInfo);
@@ -4235,9 +4455,9 @@ function renderElement(request, task, keyPath, type, props, ref) {
       var defaultProps = type.defaultProps;
       if (defaultProps) {
         newProps === props && (newProps = assign({}, newProps, props));
-        for (var propName$33 in defaultProps)
-          void 0 === newProps[propName$33] &&
-            (newProps[propName$33] = defaultProps[propName$33]);
+        for (var propName$34 in defaultProps)
+          void 0 === newProps[propName$34] &&
+            (newProps[propName$34] = defaultProps[propName$34]);
       }
       props = newProps;
       newProps = emptyContextObject;
@@ -4297,16 +4517,16 @@ function renderElement(request, task, keyPath, type, props, ref) {
             defaultProps = ref ? type[0] : newProps.state;
             initialState = !0;
             for (ref = ref ? 1 : 0; ref < type.length; ref++)
-              (propName$33 = type[ref]),
-                (propName$33 =
-                  "function" === typeof propName$33
-                    ? propName$33.call(newProps, defaultProps, props, void 0)
-                    : propName$33),
-                null != propName$33 &&
+              (propName$34 = type[ref]),
+                (propName$34 =
+                  "function" === typeof propName$34
+                    ? propName$34.call(newProps, defaultProps, props, void 0)
+                    : propName$34),
+                null != propName$34 &&
                   (initialState
                     ? ((initialState = !1),
-                      (defaultProps = assign({}, defaultProps, propName$33)))
-                    : assign(defaultProps, propName$33));
+                      (defaultProps = assign({}, defaultProps, propName$34)))
+                    : assign(defaultProps, propName$34));
             newProps.state = defaultProps;
           }
         else defaultProps.queue = null;
@@ -4340,13 +4560,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
         (task.formatContext = defaultProps),
         (task.keyPath = initialState);
     else {
-      ref = pushStartInstance(
+      initialState = pushStartInstance(
         newProps.chunks,
         type,
         props,
         request.resumableState,
         request.renderState,
-        task.blockedPreamble,
         task.hoistableState,
         task.formatContext,
         newProps.lastPushedText,
@@ -4354,42 +4573,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
       );
       newProps.lastPushedText = !1;
       defaultProps = task.formatContext;
-      initialState = task.keyPath;
+      ref = task.keyPath;
+      task.formatContext = getChildFormatContext(defaultProps, type, props);
       task.keyPath = keyPath;
-      3 ===
-      (task.formatContext = getChildFormatContext(defaultProps, type, props))
-        .insertionMode
-        ? ((keyPath = createPendingSegment(
-            request,
-            0,
-            null,
-            task.formatContext,
-            !1,
-            !1
-          )),
-          newProps.preambleChildren.push(keyPath),
-          (keyPath = createRenderTask(
-            request,
-            null,
-            ref,
-            -1,
-            task.blockedBoundary,
-            keyPath,
-            task.blockedPreamble,
-            task.hoistableState,
-            request.abortableTasks,
-            task.keyPath,
-            task.formatContext,
-            task.context,
-            task.treeContext,
-            task.componentStack,
-            task.isFallback
-          )),
-          pushComponentStack(keyPath),
-          request.pingedTasks.push(keyPath))
-        : renderNode(request, task, ref, -1);
+      renderNode(request, task, initialState, -1);
       task.formatContext = defaultProps;
-      task.keyPath = initialState;
+      task.keyPath = ref;
       a: {
         task = newProps.chunks;
         request = request.resumableState;
@@ -4424,9 +4613,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
               request.hasHtml = !0;
               break a;
             }
-            break;
-          case "head":
-            if (1 >= defaultProps.insertionMode) break a;
         }
         task.push(endChunkForTag(type));
       }
@@ -4457,6 +4643,11 @@ function renderElement(request, task, keyPath, type, props, ref) {
         task.keyPath = type;
         return;
       case REACT_VIEW_TRANSITION_TYPE:
+        type = task.keyPath;
+        task.keyPath = keyPath;
+        renderNodeDestructive(request, task, props.children, -1);
+        task.keyPath = type;
+        return;
       case REACT_SCOPE_TYPE:
         throw Error(formatProdErrorMessage(343));
       case REACT_SUSPENSE_TYPE:
@@ -4471,34 +4662,25 @@ function renderElement(request, task, keyPath, type, props, ref) {
           }
         } else {
           type = task.keyPath;
-          var parentBoundary = task.blockedBoundary;
-          ref = task.blockedPreamble;
-          var parentHoistableState = task.hoistableState;
-          propName$33 = task.blockedSegment;
-          propName = props.fallback;
+          var parentBoundary = task.blockedBoundary,
+            parentHoistableState = task.hoistableState;
+          ref = task.blockedSegment;
+          propName$34 = props.fallback;
           props = props.children;
           var fallbackAbortSet = new Set();
-          var newBoundary =
-            2 > task.formatContext.insertionMode
-              ? createSuspenseBoundary(
-                  request,
-                  fallbackAbortSet,
-                  createPreambleState(),
-                  createPreambleState()
-                )
-              : createSuspenseBoundary(request, fallbackAbortSet, null, null);
+          propName = createSuspenseBoundary(request, fallbackAbortSet);
           null !== request.trackedPostpones &&
-            (newBoundary.trackedContentKeyPath = keyPath);
+            (propName.trackedContentKeyPath = keyPath);
           var boundarySegment = createPendingSegment(
             request,
-            propName$33.chunks.length,
-            newBoundary,
+            ref.chunks.length,
+            propName,
             task.formatContext,
             !1,
             !1
           );
-          propName$33.children.push(boundarySegment);
-          propName$33.lastPushedText = !1;
+          ref.children.push(boundarySegment);
+          ref.lastPushedText = !1;
           var contentRootSegment = createPendingSegment(
             request,
             0,
@@ -4512,13 +4694,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
             newProps = [keyPath[0], "Suspense Fallback", keyPath[2]];
             defaultProps = [newProps[1], newProps[2], [], null];
             request.trackedPostpones.workingMap.set(newProps, defaultProps);
-            newBoundary.trackedFallbackNode = defaultProps;
+            propName.trackedFallbackNode = defaultProps;
             task.blockedSegment = boundarySegment;
-            task.blockedPreamble = newBoundary.fallbackPreamble;
             task.keyPath = newProps;
             boundarySegment.status = 6;
             try {
-              renderNode(request, task, propName, -1),
+              renderNode(request, task, propName$34, -1),
                 boundarySegment.lastPushedText &&
                   boundarySegment.textEmbedded &&
                   boundarySegment.chunks.push(textSeparator),
@@ -4529,19 +4710,16 @@ function renderElement(request, task, keyPath, type, props, ref) {
                 thrownValue)
               );
             } finally {
-              (task.blockedSegment = propName$33),
-                (task.blockedPreamble = ref),
-                (task.keyPath = type);
+              (task.blockedSegment = ref), (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
               props,
               -1,
-              newBoundary,
+              propName,
               contentRootSegment,
-              newBoundary.contentPreamble,
-              newBoundary.contentState,
+              propName.contentState,
               task.abortSet,
               keyPath,
               task.formatContext,
@@ -4553,9 +4731,8 @@ function renderElement(request, task, keyPath, type, props, ref) {
             pushComponentStack(task);
             request.pingedTasks.push(task);
           } else {
-            task.blockedBoundary = newBoundary;
-            task.blockedPreamble = newBoundary.contentPreamble;
-            task.hoistableState = newBoundary.contentState;
+            task.blockedBoundary = propName;
+            task.hoistableState = propName.contentState;
             task.blockedSegment = contentRootSegment;
             task.keyPath = keyPath;
             contentRootSegment.status = 6;
@@ -4566,46 +4743,46 @@ function renderElement(request, task, keyPath, type, props, ref) {
                   contentRootSegment.textEmbedded &&
                   contentRootSegment.chunks.push(textSeparator),
                 (contentRootSegment.status = 1),
-                queueCompletedSegment(newBoundary, contentRootSegment),
-                0 === newBoundary.pendingTasks && 0 === newBoundary.status)
+                queueCompletedSegment(propName, contentRootSegment),
+                0 === propName.pendingTasks && 0 === propName.status)
               ) {
-                newBoundary.status = 1;
-                0 === request.pendingRootTasks &&
-                  task.blockedPreamble &&
-                  preparePreamble(request);
+                propName.status = 1;
                 break a;
               }
-            } catch (thrownValue$28) {
-              (newBoundary.status = 4),
+            } catch (thrownValue$29) {
+              (propName.status = 4),
                 12 === request.status
                   ? ((contentRootSegment.status = 3),
                     (newProps = request.fatalError))
                   : ((contentRootSegment.status = 4),
-                    (newProps = thrownValue$28)),
+                    (newProps = thrownValue$29)),
                 (defaultProps = getThrownInfo(task.componentStack)),
-                (initialState = logRecoverableError(
-                  request,
-                  newProps,
-                  defaultProps
-                )),
-                (newBoundary.errorDigest = initialState),
-                untrackBoundary(request, newBoundary);
+                "object" === typeof newProps &&
+                null !== newProps &&
+                newProps.$$typeof === REACT_POSTPONE_TYPE
+                  ? (logPostpone(request, newProps.message, defaultProps),
+                    (initialState = "POSTPONE"))
+                  : (initialState = logRecoverableError(
+                      request,
+                      newProps,
+                      defaultProps
+                    )),
+                (propName.errorDigest = initialState),
+                untrackBoundary(request, propName);
             } finally {
               (task.blockedBoundary = parentBoundary),
-                (task.blockedPreamble = ref),
                 (task.hoistableState = parentHoistableState),
-                (task.blockedSegment = propName$33),
+                (task.blockedSegment = ref),
                 (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
-              propName,
+              propName$34,
               -1,
               parentBoundary,
               boundarySegment,
-              newBoundary.fallbackPreamble,
-              newBoundary.fallbackState,
+              propName.fallbackState,
               fallbackAbortSet,
               [keyPath[0], "Suspense Fallback", keyPath[2]],
               task.formatContext,
@@ -4624,9 +4801,9 @@ function renderElement(request, task, keyPath, type, props, ref) {
       switch (type.$$typeof) {
         case REACT_FORWARD_REF_TYPE:
           if ("ref" in props)
-            for (newBoundary in ((newProps = {}), props))
-              "ref" !== newBoundary &&
-                (newProps[newBoundary] = props[newBoundary]);
+            for (boundarySegment in ((newProps = {}), props))
+              "ref" !== boundarySegment &&
+                (newProps[boundarySegment] = props[boundarySegment]);
           else newProps = props;
           type = renderWithHooks(
             request,
@@ -4788,16 +4965,13 @@ function retryNode(request, task) {
                         );
                       task.replay.pendingTasks--;
                       props = getThrownInfo(task.componentStack);
-                      key = task.blockedBoundary;
-                      type = x;
-                      props = logRecoverableError(request, type, props);
-                      abortRemainingReplayNodes(
+                      erroredReplay(
                         request,
-                        key,
+                        task.blockedBoundary,
+                        x,
+                        props,
                         childNodes,
-                        name,
-                        type,
-                        props
+                        name
                       );
                     }
                     task.replay = replay;
@@ -4811,9 +4985,9 @@ function retryNode(request, task) {
                         )
                       );
                     b: {
-                      replay = void 0;
-                      type = node$jscomp$0[5];
-                      ref = node$jscomp$0[2];
+                      type = void 0;
+                      ref = node$jscomp$0[5];
+                      replay = node$jscomp$0[2];
                       name = node$jscomp$0[3];
                       keyOrIndex =
                         null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
@@ -4823,30 +4997,20 @@ function retryNode(request, task) {
                         previousReplaySet = task.replay,
                         parentBoundary = task.blockedBoundary,
                         parentHoistableState = task.hoistableState,
-                        content = props.children,
-                        fallback = props.fallback,
-                        fallbackAbortSet = new Set();
-                      props =
-                        2 > task.formatContext.insertionMode
-                          ? createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              createPreambleState(),
-                              createPreambleState()
-                            )
-                          : createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              null,
-                              null
-                            );
-                      props.parentFlushed = !0;
-                      props.rootSegmentID = type;
-                      task.blockedBoundary = props;
-                      task.hoistableState = props.contentState;
+                        content = props.children;
+                      props = props.fallback;
+                      var fallbackAbortSet = new Set(),
+                        resumedBoundary = createSuspenseBoundary(
+                          request,
+                          fallbackAbortSet
+                        );
+                      resumedBoundary.parentFlushed = !0;
+                      resumedBoundary.rootSegmentID = ref;
+                      task.blockedBoundary = resumedBoundary;
+                      task.hoistableState = resumedBoundary.contentState;
                       task.keyPath = key;
                       task.replay = {
-                        nodes: ref,
+                        nodes: replay,
                         slots: name,
                         pendingTasks: 1
                       };
@@ -4858,22 +5022,32 @@ function retryNode(request, task) {
                         )
                           throw Error(formatProdErrorMessage(488));
                         task.replay.pendingTasks--;
-                        if (0 === props.pendingTasks && 0 === props.status) {
-                          props.status = 1;
-                          request.completedBoundaries.push(props);
+                        if (
+                          0 === resumedBoundary.pendingTasks &&
+                          0 === resumedBoundary.status
+                        ) {
+                          resumedBoundary.status = 1;
+                          request.completedBoundaries.push(resumedBoundary);
                           break b;
                         }
                       } catch (error) {
-                        (props.status = 4),
+                        (resumedBoundary.status = 4),
                           (childNodes = getThrownInfo(task.componentStack)),
-                          (replay = logRecoverableError(
-                            request,
-                            error,
-                            childNodes
-                          )),
-                          (props.errorDigest = replay),
+                          "object" === typeof error &&
+                          null !== error &&
+                          error.$$typeof === REACT_POSTPONE_TYPE
+                            ? (logPostpone(request, error.message, childNodes),
+                              (type = "POSTPONE"))
+                            : (type = logRecoverableError(
+                                request,
+                                error,
+                                childNodes
+                              )),
+                          (resumedBoundary.errorDigest = type),
                           task.replay.pendingTasks--,
-                          request.clientRenderedBoundaries.push(props);
+                          request.clientRenderedBoundaries.push(
+                            resumedBoundary
+                          );
                       } finally {
                         (task.blockedBoundary = parentBoundary),
                           (task.hoistableState = parentHoistableState),
@@ -4888,10 +5062,10 @@ function retryNode(request, task) {
                           slots: node$jscomp$0,
                           pendingTasks: 0
                         },
-                        fallback,
+                        props,
                         -1,
                         parentBoundary,
-                        props.fallbackState,
+                        resumedBoundary.fallbackState,
                         fallbackAbortSet,
                         [key[0], "Suspense Fallback", key[2]],
                         task.formatContext,
@@ -4940,6 +5114,31 @@ function retryNode(request, task) {
         }
         return;
       }
+      if (
+        "function" === typeof node[ASYNC_ITERATOR] &&
+        (childNodes = node[ASYNC_ITERATOR]())
+      ) {
+        props = task.thenableState;
+        task.thenableState = null;
+        thenableIndexCounter = 0;
+        thenableState = props;
+        props = [];
+        key = !1;
+        if (childNodes === node)
+          for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+            if (node.done) {
+              key = !0;
+              break;
+            }
+            props.push(node.value);
+            node = readPreviousThenableFromState();
+          }
+        if (!key)
+          for (node = unwrapThenable(childNodes.next()); !node.done; )
+            props.push(node.value), (node = unwrapThenable(childNodes.next()));
+        renderChildrenArray(request, task, props, childIndex);
+        return;
+      }
       if ("function" === typeof node.then)
         return (
           (task.thenableState = null),
@@ -4952,33 +5151,33 @@ function retryNode(request, task) {
           node._currentValue,
           childIndex
         );
-      childIndex = Object.prototype.toString.call(node);
+      request = Object.prototype.toString.call(node);
       throw Error(
         formatProdErrorMessage(
           31,
-          "[object Object]" === childIndex
+          "[object Object]" === request
             ? "object with keys {" + Object.keys(node).join(", ") + "}"
-            : childIndex
+            : request
         )
       );
     }
     if ("string" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
     else if ("number" === typeof node || "bigint" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             "" + node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
   }
 }
@@ -5013,16 +5212,13 @@ function renderChildrenArray(request, task, children, childIndex) {
             throw x;
           task.replay.pendingTasks--;
           children = getThrownInfo(task.componentStack);
-          var boundary = task.blockedBoundary,
-            error = x;
-          children = logRecoverableError(request, error, children);
-          abortRemainingReplayNodes(
+          erroredReplay(
             request,
-            boundary,
+            task.blockedBoundary,
+            x,
+            children,
             childIndex,
-            node,
-            error,
-            children
+            node
           );
         }
         task.replay = replay;
@@ -5039,14 +5235,15 @@ function renderChildrenArray(request, task, children, childIndex) {
     null !== task.replay &&
     ((j = task.replay.slots), null !== j && "object" === typeof j)
   ) {
-    for (childIndex = 0; childIndex < replayNodes; childIndex++)
-      (node = children[childIndex]),
-        (task.treeContext = pushTreeContext(replay, replayNodes, childIndex)),
-        (boundary = j[childIndex]),
-        "number" === typeof boundary
-          ? (resumeNode(request, task, boundary, node, childIndex),
-            delete j[childIndex])
-          : renderNode(request, task, node, childIndex);
+    for (childIndex = 0; childIndex < replayNodes; childIndex++) {
+      node = children[childIndex];
+      task.treeContext = pushTreeContext(replay, replayNodes, childIndex);
+      var resumeSegmentID = j[childIndex];
+      "number" === typeof resumeSegmentID
+        ? (resumeNode(request, task, resumeSegmentID, node, childIndex),
+          delete j[childIndex])
+        : renderNode(request, task, node, childIndex);
+    }
     task.treeContext = replay;
     task.keyPath = prevKeyPath;
     return;
@@ -5058,6 +5255,98 @@ function renderChildrenArray(request, task, children, childIndex) {
   task.treeContext = replay;
   task.keyPath = prevKeyPath;
 }
+function trackPostpone(request, trackedPostpones, task, segment) {
+  segment.status = 5;
+  var keyPath = task.keyPath,
+    boundary = task.blockedBoundary;
+  if (null === boundary)
+    (segment.id = request.nextSegmentId++),
+      (trackedPostpones.rootSlots = segment.id),
+      null !== request.completedRootSegment &&
+        (request.completedRootSegment.status = 5);
+  else {
+    if (null !== boundary && 0 === boundary.status) {
+      boundary.status = 5;
+      boundary.rootSegmentID = request.nextSegmentId++;
+      var boundaryKeyPath = boundary.trackedContentKeyPath;
+      if (null === boundaryKeyPath) throw Error(formatProdErrorMessage(486));
+      var fallbackReplayNode = boundary.trackedFallbackNode,
+        children = [];
+      if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+        -1 === segment.id &&
+          (segment.id = segment.parentFlushed
+            ? boundary.rootSegmentID
+            : request.nextSegmentId++);
+        segment = [
+          boundaryKeyPath[1],
+          boundaryKeyPath[2],
+          children,
+          segment.id,
+          fallbackReplayNode,
+          boundary.rootSegmentID
+        ];
+        trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+        addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+        return;
+      }
+      var boundaryNode$45 = trackedPostpones.workingMap.get(boundaryKeyPath);
+      void 0 === boundaryNode$45
+        ? ((boundaryNode$45 = [
+            boundaryKeyPath[1],
+            boundaryKeyPath[2],
+            children,
+            null,
+            fallbackReplayNode,
+            boundary.rootSegmentID
+          ]),
+          trackedPostpones.workingMap.set(boundaryKeyPath, boundaryNode$45),
+          addToReplayParent(
+            boundaryNode$45,
+            boundaryKeyPath[0],
+            trackedPostpones
+          ))
+        : ((boundaryKeyPath = boundaryNode$45),
+          (boundaryKeyPath[4] = fallbackReplayNode),
+          (boundaryKeyPath[5] = boundary.rootSegmentID));
+    }
+    -1 === segment.id &&
+      (segment.id =
+        segment.parentFlushed && null !== boundary
+          ? boundary.rootSegmentID
+          : request.nextSegmentId++);
+    if (-1 === task.childIndex)
+      null === keyPath
+        ? (trackedPostpones.rootSlots = segment.id)
+        : ((task = trackedPostpones.workingMap.get(keyPath)),
+          void 0 === task
+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+              addToReplayParent(task, keyPath[0], trackedPostpones))
+            : (task[3] = segment.id));
+    else {
+      if (null === keyPath)
+        if (((request = trackedPostpones.rootSlots), null === request))
+          request = trackedPostpones.rootSlots = {};
+        else {
+          if ("number" === typeof request)
+            throw Error(formatProdErrorMessage(491));
+        }
+      else if (
+        ((boundary = trackedPostpones.workingMap),
+        (boundaryKeyPath = boundary.get(keyPath)),
+        void 0 === boundaryKeyPath)
+      )
+        (request = {}),
+          (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+          boundary.set(keyPath, boundaryKeyPath),
+          addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+      else if (((request = boundaryKeyPath[3]), null === request))
+        request = boundaryKeyPath[3] = {};
+      else if ("number" === typeof request)
+        throw Error(formatProdErrorMessage(491));
+      request[task.childIndex] = segment.id;
+    }
+  }
+}
 function untrackBoundary(request, boundary) {
   request = request.trackedPostpones;
   null !== request &&
@@ -5104,7 +5393,6 @@ function spawnNewSuspendedRenderTask(request, task, thenableState) {
     task.childIndex,
     task.blockedBoundary,
     newSegment,
-    task.blockedPreamble,
     task.hoistableState,
     task.abortSet,
     task.keyPath,
@@ -5128,13 +5416,14 @@ function renderNode(request, task, node, childIndex) {
     } catch (thrownValue) {
       if (
         (resetHooksState(),
-        (node =
+        (childIndex =
           thrownValue === SuspenseException
             ? getSuspendedThenable()
             : thrownValue),
-        "object" === typeof node && null !== node)
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -5146,7 +5435,7 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedReplayTask(request, task, node);
           request.pingedTasks.push(node);
@@ -5165,18 +5454,19 @@ function renderNode(request, task, node, childIndex) {
       chunkLength = segment.chunks.length;
     try {
       return renderNodeDestructive(request, task, node, childIndex);
-    } catch (thrownValue$48) {
+    } catch (thrownValue$57) {
       if (
         (resetHooksState(),
         (segment.children.length = childrenLength),
         (segment.chunks.length = chunkLength),
-        (node =
-          thrownValue$48 === SuspenseException
+        (childIndex =
+          thrownValue$57 === SuspenseException
             ? getSuspendedThenable()
-            : thrownValue$48),
-        "object" === typeof node && null !== node)
+            : thrownValue$57),
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -5188,7 +5478,35 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if (
+          childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+          null !== request.trackedPostpones &&
+          null !== task.blockedBoundary
+        ) {
+          node = request.trackedPostpones;
+          segment = getThrownInfo(task.componentStack);
+          logPostpone(request, childIndex.message, segment);
+          childIndex = task.blockedSegment;
+          segment = createPendingSegment(
+            request,
+            childIndex.chunks.length,
+            null,
+            task.formatContext,
+            childIndex.lastPushedText,
+            !0
+          );
+          childIndex.children.push(segment);
+          childIndex.lastPushedText = !1;
+          trackPostpone(request, node, task, segment);
+          task.formatContext = previousFormatContext;
+          task.context = previousContext;
+          task.keyPath = previousKeyPath;
+          task.treeContext = previousTreeContext;
+          task.componentStack = previousComponentStack;
+          switchContext(previousContext);
+          return;
+        }
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedRenderTask(request, task, node);
           request.pingedTasks.push(node);
@@ -5208,7 +5526,29 @@ function renderNode(request, task, node, childIndex) {
   task.keyPath = previousKeyPath;
   task.treeContext = previousTreeContext;
   switchContext(previousContext);
-  throw node;
+  throw childIndex;
+}
+function erroredReplay(
+  request,
+  boundary,
+  error,
+  errorInfo,
+  replayNodes,
+  resumeSlots
+) {
+  "object" === typeof error &&
+  null !== error &&
+  error.$$typeof === REACT_POSTPONE_TYPE
+    ? (logPostpone(request, error.message, errorInfo), (errorInfo = "POSTPONE"))
+    : (errorInfo = logRecoverableError(request, error, errorInfo));
+  abortRemainingReplayNodes(
+    request,
+    boundary,
+    replayNodes,
+    resumeSlots,
+    error,
+    errorInfo
+  );
 }
 function abortTaskSoft(task) {
   var boundary = task.blockedBoundary;
@@ -5238,12 +5578,7 @@ function abortRemainingReplayNodes(
       node = node[5];
       var request = request$jscomp$0,
         errorDigest = errorDigest$jscomp$0,
-        resumedBoundary = createSuspenseBoundary(
-          request,
-          new Set(),
-          null,
-          null
-        );
+        resumedBoundary = createSuspenseBoundary(request, new Set());
       resumedBoundary.parentFlushed = !0;
       resumedBoundary.rootSegmentID = node;
       resumedBoundary.status = 4;
@@ -5270,44 +5605,97 @@ function abortTask(task, request, error) {
     if (6 === segment.status) return;
     segment.status = 3;
   }
-  segment = getThrownInfo(task.componentStack);
+  var errorInfo = getThrownInfo(task.componentStack);
   if (null === boundary) {
     if (13 !== request.status && 14 !== request.status) {
       boundary = task.replay;
       if (null === boundary) {
-        logRecoverableError(request, error, segment);
-        fatalError(request, error);
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? ((boundary = request.trackedPostpones),
+            null !== boundary && null !== segment
+              ? (logPostpone(request, error.message, errorInfo),
+                trackPostpone(request, boundary, task, segment),
+                finishedTask(request, null, segment))
+              : ((task = Error(formatProdErrorMessage(501, error.message))),
+                logRecoverableError(request, task, errorInfo),
+                fatalError(request, task)))
+          : null !== request.trackedPostpones && null !== segment
+            ? ((boundary = request.trackedPostpones),
+              logRecoverableError(request, error, errorInfo),
+              trackPostpone(request, boundary, task, segment),
+              finishedTask(request, null, segment))
+            : (logRecoverableError(request, error, errorInfo),
+              fatalError(request, error));
         return;
       }
       boundary.pendingTasks--;
       0 === boundary.pendingTasks &&
         0 < boundary.nodes.length &&
-        ((task = logRecoverableError(request, error, segment)),
+        ("object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? (logPostpone(request, error.message, errorInfo),
+            (errorInfo = "POSTPONE"))
+          : (errorInfo = logRecoverableError(request, error, errorInfo)),
         abortRemainingReplayNodes(
           request,
           null,
           boundary.nodes,
           boundary.slots,
           error,
-          task
+          errorInfo
         ));
       request.pendingRootTasks--;
       0 === request.pendingRootTasks && completeShell(request);
     }
-  } else
-    boundary.pendingTasks--,
-      4 !== boundary.status &&
-        ((boundary.status = 4),
-        (task = logRecoverableError(request, error, segment)),
-        (boundary.status = 4),
-        (boundary.errorDigest = task),
-        untrackBoundary(request, boundary),
-        boundary.parentFlushed &&
-          request.clientRenderedBoundaries.push(boundary)),
-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-        return abortTask(fallbackTask, request, error);
-      }),
-      boundary.fallbackAbortableTasks.clear();
+  } else {
+    boundary.pendingTasks--;
+    var trackedPostpones$60 = request.trackedPostpones;
+    if (4 !== boundary.status) {
+      if (null !== trackedPostpones$60 && null !== segment)
+        return (
+          "object" === typeof error &&
+          null !== error &&
+          error.$$typeof === REACT_POSTPONE_TYPE
+            ? logPostpone(request, error.message, errorInfo)
+            : logRecoverableError(request, error, errorInfo),
+          trackPostpone(request, trackedPostpones$60, task, segment),
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          }),
+          boundary.fallbackAbortableTasks.clear(),
+          finishedTask(request, boundary, segment)
+        );
+      boundary.status = 4;
+      if (
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+      ) {
+        logPostpone(request, error.message, errorInfo);
+        if (null !== request.trackedPostpones && null !== segment) {
+          trackPostpone(request, request.trackedPostpones, task, segment);
+          finishedTask(request, task.blockedBoundary, segment);
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          });
+          boundary.fallbackAbortableTasks.clear();
+          return;
+        }
+        errorInfo = "POSTPONE";
+      } else errorInfo = logRecoverableError(request, error, errorInfo);
+      boundary.status = 4;
+      boundary.errorDigest = errorInfo;
+      untrackBoundary(request, boundary);
+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
+    }
+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+      return abortTask(fallbackTask, request, error);
+    });
+    boundary.fallbackAbortableTasks.clear();
+  }
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
@@ -5374,7 +5762,6 @@ function safelyEmitEarlyPreloads(request, shellComplete) {
 }
 function completeShell(request) {
   null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-  null === request.trackedPostpones && preparePreamble(request);
   request.onShellError = noop;
   request = request.onShellReady;
   request();
@@ -5387,7 +5774,6 @@ function completeAll(request) {
       : null === request.completedRootSegment ||
           5 !== request.completedRootSegment.status
   );
-  preparePreamble(request);
   request = request.onAllReady;
   request();
 }
@@ -5426,11 +5812,7 @@ function finishedTask(request, boundary, segment) {
               request.completedBoundaries.push(boundary),
             1 === boundary.status &&
               (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),
-              boundary.fallbackAbortableTasks.clear(),
-              0 === request.pendingRootTasks &&
-                null === request.trackedPostpones &&
-                null !== boundary.contentPreamble &&
-                preparePreamble(request)))
+              boundary.fallbackAbortableTasks.clear()))
           : null !== segment &&
             segment.parentFlushed &&
             1 === segment.status &&
@@ -5441,23 +5823,23 @@ function finishedTask(request, boundary, segment) {
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
-function performWork(request$jscomp$2) {
-  if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
+function performWork(request$jscomp$1) {
+  if (14 !== request$jscomp$1.status && 13 !== request$jscomp$1.status) {
     var prevContext = currentActiveSnapshot,
       prevDispatcher = ReactSharedInternals.H;
     ReactSharedInternals.H = HooksDispatcher;
     var prevAsyncDispatcher = ReactSharedInternals.A;
     ReactSharedInternals.A = DefaultAsyncDispatcher;
     var prevRequest = currentRequest;
-    currentRequest = request$jscomp$2;
+    currentRequest = request$jscomp$1;
     var prevResumableState = currentResumableState;
-    currentResumableState = request$jscomp$2.resumableState;
+    currentResumableState = request$jscomp$1.resumableState;
     try {
-      var pingedTasks = request$jscomp$2.pingedTasks,
+      var pingedTasks = request$jscomp$1.pingedTasks,
         i;
       for (i = 0; i < pingedTasks.length; i++) {
         var task = pingedTasks[i],
-          request = request$jscomp$2,
+          request = request$jscomp$1,
           segment = task.blockedSegment;
         if (null === segment) {
           var request$jscomp$0 = request;
@@ -5499,27 +5881,15 @@ function performWork(request$jscomp$2) {
                 task.replay.pendingTasks--;
                 task.abortSet.delete(task);
                 var errorInfo = getThrownInfo(task.componentStack);
-                request = void 0;
-                var request$jscomp$1 = request$jscomp$0,
-                  boundary = task.blockedBoundary,
-                  error$jscomp$0 =
-                    12 === request$jscomp$0.status
-                      ? request$jscomp$0.fatalError
-                      : x,
-                  replayNodes = task.replay.nodes,
-                  resumeSlots = task.replay.slots;
-                request = logRecoverableError(
-                  request$jscomp$1,
-                  error$jscomp$0,
-                  errorInfo
-                );
-                abortRemainingReplayNodes(
-                  request$jscomp$1,
-                  boundary,
-                  replayNodes,
-                  resumeSlots,
-                  error$jscomp$0,
-                  request
+                erroredReplay(
+                  request$jscomp$0,
+                  task.blockedBoundary,
+                  12 === request$jscomp$0.status
+                    ? request$jscomp$0.fatalError
+                    : x,
+                  errorInfo,
+                  task.replay.nodes,
+                  task.replay.slots
                 );
                 request$jscomp$0.pendingRootTasks--;
                 0 === request$jscomp$0.pendingRootTasks &&
@@ -5531,78 +5901,124 @@ function performWork(request$jscomp$2) {
             } finally {
             }
           }
-        } else if (
-          ((request$jscomp$0 = void 0),
-          (request$jscomp$1 = segment),
-          0 === request$jscomp$1.status)
-        ) {
-          request$jscomp$1.status = 6;
-          switchContext(task.context);
-          var childrenLength = request$jscomp$1.children.length,
-            chunkLength = request$jscomp$1.chunks.length;
-          try {
-            retryNode(request, task),
-              request$jscomp$1.lastPushedText &&
-                request$jscomp$1.textEmbedded &&
-                request$jscomp$1.chunks.push(textSeparator),
-              task.abortSet.delete(task),
-              (request$jscomp$1.status = 1),
-              finishedTask(request, task.blockedBoundary, request$jscomp$1);
-          } catch (thrownValue) {
-            resetHooksState();
-            request$jscomp$1.children.length = childrenLength;
-            request$jscomp$1.chunks.length = chunkLength;
-            var x$jscomp$0 =
-              thrownValue === SuspenseException
-                ? getSuspendedThenable()
-                : 12 === request.status
-                  ? request.fatalError
-                  : thrownValue;
-            if (
-              "object" === typeof x$jscomp$0 &&
-              null !== x$jscomp$0 &&
-              "function" === typeof x$jscomp$0.then
-            ) {
-              request$jscomp$1.status = 0;
-              task.thenableState = getThenableStateAfterSuspending();
-              var ping$jscomp$0 = task.ping;
-              x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-            } else {
-              var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
-              task.abortSet.delete(task);
-              request$jscomp$1.status = 4;
-              var boundary$jscomp$0 = task.blockedBoundary;
-              request$jscomp$0 = logRecoverableError(
-                request,
-                x$jscomp$0,
-                errorInfo$jscomp$0
-              );
-              null === boundary$jscomp$0
-                ? fatalError(request, x$jscomp$0)
-                : (boundary$jscomp$0.pendingTasks--,
-                  4 !== boundary$jscomp$0.status &&
-                    ((boundary$jscomp$0.status = 4),
-                    (boundary$jscomp$0.errorDigest = request$jscomp$0),
-                    untrackBoundary(request, boundary$jscomp$0),
-                    boundary$jscomp$0.parentFlushed &&
-                      request.clientRenderedBoundaries.push(boundary$jscomp$0),
-                    0 === request.pendingRootTasks &&
-                      null === request.trackedPostpones &&
-                      null !== boundary$jscomp$0.contentPreamble &&
-                      preparePreamble(request)));
-              request.allPendingTasks--;
-              0 === request.allPendingTasks && completeAll(request);
+        } else
+          a: {
+            request$jscomp$0 = void 0;
+            var segment$jscomp$0 = segment;
+            if (0 === segment$jscomp$0.status) {
+              segment$jscomp$0.status = 6;
+              switchContext(task.context);
+              var childrenLength = segment$jscomp$0.children.length,
+                chunkLength = segment$jscomp$0.chunks.length;
+              try {
+                retryNode(request, task),
+                  segment$jscomp$0.lastPushedText &&
+                    segment$jscomp$0.textEmbedded &&
+                    segment$jscomp$0.chunks.push(textSeparator),
+                  task.abortSet.delete(task),
+                  (segment$jscomp$0.status = 1),
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+              } catch (thrownValue) {
+                resetHooksState();
+                segment$jscomp$0.children.length = childrenLength;
+                segment$jscomp$0.chunks.length = chunkLength;
+                var x$jscomp$0 =
+                  thrownValue === SuspenseException
+                    ? getSuspendedThenable()
+                    : 12 === request.status
+                      ? request.fatalError
+                      : thrownValue;
+                if (
+                  12 === request.status &&
+                  null !== request.trackedPostpones
+                ) {
+                  var trackedPostpones = request.trackedPostpones,
+                    thrownInfo = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? logPostpone(request, x$jscomp$0.message, thrownInfo)
+                    : logRecoverableError(request, x$jscomp$0, thrownInfo);
+                  trackPostpone(
+                    request,
+                    trackedPostpones,
+                    task,
+                    segment$jscomp$0
+                  );
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+                } else {
+                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0) {
+                    if ("function" === typeof x$jscomp$0.then) {
+                      segment$jscomp$0.status = 0;
+                      task.thenableState = getThenableStateAfterSuspending();
+                      var ping$jscomp$0 = task.ping;
+                      x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                      break a;
+                    }
+                    if (
+                      null !== request.trackedPostpones &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ) {
+                      var trackedPostpones$64 = request.trackedPostpones;
+                      task.abortSet.delete(task);
+                      var postponeInfo = getThrownInfo(task.componentStack);
+                      logPostpone(request, x$jscomp$0.message, postponeInfo);
+                      trackPostpone(
+                        request,
+                        trackedPostpones$64,
+                        task,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                      break a;
+                    }
+                  }
+                  var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  segment$jscomp$0.status = 4;
+                  var boundary = task.blockedBoundary;
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        x$jscomp$0.message,
+                        errorInfo$jscomp$0
+                      ),
+                      (request$jscomp$0 = "POSTPONE"))
+                    : (request$jscomp$0 = logRecoverableError(
+                        request,
+                        x$jscomp$0,
+                        errorInfo$jscomp$0
+                      ));
+                  null === boundary
+                    ? fatalError(request, x$jscomp$0)
+                    : (boundary.pendingTasks--,
+                      4 !== boundary.status &&
+                        ((boundary.status = 4),
+                        (boundary.errorDigest = request$jscomp$0),
+                        untrackBoundary(request, boundary),
+                        boundary.parentFlushed &&
+                          request.clientRenderedBoundaries.push(boundary)));
+                  request.allPendingTasks--;
+                  0 === request.allPendingTasks && completeAll(request);
+                }
+              } finally {
+              }
             }
-          } finally {
           }
-        }
       }
       pingedTasks.splice(0, i);
-      null !== request$jscomp$2.destination &&
-        flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
+      null !== request$jscomp$1.destination &&
+        flushCompletedQueues(request$jscomp$1, request$jscomp$1.destination);
     } catch (error) {
-      logRecoverableError(request$jscomp$2, error, {}),
-        fatalError(request$jscomp$2, error);
+      logRecoverableError(request$jscomp$1, error, {}),
+        fatalError(request$jscomp$1, error);
     } finally {
       (currentResumableState = prevResumableState),
         (ReactSharedInternals.H = prevDispatcher),
@@ -5612,82 +6028,6 @@ function performWork(request$jscomp$2) {
     }
   }
 }
-function preparePreambleFromSubtree(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  segment.preambleChildren.length &&
-    collectedPreambleSegments.push(segment.preambleChildren);
-  for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-    pendingPreambles =
-      preparePreambleFromSegment(
-        request,
-        segment.children[i],
-        collectedPreambleSegments
-      ) || pendingPreambles;
-  return pendingPreambles;
-}
-function preparePreambleFromSegment(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  var boundary = segment.boundary;
-  if (null === boundary)
-    return preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    );
-  var preamble = boundary.contentPreamble,
-    fallbackPreamble = boundary.fallbackPreamble;
-  if (null === preamble || null === fallbackPreamble) return !1;
-  switch (boundary.status) {
-    case 1:
-      hoistPreambleState(request.renderState, preamble);
-      segment = boundary.completedSegments[0];
-      if (!segment) throw Error(formatProdErrorMessage(391));
-      return preparePreambleFromSubtree(
-        request,
-        segment,
-        collectedPreambleSegments
-      );
-    case 5:
-      if (null !== request.trackedPostpones) return !0;
-    case 4:
-      if (1 === segment.status)
-        return (
-          hoistPreambleState(request.renderState, fallbackPreamble),
-          preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          )
-        );
-    default:
-      return !0;
-  }
-}
-function preparePreamble(request) {
-  if (
-    request.completedRootSegment &&
-    null === request.completedPreambleSegments
-  ) {
-    var collectedPreambleSegments = [],
-      hasPendingPreambles = preparePreambleFromSegment(
-        request,
-        request.completedRootSegment,
-        collectedPreambleSegments
-      ),
-      preamble = request.renderState.preamble;
-    if (
-      !1 === hasPendingPreambles ||
-      (preamble.headChunks && preamble.bodyChunks)
-    )
-      request.completedPreambleSegments = collectedPreambleSegments;
-  }
-}
 function flushSubtree(request, destination, segment, hoistableState) {
   segment.parentFlushed = !0;
   switch (segment.status) {
@@ -5815,31 +6155,46 @@ function flushCompletedBoundary(request, destination, boundary) {
   boundary = boundary.contentState;
   var requiresStyleInsertion = request.stylesToHoist;
   request.stylesToHoist = !1;
-  writeChunk(destination, request.startInlineScript);
-  requiresStyleInsertion
-    ? 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 10),
-        writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))
-      : 0 === (completedSegments.instructions & 8)
-        ? ((completedSegments.instructions |= 8),
-          writeChunk(destination, completeBoundaryWithStylesScript1FullPartial))
-        : writeChunk(destination, completeBoundaryWithStylesScript1Partial)
-    : 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 2),
-        writeChunk(destination, completeBoundaryScript1Full))
-      : writeChunk(destination, completeBoundaryScript1Partial);
+  var scriptFormat = 0 === completedSegments.streamingFormat;
+  scriptFormat
+    ? (writeChunk(destination, request.startInlineScript),
+      requiresStyleInsertion
+        ? 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 10),
+            writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))
+          : 0 === (completedSegments.instructions & 8)
+            ? ((completedSegments.instructions |= 8),
+              writeChunk(
+                destination,
+                completeBoundaryWithStylesScript1FullPartial
+              ))
+            : writeChunk(destination, completeBoundaryWithStylesScript1Partial)
+        : 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 2),
+            writeChunk(destination, completeBoundaryScript1Full))
+          : writeChunk(destination, completeBoundaryScript1Partial))
+    : requiresStyleInsertion
+      ? writeChunk(destination, completeBoundaryWithStylesData1)
+      : writeChunk(destination, completeBoundaryData1);
   completedSegments = stringToChunk(i.toString(16));
   writeChunk(destination, request.boundaryPrefix);
   writeChunk(destination, completedSegments);
-  writeChunk(destination, completeBoundaryScript2);
+  scriptFormat
+    ? writeChunk(destination, completeBoundaryScript2)
+    : writeChunk(destination, completeBoundaryData2);
   writeChunk(destination, request.segmentPrefix);
   writeChunk(destination, completedSegments);
   requiresStyleInsertion
-    ? (writeChunk(destination, completeBoundaryScript3a),
-      writeStyleResourceDependenciesInJS(destination, boundary))
-    : writeChunk(destination, completeBoundaryScript3b);
-  boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
-  return writeBootstrap(destination, request) && boundary;
+    ? scriptFormat
+      ? (writeChunk(destination, completeBoundaryScript3a),
+        writeStyleResourceDependenciesInJS(destination, boundary))
+      : (writeChunk(destination, completeBoundaryData3a),
+        writeStyleResourceDependenciesInAttr(destination, boundary))
+    : scriptFormat && writeChunk(destination, completeBoundaryScript3b);
+  completedSegments = scriptFormat
+    ? writeChunkAndReturn(destination, completeBoundaryScriptEnd)
+    : writeChunkAndReturn(destination, dataElementQuotedEnd);
+  return writeBootstrap(destination, request) && completedSegments;
 }
 function flushPartiallyCompletedSegment(
   request,
@@ -5860,18 +6215,24 @@ function flushPartiallyCompletedSegment(
   flushSegmentContainer(request, destination, segment, hoistableState);
   boundary = request.resumableState;
   request = request.renderState;
-  writeChunk(destination, request.startInlineScript);
-  0 === (boundary.instructions & 1)
-    ? ((boundary.instructions |= 1),
-      writeChunk(destination, completeSegmentScript1Full))
-    : writeChunk(destination, completeSegmentScript1Partial);
+  (segment = 0 === boundary.streamingFormat)
+    ? (writeChunk(destination, request.startInlineScript),
+      0 === (boundary.instructions & 1)
+        ? ((boundary.instructions |= 1),
+          writeChunk(destination, completeSegmentScript1Full))
+        : writeChunk(destination, completeSegmentScript1Partial))
+    : writeChunk(destination, completeSegmentData1);
   writeChunk(destination, request.segmentPrefix);
   segmentID = stringToChunk(segmentID.toString(16));
   writeChunk(destination, segmentID);
-  writeChunk(destination, completeSegmentScript2);
+  segment
+    ? writeChunk(destination, completeSegmentScript2)
+    : writeChunk(destination, completeSegmentData2);
   writeChunk(destination, request.placeholderPrefix);
   writeChunk(destination, segmentID);
-  destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
+  destination = segment
+    ? writeChunkAndReturn(destination, completeSegmentScriptEnd)
+    : writeChunkAndReturn(destination, dataElementQuotedEnd);
   return destination;
 }
 function flushCompletedQueues(request, destination) {
@@ -5883,12 +6244,22 @@ function flushCompletedQueues(request, destination) {
         completedRootSegment = request.completedRootSegment;
       if (null !== completedRootSegment) {
         if (5 === completedRootSegment.status) return;
-        var completedPreambleSegments = request.completedPreambleSegments;
-        if (null === completedPreambleSegments) return;
-        var renderState = request.renderState,
-          preamble = renderState.preamble,
-          htmlChunks = preamble.htmlChunks,
-          headChunks = preamble.headChunks,
+        var renderState = request.renderState;
+        if (
+          (0 !== request.allPendingTasks ||
+            null !== request.trackedPostpones) &&
+          renderState.externalRuntimeScript
+        ) {
+          var _renderState$external = renderState.externalRuntimeScript,
+            resumableState = request.resumableState,
+            src = _renderState$external.src,
+            chunks = _renderState$external.chunks;
+          resumableState.scriptResources.hasOwnProperty(src) ||
+            ((resumableState.scriptResources[src] = null),
+            renderState.scripts.add(chunks));
+        }
+        var htmlChunks = renderState.htmlChunks,
+          headChunks = renderState.headChunks,
           i$jscomp$0;
         if (htmlChunks) {
           for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -5929,27 +6300,10 @@ function flushCompletedQueues(request, destination) {
         var hoistableChunks = renderState.hoistableChunks;
         for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
           writeChunk(destination, hoistableChunks[i$jscomp$0]);
-        for (
-          renderState = hoistableChunks.length = 0;
-          renderState < completedPreambleSegments.length;
-          renderState++
-        ) {
-          var segments = completedPreambleSegments[renderState];
-          for (preamble = 0; preamble < segments.length; preamble++)
-            flushSegment(request, destination, segments[preamble], null);
-        }
-        var preamble$jscomp$0 = request.renderState.preamble,
-          headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-        (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) &&
+        hoistableChunks.length = 0;
+        htmlChunks &&
+          null === headChunks &&
           writeChunk(destination, endChunkForTag("head"));
-        var bodyChunks = preamble$jscomp$0.bodyChunks;
-        if (bodyChunks)
-          for (
-            completedPreambleSegments = 0;
-            completedPreambleSegments < bodyChunks.length;
-            completedPreambleSegments++
-          )
-            writeChunk(destination, bodyChunks[completedPreambleSegments]);
         flushSegment(request, destination, completedRootSegment, null);
         request.completedRootSegment = null;
         writeBootstrap(destination, request.renderState);
@@ -5990,36 +6344,44 @@ function flushCompletedQueues(request, destination) {
       for (i = 0; i < clientRenderedBoundaries.length; i++) {
         var boundary = clientRenderedBoundaries[i];
         renderState$jscomp$0 = destination;
-        var resumableState = request.resumableState,
+        var resumableState$jscomp$0 = request.resumableState,
           renderState$jscomp$1 = request.renderState,
           id = boundary.rootSegmentID,
-          errorDigest = boundary.errorDigest;
-        writeChunk(
-          renderState$jscomp$0,
-          renderState$jscomp$1.startInlineScript
-        );
-        0 === (resumableState.instructions & 4)
-          ? ((resumableState.instructions |= 4),
-            writeChunk(renderState$jscomp$0, clientRenderScript1Full))
-          : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
+          errorDigest = boundary.errorDigest,
+          scriptFormat = 0 === resumableState$jscomp$0.streamingFormat;
+        scriptFormat
+          ? (writeChunk(
+              renderState$jscomp$0,
+              renderState$jscomp$1.startInlineScript
+            ),
+            0 === (resumableState$jscomp$0.instructions & 4)
+              ? ((resumableState$jscomp$0.instructions |= 4),
+                writeChunk(renderState$jscomp$0, clientRenderScript1Full))
+              : writeChunk(renderState$jscomp$0, clientRenderScript1Partial))
+          : writeChunk(renderState$jscomp$0, clientRenderData1);
         writeChunk(renderState$jscomp$0, renderState$jscomp$1.boundaryPrefix);
         writeChunk(renderState$jscomp$0, stringToChunk(id.toString(16)));
-        writeChunk(renderState$jscomp$0, clientRenderScript1A);
+        scriptFormat && writeChunk(renderState$jscomp$0, clientRenderScript1A);
         errorDigest &&
-          (writeChunk(
-            renderState$jscomp$0,
-            clientRenderErrorScriptArgInterstitial
-          ),
-          writeChunk(
-            renderState$jscomp$0,
-            stringToChunk(
-              escapeJSStringsForInstructionScripts(errorDigest || "")
-            )
-          ));
-        var JSCompiler_inline_result = writeChunkAndReturn(
-          renderState$jscomp$0,
-          clientRenderScriptEnd
-        );
+          (scriptFormat
+            ? (writeChunk(
+                renderState$jscomp$0,
+                clientRenderErrorScriptArgInterstitial
+              ),
+              writeChunk(
+                renderState$jscomp$0,
+                stringToChunk(
+                  escapeJSStringsForInstructionScripts(errorDigest || "")
+                )
+              ))
+            : (writeChunk(renderState$jscomp$0, clientRenderData2),
+              writeChunk(
+                renderState$jscomp$0,
+                stringToChunk(escapeTextForBrowser(errorDigest || ""))
+              )));
+        var JSCompiler_inline_result = scriptFormat
+          ? writeChunkAndReturn(renderState$jscomp$0, clientRenderScriptEnd)
+          : writeChunkAndReturn(renderState$jscomp$0, dataElementQuotedEnd);
         if (!JSCompiler_inline_result) {
           request.destination = null;
           i++;
@@ -6044,11 +6406,11 @@ function flushCompletedQueues(request, destination) {
       writtenBytes = 0;
       var partialBoundaries = request.partialBoundaries;
       for (i = 0; i < partialBoundaries.length; i++) {
-        var boundary$51 = partialBoundaries[i];
+        var boundary$67 = partialBoundaries[i];
         a: {
           clientRenderedBoundaries = request;
           boundary = destination;
-          var completedSegments = boundary$51.completedSegments;
+          var completedSegments = boundary$67.completedSegments;
           for (
             JSCompiler_inline_result = 0;
             JSCompiler_inline_result < completedSegments.length;
@@ -6058,7 +6420,7 @@ function flushCompletedQueues(request, destination) {
               !flushPartiallyCompletedSegment(
                 clientRenderedBoundaries,
                 boundary,
-                boundary$51,
+                boundary$67,
                 completedSegments[JSCompiler_inline_result]
               )
             ) {
@@ -6070,7 +6432,7 @@ function flushCompletedQueues(request, destination) {
           completedSegments.splice(0, JSCompiler_inline_result);
           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
             boundary,
-            boundary$51.contentState,
+            boundary$67.contentState,
             clientRenderedBoundaries.renderState
           );
         }
@@ -6098,9 +6460,10 @@ function flushCompletedQueues(request, destination) {
     0 === request.clientRenderedBoundaries.length &&
     0 === request.completedBoundaries.length
       ? ((request.flushScheduled = !1),
-        (i = request.resumableState),
-        i.hasBody && writeChunk(destination, endChunkForTag("body")),
-        i.hasHtml && writeChunk(destination, endChunkForTag("html")),
+        null === request.trackedPostpones &&
+          ((i = request.resumableState),
+          i.hasBody && writeChunk(destination, endChunkForTag("body")),
+          i.hasHtml && writeChunk(destination, endChunkForTag("html"))),
         completeWriting(destination),
         (request.status = 14),
         destination.close(),
@@ -6164,18 +6527,69 @@ function abort(request, reason) {
     }
     null !== request.destination &&
       flushCompletedQueues(request, request.destination);
-  } catch (error$53) {
-    logRecoverableError(request, error$53, {}), fatalError(request, error$53);
+  } catch (error$69) {
+    logRecoverableError(request, error$69, {}), fatalError(request, error$69);
   }
 }
+function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+  if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+  else {
+    var workingMap = trackedPostpones.workingMap,
+      parentNode = workingMap.get(parentKeyPath);
+    void 0 === parentNode &&
+      ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+      workingMap.set(parentKeyPath, parentNode),
+      addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+    parentNode[2].push(node);
+  }
+}
+function getPostponedState(request) {
+  var trackedPostpones = request.trackedPostpones;
+  if (
+    null === trackedPostpones ||
+    (0 === trackedPostpones.rootNodes.length &&
+      null === trackedPostpones.rootSlots)
+  )
+    return (request.trackedPostpones = null);
+  if (
+    null !== request.completedRootSegment &&
+    5 === request.completedRootSegment.status
+  ) {
+    var resumableState = request.resumableState,
+      renderState = request.renderState;
+    resumableState.nextFormID = 0;
+    resumableState.hasBody = !1;
+    resumableState.hasHtml = !1;
+    resumableState.unknownResources = { font: renderState.resets.font };
+    resumableState.dnsResources = renderState.resets.dns;
+    resumableState.connectResources = renderState.resets.connect;
+    resumableState.imageResources = renderState.resets.image;
+    resumableState.styleResources = renderState.resets.style;
+    resumableState.scriptResources = {};
+    resumableState.moduleUnknownResources = {};
+    resumableState.moduleScriptResources = {};
+  } else
+    (resumableState = request.resumableState),
+      (resumableState.bootstrapScriptContent = void 0),
+      (resumableState.bootstrapScripts = void 0),
+      (resumableState.bootstrapModules = void 0);
+  return {
+    nextSegmentId: request.nextSegmentId,
+    rootFormatContext: request.rootFormatContext,
+    progressiveChunkSize: request.progressiveChunkSize,
+    resumableState: request.resumableState,
+    replayNodes: trackedPostpones.rootNodes,
+    replaySlots: trackedPostpones.rootSlots
+  };
+}
 function ensureCorrectIsomorphicReactVersion() {
   var isomorphicReactPackageVersion = React.version;
-  if ("19.1.0-canary-c492f975-20250128" !== isomorphicReactPackageVersion)
+  if ("19.1.0-experimental-b3a95caf-20250113" !== isomorphicReactPackageVersion)
     throw Error(
       formatProdErrorMessage(
         527,
         isomorphicReactPackageVersion,
-        "19.1.0-canary-c492f975-20250128"
+        "19.1.0-experimental-b3a95caf-20250113"
       )
     );
 }
@@ -6211,22 +6625,21 @@ exports.prerender = function (children, options) {
         options ? options.progressiveChunkSize : void 0,
         options ? options.onError : void 0,
         function () {
-          var result = {
-            prelude: new ReadableStream(
-              {
-                type: "bytes",
-                pull: function (controller) {
-                  startFlowing(request, controller);
-                },
-                cancel: function (reason) {
-                  request.destination = null;
-                  abort(request, reason);
-                }
+          var stream = new ReadableStream(
+            {
+              type: "bytes",
+              pull: function (controller) {
+                startFlowing(request, controller);
               },
-              { highWaterMark: 0 }
-            )
-          };
-          resolve(result);
+              cancel: function (reason) {
+                request.destination = null;
+                abort(request, reason);
+              }
+            },
+            { highWaterMark: 0 }
+          );
+          stream = { postponed: getPostponedState(request), prelude: stream };
+          resolve(stream);
         },
         void 0,
         void 0,
@@ -6322,4 +6735,113 @@ exports.renderToReadableStream = function (children, options) {
     startWork(request);
   });
 };
-exports.version = "19.1.0-canary-c492f975-20250128";
+exports.resume = function (children, postponedState, options) {
+  return new Promise(function (resolve, reject) {
+    var onFatalError,
+      onAllReady,
+      allReady = new Promise(function (res, rej) {
+        onAllReady = res;
+        onFatalError = rej;
+      }),
+      request = resumeRequest(
+        children,
+        postponedState,
+        createRenderState(
+          postponedState.resumableState,
+          options ? options.nonce : void 0,
+          void 0,
+          void 0,
+          void 0,
+          void 0
+        ),
+        options ? options.onError : void 0,
+        onAllReady,
+        function () {
+          var stream = new ReadableStream(
+            {
+              type: "bytes",
+              pull: function (controller) {
+                startFlowing(request, controller);
+              },
+              cancel: function (reason) {
+                request.destination = null;
+                abort(request, reason);
+              }
+            },
+            { highWaterMark: 0 }
+          );
+          stream.allReady = allReady;
+          resolve(stream);
+        },
+        function (error) {
+          allReady.catch(function () {});
+          reject(error);
+        },
+        onFatalError,
+        options ? options.onPostpone : void 0
+      );
+    if (options && options.signal) {
+      var signal = options.signal;
+      if (signal.aborted) abort(request, signal.reason);
+      else {
+        var listener = function () {
+          abort(request, signal.reason);
+          signal.removeEventListener("abort", listener);
+        };
+        signal.addEventListener("abort", listener);
+      }
+    }
+    startWork(request);
+  });
+};
+exports.resumeAndPrerender = function (children, postponedState, options) {
+  return new Promise(function (resolve, reject) {
+    var request = resumeAndPrerenderRequest(
+      children,
+      postponedState,
+      createRenderState(
+        postponedState.resumableState,
+        options ? options.nonce : void 0,
+        void 0,
+        void 0,
+        void 0,
+        void 0
+      ),
+      options ? options.onError : void 0,
+      function () {
+        var stream = new ReadableStream(
+          {
+            type: "bytes",
+            pull: function (controller) {
+              startFlowing(request, controller);
+            },
+            cancel: function (reason) {
+              request.destination = null;
+              abort(request, reason);
+            }
+          },
+          { highWaterMark: 0 }
+        );
+        stream = { postponed: getPostponedState(request), prelude: stream };
+        resolve(stream);
+      },
+      void 0,
+      void 0,
+      reject,
+      options ? options.onPostpone : void 0
+    );
+    if (options && options.signal) {
+      var signal = options.signal;
+      if (signal.aborted) abort(request, signal.reason);
+      else {
+        var listener = function () {
+          abort(request, signal.reason);
+          signal.removeEventListener("abort", listener);
+        };
+        signal.addEventListener("abort", listener);
+      }
+    }
+    startWork(request);
+  });
+};
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
diff --git a/node_modules/react-dom/cjs/react-dom-server.bun.development.js b/node_modules/react-dom/cjs/react-dom-server.bun.development.js
index 01bc12e..74ecefc 100644
--- a/node_modules/react-dom/cjs/react-dom-server.bun.development.js
+++ b/node_modules/react-dom/cjs/react-dom-server.bun.development.js
@@ -27,9 +27,10 @@ var React = require("react"),
   REACT_SCOPE_TYPE = Symbol.for("react.scope"),
   REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
   REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
   REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
   MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+  ASYNC_ITERATOR = Symbol.asyncIterator,
   isArrayImpl = Array.isArray,
   jsxPropsParents = new WeakMap(),
   jsxChildrenParents = new WeakMap();
@@ -73,6 +74,8 @@ function describeElementType(type) {
       return "Suspense";
     case REACT_SUSPENSE_LIST_TYPE:
       return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
   }
   if ("object" === typeof type)
     switch (type.$$typeof) {
@@ -1366,7 +1369,8 @@ ReactDOMSharedInternals.d = {
   S: preinitStyle,
   M: preinitModuleScript
 };
-var NothingSent = 0,
+var ScriptStreamingFormat = 0,
+  NothingSent = 0,
   SentCompleteSegmentFunction = 1,
   SentCompleteBoundaryFunction = 2,
   SentClientRenderFunction = 4,
@@ -1396,24 +1400,44 @@ function createRenderState(
       void 0 === nonce
         ? "<script>"
         : '<script nonce="' + escapeTextForBrowser(nonce) + '">',
-    idPrefix = resumableState.idPrefix;
-  externalRuntimeConfig = [];
-  var bootstrapScriptContent = resumableState.bootstrapScriptContent,
+    idPrefix = resumableState.idPrefix,
+    bootstrapChunks = [],
+    externalRuntimeScript = null,
+    bootstrapScriptContent = resumableState.bootstrapScriptContent,
     bootstrapScripts = resumableState.bootstrapScripts,
     bootstrapModules = resumableState.bootstrapModules;
   void 0 !== bootstrapScriptContent &&
-    externalRuntimeConfig.push(
+    bootstrapChunks.push(
       inlineScriptWithNonce,
       escapeEntireInlineScriptContent(bootstrapScriptContent),
       "\x3c/script>"
     );
-  bootstrapScriptContent = [];
+  void 0 !== externalRuntimeConfig &&
+    ("string" === typeof externalRuntimeConfig
+      ? ((externalRuntimeScript = { src: externalRuntimeConfig, chunks: [] }),
+        pushScriptImpl(externalRuntimeScript.chunks, {
+          src: externalRuntimeConfig,
+          async: !0,
+          integrity: void 0,
+          nonce: nonce
+        }))
+      : ((externalRuntimeScript = {
+          src: externalRuntimeConfig.src,
+          chunks: []
+        }),
+        pushScriptImpl(externalRuntimeScript.chunks, {
+          src: externalRuntimeConfig.src,
+          async: !0,
+          integrity: externalRuntimeConfig.integrity,
+          nonce: nonce
+        })));
+  externalRuntimeConfig = [];
   void 0 !== importMap &&
-    (bootstrapScriptContent.push('<script type="importmap">'),
-    bootstrapScriptContent.push(
+    (externalRuntimeConfig.push('<script type="importmap">'),
+    externalRuntimeConfig.push(
       escapeEntireInlineScriptContent(JSON.stringify(importMap))
     ),
-    bootstrapScriptContent.push("\x3c/script>"));
+    externalRuntimeConfig.push("\x3c/script>"));
   onHeaders &&
     "number" === typeof maxHeadersLength &&
     0 >= maxHeadersLength &&
@@ -1421,26 +1445,26 @@ function createRenderState(
       "React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.",
       0 === maxHeadersLength ? "zero" : maxHeadersLength
     );
-  importMap = onHeaders
-    ? {
-        preconnects: "",
-        fontPreloads: "",
-        highImagePreloads: "",
-        remainingCapacity:
-          2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
-      }
-    : null;
-  onHeaders = {
+  importMap = {
     placeholderPrefix: idPrefix + "P:",
     segmentPrefix: idPrefix + "S:",
     boundaryPrefix: idPrefix + "B:",
     startInlineScript: inlineScriptWithNonce,
-    preamble: createPreambleState(),
-    externalRuntimeScript: null,
-    bootstrapChunks: externalRuntimeConfig,
-    importMapChunks: bootstrapScriptContent,
+    htmlChunks: null,
+    headChunks: null,
+    externalRuntimeScript: externalRuntimeScript,
+    bootstrapChunks: bootstrapChunks,
+    importMapChunks: externalRuntimeConfig,
     onHeaders: onHeaders,
-    headers: importMap,
+    headers: onHeaders
+      ? {
+          preconnects: "",
+          fontPreloads: "",
+          highImagePreloads: "",
+          remainingCapacity:
+            2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
+        }
+      : null,
     resets: {
       font: {},
       dns: {},
@@ -1469,103 +1493,99 @@ function createRenderState(
     stylesToHoist: !1
   };
   if (void 0 !== bootstrapScripts)
-    for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
-      maxHeadersLength = bootstrapScripts[importMap];
-      bootstrapScriptContent = idPrefix = void 0;
-      var props = {
-        rel: "preload",
-        as: "script",
-        fetchPriority: "low",
-        nonce: nonce
-      };
-      "string" === typeof maxHeadersLength
-        ? (props.href = inlineScriptWithNonce = maxHeadersLength)
-        : ((props.href = inlineScriptWithNonce = maxHeadersLength.src),
-          (props.integrity = bootstrapScriptContent =
-            "string" === typeof maxHeadersLength.integrity
-              ? maxHeadersLength.integrity
-              : void 0),
-          (props.crossOrigin = idPrefix =
-            "string" === typeof maxHeadersLength ||
-            null == maxHeadersLength.crossOrigin
-              ? void 0
-              : "use-credentials" === maxHeadersLength.crossOrigin
-                ? "use-credentials"
-                : ""));
-      preloadBootstrapScriptOrModule(
-        resumableState,
-        onHeaders,
-        inlineScriptWithNonce,
-        props
-      );
-      externalRuntimeConfig.push(
-        '<script src="',
-        escapeTextForBrowser(inlineScriptWithNonce)
-      );
-      nonce &&
-        externalRuntimeConfig.push('" nonce="', escapeTextForBrowser(nonce));
-      "string" === typeof bootstrapScriptContent &&
-        externalRuntimeConfig.push(
-          '" integrity="',
-          escapeTextForBrowser(bootstrapScriptContent)
-        );
-      "string" === typeof idPrefix &&
-        externalRuntimeConfig.push(
-          '" crossorigin="',
-          escapeTextForBrowser(idPrefix)
-        );
-      externalRuntimeConfig.push('" async="">\x3c/script>');
-    }
+    for (onHeaders = 0; onHeaders < bootstrapScripts.length; onHeaders++)
+      (maxHeadersLength = bootstrapScripts[onHeaders]),
+        (externalRuntimeScript = idPrefix = void 0),
+        (externalRuntimeConfig = {
+          rel: "preload",
+          as: "script",
+          fetchPriority: "low",
+          nonce: nonce
+        }),
+        "string" === typeof maxHeadersLength
+          ? (externalRuntimeConfig.href = inlineScriptWithNonce =
+              maxHeadersLength)
+          : ((externalRuntimeConfig.href = inlineScriptWithNonce =
+              maxHeadersLength.src),
+            (externalRuntimeConfig.integrity = externalRuntimeScript =
+              "string" === typeof maxHeadersLength.integrity
+                ? maxHeadersLength.integrity
+                : void 0),
+            (externalRuntimeConfig.crossOrigin = idPrefix =
+              "string" === typeof maxHeadersLength ||
+              null == maxHeadersLength.crossOrigin
+                ? void 0
+                : "use-credentials" === maxHeadersLength.crossOrigin
+                  ? "use-credentials"
+                  : "")),
+        preloadBootstrapScriptOrModule(
+          resumableState,
+          importMap,
+          inlineScriptWithNonce,
+          externalRuntimeConfig
+        ),
+        bootstrapChunks.push(
+          '<script src="',
+          escapeTextForBrowser(inlineScriptWithNonce)
+        ),
+        nonce && bootstrapChunks.push('" nonce="', escapeTextForBrowser(nonce)),
+        "string" === typeof externalRuntimeScript &&
+          bootstrapChunks.push(
+            '" integrity="',
+            escapeTextForBrowser(externalRuntimeScript)
+          ),
+        "string" === typeof idPrefix &&
+          bootstrapChunks.push(
+            '" crossorigin="',
+            escapeTextForBrowser(idPrefix)
+          ),
+        bootstrapChunks.push('" async="">\x3c/script>');
   if (void 0 !== bootstrapModules)
     for (
       bootstrapScripts = 0;
       bootstrapScripts < bootstrapModules.length;
       bootstrapScripts++
     )
-      (importMap = bootstrapModules[bootstrapScripts]),
+      (onHeaders = bootstrapModules[bootstrapScripts]),
         (idPrefix = inlineScriptWithNonce = void 0),
-        (bootstrapScriptContent = {
+        (externalRuntimeScript = {
           rel: "modulepreload",
           fetchPriority: "low",
           nonce: nonce
         }),
-        "string" === typeof importMap
-          ? (bootstrapScriptContent.href = maxHeadersLength = importMap)
-          : ((bootstrapScriptContent.href = maxHeadersLength = importMap.src),
-            (bootstrapScriptContent.integrity = idPrefix =
-              "string" === typeof importMap.integrity
-                ? importMap.integrity
+        "string" === typeof onHeaders
+          ? (externalRuntimeScript.href = maxHeadersLength = onHeaders)
+          : ((externalRuntimeScript.href = maxHeadersLength = onHeaders.src),
+            (externalRuntimeScript.integrity = idPrefix =
+              "string" === typeof onHeaders.integrity
+                ? onHeaders.integrity
                 : void 0),
-            (bootstrapScriptContent.crossOrigin = inlineScriptWithNonce =
-              "string" === typeof importMap || null == importMap.crossOrigin
+            (externalRuntimeScript.crossOrigin = inlineScriptWithNonce =
+              "string" === typeof onHeaders || null == onHeaders.crossOrigin
                 ? void 0
-                : "use-credentials" === importMap.crossOrigin
+                : "use-credentials" === onHeaders.crossOrigin
                   ? "use-credentials"
                   : "")),
         preloadBootstrapScriptOrModule(
           resumableState,
-          onHeaders,
+          importMap,
           maxHeadersLength,
-          bootstrapScriptContent
+          externalRuntimeScript
         ),
-        externalRuntimeConfig.push(
+        bootstrapChunks.push(
           '<script type="module" src="',
           escapeTextForBrowser(maxHeadersLength)
         ),
-        nonce &&
-          externalRuntimeConfig.push('" nonce="', escapeTextForBrowser(nonce)),
+        nonce && bootstrapChunks.push('" nonce="', escapeTextForBrowser(nonce)),
         "string" === typeof idPrefix &&
-          externalRuntimeConfig.push(
-            '" integrity="',
-            escapeTextForBrowser(idPrefix)
-          ),
+          bootstrapChunks.push('" integrity="', escapeTextForBrowser(idPrefix)),
         "string" === typeof inlineScriptWithNonce &&
-          externalRuntimeConfig.push(
+          bootstrapChunks.push(
             '" crossorigin="',
             escapeTextForBrowser(inlineScriptWithNonce)
           ),
-        externalRuntimeConfig.push('" async="">\x3c/script>');
-  return onHeaders;
+        bootstrapChunks.push('" async="">\x3c/script>');
+  return importMap;
 }
 function createResumableState(
   identifierPrefix,
@@ -1574,10 +1594,12 @@ function createResumableState(
   bootstrapScripts,
   bootstrapModules
 ) {
+  var streamingFormat = ScriptStreamingFormat;
+  void 0 !== externalRuntimeConfig && (streamingFormat = 1);
   return {
     idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
     nextFormID: 0,
-    streamingFormat: 0,
+    streamingFormat: streamingFormat,
     bootstrapScriptContent: bootstrapScriptContent,
     bootstrapScripts: bootstrapScripts,
     bootstrapModules: bootstrapModules,
@@ -1594,19 +1616,15 @@ function createResumableState(
     moduleScriptResources: {}
   };
 }
-function createPreambleState() {
-  return { htmlChunks: null, headChunks: null, bodyChunks: null };
-}
 var ROOT_HTML_MODE = 0,
   HTML_HTML_MODE = 1,
   HTML_MODE = 2,
-  HTML_HEAD_MODE = 3,
-  SVG_MODE = 4,
-  MATHML_MODE = 5,
-  HTML_TABLE_MODE = 6,
-  HTML_TABLE_BODY_MODE = 7,
-  HTML_TABLE_ROW_MODE = 8,
-  HTML_COLGROUP_MODE = 9;
+  SVG_MODE = 3,
+  MATHML_MODE = 4,
+  HTML_TABLE_MODE = 5,
+  HTML_TABLE_BODY_MODE = 6,
+  HTML_TABLE_ROW_MODE = 7,
+  HTML_COLGROUP_MODE = 8;
 function createFormatContext(insertionMode, selectedValue, tagScope) {
   return {
     insertionMode: insertionMode,
@@ -1665,26 +1683,16 @@ function getChildFormatContext(parentContext, type, props) {
         null,
         parentContext.tagScope
       );
-    case "head":
-      if (parentContext.insertionMode < HTML_MODE)
-        return createFormatContext(
-          HTML_HEAD_MODE,
-          null,
-          parentContext.tagScope
-        );
-      break;
-    case "html":
-      if (parentContext.insertionMode === ROOT_HTML_MODE)
-        return createFormatContext(
-          HTML_HTML_MODE,
-          null,
-          parentContext.tagScope
-        );
   }
-  return parentContext.insertionMode >= HTML_TABLE_MODE ||
-    parentContext.insertionMode < HTML_MODE
+  return parentContext.insertionMode >= HTML_TABLE_MODE
     ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
-    : parentContext;
+    : parentContext.insertionMode === ROOT_HTML_MODE
+      ? "html" === type
+        ? createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope)
+        : createFormatContext(HTML_MODE, null, parentContext.tagScope)
+      : parentContext.insertionMode === HTML_HTML_MODE
+        ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
+        : parentContext;
 }
 function pushTextInstance(target, text, renderState, textEmbedded) {
   if ("" === text) return textEmbedded;
@@ -2207,7 +2215,8 @@ function flattenOptionChildren(children) {
 var formReplayingRuntimeScript =
   'addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error(\'React form unexpectedly submitted.\')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});';
 function injectFormReplayingRuntime(resumableState, renderState) {
-  (resumableState.instructions & 16) === NothingSent &&
+  (resumableState.instructions & 16) !== NothingSent ||
+    renderState.externalRuntimeScript ||
     ((resumableState.instructions |= 16),
     renderState.bootstrapChunks.unshift(
       renderState.startInlineScript,
@@ -2378,7 +2387,6 @@ function pushStartInstance(
   props,
   resumableState,
   renderState,
-  preambleState,
   hoistableState,
   formatContext,
   textEmbedded,
@@ -3513,13 +3521,13 @@ function pushStartInstance(
     case "missing-glyph":
       break;
     case "head":
-      if (formatContext.insertionMode < HTML_MODE) {
-        var preamble = preambleState || renderState.preamble;
-        if (preamble.headChunks)
-          throw Error("The `<head>` tag may only be rendered once.");
-        preamble.headChunks = [];
+      if (
+        formatContext.insertionMode < HTML_MODE &&
+        null === renderState.headChunks
+      ) {
+        renderState.headChunks = [];
         var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-          preamble.headChunks,
+          renderState.headChunks,
           props,
           "head"
         );
@@ -3530,42 +3538,24 @@ function pushStartInstance(
           "head"
         );
       return JSCompiler_inline_result$jscomp$9;
-    case "body":
-      if (formatContext.insertionMode < HTML_MODE) {
-        var preamble$jscomp$0 = preambleState || renderState.preamble;
-        if (preamble$jscomp$0.bodyChunks)
-          throw Error("The `<body>` tag may only be rendered once.");
-        preamble$jscomp$0.bodyChunks = [];
-        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          preamble$jscomp$0.bodyChunks,
-          props,
-          "body"
-        );
-      } else
-        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          target$jscomp$0,
-          props,
-          "body"
-        );
-      return JSCompiler_inline_result$jscomp$10;
     case "html":
-      if (formatContext.insertionMode === ROOT_HTML_MODE) {
-        var preamble$jscomp$1 = preambleState || renderState.preamble;
-        if (preamble$jscomp$1.htmlChunks)
-          throw Error("The `<html>` tag may only be rendered once.");
-        preamble$jscomp$1.htmlChunks = ["<!DOCTYPE html>"];
-        var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-          preamble$jscomp$1.htmlChunks,
+      if (
+        formatContext.insertionMode === ROOT_HTML_MODE &&
+        null === renderState.htmlChunks
+      ) {
+        renderState.htmlChunks = ["<!DOCTYPE html>"];
+        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+          renderState.htmlChunks,
           props,
           "html"
         );
       } else
-        JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
           target$jscomp$0,
           props,
           "html"
         );
-      return JSCompiler_inline_result$jscomp$11;
+      return JSCompiler_inline_result$jscomp$10;
     default:
       if (-1 !== type.indexOf("-")) {
         target$jscomp$0.push(startChunkForTag(type));
@@ -3626,15 +3616,6 @@ function endChunkForTag(tag) {
   void 0 === chunk && ((chunk = "</" + tag + ">"), endTagCache.set(tag, chunk));
   return chunk;
 }
-function hoistPreambleState(renderState, preambleState) {
-  renderState = renderState.preamble;
-  null === renderState.htmlChunks &&
-    (renderState.htmlChunks = preambleState.htmlChunks);
-  null === renderState.headChunks &&
-    (renderState.headChunks = preambleState.headChunks);
-  null === renderState.bodyChunks &&
-    (renderState.bodyChunks = preambleState.bodyChunks);
-}
 function writeBootstrap(destination, renderState) {
   renderState = renderState.bootstrapChunks;
   for (var i = 0; i < renderState.length - 1; i++)
@@ -3692,7 +3673,6 @@ function writeStartSegment(destination, renderState, formatContext, id) {
   switch (formatContext.insertionMode) {
     case ROOT_HTML_MODE:
     case HTML_HTML_MODE:
-    case HTML_HEAD_MODE:
     case HTML_MODE:
       return (
         writeChunk(destination, startSegmentHTML),
@@ -3750,7 +3730,6 @@ function writeEndSegment(destination, formatContext) {
   switch (formatContext.insertionMode) {
     case ROOT_HTML_MODE:
     case HTML_HTML_MODE:
-    case HTML_HEAD_MODE:
     case HTML_MODE:
       return !!destination.write(endSegmentHTML);
     case SVG_MODE:
@@ -3774,6 +3753,9 @@ var completeSegmentScript1Full =
   completeSegmentScript1Partial = '$RS("',
   completeSegmentScript2 = '","',
   completeSegmentScriptEnd = '")\x3c/script>',
+  completeSegmentData1 = '<template data-rsi="" data-sid="',
+  completeSegmentData2 = '" data-pid="',
+  completeSegmentDataEnd = '"></template>',
   completeBoundaryScript1Full =
     '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("',
   completeBoundaryScript1Partial = '$RC("',
@@ -3786,12 +3768,23 @@ var completeSegmentScript1Full =
   completeBoundaryScript3a = '",',
   completeBoundaryScript3b = '"',
   completeBoundaryScriptEnd = ")\x3c/script>",
+  completeBoundaryData1 = '<template data-rci="" data-bid="',
+  completeBoundaryWithStylesData1 = '<template data-rri="" data-bid="',
+  completeBoundaryData2 = '" data-sid="',
+  completeBoundaryData3a = '" data-sty="',
+  completeBoundaryDataEnd = '"></template>',
   clientRenderScript1Full =
     '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("',
   clientRenderScript1Partial = '$RX("',
   clientRenderScript1A = '"',
   clientRenderErrorScriptArgInterstitial = ",",
   clientRenderScriptEnd = ")\x3c/script>",
+  clientRenderData1 = '<template data-rxi="" data-bid="',
+  clientRenderData2 = '" data-dgst="',
+  clientRenderData3 = '" data-msg="',
+  clientRenderData4 = '" data-stck="',
+  clientRenderData5 = '" data-cstck="',
+  clientRenderDataEnd = '"></template>',
   regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g;
 function escapeJSStringsForInstructionScripts(input) {
   return JSON.stringify(input).replace(
@@ -4062,6 +4055,113 @@ function writeStyleResourceAttributeInJS(destination, name, value) {
   writeChunk(destination, arrayInterstitial);
   writeChunk(destination, escapeJSObjectForInstructionScripts(name));
 }
+function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+  writeChunk(destination, arrayFirstOpenBracket);
+  var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
+  hoistableState.stylesheets.forEach(function (resource) {
+    if (resource.state !== PREAMBLE)
+      if (resource.state === LATE)
+        writeChunk(destination, nextArrayOpenBrackChunk),
+          (resource = resource.props.href),
+          checkAttributeStringCoercion(resource, "href"),
+          writeChunk(
+            destination,
+            escapeTextForBrowser(JSON.stringify("" + resource))
+          ),
+          writeChunk(destination, arrayCloseBracket),
+          (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);
+      else {
+        writeChunk(destination, nextArrayOpenBrackChunk);
+        var precedence = resource.props["data-precedence"],
+          props = resource.props,
+          coercedHref = sanitizeURL("" + resource.props.href);
+        writeChunk(
+          destination,
+          escapeTextForBrowser(JSON.stringify(coercedHref))
+        );
+        checkAttributeStringCoercion(precedence, "precedence");
+        precedence = "" + precedence;
+        writeChunk(destination, arrayInterstitial);
+        writeChunk(
+          destination,
+          escapeTextForBrowser(JSON.stringify(precedence))
+        );
+        for (var propKey in props)
+          if (
+            hasOwnProperty.call(props, propKey) &&
+            ((precedence = props[propKey]), null != precedence)
+          )
+            switch (propKey) {
+              case "href":
+              case "rel":
+              case "precedence":
+              case "data-precedence":
+                break;
+              case "children":
+              case "dangerouslySetInnerHTML":
+                throw Error(
+                  "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                );
+              default:
+                writeStyleResourceAttributeInAttr(
+                  destination,
+                  propKey,
+                  precedence
+                );
+            }
+        writeChunk(destination, arrayCloseBracket);
+        nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
+        resource.state = LATE;
+      }
+  });
+  writeChunk(destination, arrayCloseBracket);
+}
+function writeStyleResourceAttributeInAttr(destination, name, value) {
+  var attributeName = name.toLowerCase();
+  switch (typeof value) {
+    case "function":
+    case "symbol":
+      return;
+  }
+  switch (name) {
+    case "innerHTML":
+    case "dangerouslySetInnerHTML":
+    case "suppressContentEditableWarning":
+    case "suppressHydrationWarning":
+    case "style":
+    case "ref":
+      return;
+    case "className":
+      attributeName = "class";
+      checkAttributeStringCoercion(value, attributeName);
+      name = "" + value;
+      break;
+    case "hidden":
+      if (!1 === value) return;
+      name = "";
+      break;
+    case "src":
+    case "href":
+      value = sanitizeURL(value);
+      checkAttributeStringCoercion(value, attributeName);
+      name = "" + value;
+      break;
+    default:
+      if (
+        (2 < name.length &&
+          ("o" === name[0] || "O" === name[0]) &&
+          ("n" === name[1] || "N" === name[1])) ||
+        !isAttributeNameSafe(name)
+      )
+        return;
+      checkAttributeStringCoercion(value, attributeName);
+      name = "" + value;
+  }
+  writeChunk(destination, arrayInterstitial);
+  writeChunk(destination, escapeTextForBrowser(JSON.stringify(attributeName)));
+  writeChunk(destination, arrayInterstitial);
+  writeChunk(destination, escapeTextForBrowser(JSON.stringify(name)));
+}
 var PENDING$1 = 0,
   PRELOADED = 1,
   PREAMBLE = 2,
@@ -4515,6 +4615,8 @@ function getComponentNameFromType(type) {
       return "Suspense";
     case REACT_SUSPENSE_LIST_TYPE:
       return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
   }
   if ("object" === typeof type)
     switch (
@@ -4967,6 +5069,11 @@ function dispatchAction(componentIdentity, queue, action) {
       queue.next = componentIdentity;
     }
 }
+function throwOnUseEffectEventCall() {
+  throw Error(
+    "A function wrapped in useEffectEvent can't be called during rendering."
+  );
+}
 function unsupportedStartTransition() {
   throw Error("startTransition cannot be called during server rendering.");
 }
@@ -5041,8 +5148,15 @@ function unwrapThenable(thenable) {
   null === thenableState && (thenableState = []);
   return trackUsedThenable(thenableState, thenable, index);
 }
-function unsupportedRefresh() {
-  throw Error("Cache cannot be refreshed during server rendering.");
+function readPreviousThenableFromState() {
+  var index = thenableIndexCounter;
+  thenableIndexCounter += 1;
+  if (null !== thenableState)
+    return (
+      (index = thenableState[index]),
+      (index = void 0 === index ? void 0 : index.value),
+      index
+    );
 }
 function noop$1() {}
 var HooksDispatcher = {
@@ -5126,13 +5240,8 @@ var HooksDispatcher = {
       resolveCurrentlyRenderingComponent();
       return NotPending;
     },
-    useMemoCache: function (size) {
-      for (var data = Array(size), i = 0; i < size; i++)
-        data[i] = REACT_MEMO_CACHE_SENTINEL;
-      return data;
-    },
-    useCacheRefresh: function () {
-      return unsupportedRefresh;
+    useEffectEvent: function () {
+      return throwOnUseEffectEventCall;
     }
   },
   currentResumableState = null,
@@ -5372,6 +5481,24 @@ function describeNativeComponentFrame(fn, construct) {
   "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
   return sampleLines;
 }
+function formatOwnerStack(error) {
+  var prevPrepareStackTrace = Error.prepareStackTrace;
+  Error.prepareStackTrace = void 0;
+  error = error.stack;
+  Error.prepareStackTrace = prevPrepareStackTrace;
+  error.startsWith("Error: react-stack-top-frame\n") &&
+    (error = error.slice(29));
+  prevPrepareStackTrace = error.indexOf("\n");
+  -1 !== prevPrepareStackTrace &&
+    (error = error.slice(prevPrepareStackTrace + 1));
+  prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
+  -1 !== prevPrepareStackTrace &&
+    (prevPrepareStackTrace = error.lastIndexOf("\n", prevPrepareStackTrace));
+  if (-1 !== prevPrepareStackTrace)
+    error = error.slice(0, prevPrepareStackTrace);
+  else return "";
+  return error;
+}
 function describeComponentStackByType(type) {
   if ("string" === typeof type) return describeBuiltInComponentFrame(type);
   if ("function" === typeof type)
@@ -5408,21 +5535,11 @@ function describeComponentStackByType(type) {
       return describeBuiltInComponentFrame("SuspenseList");
     case REACT_SUSPENSE_TYPE:
       return describeBuiltInComponentFrame("Suspense");
+    case REACT_VIEW_TRANSITION_TYPE:
+      return describeBuiltInComponentFrame("ViewTransition");
   }
   return "";
 }
-function getStackByComponentStackNode(componentStack) {
-  try {
-    var info = "";
-    do
-      (info += describeComponentStackByType(componentStack.type)),
-        (componentStack = componentStack.parent);
-    while (componentStack);
-    return info;
-  } catch (x) {
-    return "\nError generating stack: " + x.message + "\n" + x.stack;
-  }
-}
 var callComponent = {
     "react-stack-bottom-frame": function (Component, props, secondArg) {
       return Component(props, secondArg);
@@ -5506,7 +5623,7 @@ function RequestInstance(
   this.status = 10;
   this.fatalError = null;
   this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-  this.completedPreambleSegments = this.completedRootSegment = null;
+  this.completedRootSegment = null;
   this.abortableTasks = abortSet;
   this.pingedTasks = [];
   this.clientRenderedBoundaries = [];
@@ -5566,14 +5683,15 @@ function createRequest(
     null,
     renderState,
     null,
-    null,
     resumableState.abortableTasks,
     null,
     rootFormatContext,
     null,
     emptyTreeContext,
     null,
-    !1
+    !1,
+    emptyContextObject,
+    null
   );
   pushComponentStack(children);
   resumableState.pingedTasks.push(children);
@@ -5592,12 +5710,7 @@ function pingTask(request, task) {
           return performWork(request);
         }, 0));
 }
-function createSuspenseBoundary(
-  request,
-  fallbackAbortableTasks,
-  contentPreamble,
-  fallbackPreamble
-) {
+function createSuspenseBoundary(request, fallbackAbortableTasks) {
   return {
     status: PENDING,
     rootSegmentID: -1,
@@ -5609,8 +5722,6 @@ function createSuspenseBoundary(
     errorDigest: null,
     contentState: createHoistableState(),
     fallbackState: createHoistableState(),
-    contentPreamble: contentPreamble,
-    fallbackPreamble: fallbackPreamble,
     trackedContentKeyPath: null,
     trackedFallbackNode: null,
     errorMessage: null,
@@ -5625,7 +5736,6 @@ function createRenderTask(
   childIndex,
   blockedBoundary,
   blockedSegment,
-  blockedPreamble,
   hoistableState,
   abortSet,
   keyPath,
@@ -5633,7 +5743,9 @@ function createRenderTask(
   context,
   treeContext,
   componentStack,
-  isFallback
+  isFallback,
+  legacyContext,
+  debugTask
 ) {
   request.allPendingTasks++;
   null === blockedBoundary
@@ -5648,7 +5760,6 @@ function createRenderTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: blockedSegment,
-    blockedPreamble: blockedPreamble,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -5659,6 +5770,7 @@ function createRenderTask(
     thenableState: thenableState,
     isFallback: isFallback
   };
+  task.debugTask = debugTask;
   abortSet.add(task);
   return task;
 }
@@ -5676,7 +5788,9 @@ function createReplayTask(
   context,
   treeContext,
   componentStack,
-  isFallback
+  isFallback,
+  legacyContext,
+  debugTask
 ) {
   request.allPendingTasks++;
   null === blockedBoundary
@@ -5692,7 +5806,6 @@ function createReplayTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: null,
-    blockedPreamble: null,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -5703,6 +5816,7 @@ function createReplayTask(
     thenableState: thenableState,
     isFallback: isFallback
   };
+  task.debugTask = debugTask;
   abortSet.add(task);
   return task;
 }
@@ -5716,12 +5830,11 @@ function createPendingSegment(
 ) {
   return {
     status: PENDING,
-    parentFlushed: !1,
     id: -1,
     index: index,
+    parentFlushed: !1,
     chunks: [],
     children: [],
-    preambleChildren: [],
     parentFormatContext: parentFormatContext,
     boundary: boundary,
     lastPushedText: lastPushedText,
@@ -5729,21 +5842,63 @@ function createPendingSegment(
   };
 }
 function getCurrentStackInDEV() {
-  return null === currentTaskInDEV || null === currentTaskInDEV.componentStack
-    ? ""
-    : getStackByComponentStackNode(currentTaskInDEV.componentStack);
+  if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
+    return "";
+  var componentStack = currentTaskInDEV.componentStack;
+  try {
+    var info = "";
+    if ("string" === typeof componentStack.type)
+      info += describeBuiltInComponentFrame(componentStack.type);
+    else if ("function" === typeof componentStack.type) {
+      if (!componentStack.owner) {
+        var JSCompiler_temp_const = info,
+          fn = componentStack.type,
+          name = fn ? fn.displayName || fn.name : "";
+        var JSCompiler_inline_result = name
+          ? describeBuiltInComponentFrame(name)
+          : "";
+        info = JSCompiler_temp_const + JSCompiler_inline_result;
+      }
+    } else
+      componentStack.owner ||
+        (info += describeComponentStackByType(componentStack.type));
+    for (; componentStack; )
+      (JSCompiler_temp_const = null),
+        null != componentStack.debugStack
+          ? (JSCompiler_temp_const = formatOwnerStack(
+              componentStack.debugStack
+            ))
+          : ((JSCompiler_inline_result = componentStack),
+            null != JSCompiler_inline_result.stack &&
+              (JSCompiler_temp_const =
+                "string" !== typeof JSCompiler_inline_result.stack
+                  ? (JSCompiler_inline_result.stack = formatOwnerStack(
+                      JSCompiler_inline_result.stack
+                    ))
+                  : JSCompiler_inline_result.stack)),
+        (componentStack = componentStack.owner) &&
+          JSCompiler_temp_const &&
+          (info += "\n" + JSCompiler_temp_const);
+    var JSCompiler_inline_result$jscomp$0 = info;
+  } catch (x) {
+    JSCompiler_inline_result$jscomp$0 =
+      "\nError generating stack: " + x.message + "\n" + x.stack;
+  }
+  return JSCompiler_inline_result$jscomp$0;
 }
 function pushServerComponentStack(task, debugInfo) {
   if (null != debugInfo)
     for (var i = 0; i < debugInfo.length; i++) {
       var componentInfo = debugInfo[i];
       "string" === typeof componentInfo.name &&
-        (task.componentStack = {
+        void 0 !== componentInfo.debugStack &&
+        ((task.componentStack = {
           parent: task.componentStack,
           type: componentInfo,
           owner: componentInfo.owner,
-          stack: null
-        });
+          stack: componentInfo.debugStack
+        }),
+        (task.debugTask = componentInfo.debugTask));
     }
 }
 function pushComponentStack(task) {
@@ -5752,13 +5907,15 @@ function pushComponentStack(task) {
     switch (node.$$typeof) {
       case REACT_ELEMENT_TYPE:
         var type = node.type,
-          owner = node._owner;
+          owner = node._owner,
+          stack = node._debugStack;
         pushServerComponentStack(task, node._debugInfo);
+        task.debugTask = node._debugTask;
         task.componentStack = {
           parent: task.componentStack,
           type: type,
           owner: owner,
-          stack: null
+          stack: stack
         };
         break;
       case REACT_LAZY_TYPE:
@@ -5769,14 +5926,24 @@ function pushComponentStack(task) {
           pushServerComponentStack(task, node._debugInfo);
     }
 }
-function getThrownInfo(node) {
+function getThrownInfo(node$jscomp$0) {
   var errorInfo = {};
-  node &&
+  node$jscomp$0 &&
     Object.defineProperty(errorInfo, "componentStack", {
       configurable: !0,
       enumerable: !0,
       get: function () {
-        var stack = getStackByComponentStackNode(node);
+        try {
+          var info = "",
+            node = node$jscomp$0;
+          do
+            (info += describeComponentStackByType(node.type)),
+              (node = node.parent);
+          while (node);
+          var stack = info;
+        } catch (x) {
+          stack = "\nError generating stack: " + x.message + "\n" + x.stack;
+        }
         Object.defineProperty(errorInfo, "componentStack", { value: stack });
         return stack;
       }
@@ -5805,9 +5972,17 @@ function encodeErrorForBoundary(
   boundary.errorStack = null !== error ? wasAborted + error : null;
   boundary.errorComponentStack = thrownInfo.componentStack;
 }
-function logRecoverableError(request, error, errorInfo) {
+function logPostpone(request, reason, postponeInfo, debugTask) {
+  request = request.onPostpone;
+  debugTask
+    ? debugTask.run(request.bind(null, reason, postponeInfo))
+    : request(reason, postponeInfo);
+}
+function logRecoverableError(request, error, errorInfo, debugTask) {
   request = request.onError;
-  error = request(error, errorInfo);
+  error = debugTask
+    ? debugTask.run(request.bind(null, error, errorInfo))
+    : request(error, errorInfo);
   if (null != error && "string" !== typeof error)
     console.error(
       'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
@@ -5815,11 +5990,13 @@ function logRecoverableError(request, error, errorInfo) {
     );
   else return error;
 }
-function fatalError(request, error) {
-  var onShellError = request.onShellError,
-    onFatalError = request.onFatalError;
-  onShellError(error);
-  onFatalError(error);
+function fatalError(request, error, errorInfo, debugTask) {
+  errorInfo = request.onShellError;
+  var onFatalError = request.onFatalError;
+  debugTask
+    ? (debugTask.run(errorInfo.bind(null, error)),
+      debugTask.run(onFatalError.bind(null, error)))
+    : (errorInfo(error), onFatalError(error));
   null !== request.destination
     ? ((request.status = CLOSED), closeWithError(request.destination, error))
     : ((request.status = 13), (request.fatalError = error));
@@ -6322,7 +6499,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
         props,
         request.resumableState,
         request.renderState,
-        task.blockedPreamble,
         task.hoistableState,
         task.formatContext,
         segment.lastPushedText,
@@ -6331,40 +6507,9 @@ function renderElement(request, task, keyPath, type, props, ref) {
       segment.lastPushedText = !1;
       var _prevContext = task.formatContext,
         _prevKeyPath2 = task.keyPath;
+      task.formatContext = getChildFormatContext(_prevContext, type, props);
       task.keyPath = keyPath;
-      if (
-        (task.formatContext = getChildFormatContext(_prevContext, type, props))
-          .insertionMode === HTML_HEAD_MODE
-      ) {
-        var preambleSegment = createPendingSegment(
-          request,
-          0,
-          null,
-          task.formatContext,
-          !1,
-          !1
-        );
-        segment.preambleChildren.push(preambleSegment);
-        var preambleTask = createRenderTask(
-          request,
-          null,
-          _children,
-          -1,
-          task.blockedBoundary,
-          preambleSegment,
-          task.blockedPreamble,
-          task.hoistableState,
-          request.abortableTasks,
-          task.keyPath,
-          task.formatContext,
-          task.context,
-          task.treeContext,
-          task.componentStack,
-          task.isFallback
-        );
-        pushComponentStack(preambleTask);
-        request.pingedTasks.push(preambleTask);
-      } else renderNode(request, task, _children, -1);
+      renderNode(request, task, _children, -1);
       task.formatContext = _prevContext;
       task.keyPath = _prevKeyPath2;
       a: {
@@ -6401,9 +6546,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
               resumableState.hasHtml = !0;
               break a;
             }
-            break;
-          case "head":
-            if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;
         }
         target.push(endChunkForTag(type));
       }
@@ -6435,6 +6577,11 @@ function renderElement(request, task, keyPath, type, props, ref) {
         task.keyPath = _prevKeyPath3;
         return;
       case REACT_VIEW_TRANSITION_TYPE:
+        var _prevKeyPath4 = task.keyPath;
+        task.keyPath = keyPath;
+        renderNodeDestructive(request, task, props.children, -1);
+        task.keyPath = _prevKeyPath4;
+        return;
       case REACT_SCOPE_TYPE:
         throw Error("ReactDOMServer does not yet support scope components.");
       case REACT_SUSPENSE_TYPE:
@@ -6450,21 +6597,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
         } else {
           var prevKeyPath$jscomp$3 = task.keyPath,
             parentBoundary = task.blockedBoundary,
-            parentPreamble = task.blockedPreamble,
             parentHoistableState = task.hoistableState,
             parentSegment = task.blockedSegment,
             fallback = props.fallback,
             content = props.children,
-            fallbackAbortSet = new Set();
-          var newBoundary =
-            task.formatContext.insertionMode < HTML_MODE
-              ? createSuspenseBoundary(
-                  request,
-                  fallbackAbortSet,
-                  createPreambleState(),
-                  createPreambleState()
-                )
-              : createSuspenseBoundary(request, fallbackAbortSet, null, null);
+            fallbackAbortSet = new Set(),
+            newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
           null !== request.trackedPostpones &&
             (newBoundary.trackedContentKeyPath = keyPath);
           var boundarySegment = createPendingSegment(
@@ -6500,7 +6638,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
             );
             newBoundary.trackedFallbackNode = fallbackReplayNode;
             task.blockedSegment = boundarySegment;
-            task.blockedPreamble = newBoundary.fallbackPreamble;
             task.keyPath = fallbackKeyPath;
             boundarySegment.status = 6;
             try {
@@ -6516,7 +6653,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
               );
             } finally {
               (task.blockedSegment = parentSegment),
-                (task.blockedPreamble = parentPreamble),
                 (task.keyPath = prevKeyPath$jscomp$3);
             }
             var suspendedPrimaryTask = createRenderTask(
@@ -6526,7 +6662,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
               -1,
               newBoundary,
               contentRootSegment,
-              newBoundary.contentPreamble,
               newBoundary.contentState,
               task.abortSet,
               keyPath,
@@ -6534,13 +6669,14 @@ function renderElement(request, task, keyPath, type, props, ref) {
               task.context,
               task.treeContext,
               task.componentStack,
-              task.isFallback
+              task.isFallback,
+              emptyContextObject,
+              task.debugTask
             );
             pushComponentStack(suspendedPrimaryTask);
             request.pingedTasks.push(suspendedPrimaryTask);
           } else {
             task.blockedBoundary = newBoundary;
-            task.blockedPreamble = newBoundary.contentPreamble;
             task.hoistableState = newBoundary.contentState;
             task.blockedSegment = contentRootSegment;
             task.keyPath = keyPath;
@@ -6557,9 +6693,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
                   newBoundary.status === PENDING)
               ) {
                 newBoundary.status = COMPLETED;
-                0 === request.pendingRootTasks &&
-                  task.blockedPreamble &&
-                  preparePreamble(request);
                 break a;
               }
             } catch (thrownValue$2) {
@@ -6569,7 +6702,20 @@ function renderElement(request, task, keyPath, type, props, ref) {
                 var error = request.fatalError;
               } else (contentRootSegment.status = 4), (error = thrownValue$2);
               var thrownInfo = getThrownInfo(task.componentStack);
-              var errorDigest = logRecoverableError(request, error, thrownInfo);
+              if (
+                "object" === typeof error &&
+                null !== error &&
+                error.$$typeof === REACT_POSTPONE_TYPE
+              ) {
+                logPostpone(request, error.message, thrownInfo, task.debugTask);
+                var errorDigest = "POSTPONE";
+              } else
+                errorDigest = logRecoverableError(
+                  request,
+                  error,
+                  thrownInfo,
+                  task.debugTask
+                );
               encodeErrorForBoundary(
                 newBoundary,
                 errorDigest,
@@ -6580,7 +6726,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
               untrackBoundary(request, newBoundary);
             } finally {
               (task.blockedBoundary = parentBoundary),
-                (task.blockedPreamble = parentPreamble),
                 (task.hoistableState = parentHoistableState),
                 (task.blockedSegment = parentSegment),
                 (task.keyPath = prevKeyPath$jscomp$3);
@@ -6592,7 +6737,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
               -1,
               parentBoundary,
               boundarySegment,
-              newBoundary.fallbackPreamble,
               newBoundary.fallbackState,
               fallbackAbortSet,
               [keyPath[0], "Suspense Fallback", keyPath[2]],
@@ -6600,7 +6744,9 @@ function renderElement(request, task, keyPath, type, props, ref) {
               task.context,
               task.treeContext,
               task.componentStack,
-              !0
+              !0,
+              emptyContextObject,
+              task.debugTask
             );
             pushComponentStack(suspendedFallbackTask);
             request.pingedTasks.push(suspendedFallbackTask);
@@ -6752,15 +6898,177 @@ function resumeNode(request, task, segmentId, node, childIndex) {
     (task.replay = prevReplay), (task.blockedSegment = null);
   }
 }
+function replayElement(
+  request,
+  task,
+  keyPath,
+  name,
+  keyOrIndex,
+  childIndex,
+  type,
+  props,
+  ref,
+  replay
+) {
+  childIndex = replay.nodes;
+  for (var i = 0; i < childIndex.length; i++) {
+    var node = childIndex[i];
+    if (keyOrIndex === node[1]) {
+      if (4 === node.length) {
+        if (null !== name && name !== node[0])
+          throw Error(
+            "Expected the resume to render <" +
+              node[0] +
+              "> in this slot but instead it rendered <" +
+              name +
+              ">. The tree doesn't match so React will fallback to client rendering."
+          );
+        var childNodes = node[2];
+        node = node[3];
+        name = task.node;
+        task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
+        try {
+          renderElement(request, task, keyPath, type, props, ref);
+          if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
+            throw Error(
+              "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+            );
+          task.replay.pendingTasks--;
+        } catch (x) {
+          if (
+            "object" === typeof x &&
+            null !== x &&
+            (x === SuspenseException || "function" === typeof x.then)
+          )
+            throw (task.node === name && (task.replay = replay), x);
+          task.replay.pendingTasks--;
+          props = getThrownInfo(task.componentStack);
+          erroredReplay(
+            request,
+            task.blockedBoundary,
+            x,
+            props,
+            childNodes,
+            node,
+            task.debugTask
+          );
+        }
+        task.replay = replay;
+      } else {
+        if (type !== REACT_SUSPENSE_TYPE)
+          throw Error(
+            "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
+              (getComponentNameFromType(type) || "Unknown") +
+              ">. The tree doesn't match so React will fallback to client rendering."
+          );
+        a: {
+          replay = void 0;
+          type = node[5];
+          ref = node[2];
+          name = node[3];
+          keyOrIndex = null === node[4] ? [] : node[4][2];
+          node = null === node[4] ? null : node[4][3];
+          var prevKeyPath = task.keyPath,
+            previousReplaySet = task.replay,
+            parentBoundary = task.blockedBoundary,
+            parentHoistableState = task.hoistableState,
+            content = props.children;
+          props = props.fallback;
+          var fallbackAbortSet = new Set(),
+            resumedBoundary = createSuspenseBoundary(request, fallbackAbortSet);
+          resumedBoundary.parentFlushed = !0;
+          resumedBoundary.rootSegmentID = type;
+          task.blockedBoundary = resumedBoundary;
+          task.hoistableState = resumedBoundary.contentState;
+          task.keyPath = keyPath;
+          task.replay = { nodes: ref, slots: name, pendingTasks: 1 };
+          try {
+            renderNode(request, task, content, -1);
+            if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
+              throw Error(
+                "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+              );
+            task.replay.pendingTasks--;
+            if (
+              0 === resumedBoundary.pendingTasks &&
+              resumedBoundary.status === PENDING
+            ) {
+              resumedBoundary.status = COMPLETED;
+              request.completedBoundaries.push(resumedBoundary);
+              break a;
+            }
+          } catch (error) {
+            (resumedBoundary.status = CLIENT_RENDERED),
+              (childNodes = getThrownInfo(task.componentStack)),
+              "object" === typeof error &&
+              null !== error &&
+              error.$$typeof === REACT_POSTPONE_TYPE
+                ? (logPostpone(
+                    request,
+                    error.message,
+                    childNodes,
+                    task.debugTask
+                  ),
+                  (replay = "POSTPONE"))
+                : (replay = logRecoverableError(
+                    request,
+                    error,
+                    childNodes,
+                    task.debugTask
+                  )),
+              encodeErrorForBoundary(
+                resumedBoundary,
+                replay,
+                error,
+                childNodes,
+                !1
+              ),
+              task.replay.pendingTasks--,
+              request.clientRenderedBoundaries.push(resumedBoundary);
+          } finally {
+            (task.blockedBoundary = parentBoundary),
+              (task.hoistableState = parentHoistableState),
+              (task.replay = previousReplaySet),
+              (task.keyPath = prevKeyPath);
+          }
+          props = createReplayTask(
+            request,
+            null,
+            { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
+            props,
+            -1,
+            parentBoundary,
+            resumedBoundary.fallbackState,
+            fallbackAbortSet,
+            [keyPath[0], "Suspense Fallback", keyPath[2]],
+            task.formatContext,
+            task.context,
+            task.treeContext,
+            task.componentStack,
+            !0,
+            emptyContextObject,
+            task.debugTask
+          );
+          pushComponentStack(props);
+          request.pingedTasks.push(props);
+        }
+      }
+      childIndex.splice(i, 1);
+      break;
+    }
+  }
+}
 function renderNodeDestructive(request, task, node, childIndex) {
   null !== task.replay && "number" === typeof task.replay.slots
     ? resumeNode(request, task, task.replay.slots, node, childIndex)
     : ((task.node = node),
       (task.childIndex = childIndex),
       (node = task.componentStack),
+      (childIndex = task.debugTask),
       pushComponentStack(task),
       retryNode(request, task),
-      (task.componentStack = node));
+      (task.componentStack = node),
+      (task.debugTask = childIndex));
 }
 function retryNode(request, task) {
   var node = task.node,
@@ -6770,175 +7078,56 @@ function retryNode(request, task) {
       switch (node.$$typeof) {
         case REACT_ELEMENT_TYPE:
           var type = node.type,
-            key = node.key,
-            props = node.props;
-          node = props.ref;
-          var ref = void 0 !== node ? node : null,
-            name = getComponentNameFromType(type),
-            keyOrIndex =
-              null == key ? (-1 === childIndex ? 0 : childIndex) : key,
-            keyPath = [task.keyPath, name, keyOrIndex];
-          if (null !== task.replay) {
-            var replay = task.replay;
-            childIndex = replay.nodes;
-            for (node = 0; node < childIndex.length; node++)
-              if (((key = childIndex[node]), keyOrIndex === key[1])) {
-                if (4 === key.length) {
-                  if (null !== name && name !== key[0])
-                    throw Error(
-                      "Expected the resume to render <" +
-                        key[0] +
-                        "> in this slot but instead it rendered <" +
-                        name +
-                        ">. The tree doesn't match so React will fallback to client rendering."
-                    );
-                  var childNodes = key[2];
-                  key = key[3];
-                  name = task.node;
-                  task.replay = {
-                    nodes: childNodes,
-                    slots: key,
-                    pendingTasks: 1
-                  };
-                  try {
-                    renderElement(request, task, keyPath, type, props, ref);
-                    if (
-                      1 === task.replay.pendingTasks &&
-                      0 < task.replay.nodes.length
-                    )
-                      throw Error(
-                        "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                      );
-                    task.replay.pendingTasks--;
-                  } catch (x) {
-                    if (
-                      "object" === typeof x &&
-                      null !== x &&
-                      (x === SuspenseException || "function" === typeof x.then)
-                    )
-                      throw (task.node === name && (task.replay = replay), x);
-                    task.replay.pendingTasks--;
-                    props = getThrownInfo(task.componentStack);
-                    erroredReplay(
-                      request,
-                      task.blockedBoundary,
-                      x,
-                      props,
-                      childNodes,
-                      key
-                    );
-                  }
-                  task.replay = replay;
-                } else {
-                  if (type !== REACT_SUSPENSE_TYPE)
-                    throw Error(
-                      "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
-                        (getComponentNameFromType(type) || "Unknown") +
-                        ">. The tree doesn't match so React will fallback to client rendering."
-                    );
-                  a: {
-                    type = void 0;
-                    ref = key[5];
-                    replay = key[2];
-                    name = key[3];
-                    keyOrIndex = null === key[4] ? [] : key[4][2];
-                    key = null === key[4] ? null : key[4][3];
-                    var prevKeyPath = task.keyPath,
-                      previousReplaySet = task.replay,
-                      parentBoundary = task.blockedBoundary,
-                      parentHoistableState = task.hoistableState,
-                      content = props.children,
-                      fallback = props.fallback,
-                      fallbackAbortSet = new Set();
-                    props =
-                      task.formatContext.insertionMode < HTML_MODE
-                        ? createSuspenseBoundary(
-                            request,
-                            fallbackAbortSet,
-                            createPreambleState(),
-                            createPreambleState()
-                          )
-                        : createSuspenseBoundary(
-                            request,
-                            fallbackAbortSet,
-                            null,
-                            null
-                          );
-                    props.parentFlushed = !0;
-                    props.rootSegmentID = ref;
-                    task.blockedBoundary = props;
-                    task.hoistableState = props.contentState;
-                    task.keyPath = keyPath;
-                    task.replay = {
-                      nodes: replay,
-                      slots: name,
-                      pendingTasks: 1
-                    };
-                    try {
-                      renderNode(request, task, content, -1);
-                      if (
-                        1 === task.replay.pendingTasks &&
-                        0 < task.replay.nodes.length
-                      )
-                        throw Error(
-                          "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                        );
-                      task.replay.pendingTasks--;
-                      if (
-                        0 === props.pendingTasks &&
-                        props.status === PENDING
-                      ) {
-                        props.status = COMPLETED;
-                        request.completedBoundaries.push(props);
-                        break a;
-                      }
-                    } catch (error) {
-                      (props.status = CLIENT_RENDERED),
-                        (childNodes = getThrownInfo(task.componentStack)),
-                        (type = logRecoverableError(
-                          request,
-                          error,
-                          childNodes
-                        )),
-                        encodeErrorForBoundary(
-                          props,
-                          type,
-                          error,
-                          childNodes,
-                          !1
-                        ),
-                        task.replay.pendingTasks--,
-                        request.clientRenderedBoundaries.push(props);
-                    } finally {
-                      (task.blockedBoundary = parentBoundary),
-                        (task.hoistableState = parentHoistableState),
-                        (task.replay = previousReplaySet),
-                        (task.keyPath = prevKeyPath);
-                    }
-                    childNodes = createReplayTask(
-                      request,
-                      null,
-                      { nodes: keyOrIndex, slots: key, pendingTasks: 0 },
-                      fallback,
-                      -1,
-                      parentBoundary,
-                      props.fallbackState,
-                      fallbackAbortSet,
-                      [keyPath[0], "Suspense Fallback", keyPath[2]],
-                      task.formatContext,
-                      task.context,
-                      task.treeContext,
-                      task.componentStack,
-                      !0
-                    );
-                    pushComponentStack(childNodes);
-                    request.pingedTasks.push(childNodes);
-                  }
-                }
-                childIndex.splice(node, 1);
-                break;
-              }
-          } else renderElement(request, task, keyPath, type, props, ref);
+            key = node.key;
+          node = node.props;
+          var refProp = node.ref;
+          refProp = void 0 !== refProp ? refProp : null;
+          var debugTask = task.debugTask,
+            name = getComponentNameFromType(type);
+          key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;
+          var keyPath = [task.keyPath, name, key];
+          null !== task.replay
+            ? debugTask
+              ? debugTask.run(
+                  replayElement.bind(
+                    null,
+                    request,
+                    task,
+                    keyPath,
+                    name,
+                    key,
+                    childIndex,
+                    type,
+                    node,
+                    refProp,
+                    task.replay
+                  )
+                )
+              : replayElement(
+                  request,
+                  task,
+                  keyPath,
+                  name,
+                  key,
+                  childIndex,
+                  type,
+                  node,
+                  refProp,
+                  task.replay
+                )
+            : debugTask
+              ? debugTask.run(
+                  renderElement.bind(
+                    null,
+                    request,
+                    task,
+                    keyPath,
+                    type,
+                    node,
+                    refProp
+                  )
+                )
+              : renderElement(request, task, keyPath, type, node, refProp);
           return;
         case REACT_PORTAL_TYPE:
           throw Error(
@@ -6955,20 +7144,20 @@ function retryNode(request, task) {
         return;
       }
       null === node || "object" !== typeof node
-        ? (props = null)
-        : ((childNodes =
+        ? (key = null)
+        : ((type =
             (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||
             node["@@iterator"]),
-          (props = "function" === typeof childNodes ? childNodes : null));
-      if (props && (childNodes = props.call(node))) {
-        if (childNodes === node) {
+          (key = "function" === typeof type ? type : null));
+      if (key && (type = key.call(node))) {
+        if (type === node) {
           if (
             -1 !== childIndex ||
             null === task.componentStack ||
             "function" !== typeof task.componentStack.type ||
             "[object GeneratorFunction]" !==
               Object.prototype.toString.call(task.componentStack.type) ||
-            "[object Generator]" !== Object.prototype.toString.call(childNodes)
+            "[object Generator]" !== Object.prototype.toString.call(type)
           )
             didWarnAboutGenerators ||
               console.error(
@@ -6976,21 +7165,59 @@ function retryNode(request, task) {
               ),
               (didWarnAboutGenerators = !0);
         } else
-          node.entries !== props ||
+          node.entries !== key ||
             didWarnAboutMaps ||
             (console.error(
               "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
             ),
             (didWarnAboutMaps = !0));
-        node = childNodes.next();
+        node = type.next();
         if (!node.done) {
-          props = [];
-          do props.push(node.value), (node = childNodes.next());
+          key = [];
+          do key.push(node.value), (node = type.next());
           while (!node.done);
-          renderChildrenArray(request, task, props, childIndex);
+          renderChildrenArray(request, task, key, childIndex);
         }
         return;
       }
+      if (
+        "function" === typeof node[ASYNC_ITERATOR] &&
+        (type = node[ASYNC_ITERATOR]())
+      ) {
+        type !== node ||
+          (-1 === childIndex &&
+            null !== task.componentStack &&
+            "function" === typeof task.componentStack.type &&
+            "[object AsyncGeneratorFunction]" ===
+              Object.prototype.toString.call(task.componentStack.type) &&
+            "[object AsyncGenerator]" ===
+              Object.prototype.toString.call(type)) ||
+          (didWarnAboutGenerators ||
+            console.error(
+              "Using AsyncIterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You can use an AsyncIterable that can iterate multiple times over the same items."
+            ),
+          (didWarnAboutGenerators = !0));
+        key = task.thenableState;
+        task.thenableState = null;
+        thenableIndexCounter = 0;
+        thenableState = key;
+        key = [];
+        refProp = !1;
+        if (type === node)
+          for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+            if (node.done) {
+              refProp = !0;
+              break;
+            }
+            key.push(node.value);
+            node = readPreviousThenableFromState();
+          }
+        if (!refProp)
+          for (node = unwrapThenable(type.next()); !node.done; )
+            key.push(node.value), (node = unwrapThenable(type.next()));
+        renderChildrenArray(request, task, key, childIndex);
+        return;
+      }
       if ("function" === typeof node.then)
         return (
           (task.thenableState = null),
@@ -7003,39 +7230,39 @@ function retryNode(request, task) {
           node._currentValue,
           childIndex
         );
-      childIndex = Object.prototype.toString.call(node);
+      request = Object.prototype.toString.call(node);
       throw Error(
         "Objects are not valid as a React child (found: " +
-          ("[object Object]" === childIndex
+          ("[object Object]" === request
             ? "object with keys {" + Object.keys(node).join(", ") + "}"
-            : childIndex) +
+            : request) +
           "). If you meant to render a collection of children, use an array instead."
       );
     }
     "string" === typeof node
-      ? ((childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      ? ((task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           )))
       : "number" === typeof node || "bigint" === typeof node
-        ? ((childIndex = task.blockedSegment),
-          null !== childIndex &&
-            (childIndex.lastPushedText = pushTextInstance(
-              childIndex.chunks,
+        ? ((task = task.blockedSegment),
+          null !== task &&
+            (task.lastPushedText = pushTextInstance(
+              task.chunks,
               "" + node,
               request.renderState,
-              childIndex.lastPushedText
+              task.lastPushedText
             )))
         : ("function" === typeof node &&
-            ((childIndex = node.displayName || node.name || "Component"),
+            ((request = node.displayName || node.name || "Component"),
             console.error(
               "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
-              childIndex,
-              childIndex
+              request,
+              request
             )),
           "symbol" === typeof node &&
             console.error(
@@ -7047,6 +7274,7 @@ function retryNode(request, task) {
 function renderChildrenArray(request$jscomp$0, task, children, childIndex) {
   var prevKeyPath = task.keyPath,
     previousComponentStack = task.componentStack;
+  var previousDebugTask = task.debugTask;
   pushServerComponentStack(task, task.node._debugInfo);
   if (
     -1 !== childIndex &&
@@ -7085,7 +7313,8 @@ function renderChildrenArray(request$jscomp$0, task, children, childIndex) {
             x,
             children,
             childIndex,
-            node
+            node,
+            task.debugTask
           );
         }
         task.replay = replay;
@@ -7095,6 +7324,7 @@ function renderChildrenArray(request$jscomp$0, task, children, childIndex) {
     }
     task.keyPath = prevKeyPath;
     task.componentStack = previousComponentStack;
+    task.debugTask = previousDebugTask;
     return;
   }
   replay = task.treeContext;
@@ -7121,6 +7351,7 @@ function renderChildrenArray(request$jscomp$0, task, children, childIndex) {
     task.treeContext = replay;
     task.keyPath = prevKeyPath;
     task.componentStack = previousComponentStack;
+    task.debugTask = previousDebugTask;
     return;
   }
   for (j = 0; j < replayNodes; j++) {
@@ -7178,7 +7409,7 @@ function renderChildrenArray(request$jscomp$0, task, children, childIndex) {
           parent: node.componentStack,
           type: resumeSegmentID.type,
           owner: resumeSegmentID._owner,
-          stack: null
+          stack: resumeSegmentID._debugStack
         };
         console.error(
           'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
@@ -7194,6 +7425,106 @@ function renderChildrenArray(request$jscomp$0, task, children, childIndex) {
   task.treeContext = replay;
   task.keyPath = prevKeyPath;
   task.componentStack = previousComponentStack;
+  task.debugTask = previousDebugTask;
+}
+function trackPostpone(request, trackedPostpones, task, segment) {
+  segment.status = POSTPONED;
+  var keyPath = task.keyPath,
+    boundary = task.blockedBoundary;
+  if (null === boundary)
+    (segment.id = request.nextSegmentId++),
+      (trackedPostpones.rootSlots = segment.id),
+      null !== request.completedRootSegment &&
+        (request.completedRootSegment.status = POSTPONED);
+  else {
+    if (null !== boundary && boundary.status === PENDING) {
+      boundary.status = POSTPONED;
+      boundary.rootSegmentID = request.nextSegmentId++;
+      var boundaryKeyPath = boundary.trackedContentKeyPath;
+      if (null === boundaryKeyPath)
+        throw Error(
+          "It should not be possible to postpone at the root. This is a bug in React."
+        );
+      var fallbackReplayNode = boundary.trackedFallbackNode,
+        children = [];
+      if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+        -1 === segment.id &&
+          (segment.id = segment.parentFlushed
+            ? boundary.rootSegmentID
+            : request.nextSegmentId++);
+        segment = [
+          boundaryKeyPath[1],
+          boundaryKeyPath[2],
+          children,
+          segment.id,
+          fallbackReplayNode,
+          boundary.rootSegmentID
+        ];
+        trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+        addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+        return;
+      }
+      var _boundaryNode = trackedPostpones.workingMap.get(boundaryKeyPath);
+      void 0 === _boundaryNode
+        ? ((_boundaryNode = [
+            boundaryKeyPath[1],
+            boundaryKeyPath[2],
+            children,
+            null,
+            fallbackReplayNode,
+            boundary.rootSegmentID
+          ]),
+          trackedPostpones.workingMap.set(boundaryKeyPath, _boundaryNode),
+          addToReplayParent(
+            _boundaryNode,
+            boundaryKeyPath[0],
+            trackedPostpones
+          ))
+        : ((boundaryKeyPath = _boundaryNode),
+          (boundaryKeyPath[4] = fallbackReplayNode),
+          (boundaryKeyPath[5] = boundary.rootSegmentID));
+    }
+    -1 === segment.id &&
+      (segment.id =
+        segment.parentFlushed && null !== boundary
+          ? boundary.rootSegmentID
+          : request.nextSegmentId++);
+    if (-1 === task.childIndex)
+      null === keyPath
+        ? (trackedPostpones.rootSlots = segment.id)
+        : ((task = trackedPostpones.workingMap.get(keyPath)),
+          void 0 === task
+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+              addToReplayParent(task, keyPath[0], trackedPostpones))
+            : (task[3] = segment.id));
+    else {
+      if (null === keyPath)
+        if (((request = trackedPostpones.rootSlots), null === request))
+          request = trackedPostpones.rootSlots = {};
+        else {
+          if ("number" === typeof request)
+            throw Error(
+              "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+            );
+        }
+      else if (
+        ((boundary = trackedPostpones.workingMap),
+        (boundaryKeyPath = boundary.get(keyPath)),
+        void 0 === boundaryKeyPath)
+      )
+        (request = {}),
+          (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+          boundary.set(keyPath, boundaryKeyPath),
+          addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+      else if (((request = boundaryKeyPath[3]), null === request))
+        request = boundaryKeyPath[3] = {};
+      else if ("number" === typeof request)
+        throw Error(
+          "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+        );
+      request[task.childIndex] = segment.id;
+    }
+  }
 }
 function untrackBoundary(request, boundary) {
   request = request.trackedPostpones;
@@ -7219,7 +7550,9 @@ function spawnNewSuspendedReplayTask(request, task, thenableState) {
     task.context,
     task.treeContext,
     task.componentStack,
-    task.isFallback
+    task.isFallback,
+    emptyContextObject,
+    task.debugTask
   );
 }
 function spawnNewSuspendedRenderTask(request, task, thenableState) {
@@ -7241,7 +7574,6 @@ function spawnNewSuspendedRenderTask(request, task, thenableState) {
     task.childIndex,
     task.blockedBoundary,
     newSegment,
-    task.blockedPreamble,
     task.hoistableState,
     task.abortSet,
     task.keyPath,
@@ -7249,7 +7581,9 @@ function spawnNewSuspendedRenderTask(request, task, thenableState) {
     task.context,
     task.treeContext,
     task.componentStack,
-    task.isFallback
+    task.isFallback,
+    emptyContextObject,
+    task.debugTask
   );
 }
 function renderNode(request, task, node, childIndex) {
@@ -7258,6 +7592,7 @@ function renderNode(request, task, node, childIndex) {
     previousKeyPath = task.keyPath,
     previousTreeContext = task.treeContext,
     previousComponentStack = task.componentStack,
+    previousDebugTask = task.debugTask,
     segment = task.blockedSegment;
   if (null === segment)
     try {
@@ -7265,13 +7600,14 @@ function renderNode(request, task, node, childIndex) {
     } catch (thrownValue) {
       if (
         (resetHooksState(),
-        (node =
+        (childIndex =
           thrownValue === SuspenseException
             ? getSuspendedThenable()
             : thrownValue),
-        "object" === typeof node && null !== node)
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -7280,10 +7616,11 @@ function renderNode(request, task, node, childIndex) {
           task.keyPath = previousKeyPath;
           task.treeContext = previousTreeContext;
           task.componentStack = previousComponentStack;
+          task.debugTask = previousDebugTask;
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedReplayTask(request, task, node);
           request.pingedTasks.push(node);
@@ -7292,6 +7629,7 @@ function renderNode(request, task, node, childIndex) {
           task.keyPath = previousKeyPath;
           task.treeContext = previousTreeContext;
           task.componentStack = previousComponentStack;
+          task.debugTask = previousDebugTask;
           switchContext(previousContext);
           return;
         }
@@ -7307,13 +7645,14 @@ function renderNode(request, task, node, childIndex) {
         (resetHooksState(),
         (segment.children.length = childrenLength),
         (segment.chunks.length = chunkLength),
-        (node =
+        (childIndex =
           thrownValue$3 === SuspenseException
             ? getSuspendedThenable()
             : thrownValue$3),
-        "object" === typeof node && null !== node)
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -7322,10 +7661,40 @@ function renderNode(request, task, node, childIndex) {
           task.keyPath = previousKeyPath;
           task.treeContext = previousTreeContext;
           task.componentStack = previousComponentStack;
+          task.debugTask = previousDebugTask;
+          switchContext(previousContext);
+          return;
+        }
+        if (
+          childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+          null !== request.trackedPostpones &&
+          null !== task.blockedBoundary
+        ) {
+          node = request.trackedPostpones;
+          segment = getThrownInfo(task.componentStack);
+          logPostpone(request, childIndex.message, segment, task.debugTask);
+          childIndex = task.blockedSegment;
+          segment = createPendingSegment(
+            request,
+            childIndex.chunks.length,
+            null,
+            task.formatContext,
+            childIndex.lastPushedText,
+            !0
+          );
+          childIndex.children.push(segment);
+          childIndex.lastPushedText = !1;
+          trackPostpone(request, node, task, segment);
+          task.formatContext = previousFormatContext;
+          task.context = previousContext;
+          task.keyPath = previousKeyPath;
+          task.treeContext = previousTreeContext;
+          task.componentStack = previousComponentStack;
+          task.debugTask = previousDebugTask;
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedRenderTask(request, task, node);
           request.pingedTasks.push(node);
@@ -7334,6 +7703,7 @@ function renderNode(request, task, node, childIndex) {
           task.keyPath = previousKeyPath;
           task.treeContext = previousTreeContext;
           task.componentStack = previousComponentStack;
+          task.debugTask = previousDebugTask;
           switchContext(previousContext);
           return;
         }
@@ -7345,7 +7715,7 @@ function renderNode(request, task, node, childIndex) {
   task.keyPath = previousKeyPath;
   task.treeContext = previousTreeContext;
   switchContext(previousContext);
-  throw node;
+  throw childIndex;
 }
 function erroredReplay(
   request,
@@ -7353,16 +7723,22 @@ function erroredReplay(
   error,
   errorInfo,
   replayNodes,
-  resumeSlots
+  resumeSlots,
+  debugTask
 ) {
-  var errorDigest = logRecoverableError(request, error, errorInfo);
+  "object" === typeof error &&
+  null !== error &&
+  error.$$typeof === REACT_POSTPONE_TYPE
+    ? (logPostpone(request, error.message, errorInfo, debugTask),
+      (debugTask = "POSTPONE"))
+    : (debugTask = logRecoverableError(request, error, errorInfo, debugTask));
   abortRemainingReplayNodes(
     request,
     boundary,
     replayNodes,
     resumeSlots,
     error,
-    errorDigest,
+    debugTask,
     errorInfo,
     !1
   );
@@ -7402,12 +7778,7 @@ function abortRemainingReplayNodes(
         errorDigest = errorDigest$jscomp$0,
         errorInfo = errorInfo$jscomp$0,
         wasAborted = aborted,
-        resumedBoundary = createSuspenseBoundary(
-          request,
-          new Set(),
-          null,
-          null
-        );
+        resumedBoundary = createSuspenseBoundary(request, new Set());
       resumedBoundary.parentFlushed = !0;
       resumedBoundary.rootSegmentID = node;
       resumedBoundary.status = CLIENT_RENDERED;
@@ -7449,19 +7820,43 @@ function abortTask(task, request, error) {
     if (6 === segment.status) return;
     segment.status = 3;
   }
-  segment = getThrownInfo(task.componentStack);
+  var errorInfo = getThrownInfo(task.componentStack);
   if (null === boundary) {
     if (13 !== request.status && request.status !== CLOSED) {
       boundary = task.replay;
       if (null === boundary) {
-        logRecoverableError(request, error, segment);
-        fatalError(request, error);
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? ((boundary = request.trackedPostpones),
+            null !== boundary && null !== segment
+              ? (logPostpone(request, error.message, errorInfo, null),
+                trackPostpone(request, boundary, task, segment),
+                finishedTask(request, null, segment))
+              : ((task = Error(
+                  "The render was aborted with postpone when the shell is incomplete. Reason: " +
+                    error.message
+                )),
+                logRecoverableError(request, task, errorInfo, null),
+                fatalError(request, task, errorInfo, null)))
+          : null !== request.trackedPostpones && null !== segment
+            ? ((boundary = request.trackedPostpones),
+              logRecoverableError(request, error, errorInfo, null),
+              trackPostpone(request, boundary, task, segment),
+              finishedTask(request, null, segment))
+            : (logRecoverableError(request, error, errorInfo, null),
+              fatalError(request, error, errorInfo, null));
         return;
       }
       boundary.pendingTasks--;
       0 === boundary.pendingTasks &&
         0 < boundary.nodes.length &&
-        ((task = logRecoverableError(request, error, segment)),
+        ("object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? (logPostpone(request, error.message, errorInfo, null),
+            (task = "POSTPONE"))
+          : (task = logRecoverableError(request, error, errorInfo, null)),
         abortRemainingReplayNodes(
           request,
           null,
@@ -7469,26 +7864,58 @@ function abortTask(task, request, error) {
           boundary.slots,
           error,
           task,
-          segment,
+          errorInfo,
           !0
         ));
       request.pendingRootTasks--;
       0 === request.pendingRootTasks && completeShell(request);
     }
-  } else
-    boundary.pendingTasks--,
-      boundary.status !== CLIENT_RENDERED &&
-        ((boundary.status = CLIENT_RENDERED),
-        (task = logRecoverableError(request, error, segment)),
-        (boundary.status = CLIENT_RENDERED),
-        encodeErrorForBoundary(boundary, task, error, segment, !0),
-        untrackBoundary(request, boundary),
-        boundary.parentFlushed &&
-          request.clientRenderedBoundaries.push(boundary)),
-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-        return abortTask(fallbackTask, request, error);
-      }),
-      boundary.fallbackAbortableTasks.clear();
+  } else {
+    boundary.pendingTasks--;
+    var _trackedPostpones2 = request.trackedPostpones;
+    if (boundary.status !== CLIENT_RENDERED) {
+      if (null !== _trackedPostpones2 && null !== segment)
+        return (
+          "object" === typeof error &&
+          null !== error &&
+          error.$$typeof === REACT_POSTPONE_TYPE
+            ? logPostpone(request, error.message, errorInfo, null)
+            : logRecoverableError(request, error, errorInfo, null),
+          trackPostpone(request, _trackedPostpones2, task, segment),
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          }),
+          boundary.fallbackAbortableTasks.clear(),
+          finishedTask(request, boundary, segment)
+        );
+      boundary.status = CLIENT_RENDERED;
+      if (
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+      ) {
+        logPostpone(request, error.message, errorInfo, null);
+        if (null !== request.trackedPostpones && null !== segment) {
+          trackPostpone(request, request.trackedPostpones, task, segment);
+          finishedTask(request, task.blockedBoundary, segment);
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          });
+          boundary.fallbackAbortableTasks.clear();
+          return;
+        }
+        task = "POSTPONE";
+      } else task = logRecoverableError(request, error, errorInfo, null);
+      boundary.status = CLIENT_RENDERED;
+      encodeErrorForBoundary(boundary, task, error, errorInfo, !0);
+      untrackBoundary(request, boundary);
+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
+    }
+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+      return abortTask(fallbackTask, request, error);
+    });
+    boundary.fallbackAbortableTasks.clear();
+  }
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
@@ -7550,12 +7977,11 @@ function safelyEmitEarlyPreloads(request, shellComplete) {
       }
     }
   } catch (error) {
-    logRecoverableError(request, error, {});
+    logRecoverableError(request, error, {}, null);
   }
 }
 function completeShell(request) {
   null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-  null === request.trackedPostpones && preparePreamble(request);
   request.onShellError = noop;
   request = request.onShellReady;
   request();
@@ -7568,7 +7994,6 @@ function completeAll(request) {
       : null === request.completedRootSegment ||
           request.completedRootSegment.status !== POSTPONED
   );
-  preparePreamble(request);
   request = request.onAllReady;
   request();
 }
@@ -7610,11 +8035,7 @@ function finishedTask(request, boundary, segment) {
               request.completedBoundaries.push(boundary),
             boundary.status === COMPLETED &&
               (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),
-              boundary.fallbackAbortableTasks.clear(),
-              0 === request.pendingRootTasks &&
-                null === request.trackedPostpones &&
-                null !== boundary.contentPreamble &&
-                preparePreamble(request)))
+              boundary.fallbackAbortableTasks.clear()))
           : null !== segment &&
             segment.parentFlushed &&
             segment.status === COMPLETED &&
@@ -7699,7 +8120,8 @@ function performWork(request$jscomp$1) {
                     : x,
                   errorInfo,
                   request.replay.nodes,
-                  request.replay.slots
+                  request.replay.slots,
+                  request.debugTask
                 );
                 request$jscomp$0.pendingRootTasks--;
                 0 === request$jscomp$0.pendingRootTasks &&
@@ -7712,94 +8134,171 @@ function performWork(request$jscomp$1) {
               currentTaskInDEV = prevTaskInDEV;
             }
           }
-        } else {
-          request$jscomp$0 = prevTaskInDEV = void 0;
-          var task$jscomp$0 = task,
-            segment$jscomp$0 = segment;
-          if (segment$jscomp$0.status === PENDING) {
-            segment$jscomp$0.status = 6;
-            switchContext(task$jscomp$0.context);
-            request$jscomp$0 = currentTaskInDEV;
-            currentTaskInDEV = task$jscomp$0;
-            var childrenLength = segment$jscomp$0.children.length,
-              chunkLength = segment$jscomp$0.chunks.length;
-            try {
-              retryNode(request, task$jscomp$0),
-                segment$jscomp$0.lastPushedText &&
-                  segment$jscomp$0.textEmbedded &&
-                  segment$jscomp$0.chunks.push("\x3c!-- --\x3e"),
-                task$jscomp$0.abortSet.delete(task$jscomp$0),
-                (segment$jscomp$0.status = COMPLETED),
-                finishedTask(
-                  request,
-                  task$jscomp$0.blockedBoundary,
-                  segment$jscomp$0
-                );
-            } catch (thrownValue) {
-              resetHooksState();
-              segment$jscomp$0.children.length = childrenLength;
-              segment$jscomp$0.chunks.length = chunkLength;
-              var x$jscomp$0 =
-                thrownValue === SuspenseException
-                  ? getSuspendedThenable()
-                  : 12 === request.status
-                    ? request.fatalError
-                    : thrownValue;
-              if (
-                "object" === typeof x$jscomp$0 &&
-                null !== x$jscomp$0 &&
-                "function" === typeof x$jscomp$0.then
-              ) {
-                segment$jscomp$0.status = PENDING;
-                task$jscomp$0.thenableState = getThenableStateAfterSuspending();
-                var ping$jscomp$0 = task$jscomp$0.ping;
-                x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-              } else {
-                var errorInfo$jscomp$0 = getThrownInfo(
-                  task$jscomp$0.componentStack
-                );
-                task$jscomp$0.abortSet.delete(task$jscomp$0);
-                segment$jscomp$0.status = 4;
-                var boundary = task$jscomp$0.blockedBoundary;
-                prevTaskInDEV = logRecoverableError(
-                  request,
-                  x$jscomp$0,
-                  errorInfo$jscomp$0
-                );
-                null === boundary
-                  ? fatalError(request, x$jscomp$0)
-                  : (boundary.pendingTasks--,
-                    boundary.status !== CLIENT_RENDERED &&
-                      ((boundary.status = CLIENT_RENDERED),
-                      encodeErrorForBoundary(
-                        boundary,
-                        prevTaskInDEV,
+        } else
+          a: {
+            request$jscomp$0 = prevTaskInDEV = void 0;
+            var task$jscomp$0 = task,
+              segment$jscomp$0 = segment;
+            if (segment$jscomp$0.status === PENDING) {
+              segment$jscomp$0.status = 6;
+              switchContext(task$jscomp$0.context);
+              request$jscomp$0 = currentTaskInDEV;
+              currentTaskInDEV = task$jscomp$0;
+              var childrenLength = segment$jscomp$0.children.length,
+                chunkLength = segment$jscomp$0.chunks.length;
+              try {
+                retryNode(request, task$jscomp$0),
+                  segment$jscomp$0.lastPushedText &&
+                    segment$jscomp$0.textEmbedded &&
+                    segment$jscomp$0.chunks.push("\x3c!-- --\x3e"),
+                  task$jscomp$0.abortSet.delete(task$jscomp$0),
+                  (segment$jscomp$0.status = COMPLETED),
+                  finishedTask(
+                    request,
+                    task$jscomp$0.blockedBoundary,
+                    segment$jscomp$0
+                  );
+              } catch (thrownValue) {
+                resetHooksState();
+                segment$jscomp$0.children.length = childrenLength;
+                segment$jscomp$0.chunks.length = chunkLength;
+                var x$jscomp$0 =
+                  thrownValue === SuspenseException
+                    ? getSuspendedThenable()
+                    : 12 === request.status
+                      ? request.fatalError
+                      : thrownValue;
+                if (
+                  12 === request.status &&
+                  null !== request.trackedPostpones
+                ) {
+                  var trackedPostpones = request.trackedPostpones,
+                    thrownInfo = getThrownInfo(task$jscomp$0.componentStack);
+                  task$jscomp$0.abortSet.delete(task$jscomp$0);
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? logPostpone(
+                        request,
+                        x$jscomp$0.message,
+                        thrownInfo,
+                        task$jscomp$0.debugTask
+                      )
+                    : logRecoverableError(
+                        request,
                         x$jscomp$0,
+                        thrownInfo,
+                        task$jscomp$0.debugTask
+                      );
+                  trackPostpone(
+                    request,
+                    trackedPostpones,
+                    task$jscomp$0,
+                    segment$jscomp$0
+                  );
+                  finishedTask(
+                    request,
+                    task$jscomp$0.blockedBoundary,
+                    segment$jscomp$0
+                  );
+                } else {
+                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0) {
+                    if ("function" === typeof x$jscomp$0.then) {
+                      segment$jscomp$0.status = PENDING;
+                      task$jscomp$0.thenableState =
+                        getThenableStateAfterSuspending();
+                      var ping$jscomp$0 = task$jscomp$0.ping;
+                      x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                      break a;
+                    }
+                    if (
+                      null !== request.trackedPostpones &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ) {
+                      var _trackedPostpones3 = request.trackedPostpones;
+                      task$jscomp$0.abortSet.delete(task$jscomp$0);
+                      var postponeInfo = getThrownInfo(
+                        task$jscomp$0.componentStack
+                      );
+                      logPostpone(
+                        request,
+                        x$jscomp$0.message,
+                        postponeInfo,
+                        task$jscomp$0.debugTask
+                      );
+                      trackPostpone(
+                        request,
+                        _trackedPostpones3,
+                        task$jscomp$0,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task$jscomp$0.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                      break a;
+                    }
+                  }
+                  var errorInfo$jscomp$0 = getThrownInfo(
+                    task$jscomp$0.componentStack
+                  );
+                  task$jscomp$0.abortSet.delete(task$jscomp$0);
+                  segment$jscomp$0.status = 4;
+                  var boundary = task$jscomp$0.blockedBoundary,
+                    debugTask = task$jscomp$0.debugTask;
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        x$jscomp$0.message,
                         errorInfo$jscomp$0,
-                        !1
+                        debugTask
                       ),
-                      untrackBoundary(request, boundary),
-                      boundary.parentFlushed &&
-                        request.clientRenderedBoundaries.push(boundary),
-                      0 === request.pendingRootTasks &&
-                        null === request.trackedPostpones &&
-                        null !== boundary.contentPreamble &&
-                        preparePreamble(request)));
-                request.allPendingTasks--;
-                0 === request.allPendingTasks && completeAll(request);
+                      (prevTaskInDEV = "POSTPONE"))
+                    : (prevTaskInDEV = logRecoverableError(
+                        request,
+                        x$jscomp$0,
+                        errorInfo$jscomp$0,
+                        debugTask
+                      ));
+                  null === boundary
+                    ? fatalError(
+                        request,
+                        x$jscomp$0,
+                        errorInfo$jscomp$0,
+                        debugTask
+                      )
+                    : (boundary.pendingTasks--,
+                      boundary.status !== CLIENT_RENDERED &&
+                        ((boundary.status = CLIENT_RENDERED),
+                        encodeErrorForBoundary(
+                          boundary,
+                          prevTaskInDEV,
+                          x$jscomp$0,
+                          errorInfo$jscomp$0,
+                          !1
+                        ),
+                        untrackBoundary(request, boundary),
+                        boundary.parentFlushed &&
+                          request.clientRenderedBoundaries.push(boundary)));
+                  request.allPendingTasks--;
+                  0 === request.allPendingTasks && completeAll(request);
+                }
+              } finally {
+                currentTaskInDEV = request$jscomp$0;
               }
-            } finally {
-              currentTaskInDEV = request$jscomp$0;
             }
           }
-        }
       }
       pingedTasks.splice(0, i);
       null !== request$jscomp$1.destination &&
         flushCompletedQueues(request$jscomp$1, request$jscomp$1.destination);
     } catch (error) {
-      logRecoverableError(request$jscomp$1, error, {}),
-        fatalError(request$jscomp$1, error);
+      (pingedTasks = {}),
+        logRecoverableError(request$jscomp$1, error, pingedTasks, null),
+        fatalError(request$jscomp$1, error, pingedTasks, null);
     } finally {
       (currentResumableState = prevResumableState),
         (ReactSharedInternals.H = prevDispatcher),
@@ -7810,85 +8309,6 @@ function performWork(request$jscomp$1) {
     }
   }
 }
-function preparePreambleFromSubtree(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  segment.preambleChildren.length &&
-    collectedPreambleSegments.push(segment.preambleChildren);
-  for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-    pendingPreambles =
-      preparePreambleFromSegment(
-        request,
-        segment.children[i],
-        collectedPreambleSegments
-      ) || pendingPreambles;
-  return pendingPreambles;
-}
-function preparePreambleFromSegment(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  var boundary = segment.boundary;
-  if (null === boundary)
-    return preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    );
-  var preamble = boundary.contentPreamble,
-    fallbackPreamble = boundary.fallbackPreamble;
-  if (null === preamble || null === fallbackPreamble) return !1;
-  switch (boundary.status) {
-    case COMPLETED:
-      hoistPreambleState(request.renderState, preamble);
-      segment = boundary.completedSegments[0];
-      if (!segment)
-        throw Error(
-          "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
-        );
-      return preparePreambleFromSubtree(
-        request,
-        segment,
-        collectedPreambleSegments
-      );
-    case POSTPONED:
-      if (null !== request.trackedPostpones) return !0;
-    case CLIENT_RENDERED:
-      if (segment.status === COMPLETED)
-        return (
-          hoistPreambleState(request.renderState, fallbackPreamble),
-          preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          )
-        );
-    default:
-      return !0;
-  }
-}
-function preparePreamble(request) {
-  if (
-    request.completedRootSegment &&
-    null === request.completedPreambleSegments
-  ) {
-    var collectedPreambleSegments = [],
-      hasPendingPreambles = preparePreambleFromSegment(
-        request,
-        request.completedRootSegment,
-        collectedPreambleSegments
-      ),
-      preamble = request.renderState.preamble;
-    if (
-      !1 === hasPendingPreambles ||
-      (preamble.headChunks && preamble.bodyChunks)
-    )
-      request.completedPreambleSegments = collectedPreambleSegments;
-  }
-}
 function flushSubtree(request, destination, segment, hoistableState) {
   segment.parentFlushed = !0;
   switch (segment.status) {
@@ -8045,37 +8465,53 @@ function flushCompletedBoundary(request, destination, boundary) {
   boundary = boundary.contentState;
   var requiresStyleInsertion = request.stylesToHoist;
   request.stylesToHoist = !1;
-  writeChunk(destination, request.startInlineScript);
-  requiresStyleInsertion
-    ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-      NothingSent
-      ? ((completedSegments.instructions =
-          completedSegments.instructions |
-          SentStyleInsertionFunction |
-          SentCompleteBoundaryFunction),
-        writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))
-      : (completedSegments.instructions & SentStyleInsertionFunction) ===
+  var scriptFormat =
+    completedSegments.streamingFormat === ScriptStreamingFormat;
+  scriptFormat
+    ? (writeChunk(destination, request.startInlineScript),
+      requiresStyleInsertion
+        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===
           NothingSent
-        ? ((completedSegments.instructions |= SentStyleInsertionFunction),
-          writeChunk(destination, completeBoundaryWithStylesScript1FullPartial))
-        : writeChunk(destination, completeBoundaryWithStylesScript1Partial)
-    : (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-        NothingSent
-      ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),
-        writeChunk(destination, completeBoundaryScript1Full))
-      : writeChunk(destination, completeBoundaryScript1Partial);
+          ? ((completedSegments.instructions =
+              completedSegments.instructions |
+              SentStyleInsertionFunction |
+              SentCompleteBoundaryFunction),
+            writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))
+          : (completedSegments.instructions & SentStyleInsertionFunction) ===
+              NothingSent
+            ? ((completedSegments.instructions |= SentStyleInsertionFunction),
+              writeChunk(
+                destination,
+                completeBoundaryWithStylesScript1FullPartial
+              ))
+            : writeChunk(destination, completeBoundaryWithStylesScript1Partial)
+        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===
+            NothingSent
+          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),
+            writeChunk(destination, completeBoundaryScript1Full))
+          : writeChunk(destination, completeBoundaryScript1Partial))
+    : requiresStyleInsertion
+      ? writeChunk(destination, completeBoundaryWithStylesData1)
+      : writeChunk(destination, completeBoundaryData1);
   completedSegments = i.toString(16);
   writeChunk(destination, request.boundaryPrefix);
   writeChunk(destination, completedSegments);
-  writeChunk(destination, completeBoundaryScript2);
+  scriptFormat
+    ? writeChunk(destination, completeBoundaryScript2)
+    : writeChunk(destination, completeBoundaryData2);
   writeChunk(destination, request.segmentPrefix);
   writeChunk(destination, completedSegments);
   requiresStyleInsertion
-    ? (writeChunk(destination, completeBoundaryScript3a),
-      writeStyleResourceDependenciesInJS(destination, boundary))
-    : writeChunk(destination, completeBoundaryScript3b);
-  boundary = !!destination.write(completeBoundaryScriptEnd);
-  return writeBootstrap(destination, request) && boundary;
+    ? scriptFormat
+      ? (writeChunk(destination, completeBoundaryScript3a),
+        writeStyleResourceDependenciesInJS(destination, boundary))
+      : (writeChunk(destination, completeBoundaryData3a),
+        writeStyleResourceDependenciesInAttr(destination, boundary))
+    : scriptFormat && writeChunk(destination, completeBoundaryScript3b);
+  completedSegments = scriptFormat
+    ? !!destination.write(completeBoundaryScriptEnd)
+    : !!destination.write(completeBoundaryDataEnd);
+  return writeBootstrap(destination, request) && completedSegments;
 }
 function flushPartiallyCompletedSegment(
   request,
@@ -8098,18 +8534,24 @@ function flushPartiallyCompletedSegment(
   flushSegmentContainer(request, destination, segment, hoistableState);
   boundary = request.resumableState;
   request = request.renderState;
-  writeChunk(destination, request.startInlineScript);
-  (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
-    ? ((boundary.instructions |= SentCompleteSegmentFunction),
-      writeChunk(destination, completeSegmentScript1Full))
-    : writeChunk(destination, completeSegmentScript1Partial);
+  (segment = boundary.streamingFormat === ScriptStreamingFormat)
+    ? (writeChunk(destination, request.startInlineScript),
+      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
+        ? ((boundary.instructions |= SentCompleteSegmentFunction),
+          writeChunk(destination, completeSegmentScript1Full))
+        : writeChunk(destination, completeSegmentScript1Partial))
+    : writeChunk(destination, completeSegmentData1);
   writeChunk(destination, request.segmentPrefix);
   segmentID = segmentID.toString(16);
   writeChunk(destination, segmentID);
-  writeChunk(destination, completeSegmentScript2);
+  segment
+    ? writeChunk(destination, completeSegmentScript2)
+    : writeChunk(destination, completeSegmentData2);
   writeChunk(destination, request.placeholderPrefix);
   writeChunk(destination, segmentID);
-  destination = !!destination.write(completeSegmentScriptEnd);
+  destination = segment
+    ? !!destination.write(completeSegmentScriptEnd)
+    : !!destination.write(completeSegmentDataEnd);
   return destination;
 }
 function flushCompletedQueues(request, destination) {
@@ -8119,12 +8561,22 @@ function flushCompletedQueues(request, destination) {
         completedRootSegment = request.completedRootSegment;
       if (null !== completedRootSegment) {
         if (completedRootSegment.status === POSTPONED) return;
-        var completedPreambleSegments = request.completedPreambleSegments;
-        if (null === completedPreambleSegments) return;
-        var renderState = request.renderState,
-          preamble = renderState.preamble,
-          htmlChunks = preamble.htmlChunks,
-          headChunks = preamble.headChunks,
+        var renderState = request.renderState;
+        if (
+          (0 !== request.allPendingTasks ||
+            null !== request.trackedPostpones) &&
+          renderState.externalRuntimeScript
+        ) {
+          var _renderState$external = renderState.externalRuntimeScript,
+            resumableState = request.resumableState,
+            src = _renderState$external.src,
+            chunks = _renderState$external.chunks;
+          resumableState.scriptResources.hasOwnProperty(src) ||
+            ((resumableState.scriptResources[src] = EXISTS),
+            renderState.scripts.add(chunks));
+        }
+        var htmlChunks = renderState.htmlChunks,
+          headChunks = renderState.headChunks,
           i$jscomp$0;
         if (htmlChunks) {
           for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -8165,27 +8617,10 @@ function flushCompletedQueues(request, destination) {
         var hoistableChunks = renderState.hoistableChunks;
         for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
           writeChunk(destination, hoistableChunks[i$jscomp$0]);
-        for (
-          renderState = hoistableChunks.length = 0;
-          renderState < completedPreambleSegments.length;
-          renderState++
-        ) {
-          var segments = completedPreambleSegments[renderState];
-          for (preamble = 0; preamble < segments.length; preamble++)
-            flushSegment(request, destination, segments[preamble], null);
-        }
-        var preamble$jscomp$0 = request.renderState.preamble,
-          headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-        (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) &&
+        hoistableChunks.length = 0;
+        htmlChunks &&
+          null === headChunks &&
           writeChunk(destination, endChunkForTag("head"));
-        var bodyChunks = preamble$jscomp$0.bodyChunks;
-        if (bodyChunks)
-          for (
-            completedPreambleSegments = 0;
-            completedPreambleSegments < bodyChunks.length;
-            completedPreambleSegments++
-          )
-            writeChunk(destination, bodyChunks[completedPreambleSegments]);
         flushSegment(request, destination, completedRootSegment, null);
         request.completedRootSegment = null;
         writeBootstrap(destination, request.renderState);
@@ -8226,63 +8661,94 @@ function flushCompletedQueues(request, destination) {
       for (i = 0; i < clientRenderedBoundaries.length; i++) {
         var boundary = clientRenderedBoundaries[i];
         renderState$jscomp$0 = destination;
-        var resumableState = request.resumableState,
+        var resumableState$jscomp$0 = request.resumableState,
           renderState$jscomp$1 = request.renderState,
           id = boundary.rootSegmentID,
           errorDigest = boundary.errorDigest,
           errorMessage = boundary.errorMessage,
           errorStack = boundary.errorStack,
-          errorComponentStack = boundary.errorComponentStack;
-        writeChunk(
-          renderState$jscomp$0,
-          renderState$jscomp$1.startInlineScript
-        );
-        (resumableState.instructions & SentClientRenderFunction) === NothingSent
-          ? ((resumableState.instructions |= SentClientRenderFunction),
-            writeChunk(renderState$jscomp$0, clientRenderScript1Full))
-          : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
+          errorComponentStack = boundary.errorComponentStack,
+          scriptFormat =
+            resumableState$jscomp$0.streamingFormat === ScriptStreamingFormat;
+        scriptFormat
+          ? (writeChunk(
+              renderState$jscomp$0,
+              renderState$jscomp$1.startInlineScript
+            ),
+            (resumableState$jscomp$0.instructions &
+              SentClientRenderFunction) ===
+            NothingSent
+              ? ((resumableState$jscomp$0.instructions |=
+                  SentClientRenderFunction),
+                writeChunk(renderState$jscomp$0, clientRenderScript1Full))
+              : writeChunk(renderState$jscomp$0, clientRenderScript1Partial))
+          : writeChunk(renderState$jscomp$0, clientRenderData1);
         writeChunk(renderState$jscomp$0, renderState$jscomp$1.boundaryPrefix);
         writeChunk(renderState$jscomp$0, id.toString(16));
-        writeChunk(renderState$jscomp$0, clientRenderScript1A);
+        scriptFormat && writeChunk(renderState$jscomp$0, clientRenderScript1A);
         if (errorDigest || errorMessage || errorStack || errorComponentStack)
-          writeChunk(
-            renderState$jscomp$0,
-            clientRenderErrorScriptArgInterstitial
-          ),
-            writeChunk(
-              renderState$jscomp$0,
-              escapeJSStringsForInstructionScripts(errorDigest || "")
-            );
+          scriptFormat
+            ? (writeChunk(
+                renderState$jscomp$0,
+                clientRenderErrorScriptArgInterstitial
+              ),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeJSStringsForInstructionScripts(errorDigest || "")
+              ))
+            : (writeChunk(renderState$jscomp$0, clientRenderData2),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeTextForBrowser(errorDigest || "")
+              ));
         if (errorMessage || errorStack || errorComponentStack)
-          writeChunk(
-            renderState$jscomp$0,
-            clientRenderErrorScriptArgInterstitial
-          ),
-            writeChunk(
-              renderState$jscomp$0,
-              escapeJSStringsForInstructionScripts(errorMessage || "")
-            );
+          scriptFormat
+            ? (writeChunk(
+                renderState$jscomp$0,
+                clientRenderErrorScriptArgInterstitial
+              ),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeJSStringsForInstructionScripts(errorMessage || "")
+              ))
+            : (writeChunk(renderState$jscomp$0, clientRenderData3),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeTextForBrowser(errorMessage || "")
+              ));
         if (errorStack || errorComponentStack)
-          writeChunk(
-            renderState$jscomp$0,
-            clientRenderErrorScriptArgInterstitial
-          ),
-            writeChunk(
-              renderState$jscomp$0,
-              escapeJSStringsForInstructionScripts(errorStack || "")
-            );
+          scriptFormat
+            ? (writeChunk(
+                renderState$jscomp$0,
+                clientRenderErrorScriptArgInterstitial
+              ),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeJSStringsForInstructionScripts(errorStack || "")
+              ))
+            : (writeChunk(renderState$jscomp$0, clientRenderData4),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeTextForBrowser(errorStack || "")
+              ));
         errorComponentStack &&
-          (writeChunk(
-            renderState$jscomp$0,
-            clientRenderErrorScriptArgInterstitial
-          ),
-          writeChunk(
-            renderState$jscomp$0,
-            escapeJSStringsForInstructionScripts(errorComponentStack)
-          ));
-        var JSCompiler_inline_result = !!renderState$jscomp$0.write(
-          clientRenderScriptEnd
-        );
+          (scriptFormat
+            ? (writeChunk(
+                renderState$jscomp$0,
+                clientRenderErrorScriptArgInterstitial
+              ),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeJSStringsForInstructionScripts(errorComponentStack)
+              ))
+            : (writeChunk(renderState$jscomp$0, clientRenderData5),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeTextForBrowser(errorComponentStack)
+              )));
+        var JSCompiler_inline_result = scriptFormat
+          ? !!renderState$jscomp$0.write(clientRenderScriptEnd)
+          : !!renderState$jscomp$0.write(clientRenderDataEnd);
         if (!JSCompiler_inline_result) {
           request.destination = null;
           i++;
@@ -8358,9 +8824,10 @@ function flushCompletedQueues(request, destination) {
     0 === request.clientRenderedBoundaries.length &&
     0 === request.completedBoundaries.length
       ? ((request.flushScheduled = !1),
-        (i = request.resumableState),
-        i.hasBody && writeChunk(destination, endChunkForTag("body")),
-        i.hasHtml && writeChunk(destination, endChunkForTag("html")),
+        null === request.trackedPostpones &&
+          ((i = request.resumableState),
+          i.hasBody && writeChunk(destination, endChunkForTag("body")),
+          i.hasHtml && writeChunk(destination, endChunkForTag("html"))),
         flushBuffered(destination),
         0 !== request.abortableTasks.size &&
           console.error(
@@ -8417,18 +8884,32 @@ function abort(request, reason) {
     null !== request.destination &&
       flushCompletedQueues(request, request.destination);
   } catch (error$4) {
-    logRecoverableError(request, error$4, {}), fatalError(request, error$4);
+    (reason = {}),
+      logRecoverableError(request, error$4, reason, null),
+      fatalError(request, error$4, reason, null);
+  }
+}
+function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+  if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+  else {
+    var workingMap = trackedPostpones.workingMap,
+      parentNode = workingMap.get(parentKeyPath);
+    void 0 === parentNode &&
+      ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+      workingMap.set(parentKeyPath, parentNode),
+      addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+    parentNode[2].push(node);
   }
 }
-var isomorphicReactPackageVersion$jscomp$inline_722 = React.version;
+var isomorphicReactPackageVersion$jscomp$inline_747 = React.version;
 if (
-  "19.1.0-canary-c492f975-20250128" !==
-  isomorphicReactPackageVersion$jscomp$inline_722
+  "19.1.0-experimental-b3a95caf-20250113" !==
+  isomorphicReactPackageVersion$jscomp$inline_747
 )
   throw Error(
     'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
-      (isomorphicReactPackageVersion$jscomp$inline_722 +
-        "\n  - react-dom:  19.1.0-canary-c492f975-20250128\nLearn more: https://react.dev/warnings/version-mismatch")
+      (isomorphicReactPackageVersion$jscomp$inline_747 +
+        "\n  - react-dom:  19.1.0-experimental-b3a95caf-20250113\nLearn more: https://react.dev/warnings/version-mismatch")
   );
 exports.renderToReadableStream = function (children, options) {
   return new Promise(function (resolve, reject) {
@@ -8483,8 +8964,9 @@ exports.renderToReadableStream = function (children, options) {
                   try {
                     flushCompletedQueues(request, controller);
                   } catch (error) {
-                    logRecoverableError(request, error, {}),
-                      fatalError(request, error);
+                    (controller = {}),
+                      logRecoverableError(request, error, controller, null),
+                      fatalError(request, error, controller, null);
                   }
                 }
               },
@@ -8520,4 +9002,4 @@ exports.renderToReadableStream = function (children, options) {
     startWork(request$jscomp$0);
   });
 };
-exports.version = "19.1.0-canary-c492f975-20250128";
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
diff --git a/node_modules/react-dom/cjs/react-dom-server.bun.production.js b/node_modules/react-dom/cjs/react-dom-server.bun.production.js
index 5564888..b72106e 100644
--- a/node_modules/react-dom/cjs/react-dom-server.bun.production.js
+++ b/node_modules/react-dom/cjs/react-dom-server.bun.production.js
@@ -27,9 +27,10 @@ var React = require("react"),
   REACT_SCOPE_TYPE = Symbol.for("react.scope"),
   REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
   REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
   REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
   MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+  ASYNC_ITERATOR = Symbol.asyncIterator,
   isArrayImpl = Array.isArray,
   scheduleMicrotask = queueMicrotask;
 function flushBuffered(destination) {
@@ -234,44 +235,64 @@ function createRenderState(
       void 0 === nonce
         ? "<script>"
         : '<script nonce="' + escapeTextForBrowser(nonce) + '">',
-    idPrefix = resumableState.idPrefix;
-  externalRuntimeConfig = [];
-  var bootstrapScriptContent = resumableState.bootstrapScriptContent,
+    idPrefix = resumableState.idPrefix,
+    bootstrapChunks = [],
+    externalRuntimeScript = null,
+    bootstrapScriptContent = resumableState.bootstrapScriptContent,
     bootstrapScripts = resumableState.bootstrapScripts,
     bootstrapModules = resumableState.bootstrapModules;
   void 0 !== bootstrapScriptContent &&
-    externalRuntimeConfig.push(
+    bootstrapChunks.push(
       inlineScriptWithNonce,
       ("" + bootstrapScriptContent).replace(scriptRegex, scriptReplacer),
       "\x3c/script>"
     );
-  bootstrapScriptContent = [];
+  void 0 !== externalRuntimeConfig &&
+    ("string" === typeof externalRuntimeConfig
+      ? ((externalRuntimeScript = { src: externalRuntimeConfig, chunks: [] }),
+        pushScriptImpl(externalRuntimeScript.chunks, {
+          src: externalRuntimeConfig,
+          async: !0,
+          integrity: void 0,
+          nonce: nonce
+        }))
+      : ((externalRuntimeScript = {
+          src: externalRuntimeConfig.src,
+          chunks: []
+        }),
+        pushScriptImpl(externalRuntimeScript.chunks, {
+          src: externalRuntimeConfig.src,
+          async: !0,
+          integrity: externalRuntimeConfig.integrity,
+          nonce: nonce
+        })));
+  externalRuntimeConfig = [];
   void 0 !== importMap &&
-    (bootstrapScriptContent.push('<script type="importmap">'),
-    bootstrapScriptContent.push(
+    (externalRuntimeConfig.push('<script type="importmap">'),
+    externalRuntimeConfig.push(
       ("" + JSON.stringify(importMap)).replace(scriptRegex, scriptReplacer)
     ),
-    bootstrapScriptContent.push("\x3c/script>"));
-  importMap = onHeaders
-    ? {
-        preconnects: "",
-        fontPreloads: "",
-        highImagePreloads: "",
-        remainingCapacity:
-          2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
-      }
-    : null;
-  onHeaders = {
+    externalRuntimeConfig.push("\x3c/script>"));
+  importMap = {
     placeholderPrefix: idPrefix + "P:",
     segmentPrefix: idPrefix + "S:",
     boundaryPrefix: idPrefix + "B:",
     startInlineScript: inlineScriptWithNonce,
-    preamble: createPreambleState(),
-    externalRuntimeScript: null,
-    bootstrapChunks: externalRuntimeConfig,
-    importMapChunks: bootstrapScriptContent,
+    htmlChunks: null,
+    headChunks: null,
+    externalRuntimeScript: externalRuntimeScript,
+    bootstrapChunks: bootstrapChunks,
+    importMapChunks: externalRuntimeConfig,
     onHeaders: onHeaders,
-    headers: importMap,
+    headers: onHeaders
+      ? {
+          preconnects: "",
+          fontPreloads: "",
+          highImagePreloads: "",
+          remainingCapacity:
+            2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
+        }
+      : null,
     resets: {
       font: {},
       dns: {},
@@ -300,105 +321,104 @@ function createRenderState(
     stylesToHoist: !1
   };
   if (void 0 !== bootstrapScripts)
-    for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
-      var scriptConfig = bootstrapScripts[importMap];
-      idPrefix = inlineScriptWithNonce = void 0;
-      bootstrapScriptContent = {
-        rel: "preload",
-        as: "script",
-        fetchPriority: "low",
-        nonce: nonce
-      };
-      "string" === typeof scriptConfig
-        ? (bootstrapScriptContent.href = maxHeadersLength = scriptConfig)
-        : ((bootstrapScriptContent.href = maxHeadersLength = scriptConfig.src),
-          (bootstrapScriptContent.integrity = idPrefix =
-            "string" === typeof scriptConfig.integrity
-              ? scriptConfig.integrity
-              : void 0),
-          (bootstrapScriptContent.crossOrigin = inlineScriptWithNonce =
-            "string" === typeof scriptConfig || null == scriptConfig.crossOrigin
-              ? void 0
-              : "use-credentials" === scriptConfig.crossOrigin
-                ? "use-credentials"
-                : ""));
-      scriptConfig = resumableState;
-      var href = maxHeadersLength;
-      scriptConfig.scriptResources[href] = null;
-      scriptConfig.moduleScriptResources[href] = null;
-      scriptConfig = [];
-      pushLinkImpl(scriptConfig, bootstrapScriptContent);
-      onHeaders.bootstrapScripts.add(scriptConfig);
-      externalRuntimeConfig.push(
-        '<script src="',
-        escapeTextForBrowser(maxHeadersLength)
-      );
-      nonce &&
-        externalRuntimeConfig.push('" nonce="', escapeTextForBrowser(nonce));
-      "string" === typeof idPrefix &&
-        externalRuntimeConfig.push(
-          '" integrity="',
-          escapeTextForBrowser(idPrefix)
-        );
-      "string" === typeof inlineScriptWithNonce &&
-        externalRuntimeConfig.push(
-          '" crossorigin="',
-          escapeTextForBrowser(inlineScriptWithNonce)
-        );
-      externalRuntimeConfig.push('" async="">\x3c/script>');
-    }
+    for (onHeaders = 0; onHeaders < bootstrapScripts.length; onHeaders++)
+      (externalRuntimeConfig = bootstrapScripts[onHeaders]),
+        (idPrefix = inlineScriptWithNonce = void 0),
+        (externalRuntimeScript = {
+          rel: "preload",
+          as: "script",
+          fetchPriority: "low",
+          nonce: nonce
+        }),
+        "string" === typeof externalRuntimeConfig
+          ? (externalRuntimeScript.href = maxHeadersLength =
+              externalRuntimeConfig)
+          : ((externalRuntimeScript.href = maxHeadersLength =
+              externalRuntimeConfig.src),
+            (externalRuntimeScript.integrity = idPrefix =
+              "string" === typeof externalRuntimeConfig.integrity
+                ? externalRuntimeConfig.integrity
+                : void 0),
+            (externalRuntimeScript.crossOrigin = inlineScriptWithNonce =
+              "string" === typeof externalRuntimeConfig ||
+              null == externalRuntimeConfig.crossOrigin
+                ? void 0
+                : "use-credentials" === externalRuntimeConfig.crossOrigin
+                  ? "use-credentials"
+                  : "")),
+        (externalRuntimeConfig = resumableState),
+        (bootstrapScriptContent = maxHeadersLength),
+        (externalRuntimeConfig.scriptResources[bootstrapScriptContent] = null),
+        (externalRuntimeConfig.moduleScriptResources[bootstrapScriptContent] =
+          null),
+        (externalRuntimeConfig = []),
+        pushLinkImpl(externalRuntimeConfig, externalRuntimeScript),
+        importMap.bootstrapScripts.add(externalRuntimeConfig),
+        bootstrapChunks.push(
+          '<script src="',
+          escapeTextForBrowser(maxHeadersLength)
+        ),
+        nonce && bootstrapChunks.push('" nonce="', escapeTextForBrowser(nonce)),
+        "string" === typeof idPrefix &&
+          bootstrapChunks.push('" integrity="', escapeTextForBrowser(idPrefix)),
+        "string" === typeof inlineScriptWithNonce &&
+          bootstrapChunks.push(
+            '" crossorigin="',
+            escapeTextForBrowser(inlineScriptWithNonce)
+          ),
+        bootstrapChunks.push('" async="">\x3c/script>');
   if (void 0 !== bootstrapModules)
     for (
       bootstrapScripts = 0;
       bootstrapScripts < bootstrapModules.length;
       bootstrapScripts++
     )
-      (bootstrapScriptContent = bootstrapModules[bootstrapScripts]),
+      (externalRuntimeScript = bootstrapModules[bootstrapScripts]),
         (inlineScriptWithNonce = maxHeadersLength = void 0),
         (idPrefix = {
           rel: "modulepreload",
           fetchPriority: "low",
           nonce: nonce
         }),
-        "string" === typeof bootstrapScriptContent
-          ? (idPrefix.href = importMap = bootstrapScriptContent)
-          : ((idPrefix.href = importMap = bootstrapScriptContent.src),
+        "string" === typeof externalRuntimeScript
+          ? (idPrefix.href = onHeaders = externalRuntimeScript)
+          : ((idPrefix.href = onHeaders = externalRuntimeScript.src),
             (idPrefix.integrity = inlineScriptWithNonce =
-              "string" === typeof bootstrapScriptContent.integrity
-                ? bootstrapScriptContent.integrity
+              "string" === typeof externalRuntimeScript.integrity
+                ? externalRuntimeScript.integrity
                 : void 0),
             (idPrefix.crossOrigin = maxHeadersLength =
-              "string" === typeof bootstrapScriptContent ||
-              null == bootstrapScriptContent.crossOrigin
+              "string" === typeof externalRuntimeScript ||
+              null == externalRuntimeScript.crossOrigin
                 ? void 0
-                : "use-credentials" === bootstrapScriptContent.crossOrigin
+                : "use-credentials" === externalRuntimeScript.crossOrigin
                   ? "use-credentials"
                   : "")),
-        (bootstrapScriptContent = resumableState),
-        (scriptConfig = importMap),
-        (bootstrapScriptContent.scriptResources[scriptConfig] = null),
-        (bootstrapScriptContent.moduleScriptResources[scriptConfig] = null),
-        (bootstrapScriptContent = []),
-        pushLinkImpl(bootstrapScriptContent, idPrefix),
-        onHeaders.bootstrapScripts.add(bootstrapScriptContent),
-        externalRuntimeConfig.push(
+        (externalRuntimeScript = resumableState),
+        (externalRuntimeConfig = onHeaders),
+        (externalRuntimeScript.scriptResources[externalRuntimeConfig] = null),
+        (externalRuntimeScript.moduleScriptResources[externalRuntimeConfig] =
+          null),
+        (externalRuntimeScript = []),
+        pushLinkImpl(externalRuntimeScript, idPrefix),
+        importMap.bootstrapScripts.add(externalRuntimeScript),
+        bootstrapChunks.push(
           '<script type="module" src="',
-          escapeTextForBrowser(importMap)
+          escapeTextForBrowser(onHeaders)
         ),
-        nonce &&
-          externalRuntimeConfig.push('" nonce="', escapeTextForBrowser(nonce)),
+        nonce && bootstrapChunks.push('" nonce="', escapeTextForBrowser(nonce)),
         "string" === typeof inlineScriptWithNonce &&
-          externalRuntimeConfig.push(
+          bootstrapChunks.push(
             '" integrity="',
             escapeTextForBrowser(inlineScriptWithNonce)
           ),
         "string" === typeof maxHeadersLength &&
-          externalRuntimeConfig.push(
+          bootstrapChunks.push(
             '" crossorigin="',
             escapeTextForBrowser(maxHeadersLength)
           ),
-        externalRuntimeConfig.push('" async="">\x3c/script>');
-  return onHeaders;
+        bootstrapChunks.push('" async="">\x3c/script>');
+  return importMap;
 }
 function createResumableState(
   identifierPrefix,
@@ -407,10 +427,12 @@ function createResumableState(
   bootstrapScripts,
   bootstrapModules
 ) {
+  var streamingFormat = 0;
+  void 0 !== externalRuntimeConfig && (streamingFormat = 1);
   return {
     idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
     nextFormID: 0,
-    streamingFormat: 0,
+    streamingFormat: streamingFormat,
     bootstrapScriptContent: bootstrapScriptContent,
     bootstrapScripts: bootstrapScripts,
     bootstrapModules: bootstrapModules,
@@ -427,9 +449,6 @@ function createResumableState(
     moduleScriptResources: {}
   };
 }
-function createPreambleState() {
-  return { htmlChunks: null, headChunks: null, bodyChunks: null };
-}
 function createFormatContext(insertionMode, selectedValue, tagScope) {
   return {
     insertionMode: insertionMode,
@@ -440,9 +459,9 @@ function createFormatContext(insertionMode, selectedValue, tagScope) {
 function createRootFormatContext(namespaceURI) {
   return createFormatContext(
     "http://www.w3.org/2000/svg" === namespaceURI
-      ? 4
+      ? 3
       : "http://www.w3.org/1998/Math/MathML" === namespaceURI
-        ? 5
+        ? 4
         : 0,
     null,
     0
@@ -459,34 +478,33 @@ function getChildFormatContext(parentContext, type, props) {
         parentContext.tagScope
       );
     case "svg":
-      return createFormatContext(4, null, parentContext.tagScope);
+      return createFormatContext(3, null, parentContext.tagScope);
     case "picture":
       return createFormatContext(2, null, parentContext.tagScope | 2);
     case "math":
-      return createFormatContext(5, null, parentContext.tagScope);
+      return createFormatContext(4, null, parentContext.tagScope);
     case "foreignObject":
       return createFormatContext(2, null, parentContext.tagScope);
     case "table":
-      return createFormatContext(6, null, parentContext.tagScope);
+      return createFormatContext(5, null, parentContext.tagScope);
     case "thead":
     case "tbody":
     case "tfoot":
-      return createFormatContext(7, null, parentContext.tagScope);
+      return createFormatContext(6, null, parentContext.tagScope);
     case "colgroup":
-      return createFormatContext(9, null, parentContext.tagScope);
-    case "tr":
       return createFormatContext(8, null, parentContext.tagScope);
-    case "head":
-      if (2 > parentContext.insertionMode)
-        return createFormatContext(3, null, parentContext.tagScope);
-      break;
-    case "html":
-      if (0 === parentContext.insertionMode)
-        return createFormatContext(1, null, parentContext.tagScope);
+    case "tr":
+      return createFormatContext(7, null, parentContext.tagScope);
   }
-  return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode
+  return 5 <= parentContext.insertionMode
     ? createFormatContext(2, null, parentContext.tagScope)
-    : parentContext;
+    : 0 === parentContext.insertionMode
+      ? "html" === type
+        ? createFormatContext(1, null, parentContext.tagScope)
+        : createFormatContext(2, null, parentContext.tagScope)
+      : 1 === parentContext.insertionMode
+        ? createFormatContext(2, null, parentContext.tagScope)
+        : parentContext;
 }
 function pushTextInstance(target, text, renderState, textEmbedded) {
   if ("" === text) return textEmbedded;
@@ -803,7 +821,8 @@ function flattenOptionChildren(children) {
   return content;
 }
 function injectFormReplayingRuntime(resumableState, renderState) {
-  0 === (resumableState.instructions & 16) &&
+  0 !== (resumableState.instructions & 16) ||
+    renderState.externalRuntimeScript ||
     ((resumableState.instructions |= 16),
     renderState.bootstrapChunks.unshift(
       renderState.startInlineScript,
@@ -958,7 +977,6 @@ function pushStartInstance(
   props,
   resumableState,
   renderState,
-  preambleState,
   hoistableState,
   formatContext,
   textEmbedded,
@@ -1438,7 +1456,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$2;
     case "title":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1457,7 +1475,7 @@ function pushStartInstance(
         href = props.href,
         precedence = props.precedence;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof rel ||
@@ -1539,7 +1557,7 @@ function pushStartInstance(
         "symbol" === typeof asyncProp ||
         props.onLoad ||
         props.onError ||
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1580,7 +1598,7 @@ function pushStartInstance(
       var precedence$jscomp$0 = props.precedence,
         href$jscomp$0 = props.href;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof precedence$jscomp$0 ||
@@ -1683,7 +1701,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$6;
     case "meta":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1861,13 +1879,10 @@ function pushStartInstance(
     case "missing-glyph":
       break;
     case "head":
-      if (2 > formatContext.insertionMode) {
-        var preamble = preambleState || renderState.preamble;
-        if (preamble.headChunks)
-          throw Error("The `<head>` tag may only be rendered once.");
-        preamble.headChunks = [];
+      if (2 > formatContext.insertionMode && null === renderState.headChunks) {
+        renderState.headChunks = [];
         var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-          preamble.headChunks,
+          renderState.headChunks,
           props,
           "head"
         );
@@ -1878,42 +1893,24 @@ function pushStartInstance(
           "head"
         );
       return JSCompiler_inline_result$jscomp$9;
-    case "body":
-      if (2 > formatContext.insertionMode) {
-        var preamble$jscomp$0 = preambleState || renderState.preamble;
-        if (preamble$jscomp$0.bodyChunks)
-          throw Error("The `<body>` tag may only be rendered once.");
-        preamble$jscomp$0.bodyChunks = [];
-        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          preamble$jscomp$0.bodyChunks,
-          props,
-          "body"
-        );
-      } else
-        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          target$jscomp$0,
-          props,
-          "body"
-        );
-      return JSCompiler_inline_result$jscomp$10;
     case "html":
-      if (0 === formatContext.insertionMode) {
-        var preamble$jscomp$1 = preambleState || renderState.preamble;
-        if (preamble$jscomp$1.htmlChunks)
-          throw Error("The `<html>` tag may only be rendered once.");
-        preamble$jscomp$1.htmlChunks = ["<!DOCTYPE html>"];
-        var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-          preamble$jscomp$1.htmlChunks,
+      if (
+        0 === formatContext.insertionMode &&
+        null === renderState.htmlChunks
+      ) {
+        renderState.htmlChunks = ["<!DOCTYPE html>"];
+        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+          renderState.htmlChunks,
           props,
           "html"
         );
       } else
-        JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
           target$jscomp$0,
           props,
           "html"
         );
-      return JSCompiler_inline_result$jscomp$11;
+      return JSCompiler_inline_result$jscomp$10;
     default:
       if (-1 !== type.indexOf("-")) {
         target$jscomp$0.push(startChunkForTag(type));
@@ -1974,15 +1971,6 @@ function endChunkForTag(tag) {
   void 0 === chunk && ((chunk = "</" + tag + ">"), endTagCache.set(tag, chunk));
   return chunk;
 }
-function hoistPreambleState(renderState, preambleState) {
-  renderState = renderState.preamble;
-  null === renderState.htmlChunks &&
-    (renderState.htmlChunks = preambleState.htmlChunks);
-  null === renderState.headChunks &&
-    (renderState.headChunks = preambleState.headChunks);
-  null === renderState.bodyChunks &&
-    (renderState.bodyChunks = preambleState.bodyChunks);
-}
 function writeBootstrap(destination, renderState) {
   renderState = renderState.bootstrapChunks;
   for (var i = 0; i < renderState.length - 1; i++)
@@ -2005,7 +1993,6 @@ function writeStartSegment(destination, renderState, formatContext, id) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return (
         writeChunk(destination, '<div hidden id="'),
@@ -2013,7 +2000,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         writeChunk(destination, id.toString(16)),
         !!destination.write('">')
       );
-    case 4:
+    case 3:
       return (
         writeChunk(
           destination,
@@ -2023,7 +2010,7 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         writeChunk(destination, id.toString(16)),
         !!destination.write('">')
       );
-    case 5:
+    case 4:
       return (
         writeChunk(
           destination,
@@ -2033,28 +2020,28 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         writeChunk(destination, id.toString(16)),
         !!destination.write('">')
       );
-    case 6:
+    case 5:
       return (
         writeChunk(destination, '<table hidden id="'),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, id.toString(16)),
         !!destination.write('">')
       );
-    case 7:
+    case 6:
       return (
         writeChunk(destination, '<table hidden><tbody id="'),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, id.toString(16)),
         !!destination.write('">')
       );
-    case 8:
+    case 7:
       return (
         writeChunk(destination, '<table hidden><tr id="'),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, id.toString(16)),
         !!destination.write('">')
       );
-    case 9:
+    case 8:
       return (
         writeChunk(destination, '<table hidden><colgroup id="'),
         writeChunk(destination, renderState.segmentPrefix),
@@ -2069,20 +2056,19 @@ function writeEndSegment(destination, formatContext) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return !!destination.write("</div>");
-    case 4:
+    case 3:
       return !!destination.write("</svg>");
-    case 5:
+    case 4:
       return !!destination.write("</math>");
-    case 6:
+    case 5:
       return !!destination.write("</table>");
-    case 7:
+    case 6:
       return !!destination.write("</tbody></table>");
-    case 8:
+    case 7:
       return !!destination.write("</tr></table>");
-    case 9:
+    case 8:
       return !!destination.write("</colgroup></table>");
     default:
       throw Error("Unknown insertion mode. This is a bug in React.");
@@ -2334,6 +2320,107 @@ function writeStyleResourceAttributeInJS(destination, name, value) {
   writeChunk(destination, ",");
   writeChunk(destination, escapeJSObjectForInstructionScripts(name));
 }
+function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+  writeChunk(destination, "[");
+  var nextArrayOpenBrackChunk = "[";
+  hoistableState.stylesheets.forEach(function (resource) {
+    if (2 !== resource.state)
+      if (3 === resource.state)
+        writeChunk(destination, nextArrayOpenBrackChunk),
+          writeChunk(
+            destination,
+            escapeTextForBrowser(JSON.stringify("" + resource.props.href))
+          ),
+          writeChunk(destination, "]"),
+          (nextArrayOpenBrackChunk = ",[");
+      else {
+        writeChunk(destination, nextArrayOpenBrackChunk);
+        var precedence = resource.props["data-precedence"],
+          props = resource.props,
+          coercedHref = sanitizeURL("" + resource.props.href);
+        writeChunk(
+          destination,
+          escapeTextForBrowser(JSON.stringify(coercedHref))
+        );
+        precedence = "" + precedence;
+        writeChunk(destination, ",");
+        writeChunk(
+          destination,
+          escapeTextForBrowser(JSON.stringify(precedence))
+        );
+        for (var propKey in props)
+          if (
+            hasOwnProperty.call(props, propKey) &&
+            ((precedence = props[propKey]), null != precedence)
+          )
+            switch (propKey) {
+              case "href":
+              case "rel":
+              case "precedence":
+              case "data-precedence":
+                break;
+              case "children":
+              case "dangerouslySetInnerHTML":
+                throw Error(
+                  "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                );
+              default:
+                writeStyleResourceAttributeInAttr(
+                  destination,
+                  propKey,
+                  precedence
+                );
+            }
+        writeChunk(destination, "]");
+        nextArrayOpenBrackChunk = ",[";
+        resource.state = 3;
+      }
+  });
+  writeChunk(destination, "]");
+}
+function writeStyleResourceAttributeInAttr(destination, name, value) {
+  var attributeName = name.toLowerCase();
+  switch (typeof value) {
+    case "function":
+    case "symbol":
+      return;
+  }
+  switch (name) {
+    case "innerHTML":
+    case "dangerouslySetInnerHTML":
+    case "suppressContentEditableWarning":
+    case "suppressHydrationWarning":
+    case "style":
+    case "ref":
+      return;
+    case "className":
+      attributeName = "class";
+      name = "" + value;
+      break;
+    case "hidden":
+      if (!1 === value) return;
+      name = "";
+      break;
+    case "src":
+    case "href":
+      value = sanitizeURL(value);
+      name = "" + value;
+      break;
+    default:
+      if (
+        (2 < name.length &&
+          ("o" === name[0] || "O" === name[0]) &&
+          ("n" === name[1] || "N" === name[1])) ||
+        !isAttributeNameSafe(name)
+      )
+        return;
+      name = "" + value;
+  }
+  writeChunk(destination, ",");
+  writeChunk(destination, escapeTextForBrowser(JSON.stringify(attributeName)));
+  writeChunk(destination, ",");
+  writeChunk(destination, escapeTextForBrowser(JSON.stringify(name)));
+}
 function createHoistableState() {
   return { styles: new Set(), stylesheets: new Set() };
 }
@@ -2761,6 +2848,8 @@ function getComponentNameFromType(type) {
       return "Suspense";
     case REACT_SUSPENSE_LIST_TYPE:
       return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
   }
   if ("object" === typeof type)
     switch (type.$$typeof) {
@@ -3103,6 +3192,11 @@ function dispatchAction(componentIdentity, queue, action) {
       queue.next = componentIdentity;
     }
 }
+function throwOnUseEffectEventCall() {
+  throw Error(
+    "A function wrapped in useEffectEvent can't be called during rendering."
+  );
+}
 function unsupportedStartTransition() {
   throw Error("startTransition cannot be called during server rendering.");
 }
@@ -3175,8 +3269,15 @@ function unwrapThenable(thenable) {
   null === thenableState && (thenableState = []);
   return trackUsedThenable(thenableState, thenable, index);
 }
-function unsupportedRefresh() {
-  throw Error("Cache cannot be refreshed during server rendering.");
+function readPreviousThenableFromState() {
+  var index = thenableIndexCounter;
+  thenableIndexCounter += 1;
+  if (null !== thenableState)
+    return (
+      (index = thenableState[index]),
+      (index = void 0 === index ? void 0 : index.value),
+      index
+    );
 }
 function noop$1() {}
 var HooksDispatcher = {
@@ -3263,13 +3364,8 @@ var HooksDispatcher = {
       resolveCurrentlyRenderingComponent();
       return sharedNotPendingObject;
     },
-    useMemoCache: function (size) {
-      for (var data = Array(size), i = 0; i < size; i++)
-        data[i] = REACT_MEMO_CACHE_SENTINEL;
-      return data;
-    },
-    useCacheRefresh: function () {
-      return unsupportedRefresh;
+    useEffectEvent: function () {
+      return throwOnUseEffectEventCall;
     }
   },
   currentResumableState = null,
@@ -3466,6 +3562,8 @@ function describeComponentStackByType(type) {
       return describeBuiltInComponentFrame("SuspenseList");
     case REACT_SUSPENSE_TYPE:
       return describeBuiltInComponentFrame("Suspense");
+    case REACT_VIEW_TRANSITION_TYPE:
+      return describeBuiltInComponentFrame("ViewTransition");
   }
   return "";
 }
@@ -3525,7 +3623,7 @@ function RequestInstance(
   this.status = 10;
   this.fatalError = null;
   this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-  this.completedPreambleSegments = this.completedRootSegment = null;
+  this.completedRootSegment = null;
   this.abortableTasks = abortSet;
   this.pingedTasks = [];
   this.clientRenderedBoundaries = [];
@@ -3584,7 +3682,6 @@ function createRequest(
     null,
     renderState,
     null,
-    null,
     resumableState.abortableTasks,
     null,
     rootFormatContext,
@@ -3610,12 +3707,7 @@ function pingTask(request, task) {
           return performWork(request);
         }, 0));
 }
-function createSuspenseBoundary(
-  request,
-  fallbackAbortableTasks,
-  contentPreamble,
-  fallbackPreamble
-) {
+function createSuspenseBoundary(request, fallbackAbortableTasks) {
   return {
     status: 0,
     rootSegmentID: -1,
@@ -3627,8 +3719,6 @@ function createSuspenseBoundary(
     errorDigest: null,
     contentState: createHoistableState(),
     fallbackState: createHoistableState(),
-    contentPreamble: contentPreamble,
-    fallbackPreamble: fallbackPreamble,
     trackedContentKeyPath: null,
     trackedFallbackNode: null
   };
@@ -3640,7 +3730,6 @@ function createRenderTask(
   childIndex,
   blockedBoundary,
   blockedSegment,
-  blockedPreamble,
   hoistableState,
   abortSet,
   keyPath,
@@ -3663,7 +3752,6 @@ function createRenderTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: blockedSegment,
-    blockedPreamble: blockedPreamble,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -3707,7 +3795,6 @@ function createReplayTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: null,
-    blockedPreamble: null,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -3731,12 +3818,11 @@ function createPendingSegment(
 ) {
   return {
     status: 0,
-    parentFlushed: !1,
     id: -1,
     index: index,
+    parentFlushed: !1,
     chunks: [],
     children: [],
-    preambleChildren: [],
     parentFormatContext: parentFormatContext,
     boundary: boundary,
     lastPushedText: lastPushedText,
@@ -3778,6 +3864,10 @@ function getThrownInfo(node$jscomp$0) {
     });
   return errorInfo;
 }
+function logPostpone(request, reason, postponeInfo) {
+  request = request.onPostpone;
+  request(reason, postponeInfo);
+}
 function logRecoverableError(request, error, errorInfo) {
   request = request.onError;
   error = request(error, errorInfo);
@@ -3964,13 +4054,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
         (task.formatContext = defaultProps),
         (task.keyPath = initialState);
     else {
-      ref = pushStartInstance(
+      initialState = pushStartInstance(
         newProps.chunks,
         type,
         props,
         request.resumableState,
         request.renderState,
-        task.blockedPreamble,
         task.hoistableState,
         task.formatContext,
         newProps.lastPushedText,
@@ -3978,42 +4067,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
       );
       newProps.lastPushedText = !1;
       defaultProps = task.formatContext;
-      initialState = task.keyPath;
+      ref = task.keyPath;
+      task.formatContext = getChildFormatContext(defaultProps, type, props);
       task.keyPath = keyPath;
-      3 ===
-      (task.formatContext = getChildFormatContext(defaultProps, type, props))
-        .insertionMode
-        ? ((keyPath = createPendingSegment(
-            request,
-            0,
-            null,
-            task.formatContext,
-            !1,
-            !1
-          )),
-          newProps.preambleChildren.push(keyPath),
-          (keyPath = createRenderTask(
-            request,
-            null,
-            ref,
-            -1,
-            task.blockedBoundary,
-            keyPath,
-            task.blockedPreamble,
-            task.hoistableState,
-            request.abortableTasks,
-            task.keyPath,
-            task.formatContext,
-            task.context,
-            task.treeContext,
-            task.componentStack,
-            task.isFallback
-          )),
-          pushComponentStack(keyPath),
-          request.pingedTasks.push(keyPath))
-        : renderNode(request, task, ref, -1);
+      renderNode(request, task, initialState, -1);
       task.formatContext = defaultProps;
-      task.keyPath = initialState;
+      task.keyPath = ref;
       a: {
         task = newProps.chunks;
         request = request.resumableState;
@@ -4048,9 +4107,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
               request.hasHtml = !0;
               break a;
             }
-            break;
-          case "head":
-            if (1 >= defaultProps.insertionMode) break a;
         }
         task.push(endChunkForTag(type));
       }
@@ -4081,6 +4137,11 @@ function renderElement(request, task, keyPath, type, props, ref) {
         task.keyPath = type;
         return;
       case REACT_VIEW_TRANSITION_TYPE:
+        type = task.keyPath;
+        task.keyPath = keyPath;
+        renderNodeDestructive(request, task, props.children, -1);
+        task.keyPath = type;
+        return;
       case REACT_SCOPE_TYPE:
         throw Error("ReactDOMServer does not yet support scope components.");
       case REACT_SUSPENSE_TYPE:
@@ -4095,34 +4156,25 @@ function renderElement(request, task, keyPath, type, props, ref) {
           }
         } else {
           type = task.keyPath;
-          var parentBoundary = task.blockedBoundary;
-          ref = task.blockedPreamble;
-          var parentHoistableState = task.hoistableState;
-          propName$33 = task.blockedSegment;
-          propName = props.fallback;
+          var parentBoundary = task.blockedBoundary,
+            parentHoistableState = task.hoistableState;
+          ref = task.blockedSegment;
+          propName$33 = props.fallback;
           props = props.children;
           var fallbackAbortSet = new Set();
-          var newBoundary =
-            2 > task.formatContext.insertionMode
-              ? createSuspenseBoundary(
-                  request,
-                  fallbackAbortSet,
-                  createPreambleState(),
-                  createPreambleState()
-                )
-              : createSuspenseBoundary(request, fallbackAbortSet, null, null);
+          propName = createSuspenseBoundary(request, fallbackAbortSet);
           null !== request.trackedPostpones &&
-            (newBoundary.trackedContentKeyPath = keyPath);
+            (propName.trackedContentKeyPath = keyPath);
           var boundarySegment = createPendingSegment(
             request,
-            propName$33.chunks.length,
-            newBoundary,
+            ref.chunks.length,
+            propName,
             task.formatContext,
             !1,
             !1
           );
-          propName$33.children.push(boundarySegment);
-          propName$33.lastPushedText = !1;
+          ref.children.push(boundarySegment);
+          ref.lastPushedText = !1;
           var contentRootSegment = createPendingSegment(
             request,
             0,
@@ -4136,13 +4188,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
             newProps = [keyPath[0], "Suspense Fallback", keyPath[2]];
             defaultProps = [newProps[1], newProps[2], [], null];
             request.trackedPostpones.workingMap.set(newProps, defaultProps);
-            newBoundary.trackedFallbackNode = defaultProps;
+            propName.trackedFallbackNode = defaultProps;
             task.blockedSegment = boundarySegment;
-            task.blockedPreamble = newBoundary.fallbackPreamble;
             task.keyPath = newProps;
             boundarySegment.status = 6;
             try {
-              renderNode(request, task, propName, -1),
+              renderNode(request, task, propName$33, -1),
                 boundarySegment.lastPushedText &&
                   boundarySegment.textEmbedded &&
                   boundarySegment.chunks.push("\x3c!-- --\x3e"),
@@ -4153,19 +4204,16 @@ function renderElement(request, task, keyPath, type, props, ref) {
                 thrownValue)
               );
             } finally {
-              (task.blockedSegment = propName$33),
-                (task.blockedPreamble = ref),
-                (task.keyPath = type);
+              (task.blockedSegment = ref), (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
               props,
               -1,
-              newBoundary,
+              propName,
               contentRootSegment,
-              newBoundary.contentPreamble,
-              newBoundary.contentState,
+              propName.contentState,
               task.abortSet,
               keyPath,
               task.formatContext,
@@ -4177,9 +4225,8 @@ function renderElement(request, task, keyPath, type, props, ref) {
             pushComponentStack(task);
             request.pingedTasks.push(task);
           } else {
-            task.blockedBoundary = newBoundary;
-            task.blockedPreamble = newBoundary.contentPreamble;
-            task.hoistableState = newBoundary.contentState;
+            task.blockedBoundary = propName;
+            task.hoistableState = propName.contentState;
             task.blockedSegment = contentRootSegment;
             task.keyPath = keyPath;
             contentRootSegment.status = 6;
@@ -4190,46 +4237,46 @@ function renderElement(request, task, keyPath, type, props, ref) {
                   contentRootSegment.textEmbedded &&
                   contentRootSegment.chunks.push("\x3c!-- --\x3e"),
                 (contentRootSegment.status = 1),
-                queueCompletedSegment(newBoundary, contentRootSegment),
-                0 === newBoundary.pendingTasks && 0 === newBoundary.status)
+                queueCompletedSegment(propName, contentRootSegment),
+                0 === propName.pendingTasks && 0 === propName.status)
               ) {
-                newBoundary.status = 1;
-                0 === request.pendingRootTasks &&
-                  task.blockedPreamble &&
-                  preparePreamble(request);
+                propName.status = 1;
                 break a;
               }
             } catch (thrownValue$28) {
-              (newBoundary.status = 4),
+              (propName.status = 4),
                 12 === request.status
                   ? ((contentRootSegment.status = 3),
                     (newProps = request.fatalError))
                   : ((contentRootSegment.status = 4),
                     (newProps = thrownValue$28)),
                 (defaultProps = getThrownInfo(task.componentStack)),
-                (initialState = logRecoverableError(
-                  request,
-                  newProps,
-                  defaultProps
-                )),
-                (newBoundary.errorDigest = initialState),
-                untrackBoundary(request, newBoundary);
+                "object" === typeof newProps &&
+                null !== newProps &&
+                newProps.$$typeof === REACT_POSTPONE_TYPE
+                  ? (logPostpone(request, newProps.message, defaultProps),
+                    (initialState = "POSTPONE"))
+                  : (initialState = logRecoverableError(
+                      request,
+                      newProps,
+                      defaultProps
+                    )),
+                (propName.errorDigest = initialState),
+                untrackBoundary(request, propName);
             } finally {
               (task.blockedBoundary = parentBoundary),
-                (task.blockedPreamble = ref),
                 (task.hoistableState = parentHoistableState),
-                (task.blockedSegment = propName$33),
+                (task.blockedSegment = ref),
                 (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
-              propName,
+              propName$33,
               -1,
               parentBoundary,
               boundarySegment,
-              newBoundary.fallbackPreamble,
-              newBoundary.fallbackState,
+              propName.fallbackState,
               fallbackAbortSet,
               [keyPath[0], "Suspense Fallback", keyPath[2]],
               task.formatContext,
@@ -4248,9 +4295,9 @@ function renderElement(request, task, keyPath, type, props, ref) {
       switch (type.$$typeof) {
         case REACT_FORWARD_REF_TYPE:
           if ("ref" in props)
-            for (newBoundary in ((newProps = {}), props))
-              "ref" !== newBoundary &&
-                (newProps[newBoundary] = props[newBoundary]);
+            for (boundarySegment in ((newProps = {}), props))
+              "ref" !== boundarySegment &&
+                (newProps[boundarySegment] = props[boundarySegment]);
           else newProps = props;
           type = renderWithHooks(
             request,
@@ -4422,16 +4469,13 @@ function retryNode(request, task) {
                         );
                       task.replay.pendingTasks--;
                       props = getThrownInfo(task.componentStack);
-                      key = task.blockedBoundary;
-                      type = x;
-                      props = logRecoverableError(request, type, props);
-                      abortRemainingReplayNodes(
+                      erroredReplay(
                         request,
-                        key,
+                        task.blockedBoundary,
+                        x,
+                        props,
                         childNodes,
-                        name,
-                        type,
-                        props
+                        name
                       );
                     }
                     task.replay = replay;
@@ -4443,9 +4487,9 @@ function retryNode(request, task) {
                           ">. The tree doesn't match so React will fallback to client rendering."
                       );
                     b: {
-                      replay = void 0;
-                      type = node$jscomp$0[5];
-                      ref = node$jscomp$0[2];
+                      type = void 0;
+                      ref = node$jscomp$0[5];
+                      replay = node$jscomp$0[2];
                       name = node$jscomp$0[3];
                       keyOrIndex =
                         null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
@@ -4455,30 +4499,20 @@ function retryNode(request, task) {
                         previousReplaySet = task.replay,
                         parentBoundary = task.blockedBoundary,
                         parentHoistableState = task.hoistableState,
-                        content = props.children,
-                        fallback = props.fallback,
-                        fallbackAbortSet = new Set();
-                      props =
-                        2 > task.formatContext.insertionMode
-                          ? createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              createPreambleState(),
-                              createPreambleState()
-                            )
-                          : createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              null,
-                              null
-                            );
-                      props.parentFlushed = !0;
-                      props.rootSegmentID = type;
-                      task.blockedBoundary = props;
-                      task.hoistableState = props.contentState;
+                        content = props.children;
+                      props = props.fallback;
+                      var fallbackAbortSet = new Set(),
+                        resumedBoundary = createSuspenseBoundary(
+                          request,
+                          fallbackAbortSet
+                        );
+                      resumedBoundary.parentFlushed = !0;
+                      resumedBoundary.rootSegmentID = ref;
+                      task.blockedBoundary = resumedBoundary;
+                      task.hoistableState = resumedBoundary.contentState;
                       task.keyPath = key;
                       task.replay = {
-                        nodes: ref,
+                        nodes: replay,
                         slots: name,
                         pendingTasks: 1
                       };
@@ -4492,22 +4526,32 @@ function retryNode(request, task) {
                             "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                           );
                         task.replay.pendingTasks--;
-                        if (0 === props.pendingTasks && 0 === props.status) {
-                          props.status = 1;
-                          request.completedBoundaries.push(props);
+                        if (
+                          0 === resumedBoundary.pendingTasks &&
+                          0 === resumedBoundary.status
+                        ) {
+                          resumedBoundary.status = 1;
+                          request.completedBoundaries.push(resumedBoundary);
                           break b;
                         }
                       } catch (error) {
-                        (props.status = 4),
+                        (resumedBoundary.status = 4),
                           (childNodes = getThrownInfo(task.componentStack)),
-                          (replay = logRecoverableError(
-                            request,
-                            error,
-                            childNodes
-                          )),
-                          (props.errorDigest = replay),
+                          "object" === typeof error &&
+                          null !== error &&
+                          error.$$typeof === REACT_POSTPONE_TYPE
+                            ? (logPostpone(request, error.message, childNodes),
+                              (type = "POSTPONE"))
+                            : (type = logRecoverableError(
+                                request,
+                                error,
+                                childNodes
+                              )),
+                          (resumedBoundary.errorDigest = type),
                           task.replay.pendingTasks--,
-                          request.clientRenderedBoundaries.push(props);
+                          request.clientRenderedBoundaries.push(
+                            resumedBoundary
+                          );
                       } finally {
                         (task.blockedBoundary = parentBoundary),
                           (task.hoistableState = parentHoistableState),
@@ -4522,10 +4566,10 @@ function retryNode(request, task) {
                           slots: node$jscomp$0,
                           pendingTasks: 0
                         },
-                        fallback,
+                        props,
                         -1,
                         parentBoundary,
-                        props.fallbackState,
+                        resumedBoundary.fallbackState,
                         fallbackAbortSet,
                         [key[0], "Suspense Fallback", key[2]],
                         task.formatContext,
@@ -4576,6 +4620,31 @@ function retryNode(request, task) {
         }
         return;
       }
+      if (
+        "function" === typeof node[ASYNC_ITERATOR] &&
+        (childNodes = node[ASYNC_ITERATOR]())
+      ) {
+        props = task.thenableState;
+        task.thenableState = null;
+        thenableIndexCounter = 0;
+        thenableState = props;
+        props = [];
+        key = !1;
+        if (childNodes === node)
+          for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+            if (node.done) {
+              key = !0;
+              break;
+            }
+            props.push(node.value);
+            node = readPreviousThenableFromState();
+          }
+        if (!key)
+          for (node = unwrapThenable(childNodes.next()); !node.done; )
+            props.push(node.value), (node = unwrapThenable(childNodes.next()));
+        renderChildrenArray(request, task, props, childIndex);
+        return;
+      }
       if ("function" === typeof node.then)
         return (
           (task.thenableState = null),
@@ -4588,32 +4657,32 @@ function retryNode(request, task) {
           node._currentValue,
           childIndex
         );
-      childIndex = Object.prototype.toString.call(node);
+      request = Object.prototype.toString.call(node);
       throw Error(
         "Objects are not valid as a React child (found: " +
-          ("[object Object]" === childIndex
+          ("[object Object]" === request
             ? "object with keys {" + Object.keys(node).join(", ") + "}"
-            : childIndex) +
+            : request) +
           "). If you meant to render a collection of children, use an array instead."
       );
     }
     if ("string" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
     else if ("number" === typeof node || "bigint" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             "" + node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
   }
 }
@@ -4650,16 +4719,13 @@ function renderChildrenArray(request, task, children, childIndex) {
             throw x;
           task.replay.pendingTasks--;
           children = getThrownInfo(task.componentStack);
-          var boundary = task.blockedBoundary,
-            error = x;
-          children = logRecoverableError(request, error, children);
-          abortRemainingReplayNodes(
+          erroredReplay(
             request,
-            boundary,
+            task.blockedBoundary,
+            x,
+            children,
             childIndex,
-            node,
-            error,
-            children
+            node
           );
         }
         task.replay = replay;
@@ -4676,14 +4742,15 @@ function renderChildrenArray(request, task, children, childIndex) {
     null !== task.replay &&
     ((j = task.replay.slots), null !== j && "object" === typeof j)
   ) {
-    for (childIndex = 0; childIndex < replayNodes; childIndex++)
-      (node = children[childIndex]),
-        (task.treeContext = pushTreeContext(replay, replayNodes, childIndex)),
-        (boundary = j[childIndex]),
-        "number" === typeof boundary
-          ? (resumeNode(request, task, boundary, node, childIndex),
-            delete j[childIndex])
-          : renderNode(request, task, node, childIndex);
+    for (childIndex = 0; childIndex < replayNodes; childIndex++) {
+      node = children[childIndex];
+      task.treeContext = pushTreeContext(replay, replayNodes, childIndex);
+      var resumeSegmentID = j[childIndex];
+      "number" === typeof resumeSegmentID
+        ? (resumeNode(request, task, resumeSegmentID, node, childIndex),
+          delete j[childIndex])
+        : renderNode(request, task, node, childIndex);
+    }
     task.treeContext = replay;
     task.keyPath = prevKeyPath;
     return;
@@ -4695,6 +4762,105 @@ function renderChildrenArray(request, task, children, childIndex) {
   task.treeContext = replay;
   task.keyPath = prevKeyPath;
 }
+function trackPostpone(request, trackedPostpones, task, segment) {
+  segment.status = 5;
+  var keyPath = task.keyPath,
+    boundary = task.blockedBoundary;
+  if (null === boundary)
+    (segment.id = request.nextSegmentId++),
+      (trackedPostpones.rootSlots = segment.id),
+      null !== request.completedRootSegment &&
+        (request.completedRootSegment.status = 5);
+  else {
+    if (null !== boundary && 0 === boundary.status) {
+      boundary.status = 5;
+      boundary.rootSegmentID = request.nextSegmentId++;
+      var boundaryKeyPath = boundary.trackedContentKeyPath;
+      if (null === boundaryKeyPath)
+        throw Error(
+          "It should not be possible to postpone at the root. This is a bug in React."
+        );
+      var fallbackReplayNode = boundary.trackedFallbackNode,
+        children = [];
+      if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+        -1 === segment.id &&
+          (segment.id = segment.parentFlushed
+            ? boundary.rootSegmentID
+            : request.nextSegmentId++);
+        segment = [
+          boundaryKeyPath[1],
+          boundaryKeyPath[2],
+          children,
+          segment.id,
+          fallbackReplayNode,
+          boundary.rootSegmentID
+        ];
+        trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+        addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+        return;
+      }
+      var boundaryNode$44 = trackedPostpones.workingMap.get(boundaryKeyPath);
+      void 0 === boundaryNode$44
+        ? ((boundaryNode$44 = [
+            boundaryKeyPath[1],
+            boundaryKeyPath[2],
+            children,
+            null,
+            fallbackReplayNode,
+            boundary.rootSegmentID
+          ]),
+          trackedPostpones.workingMap.set(boundaryKeyPath, boundaryNode$44),
+          addToReplayParent(
+            boundaryNode$44,
+            boundaryKeyPath[0],
+            trackedPostpones
+          ))
+        : ((boundaryKeyPath = boundaryNode$44),
+          (boundaryKeyPath[4] = fallbackReplayNode),
+          (boundaryKeyPath[5] = boundary.rootSegmentID));
+    }
+    -1 === segment.id &&
+      (segment.id =
+        segment.parentFlushed && null !== boundary
+          ? boundary.rootSegmentID
+          : request.nextSegmentId++);
+    if (-1 === task.childIndex)
+      null === keyPath
+        ? (trackedPostpones.rootSlots = segment.id)
+        : ((task = trackedPostpones.workingMap.get(keyPath)),
+          void 0 === task
+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+              addToReplayParent(task, keyPath[0], trackedPostpones))
+            : (task[3] = segment.id));
+    else {
+      if (null === keyPath)
+        if (((request = trackedPostpones.rootSlots), null === request))
+          request = trackedPostpones.rootSlots = {};
+        else {
+          if ("number" === typeof request)
+            throw Error(
+              "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+            );
+        }
+      else if (
+        ((boundary = trackedPostpones.workingMap),
+        (boundaryKeyPath = boundary.get(keyPath)),
+        void 0 === boundaryKeyPath)
+      )
+        (request = {}),
+          (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+          boundary.set(keyPath, boundaryKeyPath),
+          addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+      else if (((request = boundaryKeyPath[3]), null === request))
+        request = boundaryKeyPath[3] = {};
+      else if ("number" === typeof request)
+        throw Error(
+          "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+        );
+      request[task.childIndex] = segment.id;
+    }
+  }
+}
 function untrackBoundary(request, boundary) {
   request = request.trackedPostpones;
   null !== request &&
@@ -4741,7 +4907,6 @@ function spawnNewSuspendedRenderTask(request, task, thenableState) {
     task.childIndex,
     task.blockedBoundary,
     newSegment,
-    task.blockedPreamble,
     task.hoistableState,
     task.abortSet,
     task.keyPath,
@@ -4765,13 +4930,14 @@ function renderNode(request, task, node, childIndex) {
     } catch (thrownValue) {
       if (
         (resetHooksState(),
-        (node =
+        (childIndex =
           thrownValue === SuspenseException
             ? getSuspendedThenable()
             : thrownValue),
-        "object" === typeof node && null !== node)
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -4783,7 +4949,7 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedReplayTask(request, task, node);
           request.pingedTasks.push(node);
@@ -4802,18 +4968,19 @@ function renderNode(request, task, node, childIndex) {
       chunkLength = segment.chunks.length;
     try {
       return renderNodeDestructive(request, task, node, childIndex);
-    } catch (thrownValue$48) {
+    } catch (thrownValue$56) {
       if (
         (resetHooksState(),
         (segment.children.length = childrenLength),
         (segment.chunks.length = chunkLength),
-        (node =
-          thrownValue$48 === SuspenseException
+        (childIndex =
+          thrownValue$56 === SuspenseException
             ? getSuspendedThenable()
-            : thrownValue$48),
-        "object" === typeof node && null !== node)
+            : thrownValue$56),
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -4825,7 +4992,35 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if (
+          childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+          null !== request.trackedPostpones &&
+          null !== task.blockedBoundary
+        ) {
+          node = request.trackedPostpones;
+          segment = getThrownInfo(task.componentStack);
+          logPostpone(request, childIndex.message, segment);
+          childIndex = task.blockedSegment;
+          segment = createPendingSegment(
+            request,
+            childIndex.chunks.length,
+            null,
+            task.formatContext,
+            childIndex.lastPushedText,
+            !0
+          );
+          childIndex.children.push(segment);
+          childIndex.lastPushedText = !1;
+          trackPostpone(request, node, task, segment);
+          task.formatContext = previousFormatContext;
+          task.context = previousContext;
+          task.keyPath = previousKeyPath;
+          task.treeContext = previousTreeContext;
+          task.componentStack = previousComponentStack;
+          switchContext(previousContext);
+          return;
+        }
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedRenderTask(request, task, node);
           request.pingedTasks.push(node);
@@ -4845,7 +5040,29 @@ function renderNode(request, task, node, childIndex) {
   task.keyPath = previousKeyPath;
   task.treeContext = previousTreeContext;
   switchContext(previousContext);
-  throw node;
+  throw childIndex;
+}
+function erroredReplay(
+  request,
+  boundary,
+  error,
+  errorInfo,
+  replayNodes,
+  resumeSlots
+) {
+  "object" === typeof error &&
+  null !== error &&
+  error.$$typeof === REACT_POSTPONE_TYPE
+    ? (logPostpone(request, error.message, errorInfo), (errorInfo = "POSTPONE"))
+    : (errorInfo = logRecoverableError(request, error, errorInfo));
+  abortRemainingReplayNodes(
+    request,
+    boundary,
+    replayNodes,
+    resumeSlots,
+    error,
+    errorInfo
+  );
 }
 function abortTaskSoft(task) {
   var boundary = task.blockedBoundary;
@@ -4875,12 +5092,7 @@ function abortRemainingReplayNodes(
       node = node[5];
       var request = request$jscomp$0,
         errorDigest = errorDigest$jscomp$0,
-        resumedBoundary = createSuspenseBoundary(
-          request,
-          new Set(),
-          null,
-          null
-        );
+        resumedBoundary = createSuspenseBoundary(request, new Set());
       resumedBoundary.parentFlushed = !0;
       resumedBoundary.rootSegmentID = node;
       resumedBoundary.status = 4;
@@ -4910,44 +5122,100 @@ function abortTask(task, request, error) {
     if (6 === segment.status) return;
     segment.status = 3;
   }
-  segment = getThrownInfo(task.componentStack);
+  var errorInfo = getThrownInfo(task.componentStack);
   if (null === boundary) {
     if (13 !== request.status && 14 !== request.status) {
       boundary = task.replay;
       if (null === boundary) {
-        logRecoverableError(request, error, segment);
-        fatalError(request, error);
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? ((boundary = request.trackedPostpones),
+            null !== boundary && null !== segment
+              ? (logPostpone(request, error.message, errorInfo),
+                trackPostpone(request, boundary, task, segment),
+                finishedTask(request, null, segment))
+              : ((task = Error(
+                  "The render was aborted with postpone when the shell is incomplete. Reason: " +
+                    error.message
+                )),
+                logRecoverableError(request, task, errorInfo),
+                fatalError(request, task)))
+          : null !== request.trackedPostpones && null !== segment
+            ? ((boundary = request.trackedPostpones),
+              logRecoverableError(request, error, errorInfo),
+              trackPostpone(request, boundary, task, segment),
+              finishedTask(request, null, segment))
+            : (logRecoverableError(request, error, errorInfo),
+              fatalError(request, error));
         return;
       }
       boundary.pendingTasks--;
       0 === boundary.pendingTasks &&
         0 < boundary.nodes.length &&
-        ((task = logRecoverableError(request, error, segment)),
+        ("object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? (logPostpone(request, error.message, errorInfo),
+            (errorInfo = "POSTPONE"))
+          : (errorInfo = logRecoverableError(request, error, errorInfo)),
         abortRemainingReplayNodes(
           request,
           null,
           boundary.nodes,
           boundary.slots,
           error,
-          task
+          errorInfo
         ));
       request.pendingRootTasks--;
       0 === request.pendingRootTasks && completeShell(request);
     }
-  } else
-    boundary.pendingTasks--,
-      4 !== boundary.status &&
-        ((boundary.status = 4),
-        (task = logRecoverableError(request, error, segment)),
-        (boundary.status = 4),
-        (boundary.errorDigest = task),
-        untrackBoundary(request, boundary),
-        boundary.parentFlushed &&
-          request.clientRenderedBoundaries.push(boundary)),
-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-        return abortTask(fallbackTask, request, error);
-      }),
-      boundary.fallbackAbortableTasks.clear();
+  } else {
+    boundary.pendingTasks--;
+    var trackedPostpones$59 = request.trackedPostpones;
+    if (4 !== boundary.status) {
+      if (null !== trackedPostpones$59 && null !== segment)
+        return (
+          "object" === typeof error &&
+          null !== error &&
+          error.$$typeof === REACT_POSTPONE_TYPE
+            ? logPostpone(request, error.message, errorInfo)
+            : logRecoverableError(request, error, errorInfo),
+          trackPostpone(request, trackedPostpones$59, task, segment),
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          }),
+          boundary.fallbackAbortableTasks.clear(),
+          finishedTask(request, boundary, segment)
+        );
+      boundary.status = 4;
+      if (
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+      ) {
+        logPostpone(request, error.message, errorInfo);
+        if (null !== request.trackedPostpones && null !== segment) {
+          trackPostpone(request, request.trackedPostpones, task, segment);
+          finishedTask(request, task.blockedBoundary, segment);
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          });
+          boundary.fallbackAbortableTasks.clear();
+          return;
+        }
+        errorInfo = "POSTPONE";
+      } else errorInfo = logRecoverableError(request, error, errorInfo);
+      boundary.status = 4;
+      boundary.errorDigest = errorInfo;
+      untrackBoundary(request, boundary);
+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
+    }
+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+      return abortTask(fallbackTask, request, error);
+    });
+    boundary.fallbackAbortableTasks.clear();
+  }
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
@@ -5014,7 +5282,6 @@ function safelyEmitEarlyPreloads(request, shellComplete) {
 }
 function completeShell(request) {
   null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-  null === request.trackedPostpones && preparePreamble(request);
   request.onShellError = noop;
   request = request.onShellReady;
   request();
@@ -5027,7 +5294,6 @@ function completeAll(request) {
       : null === request.completedRootSegment ||
           5 !== request.completedRootSegment.status
   );
-  preparePreamble(request);
   request = request.onAllReady;
   request();
 }
@@ -5068,11 +5334,7 @@ function finishedTask(request, boundary, segment) {
               request.completedBoundaries.push(boundary),
             1 === boundary.status &&
               (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),
-              boundary.fallbackAbortableTasks.clear(),
-              0 === request.pendingRootTasks &&
-                null === request.trackedPostpones &&
-                null !== boundary.contentPreamble &&
-                preparePreamble(request)))
+              boundary.fallbackAbortableTasks.clear()))
           : null !== segment &&
             segment.parentFlushed &&
             1 === segment.status &&
@@ -5083,23 +5345,23 @@ function finishedTask(request, boundary, segment) {
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
-function performWork(request$jscomp$2) {
-  if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
+function performWork(request$jscomp$1) {
+  if (14 !== request$jscomp$1.status && 13 !== request$jscomp$1.status) {
     var prevContext = currentActiveSnapshot,
       prevDispatcher = ReactSharedInternals.H;
     ReactSharedInternals.H = HooksDispatcher;
     var prevAsyncDispatcher = ReactSharedInternals.A;
     ReactSharedInternals.A = DefaultAsyncDispatcher;
     var prevRequest = currentRequest;
-    currentRequest = request$jscomp$2;
+    currentRequest = request$jscomp$1;
     var prevResumableState = currentResumableState;
-    currentResumableState = request$jscomp$2.resumableState;
+    currentResumableState = request$jscomp$1.resumableState;
     try {
-      var pingedTasks = request$jscomp$2.pingedTasks,
+      var pingedTasks = request$jscomp$1.pingedTasks,
         i;
       for (i = 0; i < pingedTasks.length; i++) {
         var task = pingedTasks[i],
-          request = request$jscomp$2,
+          request = request$jscomp$1,
           segment = task.blockedSegment;
         if (null === segment) {
           var request$jscomp$0 = request;
@@ -5143,27 +5405,15 @@ function performWork(request$jscomp$2) {
                 task.replay.pendingTasks--;
                 task.abortSet.delete(task);
                 var errorInfo = getThrownInfo(task.componentStack);
-                request = void 0;
-                var request$jscomp$1 = request$jscomp$0,
-                  boundary = task.blockedBoundary,
-                  error$jscomp$0 =
-                    12 === request$jscomp$0.status
-                      ? request$jscomp$0.fatalError
-                      : x,
-                  replayNodes = task.replay.nodes,
-                  resumeSlots = task.replay.slots;
-                request = logRecoverableError(
-                  request$jscomp$1,
-                  error$jscomp$0,
-                  errorInfo
-                );
-                abortRemainingReplayNodes(
-                  request$jscomp$1,
-                  boundary,
-                  replayNodes,
-                  resumeSlots,
-                  error$jscomp$0,
-                  request
+                erroredReplay(
+                  request$jscomp$0,
+                  task.blockedBoundary,
+                  12 === request$jscomp$0.status
+                    ? request$jscomp$0.fatalError
+                    : x,
+                  errorInfo,
+                  task.replay.nodes,
+                  task.replay.slots
                 );
                 request$jscomp$0.pendingRootTasks--;
                 0 === request$jscomp$0.pendingRootTasks &&
@@ -5175,78 +5425,124 @@ function performWork(request$jscomp$2) {
             } finally {
             }
           }
-        } else if (
-          ((request$jscomp$0 = void 0),
-          (request$jscomp$1 = segment),
-          0 === request$jscomp$1.status)
-        ) {
-          request$jscomp$1.status = 6;
-          switchContext(task.context);
-          var childrenLength = request$jscomp$1.children.length,
-            chunkLength = request$jscomp$1.chunks.length;
-          try {
-            retryNode(request, task),
-              request$jscomp$1.lastPushedText &&
-                request$jscomp$1.textEmbedded &&
-                request$jscomp$1.chunks.push("\x3c!-- --\x3e"),
-              task.abortSet.delete(task),
-              (request$jscomp$1.status = 1),
-              finishedTask(request, task.blockedBoundary, request$jscomp$1);
-          } catch (thrownValue) {
-            resetHooksState();
-            request$jscomp$1.children.length = childrenLength;
-            request$jscomp$1.chunks.length = chunkLength;
-            var x$jscomp$0 =
-              thrownValue === SuspenseException
-                ? getSuspendedThenable()
-                : 12 === request.status
-                  ? request.fatalError
-                  : thrownValue;
-            if (
-              "object" === typeof x$jscomp$0 &&
-              null !== x$jscomp$0 &&
-              "function" === typeof x$jscomp$0.then
-            ) {
-              request$jscomp$1.status = 0;
-              task.thenableState = getThenableStateAfterSuspending();
-              var ping$jscomp$0 = task.ping;
-              x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-            } else {
-              var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
-              task.abortSet.delete(task);
-              request$jscomp$1.status = 4;
-              var boundary$jscomp$0 = task.blockedBoundary;
-              request$jscomp$0 = logRecoverableError(
-                request,
-                x$jscomp$0,
-                errorInfo$jscomp$0
-              );
-              null === boundary$jscomp$0
-                ? fatalError(request, x$jscomp$0)
-                : (boundary$jscomp$0.pendingTasks--,
-                  4 !== boundary$jscomp$0.status &&
-                    ((boundary$jscomp$0.status = 4),
-                    (boundary$jscomp$0.errorDigest = request$jscomp$0),
-                    untrackBoundary(request, boundary$jscomp$0),
-                    boundary$jscomp$0.parentFlushed &&
-                      request.clientRenderedBoundaries.push(boundary$jscomp$0),
-                    0 === request.pendingRootTasks &&
-                      null === request.trackedPostpones &&
-                      null !== boundary$jscomp$0.contentPreamble &&
-                      preparePreamble(request)));
-              request.allPendingTasks--;
-              0 === request.allPendingTasks && completeAll(request);
+        } else
+          a: {
+            request$jscomp$0 = void 0;
+            var segment$jscomp$0 = segment;
+            if (0 === segment$jscomp$0.status) {
+              segment$jscomp$0.status = 6;
+              switchContext(task.context);
+              var childrenLength = segment$jscomp$0.children.length,
+                chunkLength = segment$jscomp$0.chunks.length;
+              try {
+                retryNode(request, task),
+                  segment$jscomp$0.lastPushedText &&
+                    segment$jscomp$0.textEmbedded &&
+                    segment$jscomp$0.chunks.push("\x3c!-- --\x3e"),
+                  task.abortSet.delete(task),
+                  (segment$jscomp$0.status = 1),
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+              } catch (thrownValue) {
+                resetHooksState();
+                segment$jscomp$0.children.length = childrenLength;
+                segment$jscomp$0.chunks.length = chunkLength;
+                var x$jscomp$0 =
+                  thrownValue === SuspenseException
+                    ? getSuspendedThenable()
+                    : 12 === request.status
+                      ? request.fatalError
+                      : thrownValue;
+                if (
+                  12 === request.status &&
+                  null !== request.trackedPostpones
+                ) {
+                  var trackedPostpones = request.trackedPostpones,
+                    thrownInfo = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? logPostpone(request, x$jscomp$0.message, thrownInfo)
+                    : logRecoverableError(request, x$jscomp$0, thrownInfo);
+                  trackPostpone(
+                    request,
+                    trackedPostpones,
+                    task,
+                    segment$jscomp$0
+                  );
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+                } else {
+                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0) {
+                    if ("function" === typeof x$jscomp$0.then) {
+                      segment$jscomp$0.status = 0;
+                      task.thenableState = getThenableStateAfterSuspending();
+                      var ping$jscomp$0 = task.ping;
+                      x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                      break a;
+                    }
+                    if (
+                      null !== request.trackedPostpones &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ) {
+                      var trackedPostpones$63 = request.trackedPostpones;
+                      task.abortSet.delete(task);
+                      var postponeInfo = getThrownInfo(task.componentStack);
+                      logPostpone(request, x$jscomp$0.message, postponeInfo);
+                      trackPostpone(
+                        request,
+                        trackedPostpones$63,
+                        task,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                      break a;
+                    }
+                  }
+                  var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  segment$jscomp$0.status = 4;
+                  var boundary = task.blockedBoundary;
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        x$jscomp$0.message,
+                        errorInfo$jscomp$0
+                      ),
+                      (request$jscomp$0 = "POSTPONE"))
+                    : (request$jscomp$0 = logRecoverableError(
+                        request,
+                        x$jscomp$0,
+                        errorInfo$jscomp$0
+                      ));
+                  null === boundary
+                    ? fatalError(request, x$jscomp$0)
+                    : (boundary.pendingTasks--,
+                      4 !== boundary.status &&
+                        ((boundary.status = 4),
+                        (boundary.errorDigest = request$jscomp$0),
+                        untrackBoundary(request, boundary),
+                        boundary.parentFlushed &&
+                          request.clientRenderedBoundaries.push(boundary)));
+                  request.allPendingTasks--;
+                  0 === request.allPendingTasks && completeAll(request);
+                }
+              } finally {
+              }
             }
-          } finally {
           }
-        }
       }
       pingedTasks.splice(0, i);
-      null !== request$jscomp$2.destination &&
-        flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
+      null !== request$jscomp$1.destination &&
+        flushCompletedQueues(request$jscomp$1, request$jscomp$1.destination);
     } catch (error) {
-      logRecoverableError(request$jscomp$2, error, {}),
-        fatalError(request$jscomp$2, error);
+      logRecoverableError(request$jscomp$1, error, {}),
+        fatalError(request$jscomp$1, error);
     } finally {
       (currentResumableState = prevResumableState),
         (ReactSharedInternals.H = prevDispatcher),
@@ -5256,85 +5552,6 @@ function performWork(request$jscomp$2) {
     }
   }
 }
-function preparePreambleFromSubtree(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  segment.preambleChildren.length &&
-    collectedPreambleSegments.push(segment.preambleChildren);
-  for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-    pendingPreambles =
-      preparePreambleFromSegment(
-        request,
-        segment.children[i],
-        collectedPreambleSegments
-      ) || pendingPreambles;
-  return pendingPreambles;
-}
-function preparePreambleFromSegment(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  var boundary = segment.boundary;
-  if (null === boundary)
-    return preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    );
-  var preamble = boundary.contentPreamble,
-    fallbackPreamble = boundary.fallbackPreamble;
-  if (null === preamble || null === fallbackPreamble) return !1;
-  switch (boundary.status) {
-    case 1:
-      hoistPreambleState(request.renderState, preamble);
-      segment = boundary.completedSegments[0];
-      if (!segment)
-        throw Error(
-          "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
-        );
-      return preparePreambleFromSubtree(
-        request,
-        segment,
-        collectedPreambleSegments
-      );
-    case 5:
-      if (null !== request.trackedPostpones) return !0;
-    case 4:
-      if (1 === segment.status)
-        return (
-          hoistPreambleState(request.renderState, fallbackPreamble),
-          preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          )
-        );
-    default:
-      return !0;
-  }
-}
-function preparePreamble(request) {
-  if (
-    request.completedRootSegment &&
-    null === request.completedPreambleSegments
-  ) {
-    var collectedPreambleSegments = [],
-      hasPendingPreambles = preparePreambleFromSegment(
-        request,
-        request.completedRootSegment,
-        collectedPreambleSegments
-      ),
-      preamble = request.renderState.preamble;
-    if (
-      !1 === hasPendingPreambles ||
-      (preamble.headChunks && preamble.bodyChunks)
-    )
-      request.completedPreambleSegments = collectedPreambleSegments;
-  }
-}
 function flushSubtree(request, destination, segment, hoistableState) {
   segment.parentFlushed = !0;
   switch (segment.status) {
@@ -5463,40 +5680,52 @@ function flushCompletedBoundary(request, destination, boundary) {
   boundary = boundary.contentState;
   var requiresStyleInsertion = request.stylesToHoist;
   request.stylesToHoist = !1;
-  writeChunk(destination, request.startInlineScript);
-  requiresStyleInsertion
-    ? 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 10),
-        writeChunk(
-          destination,
-          '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
-        ))
-      : 0 === (completedSegments.instructions & 8)
-        ? ((completedSegments.instructions |= 8),
-          writeChunk(
-            destination,
-            '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
-          ))
-        : writeChunk(destination, '$RR("')
-    : 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 2),
-        writeChunk(
-          destination,
-          '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
-        ))
-      : writeChunk(destination, '$RC("');
+  var scriptFormat = 0 === completedSegments.streamingFormat;
+  scriptFormat
+    ? (writeChunk(destination, request.startInlineScript),
+      requiresStyleInsertion
+        ? 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 10),
+            writeChunk(
+              destination,
+              '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
+            ))
+          : 0 === (completedSegments.instructions & 8)
+            ? ((completedSegments.instructions |= 8),
+              writeChunk(
+                destination,
+                '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
+              ))
+            : writeChunk(destination, '$RR("')
+        : 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 2),
+            writeChunk(
+              destination,
+              '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
+            ))
+          : writeChunk(destination, '$RC("'))
+    : requiresStyleInsertion
+      ? writeChunk(destination, '<template data-rri="" data-bid="')
+      : writeChunk(destination, '<template data-rci="" data-bid="');
   completedSegments = i.toString(16);
   writeChunk(destination, request.boundaryPrefix);
   writeChunk(destination, completedSegments);
-  writeChunk(destination, '","');
+  scriptFormat
+    ? writeChunk(destination, '","')
+    : writeChunk(destination, '" data-sid="');
   writeChunk(destination, request.segmentPrefix);
   writeChunk(destination, completedSegments);
   requiresStyleInsertion
-    ? (writeChunk(destination, '",'),
-      writeStyleResourceDependenciesInJS(destination, boundary))
-    : writeChunk(destination, '"');
-  boundary = !!destination.write(")\x3c/script>");
-  return writeBootstrap(destination, request) && boundary;
+    ? scriptFormat
+      ? (writeChunk(destination, '",'),
+        writeStyleResourceDependenciesInJS(destination, boundary))
+      : (writeChunk(destination, '" data-sty="'),
+        writeStyleResourceDependenciesInAttr(destination, boundary))
+    : scriptFormat && writeChunk(destination, '"');
+  completedSegments = scriptFormat
+    ? !!destination.write(")\x3c/script>")
+    : !!destination.write('"></template>');
+  return writeBootstrap(destination, request) && completedSegments;
 }
 function flushPartiallyCompletedSegment(
   request,
@@ -5519,21 +5748,27 @@ function flushPartiallyCompletedSegment(
   flushSegmentContainer(request, destination, segment, hoistableState);
   boundary = request.resumableState;
   request = request.renderState;
-  writeChunk(destination, request.startInlineScript);
-  0 === (boundary.instructions & 1)
-    ? ((boundary.instructions |= 1),
-      writeChunk(
-        destination,
-        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
-      ))
-    : writeChunk(destination, '$RS("');
+  (segment = 0 === boundary.streamingFormat)
+    ? (writeChunk(destination, request.startInlineScript),
+      0 === (boundary.instructions & 1)
+        ? ((boundary.instructions |= 1),
+          writeChunk(
+            destination,
+            '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
+          ))
+        : writeChunk(destination, '$RS("'))
+    : writeChunk(destination, '<template data-rsi="" data-sid="');
   writeChunk(destination, request.segmentPrefix);
   segmentID = segmentID.toString(16);
   writeChunk(destination, segmentID);
-  writeChunk(destination, '","');
+  segment
+    ? writeChunk(destination, '","')
+    : writeChunk(destination, '" data-pid="');
   writeChunk(destination, request.placeholderPrefix);
   writeChunk(destination, segmentID);
-  destination = !!destination.write('")\x3c/script>');
+  destination = segment
+    ? !!destination.write('")\x3c/script>')
+    : !!destination.write('"></template>');
   return destination;
 }
 function flushCompletedQueues(request, destination) {
@@ -5543,12 +5778,22 @@ function flushCompletedQueues(request, destination) {
         completedRootSegment = request.completedRootSegment;
       if (null !== completedRootSegment) {
         if (5 === completedRootSegment.status) return;
-        var completedPreambleSegments = request.completedPreambleSegments;
-        if (null === completedPreambleSegments) return;
-        var renderState = request.renderState,
-          preamble = renderState.preamble,
-          htmlChunks = preamble.htmlChunks,
-          headChunks = preamble.headChunks,
+        var renderState = request.renderState;
+        if (
+          (0 !== request.allPendingTasks ||
+            null !== request.trackedPostpones) &&
+          renderState.externalRuntimeScript
+        ) {
+          var _renderState$external = renderState.externalRuntimeScript,
+            resumableState = request.resumableState,
+            src = _renderState$external.src,
+            chunks = _renderState$external.chunks;
+          resumableState.scriptResources.hasOwnProperty(src) ||
+            ((resumableState.scriptResources[src] = null),
+            renderState.scripts.add(chunks));
+        }
+        var htmlChunks = renderState.htmlChunks,
+          headChunks = renderState.headChunks,
           i$jscomp$0;
         if (htmlChunks) {
           for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -5589,27 +5834,10 @@ function flushCompletedQueues(request, destination) {
         var hoistableChunks = renderState.hoistableChunks;
         for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
           writeChunk(destination, hoistableChunks[i$jscomp$0]);
-        for (
-          renderState = hoistableChunks.length = 0;
-          renderState < completedPreambleSegments.length;
-          renderState++
-        ) {
-          var segments = completedPreambleSegments[renderState];
-          for (preamble = 0; preamble < segments.length; preamble++)
-            flushSegment(request, destination, segments[preamble], null);
-        }
-        var preamble$jscomp$0 = request.renderState.preamble,
-          headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-        (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) &&
+        hoistableChunks.length = 0;
+        htmlChunks &&
+          null === headChunks &&
           writeChunk(destination, endChunkForTag("head"));
-        var bodyChunks = preamble$jscomp$0.bodyChunks;
-        if (bodyChunks)
-          for (
-            completedPreambleSegments = 0;
-            completedPreambleSegments < bodyChunks.length;
-            completedPreambleSegments++
-          )
-            writeChunk(destination, bodyChunks[completedPreambleSegments]);
         flushSegment(request, destination, completedRootSegment, null);
         request.completedRootSegment = null;
         writeBootstrap(destination, request.renderState);
@@ -5650,32 +5878,45 @@ function flushCompletedQueues(request, destination) {
       for (i = 0; i < clientRenderedBoundaries.length; i++) {
         var boundary = clientRenderedBoundaries[i];
         renderState$jscomp$0 = destination;
-        var resumableState = request.resumableState,
+        var resumableState$jscomp$0 = request.resumableState,
           renderState$jscomp$1 = request.renderState,
           id = boundary.rootSegmentID,
-          errorDigest = boundary.errorDigest;
-        writeChunk(
-          renderState$jscomp$0,
-          renderState$jscomp$1.startInlineScript
-        );
-        0 === (resumableState.instructions & 4)
-          ? ((resumableState.instructions |= 4),
-            writeChunk(
+          errorDigest = boundary.errorDigest,
+          scriptFormat = 0 === resumableState$jscomp$0.streamingFormat;
+        scriptFormat
+          ? (writeChunk(
               renderState$jscomp$0,
-              '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
-            ))
-          : writeChunk(renderState$jscomp$0, '$RX("');
+              renderState$jscomp$1.startInlineScript
+            ),
+            0 === (resumableState$jscomp$0.instructions & 4)
+              ? ((resumableState$jscomp$0.instructions |= 4),
+                writeChunk(
+                  renderState$jscomp$0,
+                  '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
+                ))
+              : writeChunk(renderState$jscomp$0, '$RX("'))
+          : writeChunk(
+              renderState$jscomp$0,
+              '<template data-rxi="" data-bid="'
+            );
         writeChunk(renderState$jscomp$0, renderState$jscomp$1.boundaryPrefix);
         writeChunk(renderState$jscomp$0, id.toString(16));
-        writeChunk(renderState$jscomp$0, '"');
+        scriptFormat && writeChunk(renderState$jscomp$0, '"');
         errorDigest &&
-          (writeChunk(renderState$jscomp$0, ","),
-          writeChunk(
-            renderState$jscomp$0,
-            escapeJSStringsForInstructionScripts(errorDigest || "")
-          ));
-        var JSCompiler_inline_result =
-          !!renderState$jscomp$0.write(")\x3c/script>");
+          (scriptFormat
+            ? (writeChunk(renderState$jscomp$0, ","),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeJSStringsForInstructionScripts(errorDigest || "")
+              ))
+            : (writeChunk(renderState$jscomp$0, '" data-dgst="'),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeTextForBrowser(errorDigest || "")
+              )));
+        var JSCompiler_inline_result = scriptFormat
+          ? !!renderState$jscomp$0.write(")\x3c/script>")
+          : !!renderState$jscomp$0.write('"></template>');
         if (!JSCompiler_inline_result) {
           request.destination = null;
           i++;
@@ -5697,11 +5938,11 @@ function flushCompletedQueues(request, destination) {
       completedBoundaries.splice(0, i);
       var partialBoundaries = request.partialBoundaries;
       for (i = 0; i < partialBoundaries.length; i++) {
-        var boundary$51 = partialBoundaries[i];
+        var boundary$66 = partialBoundaries[i];
         a: {
           clientRenderedBoundaries = request;
           boundary = destination;
-          var completedSegments = boundary$51.completedSegments;
+          var completedSegments = boundary$66.completedSegments;
           for (
             JSCompiler_inline_result = 0;
             JSCompiler_inline_result < completedSegments.length;
@@ -5711,7 +5952,7 @@ function flushCompletedQueues(request, destination) {
               !flushPartiallyCompletedSegment(
                 clientRenderedBoundaries,
                 boundary,
-                boundary$51,
+                boundary$66,
                 completedSegments[JSCompiler_inline_result]
               )
             ) {
@@ -5723,7 +5964,7 @@ function flushCompletedQueues(request, destination) {
           completedSegments.splice(0, JSCompiler_inline_result);
           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
             boundary,
-            boundary$51.contentState,
+            boundary$66.contentState,
             clientRenderedBoundaries.renderState
           );
         }
@@ -5751,9 +5992,10 @@ function flushCompletedQueues(request, destination) {
     0 === request.clientRenderedBoundaries.length &&
     0 === request.completedBoundaries.length
       ? ((request.flushScheduled = !1),
-        (i = request.resumableState),
-        i.hasBody && writeChunk(destination, endChunkForTag("body")),
-        i.hasHtml && writeChunk(destination, endChunkForTag("html")),
+        null === request.trackedPostpones &&
+          ((i = request.resumableState),
+          i.hasBody && writeChunk(destination, endChunkForTag("body")),
+          i.hasHtml && writeChunk(destination, endChunkForTag("html"))),
         flushBuffered(destination),
         (request.status = 14),
         destination.end(),
@@ -5805,19 +6047,31 @@ function abort(request, reason) {
     }
     null !== request.destination &&
       flushCompletedQueues(request, request.destination);
-  } catch (error$53) {
-    logRecoverableError(request, error$53, {}), fatalError(request, error$53);
+  } catch (error$68) {
+    logRecoverableError(request, error$68, {}), fatalError(request, error$68);
+  }
+}
+function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+  if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+  else {
+    var workingMap = trackedPostpones.workingMap,
+      parentNode = workingMap.get(parentKeyPath);
+    void 0 === parentNode &&
+      ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+      workingMap.set(parentKeyPath, parentNode),
+      addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+    parentNode[2].push(node);
   }
 }
-var isomorphicReactPackageVersion$jscomp$inline_751 = React.version;
+var isomorphicReactPackageVersion$jscomp$inline_777 = React.version;
 if (
-  "19.1.0-canary-c492f975-20250128" !==
-  isomorphicReactPackageVersion$jscomp$inline_751
+  "19.1.0-experimental-b3a95caf-20250113" !==
+  isomorphicReactPackageVersion$jscomp$inline_777
 )
   throw Error(
     'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
-      (isomorphicReactPackageVersion$jscomp$inline_751 +
-        "\n  - react-dom:  19.1.0-canary-c492f975-20250128\nLearn more: https://react.dev/warnings/version-mismatch")
+      (isomorphicReactPackageVersion$jscomp$inline_777 +
+        "\n  - react-dom:  19.1.0-experimental-b3a95caf-20250113\nLearn more: https://react.dev/warnings/version-mismatch")
   );
 exports.renderToReadableStream = function (children, options) {
   return new Promise(function (resolve, reject) {
@@ -5908,4 +6162,4 @@ exports.renderToReadableStream = function (children, options) {
     startWork(request);
   });
 };
-exports.version = "19.1.0-canary-c492f975-20250128";
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
diff --git a/node_modules/react-dom/cjs/react-dom-server.edge.development.js b/node_modules/react-dom/cjs/react-dom-server.edge.development.js
index dd2901c..82bc69d 100644
--- a/node_modules/react-dom/cjs/react-dom-server.edge.development.js
+++ b/node_modules/react-dom/cjs/react-dom-server.edge.development.js
@@ -81,6 +81,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (type.$$typeof) {
@@ -806,28 +808,51 @@
             : stringToPrecomputedChunk(
                 '<script nonce="' + escapeTextForBrowser(nonce) + '">'
               ),
-        idPrefix = resumableState.idPrefix;
-      externalRuntimeConfig = [];
-      var bootstrapScriptContent = resumableState.bootstrapScriptContent,
+        idPrefix = resumableState.idPrefix,
+        bootstrapChunks = [],
+        externalRuntimeScript = null,
+        bootstrapScriptContent = resumableState.bootstrapScriptContent,
         bootstrapScripts = resumableState.bootstrapScripts,
         bootstrapModules = resumableState.bootstrapModules;
       void 0 !== bootstrapScriptContent &&
-        externalRuntimeConfig.push(
+        bootstrapChunks.push(
           inlineScriptWithNonce,
           stringToChunk(
             escapeEntireInlineScriptContent(bootstrapScriptContent)
           ),
           endInlineScript
         );
-      bootstrapScriptContent = [];
+      void 0 !== externalRuntimeConfig &&
+        ("string" === typeof externalRuntimeConfig
+          ? ((externalRuntimeScript = {
+              src: externalRuntimeConfig,
+              chunks: []
+            }),
+            pushScriptImpl(externalRuntimeScript.chunks, {
+              src: externalRuntimeConfig,
+              async: !0,
+              integrity: void 0,
+              nonce: nonce
+            }))
+          : ((externalRuntimeScript = {
+              src: externalRuntimeConfig.src,
+              chunks: []
+            }),
+            pushScriptImpl(externalRuntimeScript.chunks, {
+              src: externalRuntimeConfig.src,
+              async: !0,
+              integrity: externalRuntimeConfig.integrity,
+              nonce: nonce
+            })));
+      externalRuntimeConfig = [];
       void 0 !== importMap &&
-        (bootstrapScriptContent.push(importMapScriptStart),
-        bootstrapScriptContent.push(
+        (externalRuntimeConfig.push(importMapScriptStart),
+        externalRuntimeConfig.push(
           stringToChunk(
             escapeEntireInlineScriptContent(JSON.stringify(importMap))
           )
         ),
-        bootstrapScriptContent.push(importMapScriptEnd));
+        externalRuntimeConfig.push(importMapScriptEnd));
       onHeaders &&
         "number" === typeof maxHeadersLength &&
         0 >= maxHeadersLength &&
@@ -850,10 +875,11 @@
         segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
         boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
         startInlineScript: inlineScriptWithNonce,
-        preamble: createPreambleState(),
-        externalRuntimeScript: null,
-        bootstrapChunks: externalRuntimeConfig,
-        importMapChunks: bootstrapScriptContent,
+        htmlChunks: null,
+        headChunks: null,
+        externalRuntimeScript: externalRuntimeScript,
+        bootstrapChunks: bootstrapChunks,
+        importMapChunks: externalRuntimeConfig,
         onHeaders: onHeaders,
         headers: importMap,
         resets: {
@@ -884,109 +910,112 @@
         stylesToHoist: !1
       };
       if (void 0 !== bootstrapScripts)
-        for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
-          maxHeadersLength = bootstrapScripts[importMap];
-          bootstrapScriptContent = idPrefix = void 0;
-          var props = {
-            rel: "preload",
-            as: "script",
-            fetchPriority: "low",
-            nonce: nonce
-          };
-          "string" === typeof maxHeadersLength
-            ? (props.href = inlineScriptWithNonce = maxHeadersLength)
-            : ((props.href = inlineScriptWithNonce = maxHeadersLength.src),
-              (props.integrity = bootstrapScriptContent =
-                "string" === typeof maxHeadersLength.integrity
-                  ? maxHeadersLength.integrity
-                  : void 0),
-              (props.crossOrigin = idPrefix =
-                "string" === typeof maxHeadersLength ||
-                null == maxHeadersLength.crossOrigin
-                  ? void 0
-                  : "use-credentials" === maxHeadersLength.crossOrigin
-                    ? "use-credentials"
-                    : ""));
-          preloadBootstrapScriptOrModule(
-            resumableState,
-            onHeaders,
-            inlineScriptWithNonce,
-            props
-          );
-          externalRuntimeConfig.push(
-            startScriptSrc,
-            stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
-          );
-          nonce &&
-            externalRuntimeConfig.push(
-              scriptNonce,
-              stringToChunk(escapeTextForBrowser(nonce))
-            );
-          "string" === typeof bootstrapScriptContent &&
-            externalRuntimeConfig.push(
-              scriptIntegirty,
-              stringToChunk(escapeTextForBrowser(bootstrapScriptContent))
-            );
-          "string" === typeof idPrefix &&
-            externalRuntimeConfig.push(
-              scriptCrossOrigin,
-              stringToChunk(escapeTextForBrowser(idPrefix))
-            );
-          externalRuntimeConfig.push(endAsyncScript);
-        }
+        for (
+          inlineScriptWithNonce = 0;
+          inlineScriptWithNonce < bootstrapScripts.length;
+          inlineScriptWithNonce++
+        )
+          (idPrefix = bootstrapScripts[inlineScriptWithNonce]),
+            (maxHeadersLength = importMap = void 0),
+            (externalRuntimeConfig = {
+              rel: "preload",
+              as: "script",
+              fetchPriority: "low",
+              nonce: nonce
+            }),
+            "string" === typeof idPrefix
+              ? (externalRuntimeConfig.href = externalRuntimeScript = idPrefix)
+              : ((externalRuntimeConfig.href = externalRuntimeScript =
+                  idPrefix.src),
+                (externalRuntimeConfig.integrity = maxHeadersLength =
+                  "string" === typeof idPrefix.integrity
+                    ? idPrefix.integrity
+                    : void 0),
+                (externalRuntimeConfig.crossOrigin = importMap =
+                  "string" === typeof idPrefix || null == idPrefix.crossOrigin
+                    ? void 0
+                    : "use-credentials" === idPrefix.crossOrigin
+                      ? "use-credentials"
+                      : "")),
+            preloadBootstrapScriptOrModule(
+              resumableState,
+              onHeaders,
+              externalRuntimeScript,
+              externalRuntimeConfig
+            ),
+            bootstrapChunks.push(
+              startScriptSrc,
+              stringToChunk(escapeTextForBrowser(externalRuntimeScript))
+            ),
+            nonce &&
+              bootstrapChunks.push(
+                scriptNonce,
+                stringToChunk(escapeTextForBrowser(nonce))
+              ),
+            "string" === typeof maxHeadersLength &&
+              bootstrapChunks.push(
+                scriptIntegirty,
+                stringToChunk(escapeTextForBrowser(maxHeadersLength))
+              ),
+            "string" === typeof importMap &&
+              bootstrapChunks.push(
+                scriptCrossOrigin,
+                stringToChunk(escapeTextForBrowser(importMap))
+              ),
+            bootstrapChunks.push(endAsyncScript);
       if (void 0 !== bootstrapModules)
         for (
           bootstrapScripts = 0;
           bootstrapScripts < bootstrapModules.length;
           bootstrapScripts++
         )
-          (importMap = bootstrapModules[bootstrapScripts]),
-            (idPrefix = inlineScriptWithNonce = void 0),
-            (bootstrapScriptContent = {
+          (inlineScriptWithNonce = bootstrapModules[bootstrapScripts]),
+            (importMap = externalRuntimeScript = void 0),
+            (maxHeadersLength = {
               rel: "modulepreload",
               fetchPriority: "low",
               nonce: nonce
             }),
-            "string" === typeof importMap
-              ? (bootstrapScriptContent.href = maxHeadersLength = importMap)
-              : ((bootstrapScriptContent.href = maxHeadersLength =
-                  importMap.src),
-                (bootstrapScriptContent.integrity = idPrefix =
-                  "string" === typeof importMap.integrity
-                    ? importMap.integrity
+            "string" === typeof inlineScriptWithNonce
+              ? (maxHeadersLength.href = idPrefix = inlineScriptWithNonce)
+              : ((maxHeadersLength.href = idPrefix = inlineScriptWithNonce.src),
+                (maxHeadersLength.integrity = importMap =
+                  "string" === typeof inlineScriptWithNonce.integrity
+                    ? inlineScriptWithNonce.integrity
                     : void 0),
-                (bootstrapScriptContent.crossOrigin = inlineScriptWithNonce =
-                  "string" === typeof importMap || null == importMap.crossOrigin
+                (maxHeadersLength.crossOrigin = externalRuntimeScript =
+                  "string" === typeof inlineScriptWithNonce ||
+                  null == inlineScriptWithNonce.crossOrigin
                     ? void 0
-                    : "use-credentials" === importMap.crossOrigin
+                    : "use-credentials" === inlineScriptWithNonce.crossOrigin
                       ? "use-credentials"
                       : "")),
             preloadBootstrapScriptOrModule(
               resumableState,
               onHeaders,
-              maxHeadersLength,
-              bootstrapScriptContent
+              idPrefix,
+              maxHeadersLength
             ),
-            externalRuntimeConfig.push(
+            bootstrapChunks.push(
               startModuleSrc,
-              stringToChunk(escapeTextForBrowser(maxHeadersLength))
+              stringToChunk(escapeTextForBrowser(idPrefix))
             ),
             nonce &&
-              externalRuntimeConfig.push(
+              bootstrapChunks.push(
                 scriptNonce,
                 stringToChunk(escapeTextForBrowser(nonce))
               ),
-            "string" === typeof idPrefix &&
-              externalRuntimeConfig.push(
+            "string" === typeof importMap &&
+              bootstrapChunks.push(
                 scriptIntegirty,
-                stringToChunk(escapeTextForBrowser(idPrefix))
+                stringToChunk(escapeTextForBrowser(importMap))
               ),
-            "string" === typeof inlineScriptWithNonce &&
-              externalRuntimeConfig.push(
+            "string" === typeof externalRuntimeScript &&
+              bootstrapChunks.push(
                 scriptCrossOrigin,
-                stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
+                stringToChunk(escapeTextForBrowser(externalRuntimeScript))
               ),
-            externalRuntimeConfig.push(endAsyncScript);
+            bootstrapChunks.push(endAsyncScript);
       return onHeaders;
     }
     function createResumableState(
@@ -996,10 +1025,12 @@
       bootstrapScripts,
       bootstrapModules
     ) {
+      var streamingFormat = ScriptStreamingFormat;
+      void 0 !== externalRuntimeConfig && (streamingFormat = 1);
       return {
         idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
         nextFormID: 0,
-        streamingFormat: 0,
+        streamingFormat: streamingFormat,
         bootstrapScriptContent: bootstrapScriptContent,
         bootstrapScripts: bootstrapScripts,
         bootstrapModules: bootstrapModules,
@@ -1016,9 +1047,6 @@
         moduleScriptResources: {}
       };
     }
-    function createPreambleState() {
-      return { htmlChunks: null, headChunks: null, bodyChunks: null };
-    }
     function createFormatContext(insertionMode, selectedValue, tagScope) {
       return {
         insertionMode: insertionMode,
@@ -1089,26 +1117,16 @@
             null,
             parentContext.tagScope
           );
-        case "head":
-          if (parentContext.insertionMode < HTML_MODE)
-            return createFormatContext(
-              HTML_HEAD_MODE,
-              null,
-              parentContext.tagScope
-            );
-          break;
-        case "html":
-          if (parentContext.insertionMode === ROOT_HTML_MODE)
-            return createFormatContext(
-              HTML_HTML_MODE,
-              null,
-              parentContext.tagScope
-            );
       }
-      return parentContext.insertionMode >= HTML_TABLE_MODE ||
-        parentContext.insertionMode < HTML_MODE
+      return parentContext.insertionMode >= HTML_TABLE_MODE
         ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
-        : parentContext;
+        : parentContext.insertionMode === ROOT_HTML_MODE
+          ? "html" === type
+            ? createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope)
+            : createFormatContext(HTML_MODE, null, parentContext.tagScope)
+          : parentContext.insertionMode === HTML_HTML_MODE
+            ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
+            : parentContext;
     }
     function pushTextInstance(target, text, renderState, textEmbedded) {
       if ("" === text) return textEmbedded;
@@ -1634,7 +1652,8 @@
       return content;
     }
     function injectFormReplayingRuntime(resumableState, renderState) {
-      (resumableState.instructions & 16) === NothingSent &&
+      (resumableState.instructions & 16) !== NothingSent ||
+        renderState.externalRuntimeScript ||
         ((resumableState.instructions |= 16),
         renderState.bootstrapChunks.unshift(
           renderState.startInlineScript,
@@ -1799,7 +1818,6 @@
       props,
       resumableState,
       renderState,
-      preambleState,
       hoistableState,
       formatContext,
       textEmbedded,
@@ -2968,13 +2986,13 @@
         case "missing-glyph":
           break;
         case "head":
-          if (formatContext.insertionMode < HTML_MODE) {
-            var preamble = preambleState || renderState.preamble;
-            if (preamble.headChunks)
-              throw Error("The `<head>` tag may only be rendered once.");
-            preamble.headChunks = [];
+          if (
+            formatContext.insertionMode < HTML_MODE &&
+            null === renderState.headChunks
+          ) {
+            renderState.headChunks = [];
             var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-              preamble.headChunks,
+              renderState.headChunks,
               props,
               "head"
             );
@@ -2985,42 +3003,24 @@
               "head"
             );
           return JSCompiler_inline_result$jscomp$9;
-        case "body":
-          if (formatContext.insertionMode < HTML_MODE) {
-            var preamble$jscomp$0 = preambleState || renderState.preamble;
-            if (preamble$jscomp$0.bodyChunks)
-              throw Error("The `<body>` tag may only be rendered once.");
-            preamble$jscomp$0.bodyChunks = [];
-            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-              preamble$jscomp$0.bodyChunks,
-              props,
-              "body"
-            );
-          } else
-            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-              target$jscomp$0,
-              props,
-              "body"
-            );
-          return JSCompiler_inline_result$jscomp$10;
         case "html":
-          if (formatContext.insertionMode === ROOT_HTML_MODE) {
-            var preamble$jscomp$1 = preambleState || renderState.preamble;
-            if (preamble$jscomp$1.htmlChunks)
-              throw Error("The `<html>` tag may only be rendered once.");
-            preamble$jscomp$1.htmlChunks = [doctypeChunk];
-            var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-              preamble$jscomp$1.htmlChunks,
+          if (
+            formatContext.insertionMode === ROOT_HTML_MODE &&
+            null === renderState.htmlChunks
+          ) {
+            renderState.htmlChunks = [doctypeChunk];
+            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+              renderState.htmlChunks,
               props,
               "html"
             );
           } else
-            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
               target$jscomp$0,
               props,
               "html"
             );
-          return JSCompiler_inline_result$jscomp$11;
+          return JSCompiler_inline_result$jscomp$10;
         default:
           if (-1 !== type.indexOf("-")) {
             target$jscomp$0.push(startChunkForTag(type));
@@ -3090,15 +3090,6 @@
         endTagCache.set(tag, chunk));
       return chunk;
     }
-    function hoistPreambleState(renderState, preambleState) {
-      renderState = renderState.preamble;
-      null === renderState.htmlChunks &&
-        (renderState.htmlChunks = preambleState.htmlChunks);
-      null === renderState.headChunks &&
-        (renderState.headChunks = preambleState.headChunks);
-      null === renderState.bodyChunks &&
-        (renderState.bodyChunks = preambleState.bodyChunks);
-    }
     function writeBootstrap(destination, renderState) {
       renderState = renderState.bootstrapChunks;
       for (var i = 0; i < renderState.length - 1; i++)
@@ -3123,7 +3114,6 @@
       switch (formatContext.insertionMode) {
         case ROOT_HTML_MODE:
         case HTML_HTML_MODE:
-        case HTML_HEAD_MODE:
         case HTML_MODE:
           return (
             writeChunk(destination, startSegmentHTML),
@@ -3181,7 +3171,6 @@
       switch (formatContext.insertionMode) {
         case ROOT_HTML_MODE:
         case HTML_HTML_MODE:
-        case HTML_HEAD_MODE:
         case HTML_MODE:
           return writeChunkAndReturn(destination, endSegmentHTML);
         case SVG_MODE:
@@ -3472,6 +3461,121 @@
         stringToChunk(escapeJSObjectForInstructionScripts(name))
       );
     }
+    function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+      writeChunk(destination, arrayFirstOpenBracket);
+      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
+      hoistableState.stylesheets.forEach(function (resource) {
+        if (resource.state !== PREAMBLE)
+          if (resource.state === LATE)
+            writeChunk(destination, nextArrayOpenBrackChunk),
+              (resource = resource.props.href),
+              checkAttributeStringCoercion(resource, "href"),
+              writeChunk(
+                destination,
+                stringToChunk(
+                  escapeTextForBrowser(JSON.stringify("" + resource))
+                )
+              ),
+              writeChunk(destination, arrayCloseBracket),
+              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);
+          else {
+            writeChunk(destination, nextArrayOpenBrackChunk);
+            var precedence = resource.props["data-precedence"],
+              props = resource.props,
+              coercedHref = sanitizeURL("" + resource.props.href);
+            writeChunk(
+              destination,
+              stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref)))
+            );
+            checkAttributeStringCoercion(precedence, "precedence");
+            precedence = "" + precedence;
+            writeChunk(destination, arrayInterstitial);
+            writeChunk(
+              destination,
+              stringToChunk(escapeTextForBrowser(JSON.stringify(precedence)))
+            );
+            for (var propKey in props)
+              if (
+                hasOwnProperty.call(props, propKey) &&
+                ((precedence = props[propKey]), null != precedence)
+              )
+                switch (propKey) {
+                  case "href":
+                  case "rel":
+                  case "precedence":
+                  case "data-precedence":
+                    break;
+                  case "children":
+                  case "dangerouslySetInnerHTML":
+                    throw Error(
+                      "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                    );
+                  default:
+                    writeStyleResourceAttributeInAttr(
+                      destination,
+                      propKey,
+                      precedence
+                    );
+                }
+            writeChunk(destination, arrayCloseBracket);
+            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
+            resource.state = LATE;
+          }
+      });
+      writeChunk(destination, arrayCloseBracket);
+    }
+    function writeStyleResourceAttributeInAttr(destination, name, value) {
+      var attributeName = name.toLowerCase();
+      switch (typeof value) {
+        case "function":
+        case "symbol":
+          return;
+      }
+      switch (name) {
+        case "innerHTML":
+        case "dangerouslySetInnerHTML":
+        case "suppressContentEditableWarning":
+        case "suppressHydrationWarning":
+        case "style":
+        case "ref":
+          return;
+        case "className":
+          attributeName = "class";
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+          break;
+        case "hidden":
+          if (!1 === value) return;
+          name = "";
+          break;
+        case "src":
+        case "href":
+          value = sanitizeURL(value);
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+          break;
+        default:
+          if (
+            (2 < name.length &&
+              ("o" === name[0] || "O" === name[0]) &&
+              ("n" === name[1] || "N" === name[1])) ||
+            !isAttributeNameSafe(name)
+          )
+            return;
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+      }
+      writeChunk(destination, arrayInterstitial);
+      writeChunk(
+        destination,
+        stringToChunk(escapeTextForBrowser(JSON.stringify(attributeName)))
+      );
+      writeChunk(destination, arrayInterstitial);
+      writeChunk(
+        destination,
+        stringToChunk(escapeTextForBrowser(JSON.stringify(name)))
+      );
+    }
     function createHoistableState() {
       return { styles: new Set(), stylesheets: new Set() };
     }
@@ -3598,6 +3702,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (
@@ -3974,6 +4080,11 @@
           queue.next = componentIdentity;
         }
     }
+    function throwOnUseEffectEventCall() {
+      throw Error(
+        "A function wrapped in useEffectEvent can't be called during rendering."
+      );
+    }
     function unsupportedStartTransition() {
       throw Error("startTransition cannot be called during server rendering.");
     }
@@ -4054,8 +4165,15 @@
       null === thenableState && (thenableState = []);
       return trackUsedThenable(thenableState, thenable, index);
     }
-    function unsupportedRefresh() {
-      throw Error("Cache cannot be refreshed during server rendering.");
+    function readPreviousThenableFromState() {
+      var index = thenableIndexCounter;
+      thenableIndexCounter += 1;
+      if (null !== thenableState)
+        return (
+          (index = thenableState[index]),
+          (index = void 0 === index ? void 0 : index.value),
+          index
+        );
     }
     function noop$1() {}
     function disabledLog() {}
@@ -4283,6 +4401,27 @@
       "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
       return sampleLines;
     }
+    function formatOwnerStack(error) {
+      var prevPrepareStackTrace = Error.prepareStackTrace;
+      Error.prepareStackTrace = prepareStackTrace;
+      error = error.stack;
+      Error.prepareStackTrace = prevPrepareStackTrace;
+      error.startsWith("Error: react-stack-top-frame\n") &&
+        (error = error.slice(29));
+      prevPrepareStackTrace = error.indexOf("\n");
+      -1 !== prevPrepareStackTrace &&
+        (error = error.slice(prevPrepareStackTrace + 1));
+      prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
+      -1 !== prevPrepareStackTrace &&
+        (prevPrepareStackTrace = error.lastIndexOf(
+          "\n",
+          prevPrepareStackTrace
+        ));
+      if (-1 !== prevPrepareStackTrace)
+        error = error.slice(0, prevPrepareStackTrace);
+      else return "";
+      return error;
+    }
     function describeComponentStackByType(type) {
       if ("string" === typeof type) return describeBuiltInComponentFrame(type);
       if ("function" === typeof type)
@@ -4319,21 +4458,11 @@
           return describeBuiltInComponentFrame("SuspenseList");
         case REACT_SUSPENSE_TYPE:
           return describeBuiltInComponentFrame("Suspense");
+        case REACT_VIEW_TRANSITION_TYPE:
+          return describeBuiltInComponentFrame("ViewTransition");
       }
       return "";
     }
-    function getStackByComponentStackNode(componentStack) {
-      try {
-        var info = "";
-        do
-          (info += describeComponentStackByType(componentStack.type)),
-            (componentStack = componentStack.parent);
-        while (componentStack);
-        return info;
-      } catch (x) {
-        return "\nError generating stack: " + x.message + "\n" + x.stack;
-      }
-    }
     function defaultErrorHandler(error) {
       if (
         "object" === typeof error &&
@@ -4390,7 +4519,7 @@
       this.status = 10;
       this.fatalError = null;
       this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-      this.completedPreambleSegments = this.completedRootSegment = null;
+      this.completedRootSegment = null;
       this.abortableTasks = abortSet;
       this.pingedTasks = [];
       this.clientRenderedBoundaries = [];
@@ -4450,14 +4579,15 @@
         null,
         renderState,
         null,
-        null,
         resumableState.abortableTasks,
         null,
         rootFormatContext,
         null,
         emptyTreeContext,
         null,
-        !1
+        !1,
+        emptyContextObject,
+        null
       );
       pushComponentStack(children);
       resumableState.pingedTasks.push(children);
@@ -4497,73 +4627,182 @@
       };
       return children;
     }
-    function resolveRequest() {
-      if (currentRequest) return currentRequest;
-      if (supportsRequestStorage) {
-        var store = requestStorage.getStore();
-        if (store) return store;
-      }
-      return null;
-    }
-    function pingTask(request, task) {
-      request.pingedTasks.push(task);
-      1 === request.pingedTasks.length &&
-        ((request.flushScheduled = null !== request.destination),
-        null !== request.trackedPostpones || 10 === request.status
-          ? scheduleMicrotask(function () {
-              return performWork(request);
-            })
-          : setTimeout(function () {
-              return performWork(request);
-            }, 0));
-    }
-    function createSuspenseBoundary(
-      request,
-      fallbackAbortableTasks,
-      contentPreamble,
-      fallbackPreamble
-    ) {
-      return {
-        status: PENDING,
-        rootSegmentID: -1,
-        parentFlushed: !1,
-        pendingTasks: 0,
-        completedSegments: [],
-        byteSize: 0,
-        fallbackAbortableTasks: fallbackAbortableTasks,
-        errorDigest: null,
-        contentState: createHoistableState(),
-        fallbackState: createHoistableState(),
-        contentPreamble: contentPreamble,
-        fallbackPreamble: fallbackPreamble,
-        trackedContentKeyPath: null,
-        trackedFallbackNode: null,
-        errorMessage: null,
-        errorStack: null,
-        errorComponentStack: null
-      };
-    }
-    function createRenderTask(
-      request,
-      thenableState,
-      node,
-      childIndex,
-      blockedBoundary,
-      blockedSegment,
-      blockedPreamble,
-      hoistableState,
-      abortSet,
-      keyPath,
-      formatContext,
-      context,
-      treeContext,
-      componentStack,
-      isFallback
+    function resumeRequest(
+      children,
+      postponedState,
+      renderState,
+      onError,
+      onAllReady,
+      onShellReady,
+      onShellError,
+      onFatalError,
+      onPostpone
     ) {
-      request.allPendingTasks++;
-      null === blockedBoundary
-        ? request.pendingRootTasks++
-        : blockedBoundary.pendingTasks++;
+      renderState = new RequestInstance(
+        postponedState.resumableState,
+        renderState,
+        postponedState.rootFormatContext,
+        postponedState.progressiveChunkSize,
+        onError,
+        onAllReady,
+        onShellReady,
+        onShellError,
+        onFatalError,
+        onPostpone,
+        null
+      );
+      renderState.nextSegmentId = postponedState.nextSegmentId;
+      if ("number" === typeof postponedState.replaySlots)
+        return (
+          (onError = postponedState.replaySlots),
+          (onAllReady = createPendingSegment(
+            renderState,
+            0,
+            null,
+            postponedState.rootFormatContext,
+            !1,
+            !1
+          )),
+          (onAllReady.id = onError),
+          (onAllReady.parentFlushed = !0),
+          (children = createRenderTask(
+            renderState,
+            null,
+            children,
+            -1,
+            null,
+            onAllReady,
+            null,
+            renderState.abortableTasks,
+            null,
+            postponedState.rootFormatContext,
+            null,
+            emptyTreeContext,
+            null,
+            !1,
+            emptyContextObject,
+            null
+          )),
+          pushComponentStack(children),
+          renderState.pingedTasks.push(children),
+          renderState
+        );
+      children = createReplayTask(
+        renderState,
+        null,
+        {
+          nodes: postponedState.replayNodes,
+          slots: postponedState.replaySlots,
+          pendingTasks: 0
+        },
+        children,
+        -1,
+        null,
+        null,
+        renderState.abortableTasks,
+        null,
+        postponedState.rootFormatContext,
+        null,
+        emptyTreeContext,
+        null,
+        !1,
+        emptyContextObject,
+        null
+      );
+      pushComponentStack(children);
+      renderState.pingedTasks.push(children);
+      return renderState;
+    }
+    function resumeAndPrerenderRequest(
+      children,
+      postponedState,
+      renderState,
+      onError,
+      onAllReady,
+      onShellReady,
+      onShellError,
+      onFatalError,
+      onPostpone
+    ) {
+      children = resumeRequest(
+        children,
+        postponedState,
+        renderState,
+        onError,
+        onAllReady,
+        onShellReady,
+        onShellError,
+        onFatalError,
+        onPostpone
+      );
+      children.trackedPostpones = {
+        workingMap: new Map(),
+        rootNodes: [],
+        rootSlots: null
+      };
+      return children;
+    }
+    function resolveRequest() {
+      if (currentRequest) return currentRequest;
+      if (supportsRequestStorage) {
+        var store = requestStorage.getStore();
+        if (store) return store;
+      }
+      return null;
+    }
+    function pingTask(request, task) {
+      request.pingedTasks.push(task);
+      1 === request.pingedTasks.length &&
+        ((request.flushScheduled = null !== request.destination),
+        null !== request.trackedPostpones || 10 === request.status
+          ? scheduleMicrotask(function () {
+              return performWork(request);
+            })
+          : setTimeout(function () {
+              return performWork(request);
+            }, 0));
+    }
+    function createSuspenseBoundary(request, fallbackAbortableTasks) {
+      return {
+        status: PENDING,
+        rootSegmentID: -1,
+        parentFlushed: !1,
+        pendingTasks: 0,
+        completedSegments: [],
+        byteSize: 0,
+        fallbackAbortableTasks: fallbackAbortableTasks,
+        errorDigest: null,
+        contentState: createHoistableState(),
+        fallbackState: createHoistableState(),
+        trackedContentKeyPath: null,
+        trackedFallbackNode: null,
+        errorMessage: null,
+        errorStack: null,
+        errorComponentStack: null
+      };
+    }
+    function createRenderTask(
+      request,
+      thenableState,
+      node,
+      childIndex,
+      blockedBoundary,
+      blockedSegment,
+      hoistableState,
+      abortSet,
+      keyPath,
+      formatContext,
+      context,
+      treeContext,
+      componentStack,
+      isFallback,
+      legacyContext,
+      debugTask
+    ) {
+      request.allPendingTasks++;
+      null === blockedBoundary
+        ? request.pendingRootTasks++
+        : blockedBoundary.pendingTasks++;
       var task = {
         replay: null,
         node: node,
@@ -4573,7 +4812,6 @@
         },
         blockedBoundary: blockedBoundary,
         blockedSegment: blockedSegment,
-        blockedPreamble: blockedPreamble,
         hoistableState: hoistableState,
         abortSet: abortSet,
         keyPath: keyPath,
@@ -4584,6 +4822,7 @@
         thenableState: thenableState,
         isFallback: isFallback
       };
+      task.debugTask = debugTask;
       abortSet.add(task);
       return task;
     }
@@ -4601,7 +4840,9 @@
       context,
       treeContext,
       componentStack,
-      isFallback
+      isFallback,
+      legacyContext,
+      debugTask
     ) {
       request.allPendingTasks++;
       null === blockedBoundary
@@ -4617,7 +4858,6 @@
         },
         blockedBoundary: blockedBoundary,
         blockedSegment: null,
-        blockedPreamble: null,
         hoistableState: hoistableState,
         abortSet: abortSet,
         keyPath: keyPath,
@@ -4628,6 +4868,7 @@
         thenableState: thenableState,
         isFallback: isFallback
       };
+      task.debugTask = debugTask;
       abortSet.add(task);
       return task;
     }
@@ -4641,12 +4882,11 @@
     ) {
       return {
         status: PENDING,
-        parentFlushed: !1,
         id: -1,
         index: index,
+        parentFlushed: !1,
         chunks: [],
         children: [],
-        preambleChildren: [],
         parentFormatContext: parentFormatContext,
         boundary: boundary,
         lastPushedText: lastPushedText,
@@ -4654,22 +4894,63 @@
       };
     }
     function getCurrentStackInDEV() {
-      return null === currentTaskInDEV ||
-        null === currentTaskInDEV.componentStack
-        ? ""
-        : getStackByComponentStackNode(currentTaskInDEV.componentStack);
+      if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
+        return "";
+      var componentStack = currentTaskInDEV.componentStack;
+      try {
+        var info = "";
+        if ("string" === typeof componentStack.type)
+          info += describeBuiltInComponentFrame(componentStack.type);
+        else if ("function" === typeof componentStack.type) {
+          if (!componentStack.owner) {
+            var JSCompiler_temp_const = info,
+              fn = componentStack.type,
+              name = fn ? fn.displayName || fn.name : "";
+            var JSCompiler_inline_result = name
+              ? describeBuiltInComponentFrame(name)
+              : "";
+            info = JSCompiler_temp_const + JSCompiler_inline_result;
+          }
+        } else
+          componentStack.owner ||
+            (info += describeComponentStackByType(componentStack.type));
+        for (; componentStack; )
+          (JSCompiler_temp_const = null),
+            null != componentStack.debugStack
+              ? (JSCompiler_temp_const = formatOwnerStack(
+                  componentStack.debugStack
+                ))
+              : ((JSCompiler_inline_result = componentStack),
+                null != JSCompiler_inline_result.stack &&
+                  (JSCompiler_temp_const =
+                    "string" !== typeof JSCompiler_inline_result.stack
+                      ? (JSCompiler_inline_result.stack = formatOwnerStack(
+                          JSCompiler_inline_result.stack
+                        ))
+                      : JSCompiler_inline_result.stack)),
+            (componentStack = componentStack.owner) &&
+              JSCompiler_temp_const &&
+              (info += "\n" + JSCompiler_temp_const);
+        var JSCompiler_inline_result$jscomp$0 = info;
+      } catch (x) {
+        JSCompiler_inline_result$jscomp$0 =
+          "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+      return JSCompiler_inline_result$jscomp$0;
     }
     function pushServerComponentStack(task, debugInfo) {
       if (null != debugInfo)
         for (var i = 0; i < debugInfo.length; i++) {
           var componentInfo = debugInfo[i];
           "string" === typeof componentInfo.name &&
-            (task.componentStack = {
+            void 0 !== componentInfo.debugStack &&
+            ((task.componentStack = {
               parent: task.componentStack,
               type: componentInfo,
               owner: componentInfo.owner,
-              stack: null
-            });
+              stack: componentInfo.debugStack
+            }),
+            (task.debugTask = componentInfo.debugTask));
         }
     }
     function pushComponentStack(task) {
@@ -4678,13 +4959,15 @@
         switch (node.$$typeof) {
           case REACT_ELEMENT_TYPE:
             var type = node.type,
-              owner = node._owner;
+              owner = node._owner,
+              stack = node._debugStack;
             pushServerComponentStack(task, node._debugInfo);
+            task.debugTask = node._debugTask;
             task.componentStack = {
               parent: task.componentStack,
               type: type,
               owner: owner,
-              stack: null
+              stack: stack
             };
             break;
           case REACT_LAZY_TYPE:
@@ -4695,14 +4978,24 @@
               pushServerComponentStack(task, node._debugInfo);
         }
     }
-    function getThrownInfo(node) {
+    function getThrownInfo(node$jscomp$0) {
       var errorInfo = {};
-      node &&
+      node$jscomp$0 &&
         Object.defineProperty(errorInfo, "componentStack", {
           configurable: !0,
           enumerable: !0,
           get: function () {
-            var stack = getStackByComponentStackNode(node);
+            try {
+              var info = "",
+                node = node$jscomp$0;
+              do
+                (info += describeComponentStackByType(node.type)),
+                  (node = node.parent);
+              while (node);
+              var stack = info;
+            } catch (x) {
+              stack = "\nError generating stack: " + x.message + "\n" + x.stack;
+            }
             Object.defineProperty(errorInfo, "componentStack", {
               value: stack
             });
@@ -4733,9 +5026,17 @@
       boundary.errorStack = null !== error ? wasAborted + error : null;
       boundary.errorComponentStack = thrownInfo.componentStack;
     }
-    function logRecoverableError(request, error, errorInfo) {
+    function logPostpone(request, reason, postponeInfo, debugTask) {
+      request = request.onPostpone;
+      debugTask
+        ? debugTask.run(request.bind(null, reason, postponeInfo))
+        : request(reason, postponeInfo);
+    }
+    function logRecoverableError(request, error, errorInfo, debugTask) {
       request = request.onError;
-      error = request(error, errorInfo);
+      error = debugTask
+        ? debugTask.run(request.bind(null, error, errorInfo))
+        : request(error, errorInfo);
       if (null != error && "string" !== typeof error)
         console.error(
           'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
@@ -4743,11 +5044,13 @@
         );
       else return error;
     }
-    function fatalError(request, error) {
-      var onShellError = request.onShellError,
-        onFatalError = request.onFatalError;
-      onShellError(error);
-      onFatalError(error);
+    function fatalError(request, error, errorInfo, debugTask) {
+      errorInfo = request.onShellError;
+      var onFatalError = request.onFatalError;
+      debugTask
+        ? (debugTask.run(errorInfo.bind(null, error)),
+          debugTask.run(onFatalError.bind(null, error)))
+        : (errorInfo(error), onFatalError(error));
       null !== request.destination
         ? ((request.status = CLOSED),
           closeWithError(request.destination, error))
@@ -5287,7 +5590,6 @@
             props,
             request.resumableState,
             request.renderState,
-            task.blockedPreamble,
             task.hoistableState,
             task.formatContext,
             segment.lastPushedText,
@@ -5296,43 +5598,9 @@
           segment.lastPushedText = !1;
           var _prevContext = task.formatContext,
             _prevKeyPath2 = task.keyPath;
+          task.formatContext = getChildFormatContext(_prevContext, type, props);
           task.keyPath = keyPath;
-          if (
-            (task.formatContext = getChildFormatContext(
-              _prevContext,
-              type,
-              props
-            )).insertionMode === HTML_HEAD_MODE
-          ) {
-            var preambleSegment = createPendingSegment(
-              request,
-              0,
-              null,
-              task.formatContext,
-              !1,
-              !1
-            );
-            segment.preambleChildren.push(preambleSegment);
-            var preambleTask = createRenderTask(
-              request,
-              null,
-              _children,
-              -1,
-              task.blockedBoundary,
-              preambleSegment,
-              task.blockedPreamble,
-              task.hoistableState,
-              request.abortableTasks,
-              task.keyPath,
-              task.formatContext,
-              task.context,
-              task.treeContext,
-              task.componentStack,
-              task.isFallback
-            );
-            pushComponentStack(preambleTask);
-            request.pingedTasks.push(preambleTask);
-          } else renderNode(request, task, _children, -1);
+          renderNode(request, task, _children, -1);
           task.formatContext = _prevContext;
           task.keyPath = _prevKeyPath2;
           a: {
@@ -5369,9 +5637,6 @@
                   resumableState.hasHtml = !0;
                   break a;
                 }
-                break;
-              case "head":
-                if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;
             }
             target.push(endChunkForTag(type));
           }
@@ -5403,6 +5668,11 @@
             task.keyPath = _prevKeyPath3;
             return;
           case REACT_VIEW_TRANSITION_TYPE:
+            var _prevKeyPath4 = task.keyPath;
+            task.keyPath = keyPath;
+            renderNodeDestructive(request, task, props.children, -1);
+            task.keyPath = _prevKeyPath4;
+            return;
           case REACT_SCOPE_TYPE:
             throw Error(
               "ReactDOMServer does not yet support scope components."
@@ -5420,26 +5690,12 @@
             } else {
               var prevKeyPath$jscomp$3 = task.keyPath,
                 parentBoundary = task.blockedBoundary,
-                parentPreamble = task.blockedPreamble,
                 parentHoistableState = task.hoistableState,
                 parentSegment = task.blockedSegment,
                 fallback = props.fallback,
                 content = props.children,
-                fallbackAbortSet = new Set();
-              var newBoundary =
-                task.formatContext.insertionMode < HTML_MODE
-                  ? createSuspenseBoundary(
-                      request,
-                      fallbackAbortSet,
-                      createPreambleState(),
-                      createPreambleState()
-                    )
-                  : createSuspenseBoundary(
-                      request,
-                      fallbackAbortSet,
-                      null,
-                      null
-                    );
+                fallbackAbortSet = new Set(),
+                newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
               null !== request.trackedPostpones &&
                 (newBoundary.trackedContentKeyPath = keyPath);
               var boundarySegment = createPendingSegment(
@@ -5479,7 +5735,6 @@
                 );
                 newBoundary.trackedFallbackNode = fallbackReplayNode;
                 task.blockedSegment = boundarySegment;
-                task.blockedPreamble = newBoundary.fallbackPreamble;
                 task.keyPath = fallbackKeyPath;
                 boundarySegment.status = 6;
                 try {
@@ -5495,7 +5750,6 @@
                   );
                 } finally {
                   (task.blockedSegment = parentSegment),
-                    (task.blockedPreamble = parentPreamble),
                     (task.keyPath = prevKeyPath$jscomp$3);
                 }
                 var suspendedPrimaryTask = createRenderTask(
@@ -5505,7 +5759,6 @@
                   -1,
                   newBoundary,
                   contentRootSegment,
-                  newBoundary.contentPreamble,
                   newBoundary.contentState,
                   task.abortSet,
                   keyPath,
@@ -5513,13 +5766,14 @@
                   task.context,
                   task.treeContext,
                   task.componentStack,
-                  task.isFallback
+                  task.isFallback,
+                  emptyContextObject,
+                  task.debugTask
                 );
                 pushComponentStack(suspendedPrimaryTask);
                 request.pingedTasks.push(suspendedPrimaryTask);
               } else {
                 task.blockedBoundary = newBoundary;
-                task.blockedPreamble = newBoundary.contentPreamble;
                 task.hoistableState = newBoundary.contentState;
                 task.blockedSegment = contentRootSegment;
                 task.keyPath = keyPath;
@@ -5536,9 +5790,6 @@
                       newBoundary.status === PENDING)
                   ) {
                     newBoundary.status = COMPLETED;
-                    0 === request.pendingRootTasks &&
-                      task.blockedPreamble &&
-                      preparePreamble(request);
                     break a;
                   }
                 } catch (thrownValue$2) {
@@ -5549,11 +5800,25 @@
                   } else
                     (contentRootSegment.status = 4), (error = thrownValue$2);
                   var thrownInfo = getThrownInfo(task.componentStack);
-                  var errorDigest = logRecoverableError(
-                    request,
-                    error,
-                    thrownInfo
-                  );
+                  if (
+                    "object" === typeof error &&
+                    null !== error &&
+                    error.$$typeof === REACT_POSTPONE_TYPE
+                  ) {
+                    logPostpone(
+                      request,
+                      error.message,
+                      thrownInfo,
+                      task.debugTask
+                    );
+                    var errorDigest = "POSTPONE";
+                  } else
+                    errorDigest = logRecoverableError(
+                      request,
+                      error,
+                      thrownInfo,
+                      task.debugTask
+                    );
                   encodeErrorForBoundary(
                     newBoundary,
                     errorDigest,
@@ -5564,7 +5829,6 @@
                   untrackBoundary(request, newBoundary);
                 } finally {
                   (task.blockedBoundary = parentBoundary),
-                    (task.blockedPreamble = parentPreamble),
                     (task.hoistableState = parentHoistableState),
                     (task.blockedSegment = parentSegment),
                     (task.keyPath = prevKeyPath$jscomp$3);
@@ -5576,7 +5840,6 @@
                   -1,
                   parentBoundary,
                   boundarySegment,
-                  newBoundary.fallbackPreamble,
                   newBoundary.fallbackState,
                   fallbackAbortSet,
                   [keyPath[0], "Suspense Fallback", keyPath[2]],
@@ -5584,7 +5847,9 @@
                   task.context,
                   task.treeContext,
                   task.componentStack,
-                  !0
+                  !0,
+                  emptyContextObject,
+                  task.debugTask
                 );
                 pushComponentStack(suspendedFallbackTask);
                 request.pingedTasks.push(suspendedFallbackTask);
@@ -5736,15 +6001,186 @@
         (task.replay = prevReplay), (task.blockedSegment = null);
       }
     }
+    function replayElement(
+      request,
+      task,
+      keyPath,
+      name,
+      keyOrIndex,
+      childIndex,
+      type,
+      props,
+      ref,
+      replay
+    ) {
+      childIndex = replay.nodes;
+      for (var i = 0; i < childIndex.length; i++) {
+        var node = childIndex[i];
+        if (keyOrIndex === node[1]) {
+          if (4 === node.length) {
+            if (null !== name && name !== node[0])
+              throw Error(
+                "Expected the resume to render <" +
+                  node[0] +
+                  "> in this slot but instead it rendered <" +
+                  name +
+                  ">. The tree doesn't match so React will fallback to client rendering."
+              );
+            var childNodes = node[2];
+            node = node[3];
+            name = task.node;
+            task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
+            try {
+              renderElement(request, task, keyPath, type, props, ref);
+              if (
+                1 === task.replay.pendingTasks &&
+                0 < task.replay.nodes.length
+              )
+                throw Error(
+                  "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+                );
+              task.replay.pendingTasks--;
+            } catch (x) {
+              if (
+                "object" === typeof x &&
+                null !== x &&
+                (x === SuspenseException || "function" === typeof x.then)
+              )
+                throw (task.node === name && (task.replay = replay), x);
+              task.replay.pendingTasks--;
+              props = getThrownInfo(task.componentStack);
+              erroredReplay(
+                request,
+                task.blockedBoundary,
+                x,
+                props,
+                childNodes,
+                node,
+                task.debugTask
+              );
+            }
+            task.replay = replay;
+          } else {
+            if (type !== REACT_SUSPENSE_TYPE)
+              throw Error(
+                "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
+                  (getComponentNameFromType(type) || "Unknown") +
+                  ">. The tree doesn't match so React will fallback to client rendering."
+              );
+            a: {
+              replay = void 0;
+              type = node[5];
+              ref = node[2];
+              name = node[3];
+              keyOrIndex = null === node[4] ? [] : node[4][2];
+              node = null === node[4] ? null : node[4][3];
+              var prevKeyPath = task.keyPath,
+                previousReplaySet = task.replay,
+                parentBoundary = task.blockedBoundary,
+                parentHoistableState = task.hoistableState,
+                content = props.children;
+              props = props.fallback;
+              var fallbackAbortSet = new Set(),
+                resumedBoundary = createSuspenseBoundary(
+                  request,
+                  fallbackAbortSet
+                );
+              resumedBoundary.parentFlushed = !0;
+              resumedBoundary.rootSegmentID = type;
+              task.blockedBoundary = resumedBoundary;
+              task.hoistableState = resumedBoundary.contentState;
+              task.keyPath = keyPath;
+              task.replay = { nodes: ref, slots: name, pendingTasks: 1 };
+              try {
+                renderNode(request, task, content, -1);
+                if (
+                  1 === task.replay.pendingTasks &&
+                  0 < task.replay.nodes.length
+                )
+                  throw Error(
+                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+                  );
+                task.replay.pendingTasks--;
+                if (
+                  0 === resumedBoundary.pendingTasks &&
+                  resumedBoundary.status === PENDING
+                ) {
+                  resumedBoundary.status = COMPLETED;
+                  request.completedBoundaries.push(resumedBoundary);
+                  break a;
+                }
+              } catch (error) {
+                (resumedBoundary.status = CLIENT_RENDERED),
+                  (childNodes = getThrownInfo(task.componentStack)),
+                  "object" === typeof error &&
+                  null !== error &&
+                  error.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        error.message,
+                        childNodes,
+                        task.debugTask
+                      ),
+                      (replay = "POSTPONE"))
+                    : (replay = logRecoverableError(
+                        request,
+                        error,
+                        childNodes,
+                        task.debugTask
+                      )),
+                  encodeErrorForBoundary(
+                    resumedBoundary,
+                    replay,
+                    error,
+                    childNodes,
+                    !1
+                  ),
+                  task.replay.pendingTasks--,
+                  request.clientRenderedBoundaries.push(resumedBoundary);
+              } finally {
+                (task.blockedBoundary = parentBoundary),
+                  (task.hoistableState = parentHoistableState),
+                  (task.replay = previousReplaySet),
+                  (task.keyPath = prevKeyPath);
+              }
+              props = createReplayTask(
+                request,
+                null,
+                { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
+                props,
+                -1,
+                parentBoundary,
+                resumedBoundary.fallbackState,
+                fallbackAbortSet,
+                [keyPath[0], "Suspense Fallback", keyPath[2]],
+                task.formatContext,
+                task.context,
+                task.treeContext,
+                task.componentStack,
+                !0,
+                emptyContextObject,
+                task.debugTask
+              );
+              pushComponentStack(props);
+              request.pingedTasks.push(props);
+            }
+          }
+          childIndex.splice(i, 1);
+          break;
+        }
+      }
+    }
     function renderNodeDestructive(request, task, node, childIndex) {
       null !== task.replay && "number" === typeof task.replay.slots
         ? resumeNode(request, task, task.replay.slots, node, childIndex)
         : ((task.node = node),
           (task.childIndex = childIndex),
           (node = task.componentStack),
+          (childIndex = task.debugTask),
           pushComponentStack(task),
           retryNode(request, task),
-          (task.componentStack = node));
+          (task.componentStack = node),
+          (task.debugTask = childIndex));
     }
     function retryNode(request, task) {
       var node = task.node,
@@ -5754,178 +6190,56 @@
           switch (node.$$typeof) {
             case REACT_ELEMENT_TYPE:
               var type = node.type,
-                key = node.key,
-                props = node.props;
-              node = props.ref;
-              var ref = void 0 !== node ? node : null,
-                name = getComponentNameFromType(type),
-                keyOrIndex =
-                  null == key ? (-1 === childIndex ? 0 : childIndex) : key,
-                keyPath = [task.keyPath, name, keyOrIndex];
-              if (null !== task.replay) {
-                var replay = task.replay;
-                childIndex = replay.nodes;
-                for (node = 0; node < childIndex.length; node++)
-                  if (((key = childIndex[node]), keyOrIndex === key[1])) {
-                    if (4 === key.length) {
-                      if (null !== name && name !== key[0])
-                        throw Error(
-                          "Expected the resume to render <" +
-                            key[0] +
-                            "> in this slot but instead it rendered <" +
-                            name +
-                            ">. The tree doesn't match so React will fallback to client rendering."
-                        );
-                      var childNodes = key[2];
-                      key = key[3];
-                      name = task.node;
-                      task.replay = {
-                        nodes: childNodes,
-                        slots: key,
-                        pendingTasks: 1
-                      };
-                      try {
-                        renderElement(request, task, keyPath, type, props, ref);
-                        if (
-                          1 === task.replay.pendingTasks &&
-                          0 < task.replay.nodes.length
-                        )
-                          throw Error(
-                            "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                          );
-                        task.replay.pendingTasks--;
-                      } catch (x) {
-                        if (
-                          "object" === typeof x &&
-                          null !== x &&
-                          (x === SuspenseException ||
-                            "function" === typeof x.then)
-                        )
-                          throw (
-                            (task.node === name && (task.replay = replay), x)
-                          );
-                        task.replay.pendingTasks--;
-                        props = getThrownInfo(task.componentStack);
-                        erroredReplay(
-                          request,
-                          task.blockedBoundary,
-                          x,
-                          props,
-                          childNodes,
-                          key
-                        );
-                      }
-                      task.replay = replay;
-                    } else {
-                      if (type !== REACT_SUSPENSE_TYPE)
-                        throw Error(
-                          "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
-                            (getComponentNameFromType(type) || "Unknown") +
-                            ">. The tree doesn't match so React will fallback to client rendering."
-                        );
-                      a: {
-                        type = void 0;
-                        ref = key[5];
-                        replay = key[2];
-                        name = key[3];
-                        keyOrIndex = null === key[4] ? [] : key[4][2];
-                        key = null === key[4] ? null : key[4][3];
-                        var prevKeyPath = task.keyPath,
-                          previousReplaySet = task.replay,
-                          parentBoundary = task.blockedBoundary,
-                          parentHoistableState = task.hoistableState,
-                          content = props.children,
-                          fallback = props.fallback,
-                          fallbackAbortSet = new Set();
-                        props =
-                          task.formatContext.insertionMode < HTML_MODE
-                            ? createSuspenseBoundary(
-                                request,
-                                fallbackAbortSet,
-                                createPreambleState(),
-                                createPreambleState()
-                              )
-                            : createSuspenseBoundary(
-                                request,
-                                fallbackAbortSet,
-                                null,
-                                null
-                              );
-                        props.parentFlushed = !0;
-                        props.rootSegmentID = ref;
-                        task.blockedBoundary = props;
-                        task.hoistableState = props.contentState;
-                        task.keyPath = keyPath;
-                        task.replay = {
-                          nodes: replay,
-                          slots: name,
-                          pendingTasks: 1
-                        };
-                        try {
-                          renderNode(request, task, content, -1);
-                          if (
-                            1 === task.replay.pendingTasks &&
-                            0 < task.replay.nodes.length
-                          )
-                            throw Error(
-                              "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                            );
-                          task.replay.pendingTasks--;
-                          if (
-                            0 === props.pendingTasks &&
-                            props.status === PENDING
-                          ) {
-                            props.status = COMPLETED;
-                            request.completedBoundaries.push(props);
-                            break a;
-                          }
-                        } catch (error) {
-                          (props.status = CLIENT_RENDERED),
-                            (childNodes = getThrownInfo(task.componentStack)),
-                            (type = logRecoverableError(
-                              request,
-                              error,
-                              childNodes
-                            )),
-                            encodeErrorForBoundary(
-                              props,
-                              type,
-                              error,
-                              childNodes,
-                              !1
-                            ),
-                            task.replay.pendingTasks--,
-                            request.clientRenderedBoundaries.push(props);
-                        } finally {
-                          (task.blockedBoundary = parentBoundary),
-                            (task.hoistableState = parentHoistableState),
-                            (task.replay = previousReplaySet),
-                            (task.keyPath = prevKeyPath);
-                        }
-                        childNodes = createReplayTask(
-                          request,
-                          null,
-                          { nodes: keyOrIndex, slots: key, pendingTasks: 0 },
-                          fallback,
-                          -1,
-                          parentBoundary,
-                          props.fallbackState,
-                          fallbackAbortSet,
-                          [keyPath[0], "Suspense Fallback", keyPath[2]],
-                          task.formatContext,
-                          task.context,
-                          task.treeContext,
-                          task.componentStack,
-                          !0
-                        );
-                        pushComponentStack(childNodes);
-                        request.pingedTasks.push(childNodes);
-                      }
-                    }
-                    childIndex.splice(node, 1);
-                    break;
-                  }
-              } else renderElement(request, task, keyPath, type, props, ref);
+                key = node.key;
+              node = node.props;
+              var refProp = node.ref;
+              refProp = void 0 !== refProp ? refProp : null;
+              var debugTask = task.debugTask,
+                name = getComponentNameFromType(type);
+              key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;
+              var keyPath = [task.keyPath, name, key];
+              null !== task.replay
+                ? debugTask
+                  ? debugTask.run(
+                      replayElement.bind(
+                        null,
+                        request,
+                        task,
+                        keyPath,
+                        name,
+                        key,
+                        childIndex,
+                        type,
+                        node,
+                        refProp,
+                        task.replay
+                      )
+                    )
+                  : replayElement(
+                      request,
+                      task,
+                      keyPath,
+                      name,
+                      key,
+                      childIndex,
+                      type,
+                      node,
+                      refProp,
+                      task.replay
+                    )
+                : debugTask
+                  ? debugTask.run(
+                      renderElement.bind(
+                        null,
+                        request,
+                        task,
+                        keyPath,
+                        type,
+                        node,
+                        refProp
+                      )
+                    )
+                  : renderElement(request, task, keyPath, type, node, refProp);
               return;
             case REACT_PORTAL_TYPE:
               throw Error(
@@ -5942,21 +6256,20 @@
             return;
           }
           null === node || "object" !== typeof node
-            ? (props = null)
-            : ((childNodes =
+            ? (key = null)
+            : ((type =
                 (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||
                 node["@@iterator"]),
-              (props = "function" === typeof childNodes ? childNodes : null));
-          if (props && (childNodes = props.call(node))) {
-            if (childNodes === node) {
+              (key = "function" === typeof type ? type : null));
+          if (key && (type = key.call(node))) {
+            if (type === node) {
               if (
                 -1 !== childIndex ||
                 null === task.componentStack ||
                 "function" !== typeof task.componentStack.type ||
                 "[object GeneratorFunction]" !==
                   Object.prototype.toString.call(task.componentStack.type) ||
-                "[object Generator]" !==
-                  Object.prototype.toString.call(childNodes)
+                "[object Generator]" !== Object.prototype.toString.call(type)
               )
                 didWarnAboutGenerators ||
                   console.error(
@@ -5964,21 +6277,59 @@
                   ),
                   (didWarnAboutGenerators = !0);
             } else
-              node.entries !== props ||
+              node.entries !== key ||
                 didWarnAboutMaps ||
                 (console.error(
                   "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                 ),
                 (didWarnAboutMaps = !0));
-            node = childNodes.next();
+            node = type.next();
             if (!node.done) {
-              props = [];
-              do props.push(node.value), (node = childNodes.next());
+              key = [];
+              do key.push(node.value), (node = type.next());
               while (!node.done);
-              renderChildrenArray(request, task, props, childIndex);
+              renderChildrenArray(request, task, key, childIndex);
             }
             return;
           }
+          if (
+            "function" === typeof node[ASYNC_ITERATOR] &&
+            (type = node[ASYNC_ITERATOR]())
+          ) {
+            type !== node ||
+              (-1 === childIndex &&
+                null !== task.componentStack &&
+                "function" === typeof task.componentStack.type &&
+                "[object AsyncGeneratorFunction]" ===
+                  Object.prototype.toString.call(task.componentStack.type) &&
+                "[object AsyncGenerator]" ===
+                  Object.prototype.toString.call(type)) ||
+              (didWarnAboutGenerators ||
+                console.error(
+                  "Using AsyncIterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You can use an AsyncIterable that can iterate multiple times over the same items."
+                ),
+              (didWarnAboutGenerators = !0));
+            key = task.thenableState;
+            task.thenableState = null;
+            thenableIndexCounter = 0;
+            thenableState = key;
+            key = [];
+            refProp = !1;
+            if (type === node)
+              for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+                if (node.done) {
+                  refProp = !0;
+                  break;
+                }
+                key.push(node.value);
+                node = readPreviousThenableFromState();
+              }
+            if (!refProp)
+              for (node = unwrapThenable(type.next()); !node.done; )
+                key.push(node.value), (node = unwrapThenable(type.next()));
+            renderChildrenArray(request, task, key, childIndex);
+            return;
+          }
           if ("function" === typeof node.then)
             return (
               (task.thenableState = null),
@@ -5996,39 +6347,39 @@
               node._currentValue,
               childIndex
             );
-          childIndex = Object.prototype.toString.call(node);
+          request = Object.prototype.toString.call(node);
           throw Error(
             "Objects are not valid as a React child (found: " +
-              ("[object Object]" === childIndex
+              ("[object Object]" === request
                 ? "object with keys {" + Object.keys(node).join(", ") + "}"
-                : childIndex) +
+                : request) +
               "). If you meant to render a collection of children, use an array instead."
           );
         }
         "string" === typeof node
-          ? ((childIndex = task.blockedSegment),
-            null !== childIndex &&
-              (childIndex.lastPushedText = pushTextInstance(
-                childIndex.chunks,
+          ? ((task = task.blockedSegment),
+            null !== task &&
+              (task.lastPushedText = pushTextInstance(
+                task.chunks,
                 node,
                 request.renderState,
-                childIndex.lastPushedText
+                task.lastPushedText
               )))
           : "number" === typeof node || "bigint" === typeof node
-            ? ((childIndex = task.blockedSegment),
-              null !== childIndex &&
-                (childIndex.lastPushedText = pushTextInstance(
-                  childIndex.chunks,
+            ? ((task = task.blockedSegment),
+              null !== task &&
+                (task.lastPushedText = pushTextInstance(
+                  task.chunks,
                   "" + node,
                   request.renderState,
-                  childIndex.lastPushedText
+                  task.lastPushedText
                 )))
             : ("function" === typeof node &&
-                ((childIndex = node.displayName || node.name || "Component"),
+                ((request = node.displayName || node.name || "Component"),
                 console.error(
                   "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
-                  childIndex,
-                  childIndex
+                  request,
+                  request
                 )),
               "symbol" === typeof node &&
                 console.error(
@@ -6040,6 +6391,7 @@
     function renderChildrenArray(request$jscomp$0, task, children, childIndex) {
       var prevKeyPath = task.keyPath,
         previousComponentStack = task.componentStack;
+      var previousDebugTask = task.debugTask;
       pushServerComponentStack(task, task.node._debugInfo);
       if (
         -1 !== childIndex &&
@@ -6081,7 +6433,8 @@
                 x,
                 children,
                 childIndex,
-                node
+                node,
+                task.debugTask
               );
             }
             task.replay = replay;
@@ -6091,6 +6444,7 @@
         }
         task.keyPath = prevKeyPath;
         task.componentStack = previousComponentStack;
+        task.debugTask = previousDebugTask;
         return;
       }
       replay = task.treeContext;
@@ -6117,6 +6471,7 @@
         task.treeContext = replay;
         task.keyPath = prevKeyPath;
         task.componentStack = previousComponentStack;
+        task.debugTask = previousDebugTask;
         return;
       }
       for (j = 0; j < replayNodes; j++) {
@@ -6175,7 +6530,7 @@
               parent: node.componentStack,
               type: resumeSegmentID.type,
               owner: resumeSegmentID._owner,
-              stack: null
+              stack: resumeSegmentID._debugStack
             };
             console.error(
               'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
@@ -6191,6 +6546,106 @@
       task.treeContext = replay;
       task.keyPath = prevKeyPath;
       task.componentStack = previousComponentStack;
+      task.debugTask = previousDebugTask;
+    }
+    function trackPostpone(request, trackedPostpones, task, segment) {
+      segment.status = POSTPONED;
+      var keyPath = task.keyPath,
+        boundary = task.blockedBoundary;
+      if (null === boundary)
+        (segment.id = request.nextSegmentId++),
+          (trackedPostpones.rootSlots = segment.id),
+          null !== request.completedRootSegment &&
+            (request.completedRootSegment.status = POSTPONED);
+      else {
+        if (null !== boundary && boundary.status === PENDING) {
+          boundary.status = POSTPONED;
+          boundary.rootSegmentID = request.nextSegmentId++;
+          var boundaryKeyPath = boundary.trackedContentKeyPath;
+          if (null === boundaryKeyPath)
+            throw Error(
+              "It should not be possible to postpone at the root. This is a bug in React."
+            );
+          var fallbackReplayNode = boundary.trackedFallbackNode,
+            children = [];
+          if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+            -1 === segment.id &&
+              (segment.id = segment.parentFlushed
+                ? boundary.rootSegmentID
+                : request.nextSegmentId++);
+            segment = [
+              boundaryKeyPath[1],
+              boundaryKeyPath[2],
+              children,
+              segment.id,
+              fallbackReplayNode,
+              boundary.rootSegmentID
+            ];
+            trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+            addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+            return;
+          }
+          var _boundaryNode = trackedPostpones.workingMap.get(boundaryKeyPath);
+          void 0 === _boundaryNode
+            ? ((_boundaryNode = [
+                boundaryKeyPath[1],
+                boundaryKeyPath[2],
+                children,
+                null,
+                fallbackReplayNode,
+                boundary.rootSegmentID
+              ]),
+              trackedPostpones.workingMap.set(boundaryKeyPath, _boundaryNode),
+              addToReplayParent(
+                _boundaryNode,
+                boundaryKeyPath[0],
+                trackedPostpones
+              ))
+            : ((boundaryKeyPath = _boundaryNode),
+              (boundaryKeyPath[4] = fallbackReplayNode),
+              (boundaryKeyPath[5] = boundary.rootSegmentID));
+        }
+        -1 === segment.id &&
+          (segment.id =
+            segment.parentFlushed && null !== boundary
+              ? boundary.rootSegmentID
+              : request.nextSegmentId++);
+        if (-1 === task.childIndex)
+          null === keyPath
+            ? (trackedPostpones.rootSlots = segment.id)
+            : ((task = trackedPostpones.workingMap.get(keyPath)),
+              void 0 === task
+                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+                  addToReplayParent(task, keyPath[0], trackedPostpones))
+                : (task[3] = segment.id));
+        else {
+          if (null === keyPath)
+            if (((request = trackedPostpones.rootSlots), null === request))
+              request = trackedPostpones.rootSlots = {};
+            else {
+              if ("number" === typeof request)
+                throw Error(
+                  "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+                );
+            }
+          else if (
+            ((boundary = trackedPostpones.workingMap),
+            (boundaryKeyPath = boundary.get(keyPath)),
+            void 0 === boundaryKeyPath)
+          )
+            (request = {}),
+              (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+              boundary.set(keyPath, boundaryKeyPath),
+              addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+          else if (((request = boundaryKeyPath[3]), null === request))
+            request = boundaryKeyPath[3] = {};
+          else if ("number" === typeof request)
+            throw Error(
+              "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+            );
+          request[task.childIndex] = segment.id;
+        }
+      }
     }
     function untrackBoundary(request, boundary) {
       request = request.trackedPostpones;
@@ -6216,7 +6671,9 @@
         task.context,
         task.treeContext,
         task.componentStack,
-        task.isFallback
+        task.isFallback,
+        emptyContextObject,
+        task.debugTask
       );
     }
     function spawnNewSuspendedRenderTask(request, task, thenableState) {
@@ -6238,7 +6695,6 @@
         task.childIndex,
         task.blockedBoundary,
         newSegment,
-        task.blockedPreamble,
         task.hoistableState,
         task.abortSet,
         task.keyPath,
@@ -6246,7 +6702,9 @@
         task.context,
         task.treeContext,
         task.componentStack,
-        task.isFallback
+        task.isFallback,
+        emptyContextObject,
+        task.debugTask
       );
     }
     function renderNode(request, task, node, childIndex) {
@@ -6255,6 +6713,7 @@
         previousKeyPath = task.keyPath,
         previousTreeContext = task.treeContext,
         previousComponentStack = task.componentStack,
+        previousDebugTask = task.debugTask,
         segment = task.blockedSegment;
       if (null === segment)
         try {
@@ -6262,13 +6721,14 @@
         } catch (thrownValue) {
           if (
             (resetHooksState(),
-            (node =
+            (childIndex =
               thrownValue === SuspenseException
                 ? getSuspendedThenable()
                 : thrownValue),
-            "object" === typeof node && null !== node)
+            "object" === typeof childIndex && null !== childIndex)
           ) {
-            if ("function" === typeof node.then) {
+            if ("function" === typeof childIndex.then) {
+              node = childIndex;
               childIndex = getThenableStateAfterSuspending();
               request = spawnNewSuspendedReplayTask(
                 request,
@@ -6281,10 +6741,11 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
-            if ("Maximum call stack size exceeded" === node.message) {
+            if ("Maximum call stack size exceeded" === childIndex.message) {
               node = getThenableStateAfterSuspending();
               node = spawnNewSuspendedReplayTask(request, task, node);
               request.pingedTasks.push(node);
@@ -6293,6 +6754,7 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
@@ -6308,13 +6770,14 @@
             (resetHooksState(),
             (segment.children.length = childrenLength),
             (segment.chunks.length = chunkLength),
-            (node =
+            (childIndex =
               thrownValue$3 === SuspenseException
                 ? getSuspendedThenable()
                 : thrownValue$3),
-            "object" === typeof node && null !== node)
+            "object" === typeof childIndex && null !== childIndex)
           ) {
-            if ("function" === typeof node.then) {
+            if ("function" === typeof childIndex.then) {
+              node = childIndex;
               childIndex = getThenableStateAfterSuspending();
               request = spawnNewSuspendedRenderTask(
                 request,
@@ -6327,10 +6790,40 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
+              switchContext(previousContext);
+              return;
+            }
+            if (
+              childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+              null !== request.trackedPostpones &&
+              null !== task.blockedBoundary
+            ) {
+              node = request.trackedPostpones;
+              segment = getThrownInfo(task.componentStack);
+              logPostpone(request, childIndex.message, segment, task.debugTask);
+              childIndex = task.blockedSegment;
+              segment = createPendingSegment(
+                request,
+                childIndex.chunks.length,
+                null,
+                task.formatContext,
+                childIndex.lastPushedText,
+                !0
+              );
+              childIndex.children.push(segment);
+              childIndex.lastPushedText = !1;
+              trackPostpone(request, node, task, segment);
+              task.formatContext = previousFormatContext;
+              task.context = previousContext;
+              task.keyPath = previousKeyPath;
+              task.treeContext = previousTreeContext;
+              task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
-            if ("Maximum call stack size exceeded" === node.message) {
+            if ("Maximum call stack size exceeded" === childIndex.message) {
               node = getThenableStateAfterSuspending();
               node = spawnNewSuspendedRenderTask(request, task, node);
               request.pingedTasks.push(node);
@@ -6339,6 +6832,7 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
@@ -6350,7 +6844,7 @@
       task.keyPath = previousKeyPath;
       task.treeContext = previousTreeContext;
       switchContext(previousContext);
-      throw node;
+      throw childIndex;
     }
     function erroredReplay(
       request,
@@ -6358,16 +6852,27 @@
       error,
       errorInfo,
       replayNodes,
-      resumeSlots
+      resumeSlots,
+      debugTask
     ) {
-      var errorDigest = logRecoverableError(request, error, errorInfo);
+      "object" === typeof error &&
+      null !== error &&
+      error.$$typeof === REACT_POSTPONE_TYPE
+        ? (logPostpone(request, error.message, errorInfo, debugTask),
+          (debugTask = "POSTPONE"))
+        : (debugTask = logRecoverableError(
+            request,
+            error,
+            errorInfo,
+            debugTask
+          ));
       abortRemainingReplayNodes(
         request,
         boundary,
         replayNodes,
         resumeSlots,
         error,
-        errorDigest,
+        debugTask,
         errorInfo,
         !1
       );
@@ -6407,12 +6912,7 @@
             errorDigest = errorDigest$jscomp$0,
             errorInfo = errorInfo$jscomp$0,
             wasAborted = aborted,
-            resumedBoundary = createSuspenseBoundary(
-              request,
-              new Set(),
-              null,
-              null
-            );
+            resumedBoundary = createSuspenseBoundary(request, new Set());
           resumedBoundary.parentFlushed = !0;
           resumedBoundary.rootSegmentID = node;
           resumedBoundary.status = CLIENT_RENDERED;
@@ -6455,19 +6955,43 @@
         if (6 === segment.status) return;
         segment.status = 3;
       }
-      segment = getThrownInfo(task.componentStack);
+      var errorInfo = getThrownInfo(task.componentStack);
       if (null === boundary) {
         if (13 !== request.status && request.status !== CLOSED) {
           boundary = task.replay;
           if (null === boundary) {
-            logRecoverableError(request, error, segment);
-            fatalError(request, error);
+            "object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+              ? ((boundary = request.trackedPostpones),
+                null !== boundary && null !== segment
+                  ? (logPostpone(request, error.message, errorInfo, null),
+                    trackPostpone(request, boundary, task, segment),
+                    finishedTask(request, null, segment))
+                  : ((task = Error(
+                      "The render was aborted with postpone when the shell is incomplete. Reason: " +
+                        error.message
+                    )),
+                    logRecoverableError(request, task, errorInfo, null),
+                    fatalError(request, task, errorInfo, null)))
+              : null !== request.trackedPostpones && null !== segment
+                ? ((boundary = request.trackedPostpones),
+                  logRecoverableError(request, error, errorInfo, null),
+                  trackPostpone(request, boundary, task, segment),
+                  finishedTask(request, null, segment))
+                : (logRecoverableError(request, error, errorInfo, null),
+                  fatalError(request, error, errorInfo, null));
             return;
           }
           boundary.pendingTasks--;
           0 === boundary.pendingTasks &&
             0 < boundary.nodes.length &&
-            ((task = logRecoverableError(request, error, segment)),
+            ("object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+              ? (logPostpone(request, error.message, errorInfo, null),
+                (task = "POSTPONE"))
+              : (task = logRecoverableError(request, error, errorInfo, null)),
             abortRemainingReplayNodes(
               request,
               null,
@@ -6475,26 +6999,59 @@
               boundary.slots,
               error,
               task,
-              segment,
+              errorInfo,
               !0
             ));
           request.pendingRootTasks--;
           0 === request.pendingRootTasks && completeShell(request);
         }
-      } else
-        boundary.pendingTasks--,
-          boundary.status !== CLIENT_RENDERED &&
-            ((boundary.status = CLIENT_RENDERED),
-            (task = logRecoverableError(request, error, segment)),
-            (boundary.status = CLIENT_RENDERED),
-            encodeErrorForBoundary(boundary, task, error, segment, !0),
-            untrackBoundary(request, boundary),
-            boundary.parentFlushed &&
-              request.clientRenderedBoundaries.push(boundary)),
-          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-            return abortTask(fallbackTask, request, error);
-          }),
-          boundary.fallbackAbortableTasks.clear();
+      } else {
+        boundary.pendingTasks--;
+        var _trackedPostpones2 = request.trackedPostpones;
+        if (boundary.status !== CLIENT_RENDERED) {
+          if (null !== _trackedPostpones2 && null !== segment)
+            return (
+              "object" === typeof error &&
+              null !== error &&
+              error.$$typeof === REACT_POSTPONE_TYPE
+                ? logPostpone(request, error.message, errorInfo, null)
+                : logRecoverableError(request, error, errorInfo, null),
+              trackPostpone(request, _trackedPostpones2, task, segment),
+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+                return abortTask(fallbackTask, request, error);
+              }),
+              boundary.fallbackAbortableTasks.clear(),
+              finishedTask(request, boundary, segment)
+            );
+          boundary.status = CLIENT_RENDERED;
+          if (
+            "object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+          ) {
+            logPostpone(request, error.message, errorInfo, null);
+            if (null !== request.trackedPostpones && null !== segment) {
+              trackPostpone(request, request.trackedPostpones, task, segment);
+              finishedTask(request, task.blockedBoundary, segment);
+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+                return abortTask(fallbackTask, request, error);
+              });
+              boundary.fallbackAbortableTasks.clear();
+              return;
+            }
+            task = "POSTPONE";
+          } else task = logRecoverableError(request, error, errorInfo, null);
+          boundary.status = CLIENT_RENDERED;
+          encodeErrorForBoundary(boundary, task, error, errorInfo, !0);
+          untrackBoundary(request, boundary);
+          boundary.parentFlushed &&
+            request.clientRenderedBoundaries.push(boundary);
+        }
+        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+          return abortTask(fallbackTask, request, error);
+        });
+        boundary.fallbackAbortableTasks.clear();
+      }
       request.allPendingTasks--;
       0 === request.allPendingTasks && completeAll(request);
     }
@@ -6560,12 +7117,11 @@
           }
         }
       } catch (error) {
-        logRecoverableError(request, error, {});
+        logRecoverableError(request, error, {}, null);
       }
     }
     function completeShell(request) {
       null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-      null === request.trackedPostpones && preparePreamble(request);
       request.onShellError = noop;
       request = request.onShellReady;
       request();
@@ -6578,7 +7134,6 @@
           : null === request.completedRootSegment ||
               request.completedRootSegment.status !== POSTPONED
       );
-      preparePreamble(request);
       request = request.onAllReady;
       request();
     }
@@ -6623,11 +7178,7 @@
                     abortTaskSoft,
                     request
                   ),
-                  boundary.fallbackAbortableTasks.clear(),
-                  0 === request.pendingRootTasks &&
-                    null === request.trackedPostpones &&
-                    null !== boundary.contentPreamble &&
-                    preparePreamble(request)))
+                  boundary.fallbackAbortableTasks.clear()))
               : null !== segment &&
                 segment.parentFlushed &&
                 segment.status === COMPLETED &&
@@ -6715,7 +7266,8 @@
                         : x,
                       errorInfo,
                       request.replay.nodes,
-                      request.replay.slots
+                      request.replay.slots,
+                      request.debugTask
                     );
                     request$jscomp$0.pendingRootTasks--;
                     0 === request$jscomp$0.pendingRootTasks &&
@@ -6728,88 +7280,168 @@
                   currentTaskInDEV = prevTaskInDEV;
                 }
               }
-            } else {
-              request$jscomp$0 = prevTaskInDEV = void 0;
-              var task$jscomp$0 = task,
-                segment$jscomp$0 = segment;
-              if (segment$jscomp$0.status === PENDING) {
-                segment$jscomp$0.status = 6;
-                switchContext(task$jscomp$0.context);
-                request$jscomp$0 = currentTaskInDEV;
-                currentTaskInDEV = task$jscomp$0;
-                var childrenLength = segment$jscomp$0.children.length,
-                  chunkLength = segment$jscomp$0.chunks.length;
-                try {
-                  retryNode(request, task$jscomp$0),
-                    segment$jscomp$0.lastPushedText &&
-                      segment$jscomp$0.textEmbedded &&
-                      segment$jscomp$0.chunks.push(textSeparator),
-                    task$jscomp$0.abortSet.delete(task$jscomp$0),
-                    (segment$jscomp$0.status = COMPLETED),
-                    finishedTask(
-                      request,
-                      task$jscomp$0.blockedBoundary,
-                      segment$jscomp$0
-                    );
-                } catch (thrownValue) {
-                  resetHooksState();
-                  segment$jscomp$0.children.length = childrenLength;
-                  segment$jscomp$0.chunks.length = chunkLength;
-                  var x$jscomp$0 =
-                    thrownValue === SuspenseException
-                      ? getSuspendedThenable()
-                      : 12 === request.status
-                        ? request.fatalError
-                        : thrownValue;
-                  if (
-                    "object" === typeof x$jscomp$0 &&
-                    null !== x$jscomp$0 &&
-                    "function" === typeof x$jscomp$0.then
-                  ) {
-                    segment$jscomp$0.status = PENDING;
-                    task$jscomp$0.thenableState =
-                      getThenableStateAfterSuspending();
-                    var ping$jscomp$0 = task$jscomp$0.ping;
-                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-                  } else {
-                    var errorInfo$jscomp$0 = getThrownInfo(
-                      task$jscomp$0.componentStack
-                    );
-                    task$jscomp$0.abortSet.delete(task$jscomp$0);
-                    segment$jscomp$0.status = 4;
-                    var boundary = task$jscomp$0.blockedBoundary;
-                    prevTaskInDEV = logRecoverableError(
-                      request,
-                      x$jscomp$0,
-                      errorInfo$jscomp$0
-                    );
-                    null === boundary
-                      ? fatalError(request, x$jscomp$0)
-                      : (boundary.pendingTasks--,
-                        boundary.status !== CLIENT_RENDERED &&
-                          ((boundary.status = CLIENT_RENDERED),
-                          encodeErrorForBoundary(
-                            boundary,
-                            prevTaskInDEV,
+            } else
+              a: {
+                request$jscomp$0 = prevTaskInDEV = void 0;
+                var task$jscomp$0 = task,
+                  segment$jscomp$0 = segment;
+                if (segment$jscomp$0.status === PENDING) {
+                  segment$jscomp$0.status = 6;
+                  switchContext(task$jscomp$0.context);
+                  request$jscomp$0 = currentTaskInDEV;
+                  currentTaskInDEV = task$jscomp$0;
+                  var childrenLength = segment$jscomp$0.children.length,
+                    chunkLength = segment$jscomp$0.chunks.length;
+                  try {
+                    retryNode(request, task$jscomp$0),
+                      segment$jscomp$0.lastPushedText &&
+                        segment$jscomp$0.textEmbedded &&
+                        segment$jscomp$0.chunks.push(textSeparator),
+                      task$jscomp$0.abortSet.delete(task$jscomp$0),
+                      (segment$jscomp$0.status = COMPLETED),
+                      finishedTask(
+                        request,
+                        task$jscomp$0.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                  } catch (thrownValue) {
+                    resetHooksState();
+                    segment$jscomp$0.children.length = childrenLength;
+                    segment$jscomp$0.chunks.length = chunkLength;
+                    var x$jscomp$0 =
+                      thrownValue === SuspenseException
+                        ? getSuspendedThenable()
+                        : 12 === request.status
+                          ? request.fatalError
+                          : thrownValue;
+                    if (
+                      12 === request.status &&
+                      null !== request.trackedPostpones
+                    ) {
+                      var trackedPostpones = request.trackedPostpones,
+                        thrownInfo = getThrownInfo(
+                          task$jscomp$0.componentStack
+                        );
+                      task$jscomp$0.abortSet.delete(task$jscomp$0);
+                      "object" === typeof x$jscomp$0 &&
+                      null !== x$jscomp$0 &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ? logPostpone(
+                            request,
+                            x$jscomp$0.message,
+                            thrownInfo,
+                            task$jscomp$0.debugTask
+                          )
+                        : logRecoverableError(
+                            request,
                             x$jscomp$0,
+                            thrownInfo,
+                            task$jscomp$0.debugTask
+                          );
+                      trackPostpone(
+                        request,
+                        trackedPostpones,
+                        task$jscomp$0,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task$jscomp$0.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                    } else {
+                      if (
+                        "object" === typeof x$jscomp$0 &&
+                        null !== x$jscomp$0
+                      ) {
+                        if ("function" === typeof x$jscomp$0.then) {
+                          segment$jscomp$0.status = PENDING;
+                          task$jscomp$0.thenableState =
+                            getThenableStateAfterSuspending();
+                          var ping$jscomp$0 = task$jscomp$0.ping;
+                          x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                          break a;
+                        }
+                        if (
+                          null !== request.trackedPostpones &&
+                          x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ) {
+                          var _trackedPostpones3 = request.trackedPostpones;
+                          task$jscomp$0.abortSet.delete(task$jscomp$0);
+                          var postponeInfo = getThrownInfo(
+                            task$jscomp$0.componentStack
+                          );
+                          logPostpone(
+                            request,
+                            x$jscomp$0.message,
+                            postponeInfo,
+                            task$jscomp$0.debugTask
+                          );
+                          trackPostpone(
+                            request,
+                            _trackedPostpones3,
+                            task$jscomp$0,
+                            segment$jscomp$0
+                          );
+                          finishedTask(
+                            request,
+                            task$jscomp$0.blockedBoundary,
+                            segment$jscomp$0
+                          );
+                          break a;
+                        }
+                      }
+                      var errorInfo$jscomp$0 = getThrownInfo(
+                        task$jscomp$0.componentStack
+                      );
+                      task$jscomp$0.abortSet.delete(task$jscomp$0);
+                      segment$jscomp$0.status = 4;
+                      var boundary = task$jscomp$0.blockedBoundary,
+                        debugTask = task$jscomp$0.debugTask;
+                      "object" === typeof x$jscomp$0 &&
+                      null !== x$jscomp$0 &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ? (logPostpone(
+                            request,
+                            x$jscomp$0.message,
                             errorInfo$jscomp$0,
-                            !1
+                            debugTask
                           ),
-                          untrackBoundary(request, boundary),
-                          boundary.parentFlushed &&
-                            request.clientRenderedBoundaries.push(boundary),
-                          0 === request.pendingRootTasks &&
-                            null === request.trackedPostpones &&
-                            null !== boundary.contentPreamble &&
-                            preparePreamble(request)));
-                    request.allPendingTasks--;
-                    0 === request.allPendingTasks && completeAll(request);
+                          (prevTaskInDEV = "POSTPONE"))
+                        : (prevTaskInDEV = logRecoverableError(
+                            request,
+                            x$jscomp$0,
+                            errorInfo$jscomp$0,
+                            debugTask
+                          ));
+                      null === boundary
+                        ? fatalError(
+                            request,
+                            x$jscomp$0,
+                            errorInfo$jscomp$0,
+                            debugTask
+                          )
+                        : (boundary.pendingTasks--,
+                          boundary.status !== CLIENT_RENDERED &&
+                            ((boundary.status = CLIENT_RENDERED),
+                            encodeErrorForBoundary(
+                              boundary,
+                              prevTaskInDEV,
+                              x$jscomp$0,
+                              errorInfo$jscomp$0,
+                              !1
+                            ),
+                            untrackBoundary(request, boundary),
+                            boundary.parentFlushed &&
+                              request.clientRenderedBoundaries.push(boundary)));
+                      request.allPendingTasks--;
+                      0 === request.allPendingTasks && completeAll(request);
+                    }
+                  } finally {
+                    currentTaskInDEV = request$jscomp$0;
                   }
-                } finally {
-                  currentTaskInDEV = request$jscomp$0;
                 }
               }
-            }
           }
           pingedTasks.splice(0, i);
           null !== request$jscomp$1.destination &&
@@ -6818,8 +7450,9 @@
               request$jscomp$1.destination
             );
         } catch (error) {
-          logRecoverableError(request$jscomp$1, error, {}),
-            fatalError(request$jscomp$1, error);
+          (pingedTasks = {}),
+            logRecoverableError(request$jscomp$1, error, pingedTasks, null),
+            fatalError(request$jscomp$1, error, pingedTasks, null);
         } finally {
           (currentResumableState = prevResumableState),
             (ReactSharedInternals.H = prevDispatcher),
@@ -6830,85 +7463,6 @@
         }
       }
     }
-    function preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    ) {
-      segment.preambleChildren.length &&
-        collectedPreambleSegments.push(segment.preambleChildren);
-      for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-        pendingPreambles =
-          preparePreambleFromSegment(
-            request,
-            segment.children[i],
-            collectedPreambleSegments
-          ) || pendingPreambles;
-      return pendingPreambles;
-    }
-    function preparePreambleFromSegment(
-      request,
-      segment,
-      collectedPreambleSegments
-    ) {
-      var boundary = segment.boundary;
-      if (null === boundary)
-        return preparePreambleFromSubtree(
-          request,
-          segment,
-          collectedPreambleSegments
-        );
-      var preamble = boundary.contentPreamble,
-        fallbackPreamble = boundary.fallbackPreamble;
-      if (null === preamble || null === fallbackPreamble) return !1;
-      switch (boundary.status) {
-        case COMPLETED:
-          hoistPreambleState(request.renderState, preamble);
-          segment = boundary.completedSegments[0];
-          if (!segment)
-            throw Error(
-              "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
-            );
-          return preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          );
-        case POSTPONED:
-          if (null !== request.trackedPostpones) return !0;
-        case CLIENT_RENDERED:
-          if (segment.status === COMPLETED)
-            return (
-              hoistPreambleState(request.renderState, fallbackPreamble),
-              preparePreambleFromSubtree(
-                request,
-                segment,
-                collectedPreambleSegments
-              )
-            );
-        default:
-          return !0;
-      }
-    }
-    function preparePreamble(request) {
-      if (
-        request.completedRootSegment &&
-        null === request.completedPreambleSegments
-      ) {
-        var collectedPreambleSegments = [],
-          hasPendingPreambles = preparePreambleFromSegment(
-            request,
-            request.completedRootSegment,
-            collectedPreambleSegments
-          ),
-          preamble = request.renderState.preamble;
-        if (
-          !1 === hasPendingPreambles ||
-          (preamble.headChunks && preamble.bodyChunks)
-        )
-          request.completedPreambleSegments = collectedPreambleSegments;
-      }
-    }
     function flushSubtree(request, destination, segment, hoistableState) {
       segment.parentFlushed = !0;
       switch (segment.status) {
@@ -7086,40 +7640,64 @@
       boundary = boundary.contentState;
       var requiresStyleInsertion = request.stylesToHoist;
       request.stylesToHoist = !1;
-      writeChunk(destination, request.startInlineScript);
-      requiresStyleInsertion
-        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-          NothingSent
-          ? ((completedSegments.instructions =
-              completedSegments.instructions |
-              SentStyleInsertionFunction |
-              SentCompleteBoundaryFunction),
-            writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))
-          : (completedSegments.instructions & SentStyleInsertionFunction) ===
+      var scriptFormat =
+        completedSegments.streamingFormat === ScriptStreamingFormat;
+      scriptFormat
+        ? (writeChunk(destination, request.startInlineScript),
+          requiresStyleInsertion
+            ? (completedSegments.instructions &
+                SentCompleteBoundaryFunction) ===
               NothingSent
-            ? ((completedSegments.instructions |= SentStyleInsertionFunction),
-              writeChunk(
-                destination,
-                completeBoundaryWithStylesScript1FullPartial
-              ))
-            : writeChunk(destination, completeBoundaryWithStylesScript1Partial)
-        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-            NothingSent
-          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),
-            writeChunk(destination, completeBoundaryScript1Full))
-          : writeChunk(destination, completeBoundaryScript1Partial);
+              ? ((completedSegments.instructions =
+                  completedSegments.instructions |
+                  SentStyleInsertionFunction |
+                  SentCompleteBoundaryFunction),
+                writeChunk(
+                  destination,
+                  completeBoundaryWithStylesScript1FullBoth
+                ))
+              : (completedSegments.instructions &
+                    SentStyleInsertionFunction) ===
+                  NothingSent
+                ? ((completedSegments.instructions |=
+                    SentStyleInsertionFunction),
+                  writeChunk(
+                    destination,
+                    completeBoundaryWithStylesScript1FullPartial
+                  ))
+                : writeChunk(
+                    destination,
+                    completeBoundaryWithStylesScript1Partial
+                  )
+            : (completedSegments.instructions &
+                  SentCompleteBoundaryFunction) ===
+                NothingSent
+              ? ((completedSegments.instructions |=
+                  SentCompleteBoundaryFunction),
+                writeChunk(destination, completeBoundaryScript1Full))
+              : writeChunk(destination, completeBoundaryScript1Partial))
+        : requiresStyleInsertion
+          ? writeChunk(destination, completeBoundaryWithStylesData1)
+          : writeChunk(destination, completeBoundaryData1);
       completedSegments = stringToChunk(i.toString(16));
       writeChunk(destination, request.boundaryPrefix);
       writeChunk(destination, completedSegments);
-      writeChunk(destination, completeBoundaryScript2);
+      scriptFormat
+        ? writeChunk(destination, completeBoundaryScript2)
+        : writeChunk(destination, completeBoundaryData2);
       writeChunk(destination, request.segmentPrefix);
       writeChunk(destination, completedSegments);
       requiresStyleInsertion
-        ? (writeChunk(destination, completeBoundaryScript3a),
-          writeStyleResourceDependenciesInJS(destination, boundary))
-        : writeChunk(destination, completeBoundaryScript3b);
-      boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
-      return writeBootstrap(destination, request) && boundary;
+        ? scriptFormat
+          ? (writeChunk(destination, completeBoundaryScript3a),
+            writeStyleResourceDependenciesInJS(destination, boundary))
+          : (writeChunk(destination, completeBoundaryData3a),
+            writeStyleResourceDependenciesInAttr(destination, boundary))
+        : scriptFormat && writeChunk(destination, completeBoundaryScript3b);
+      completedSegments = scriptFormat
+        ? writeChunkAndReturn(destination, completeBoundaryScriptEnd)
+        : writeChunkAndReturn(destination, completeBoundaryDataEnd);
+      return writeBootstrap(destination, request) && completedSegments;
     }
     function flushPartiallyCompletedSegment(
       request,
@@ -7152,18 +7730,24 @@
       flushSegmentContainer(request, destination, segment, hoistableState);
       boundary = request.resumableState;
       request = request.renderState;
-      writeChunk(destination, request.startInlineScript);
-      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
-        ? ((boundary.instructions |= SentCompleteSegmentFunction),
-          writeChunk(destination, completeSegmentScript1Full))
-        : writeChunk(destination, completeSegmentScript1Partial);
+      (segment = boundary.streamingFormat === ScriptStreamingFormat)
+        ? (writeChunk(destination, request.startInlineScript),
+          (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
+            ? ((boundary.instructions |= SentCompleteSegmentFunction),
+              writeChunk(destination, completeSegmentScript1Full))
+            : writeChunk(destination, completeSegmentScript1Partial))
+        : writeChunk(destination, completeSegmentData1);
       writeChunk(destination, request.segmentPrefix);
       segmentID = stringToChunk(segmentID.toString(16));
       writeChunk(destination, segmentID);
-      writeChunk(destination, completeSegmentScript2);
+      segment
+        ? writeChunk(destination, completeSegmentScript2)
+        : writeChunk(destination, completeSegmentData2);
       writeChunk(destination, request.placeholderPrefix);
       writeChunk(destination, segmentID);
-      destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
+      destination = segment
+        ? writeChunkAndReturn(destination, completeSegmentScriptEnd)
+        : writeChunkAndReturn(destination, completeSegmentDataEnd);
       return destination;
     }
     function flushCompletedQueues(request, destination) {
@@ -7175,12 +7759,22 @@
             completedRootSegment = request.completedRootSegment;
           if (null !== completedRootSegment) {
             if (completedRootSegment.status === POSTPONED) return;
-            var completedPreambleSegments = request.completedPreambleSegments;
-            if (null === completedPreambleSegments) return;
-            var renderState = request.renderState,
-              preamble = renderState.preamble,
-              htmlChunks = preamble.htmlChunks,
-              headChunks = preamble.headChunks,
+            var renderState = request.renderState;
+            if (
+              (0 !== request.allPendingTasks ||
+                null !== request.trackedPostpones) &&
+              renderState.externalRuntimeScript
+            ) {
+              var _renderState$external = renderState.externalRuntimeScript,
+                resumableState = request.resumableState,
+                src = _renderState$external.src,
+                chunks = _renderState$external.chunks;
+              resumableState.scriptResources.hasOwnProperty(src) ||
+                ((resumableState.scriptResources[src] = EXISTS),
+                renderState.scripts.add(chunks));
+            }
+            var htmlChunks = renderState.htmlChunks,
+              headChunks = renderState.headChunks,
               i$jscomp$0;
             if (htmlChunks) {
               for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -7241,27 +7835,10 @@
               i$jscomp$0++
             )
               writeChunk(destination, hoistableChunks[i$jscomp$0]);
-            for (
-              renderState = hoistableChunks.length = 0;
-              renderState < completedPreambleSegments.length;
-              renderState++
-            ) {
-              var segments = completedPreambleSegments[renderState];
-              for (preamble = 0; preamble < segments.length; preamble++)
-                flushSegment(request, destination, segments[preamble], null);
-            }
-            var preamble$jscomp$0 = request.renderState.preamble,
-              headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-            (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) &&
+            hoistableChunks.length = 0;
+            htmlChunks &&
+              null === headChunks &&
               writeChunk(destination, endChunkForTag("head"));
-            var bodyChunks = preamble$jscomp$0.bodyChunks;
-            if (bodyChunks)
-              for (
-                completedPreambleSegments = 0;
-                completedPreambleSegments < bodyChunks.length;
-                completedPreambleSegments++
-              )
-                writeChunk(destination, bodyChunks[completedPreambleSegments]);
             flushSegment(request, destination, completedRootSegment, null);
             request.completedRootSegment = null;
             writeBootstrap(destination, request.renderState);
@@ -7308,81 +7885,115 @@
           for (i = 0; i < clientRenderedBoundaries.length; i++) {
             var boundary = clientRenderedBoundaries[i];
             renderState$jscomp$0 = destination;
-            var resumableState = request.resumableState,
+            var resumableState$jscomp$0 = request.resumableState,
               renderState$jscomp$1 = request.renderState,
               id = boundary.rootSegmentID,
               errorDigest = boundary.errorDigest,
               errorMessage = boundary.errorMessage,
               errorStack = boundary.errorStack,
-              errorComponentStack = boundary.errorComponentStack;
-            writeChunk(
-              renderState$jscomp$0,
-              renderState$jscomp$1.startInlineScript
-            );
-            (resumableState.instructions & SentClientRenderFunction) ===
-            NothingSent
-              ? ((resumableState.instructions |= SentClientRenderFunction),
-                writeChunk(renderState$jscomp$0, clientRenderScript1Full))
-              : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
+              errorComponentStack = boundary.errorComponentStack,
+              scriptFormat =
+                resumableState$jscomp$0.streamingFormat ===
+                ScriptStreamingFormat;
+            scriptFormat
+              ? (writeChunk(
+                  renderState$jscomp$0,
+                  renderState$jscomp$1.startInlineScript
+                ),
+                (resumableState$jscomp$0.instructions &
+                  SentClientRenderFunction) ===
+                NothingSent
+                  ? ((resumableState$jscomp$0.instructions |=
+                      SentClientRenderFunction),
+                    writeChunk(renderState$jscomp$0, clientRenderScript1Full))
+                  : writeChunk(
+                      renderState$jscomp$0,
+                      clientRenderScript1Partial
+                    ))
+              : writeChunk(renderState$jscomp$0, clientRenderData1);
             writeChunk(
               renderState$jscomp$0,
               renderState$jscomp$1.boundaryPrefix
             );
             writeChunk(renderState$jscomp$0, stringToChunk(id.toString(16)));
-            writeChunk(renderState$jscomp$0, clientRenderScript1A);
+            scriptFormat &&
+              writeChunk(renderState$jscomp$0, clientRenderScript1A);
             if (
               errorDigest ||
               errorMessage ||
               errorStack ||
               errorComponentStack
             )
-              writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-                writeChunk(
-                  renderState$jscomp$0,
-                  stringToChunk(
-                    escapeJSStringsForInstructionScripts(errorDigest || "")
-                  )
-                );
+              scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(
+                      escapeJSStringsForInstructionScripts(errorDigest || "")
+                    )
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData2),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(escapeTextForBrowser(errorDigest || ""))
+                  ));
             if (errorMessage || errorStack || errorComponentStack)
-              writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-                writeChunk(
-                  renderState$jscomp$0,
-                  stringToChunk(
-                    escapeJSStringsForInstructionScripts(errorMessage || "")
-                  )
-                );
+              scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(
+                      escapeJSStringsForInstructionScripts(errorMessage || "")
+                    )
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData3),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(escapeTextForBrowser(errorMessage || ""))
+                  ));
             if (errorStack || errorComponentStack)
-              writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-                writeChunk(
-                  renderState$jscomp$0,
-                  stringToChunk(
-                    escapeJSStringsForInstructionScripts(errorStack || "")
-                  )
-                );
+              scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(
+                      escapeJSStringsForInstructionScripts(errorStack || "")
+                    )
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData4),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(escapeTextForBrowser(errorStack || ""))
+                  ));
             errorComponentStack &&
-              (writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-              writeChunk(
-                renderState$jscomp$0,
-                stringToChunk(
-                  escapeJSStringsForInstructionScripts(errorComponentStack)
-                )
-              ));
-            var JSCompiler_inline_result = writeChunkAndReturn(
-              renderState$jscomp$0,
-              clientRenderScriptEnd
-            );
+              (scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(
+                      escapeJSStringsForInstructionScripts(errorComponentStack)
+                    )
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData5),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    stringToChunk(escapeTextForBrowser(errorComponentStack))
+                  )));
+            var JSCompiler_inline_result = scriptFormat
+              ? writeChunkAndReturn(renderState$jscomp$0, clientRenderScriptEnd)
+              : writeChunkAndReturn(renderState$jscomp$0, clientRenderDataEnd);
             if (!JSCompiler_inline_result) {
               request.destination = null;
               i++;
@@ -7467,9 +8078,10 @@
         0 === request.clientRenderedBoundaries.length &&
         0 === request.completedBoundaries.length
           ? ((request.flushScheduled = !1),
-            (i = request.resumableState),
-            i.hasBody && writeChunk(destination, endChunkForTag("body")),
-            i.hasHtml && writeChunk(destination, endChunkForTag("html")),
+            null === request.trackedPostpones &&
+              ((i = request.resumableState),
+              i.hasBody && writeChunk(destination, endChunkForTag("body")),
+              i.hasHtml && writeChunk(destination, endChunkForTag("html"))),
             completeWriting(destination),
             0 !== request.abortableTasks.size &&
               console.error(
@@ -7526,7 +8138,9 @@
         try {
           flushCompletedQueues(request, destination);
         } catch (error) {
-          logRecoverableError(request, error, {}), fatalError(request, error);
+          (destination = {}),
+            logRecoverableError(request, error, destination, null),
+            fatalError(request, error, destination, null);
         }
       }
     }
@@ -7552,16 +8166,69 @@
         null !== request.destination &&
           flushCompletedQueues(request, request.destination);
       } catch (error$4) {
-        logRecoverableError(request, error$4, {}), fatalError(request, error$4);
+        (reason = {}),
+          logRecoverableError(request, error$4, reason, null),
+          fatalError(request, error$4, reason, null);
+      }
+    }
+    function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+      if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+      else {
+        var workingMap = trackedPostpones.workingMap,
+          parentNode = workingMap.get(parentKeyPath);
+        void 0 === parentNode &&
+          ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+          workingMap.set(parentKeyPath, parentNode),
+          addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+        parentNode[2].push(node);
       }
     }
+    function getPostponedState(request) {
+      var trackedPostpones = request.trackedPostpones;
+      if (
+        null === trackedPostpones ||
+        (0 === trackedPostpones.rootNodes.length &&
+          null === trackedPostpones.rootSlots)
+      )
+        return (request.trackedPostpones = null);
+      if (
+        null !== request.completedRootSegment &&
+        request.completedRootSegment.status === POSTPONED
+      ) {
+        var resumableState = request.resumableState,
+          renderState = request.renderState;
+        resumableState.nextFormID = 0;
+        resumableState.hasBody = !1;
+        resumableState.hasHtml = !1;
+        resumableState.unknownResources = { font: renderState.resets.font };
+        resumableState.dnsResources = renderState.resets.dns;
+        resumableState.connectResources = renderState.resets.connect;
+        resumableState.imageResources = renderState.resets.image;
+        resumableState.styleResources = renderState.resets.style;
+        resumableState.scriptResources = {};
+        resumableState.moduleUnknownResources = {};
+        resumableState.moduleScriptResources = {};
+      } else
+        (resumableState = request.resumableState),
+          (resumableState.bootstrapScriptContent = void 0),
+          (resumableState.bootstrapScripts = void 0),
+          (resumableState.bootstrapModules = void 0);
+      return {
+        nextSegmentId: request.nextSegmentId,
+        rootFormatContext: request.rootFormatContext,
+        progressiveChunkSize: request.progressiveChunkSize,
+        resumableState: request.resumableState,
+        replayNodes: trackedPostpones.rootNodes,
+        replaySlots: trackedPostpones.rootSlots
+      };
+    }
     function ensureCorrectIsomorphicReactVersion() {
       var isomorphicReactPackageVersion = React.version;
-      if ("19.1.0-canary-c492f975-20250128" !== isomorphicReactPackageVersion)
+      if ("19.1.0-experimental-b3a95caf-20250113" !== isomorphicReactPackageVersion)
         throw Error(
           'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
             (isomorphicReactPackageVersion +
-              "\n  - react-dom:  19.1.0-canary-c492f975-20250128\nLearn more: https://react.dev/warnings/version-mismatch")
+              "\n  - react-dom:  19.1.0-experimental-b3a95caf-20250113\nLearn more: https://react.dev/warnings/version-mismatch")
         );
     }
     var React = require("react"),
@@ -7582,9 +8249,10 @@
       REACT_SCOPE_TYPE = Symbol.for("react.scope"),
       REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
       REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-      REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+      REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
       REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
       MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+      ASYNC_ITERATOR = Symbol.asyncIterator,
       isArrayImpl = Array.isArray,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
@@ -8638,7 +9306,8 @@
         } else previousDispatcher.M(src, options);
       }
     };
-    var NothingSent = 0,
+    var ScriptStreamingFormat = 0,
+      NothingSent = 0,
       SentCompleteSegmentFunction = 1,
       SentCompleteBoundaryFunction = 2,
       SentClientRenderFunction = 4,
@@ -8646,8 +9315,8 @@
       EXISTS = null,
       PRELOAD_NO_CREDS = [];
     Object.freeze(PRELOAD_NO_CREDS);
-    stringToPrecomputedChunk('"></template>');
-    var startInlineScript = stringToPrecomputedChunk("<script>"),
+    var dataElementQuotedEnd = stringToPrecomputedChunk('"></template>'),
+      startInlineScript = stringToPrecomputedChunk("<script>"),
       endInlineScript = stringToPrecomputedChunk("\x3c/script>"),
       startScriptSrc = stringToPrecomputedChunk('<script src="'),
       startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'),
@@ -8664,13 +9333,12 @@
     var ROOT_HTML_MODE = 0,
       HTML_HTML_MODE = 1,
       HTML_MODE = 2,
-      HTML_HEAD_MODE = 3,
-      SVG_MODE = 4,
-      MATHML_MODE = 5,
-      HTML_TABLE_MODE = 6,
-      HTML_TABLE_BODY_MODE = 7,
-      HTML_TABLE_ROW_MODE = 8,
-      HTML_COLGROUP_MODE = 9,
+      SVG_MODE = 3,
+      MATHML_MODE = 4,
+      HTML_TABLE_MODE = 5,
+      HTML_TABLE_BODY_MODE = 6,
+      HTML_TABLE_ROW_MODE = 7,
+      HTML_COLGROUP_MODE = 8,
       textSeparator = stringToPrecomputedChunk("\x3c!-- --\x3e"),
       styleNameCache = new Map(),
       styleAttributeStart = stringToPrecomputedChunk(' style="'),
@@ -8770,10 +9438,13 @@
       ),
       completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'),
       completeSegmentScript2 = stringToPrecomputedChunk('","'),
-      completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>');
-    stringToPrecomputedChunk('<template data-rsi="" data-sid="');
-    stringToPrecomputedChunk('" data-pid="');
-    var completeBoundaryScript1Full = stringToPrecomputedChunk(
+      completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>'),
+      completeSegmentData1 = stringToPrecomputedChunk(
+        '<template data-rsi="" data-sid="'
+      ),
+      completeSegmentData2 = stringToPrecomputedChunk('" data-pid="'),
+      completeSegmentDataEnd = dataElementQuotedEnd,
+      completeBoundaryScript1Full = stringToPrecomputedChunk(
         '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
       ),
       completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'),
@@ -8788,24 +9459,32 @@
       completeBoundaryScript2 = stringToPrecomputedChunk('","'),
       completeBoundaryScript3a = stringToPrecomputedChunk('",'),
       completeBoundaryScript3b = stringToPrecomputedChunk('"'),
-      completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-    stringToPrecomputedChunk('<template data-rci="" data-bid="');
-    stringToPrecomputedChunk('<template data-rri="" data-bid="');
-    stringToPrecomputedChunk('" data-sid="');
-    stringToPrecomputedChunk('" data-sty="');
-    var clientRenderScript1Full = stringToPrecomputedChunk(
+      completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+      completeBoundaryData1 = stringToPrecomputedChunk(
+        '<template data-rci="" data-bid="'
+      ),
+      completeBoundaryWithStylesData1 = stringToPrecomputedChunk(
+        '<template data-rri="" data-bid="'
+      ),
+      completeBoundaryData2 = stringToPrecomputedChunk('" data-sid="'),
+      completeBoundaryData3a = stringToPrecomputedChunk('" data-sty="'),
+      completeBoundaryDataEnd = dataElementQuotedEnd,
+      clientRenderScript1Full = stringToPrecomputedChunk(
         '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
       ),
       clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'),
       clientRenderScript1A = stringToPrecomputedChunk('"'),
       clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","),
-      clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-    stringToPrecomputedChunk('<template data-rxi="" data-bid="');
-    stringToPrecomputedChunk('" data-dgst="');
-    stringToPrecomputedChunk('" data-msg="');
-    stringToPrecomputedChunk('" data-stck="');
-    stringToPrecomputedChunk('" data-cstck="');
-    var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g,
+      clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+      clientRenderData1 = stringToPrecomputedChunk(
+        '<template data-rxi="" data-bid="'
+      ),
+      clientRenderData2 = stringToPrecomputedChunk('" data-dgst="'),
+      clientRenderData3 = stringToPrecomputedChunk('" data-msg="'),
+      clientRenderData4 = stringToPrecomputedChunk('" data-stck="'),
+      clientRenderData5 = stringToPrecomputedChunk('" data-cstck="'),
+      clientRenderDataEnd = dataElementQuotedEnd,
+      regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g,
       regexForJSStringsInScripts = /[&><\u2028\u2029]/g,
       lateStyleTagResourceOpen1 = stringToPrecomputedChunk(
         '<style media="not all" data-precedence="'
@@ -8993,13 +9672,8 @@
           resolveCurrentlyRenderingComponent();
           return NotPending;
         },
-        useMemoCache: function (size) {
-          for (var data = Array(size), i = 0; i < size; i++)
-            data[i] = REACT_MEMO_CACHE_SENTINEL;
-          return data;
-        },
-        useCacheRefresh: function () {
-          return unsupportedRefresh;
+        useEffectEvent: function () {
+          return throwOnUseEffectEventCall;
         }
       },
       currentResumableState = null,
@@ -9096,22 +9770,24 @@
             options ? options.progressiveChunkSize : void 0,
             options ? options.onError : void 0,
             function () {
-              var result = {
-                prelude: new ReadableStream(
-                  {
-                    type: "bytes",
-                    pull: function (controller) {
-                      startFlowing(request, controller);
-                    },
-                    cancel: function (reason) {
-                      request.destination = null;
-                      abort(request, reason);
-                    }
+              var stream = new ReadableStream(
+                {
+                  type: "bytes",
+                  pull: function (controller) {
+                    startFlowing(request, controller);
                   },
-                  { highWaterMark: 0 }
-                )
+                  cancel: function (reason) {
+                    request.destination = null;
+                    abort(request, reason);
+                  }
+                },
+                { highWaterMark: 0 }
+              );
+              stream = {
+                postponed: getPostponedState(request),
+                prelude: stream
               };
-              resolve(result);
+              resolve(stream);
             },
             void 0,
             void 0,
@@ -9207,5 +9883,114 @@
         startWork(request);
       });
     };
-    exports.version = "19.1.0-canary-c492f975-20250128";
+    exports.resume = function (children, postponedState, options) {
+      return new Promise(function (resolve, reject) {
+        var onFatalError,
+          onAllReady,
+          allReady = new Promise(function (res, rej) {
+            onAllReady = res;
+            onFatalError = rej;
+          }),
+          request = resumeRequest(
+            children,
+            postponedState,
+            createRenderState(
+              postponedState.resumableState,
+              options ? options.nonce : void 0,
+              void 0,
+              void 0,
+              void 0,
+              void 0
+            ),
+            options ? options.onError : void 0,
+            onAllReady,
+            function () {
+              var stream = new ReadableStream(
+                {
+                  type: "bytes",
+                  pull: function (controller) {
+                    startFlowing(request, controller);
+                  },
+                  cancel: function (reason) {
+                    request.destination = null;
+                    abort(request, reason);
+                  }
+                },
+                { highWaterMark: 0 }
+              );
+              stream.allReady = allReady;
+              resolve(stream);
+            },
+            function (error) {
+              allReady.catch(function () {});
+              reject(error);
+            },
+            onFatalError,
+            options ? options.onPostpone : void 0
+          );
+        if (options && options.signal) {
+          var signal = options.signal;
+          if (signal.aborted) abort(request, signal.reason);
+          else {
+            var listener = function () {
+              abort(request, signal.reason);
+              signal.removeEventListener("abort", listener);
+            };
+            signal.addEventListener("abort", listener);
+          }
+        }
+        startWork(request);
+      });
+    };
+    exports.resumeAndPrerender = function (children, postponedState, options) {
+      return new Promise(function (resolve, reject) {
+        var request = resumeAndPrerenderRequest(
+          children,
+          postponedState,
+          createRenderState(
+            postponedState.resumableState,
+            options ? options.nonce : void 0,
+            void 0,
+            void 0,
+            void 0,
+            void 0
+          ),
+          options ? options.onError : void 0,
+          function () {
+            var stream = new ReadableStream(
+              {
+                type: "bytes",
+                pull: function (controller) {
+                  startFlowing(request, controller);
+                },
+                cancel: function (reason) {
+                  request.destination = null;
+                  abort(request, reason);
+                }
+              },
+              { highWaterMark: 0 }
+            );
+            stream = { postponed: getPostponedState(request), prelude: stream };
+            resolve(stream);
+          },
+          void 0,
+          void 0,
+          reject,
+          options ? options.onPostpone : void 0
+        );
+        if (options && options.signal) {
+          var signal = options.signal;
+          if (signal.aborted) abort(request, signal.reason);
+          else {
+            var listener = function () {
+              abort(request, signal.reason);
+              signal.removeEventListener("abort", listener);
+            };
+            signal.addEventListener("abort", listener);
+          }
+        }
+        startWork(request);
+      });
+    };
+    exports.version = "19.1.0-experimental-b3a95caf-20250113";
   })();
diff --git a/node_modules/react-dom/cjs/react-dom-server.edge.production.js b/node_modules/react-dom/cjs/react-dom-server.edge.production.js
index 92fc2a8..4ea23d9 100644
--- a/node_modules/react-dom/cjs/react-dom-server.edge.production.js
+++ b/node_modules/react-dom/cjs/react-dom-server.edge.production.js
@@ -51,9 +51,10 @@ var React = require("react"),
   REACT_SCOPE_TYPE = Symbol.for("react.scope"),
   REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
   REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
   REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
   MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+  ASYNC_ITERATOR = Symbol.asyncIterator,
   isArrayImpl = Array.isArray;
 function murmurhash3_32_gc(key, seed) {
   var remainder = key.length & 3;
@@ -345,9 +346,9 @@ ReactDOMSharedInternals.d = {
   S: preinitStyle,
   M: preinitModuleScript
 };
-var PRELOAD_NO_CREDS = [];
-stringToPrecomputedChunk('"></template>');
-var startInlineScript = stringToPrecomputedChunk("<script>"),
+var PRELOAD_NO_CREDS = [],
+  dataElementQuotedEnd = stringToPrecomputedChunk('"></template>'),
+  startInlineScript = stringToPrecomputedChunk("<script>"),
   endInlineScript = stringToPrecomputedChunk("\x3c/script>"),
   startScriptSrc = stringToPrecomputedChunk('<script src="'),
   startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'),
@@ -377,28 +378,48 @@ function createRenderState(
         : stringToPrecomputedChunk(
             '<script nonce="' + escapeTextForBrowser(nonce) + '">'
           ),
-    idPrefix = resumableState.idPrefix;
-  externalRuntimeConfig = [];
-  var bootstrapScriptContent = resumableState.bootstrapScriptContent,
+    idPrefix = resumableState.idPrefix,
+    bootstrapChunks = [],
+    externalRuntimeScript = null,
+    bootstrapScriptContent = resumableState.bootstrapScriptContent,
     bootstrapScripts = resumableState.bootstrapScripts,
     bootstrapModules = resumableState.bootstrapModules;
   void 0 !== bootstrapScriptContent &&
-    externalRuntimeConfig.push(
+    bootstrapChunks.push(
       inlineScriptWithNonce,
       stringToChunk(
         ("" + bootstrapScriptContent).replace(scriptRegex, scriptReplacer)
       ),
       endInlineScript
     );
-  bootstrapScriptContent = [];
+  void 0 !== externalRuntimeConfig &&
+    ("string" === typeof externalRuntimeConfig
+      ? ((externalRuntimeScript = { src: externalRuntimeConfig, chunks: [] }),
+        pushScriptImpl(externalRuntimeScript.chunks, {
+          src: externalRuntimeConfig,
+          async: !0,
+          integrity: void 0,
+          nonce: nonce
+        }))
+      : ((externalRuntimeScript = {
+          src: externalRuntimeConfig.src,
+          chunks: []
+        }),
+        pushScriptImpl(externalRuntimeScript.chunks, {
+          src: externalRuntimeConfig.src,
+          async: !0,
+          integrity: externalRuntimeConfig.integrity,
+          nonce: nonce
+        })));
+  externalRuntimeConfig = [];
   void 0 !== importMap &&
-    (bootstrapScriptContent.push(importMapScriptStart),
-    bootstrapScriptContent.push(
+    (externalRuntimeConfig.push(importMapScriptStart),
+    externalRuntimeConfig.push(
       stringToChunk(
         ("" + JSON.stringify(importMap)).replace(scriptRegex, scriptReplacer)
       )
     ),
-    bootstrapScriptContent.push(importMapScriptEnd));
+    externalRuntimeConfig.push(importMapScriptEnd));
   importMap = onHeaders
     ? {
         preconnects: "",
@@ -413,10 +434,11 @@ function createRenderState(
     segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
     boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
     startInlineScript: inlineScriptWithNonce,
-    preamble: createPreambleState(),
-    externalRuntimeScript: null,
-    bootstrapChunks: externalRuntimeConfig,
-    importMapChunks: bootstrapScriptContent,
+    htmlChunks: null,
+    headChunks: null,
+    externalRuntimeScript: externalRuntimeScript,
+    bootstrapChunks: bootstrapChunks,
+    importMapChunks: externalRuntimeConfig,
     onHeaders: onHeaders,
     headers: importMap,
     resets: {
@@ -447,110 +469,115 @@ function createRenderState(
     stylesToHoist: !1
   };
   if (void 0 !== bootstrapScripts)
-    for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
-      var scriptConfig = bootstrapScripts[importMap];
-      idPrefix = inlineScriptWithNonce = void 0;
-      bootstrapScriptContent = {
-        rel: "preload",
-        as: "script",
-        fetchPriority: "low",
-        nonce: nonce
-      };
-      "string" === typeof scriptConfig
-        ? (bootstrapScriptContent.href = maxHeadersLength = scriptConfig)
-        : ((bootstrapScriptContent.href = maxHeadersLength = scriptConfig.src),
-          (bootstrapScriptContent.integrity = idPrefix =
-            "string" === typeof scriptConfig.integrity
-              ? scriptConfig.integrity
-              : void 0),
-          (bootstrapScriptContent.crossOrigin = inlineScriptWithNonce =
-            "string" === typeof scriptConfig || null == scriptConfig.crossOrigin
-              ? void 0
-              : "use-credentials" === scriptConfig.crossOrigin
-                ? "use-credentials"
-                : ""));
-      scriptConfig = resumableState;
-      var href = maxHeadersLength;
-      scriptConfig.scriptResources[href] = null;
-      scriptConfig.moduleScriptResources[href] = null;
-      scriptConfig = [];
-      pushLinkImpl(scriptConfig, bootstrapScriptContent);
-      onHeaders.bootstrapScripts.add(scriptConfig);
-      externalRuntimeConfig.push(
-        startScriptSrc,
-        stringToChunk(escapeTextForBrowser(maxHeadersLength))
-      );
-      nonce &&
-        externalRuntimeConfig.push(
-          scriptNonce,
-          stringToChunk(escapeTextForBrowser(nonce))
-        );
-      "string" === typeof idPrefix &&
-        externalRuntimeConfig.push(
-          scriptIntegirty,
+    for (
+      inlineScriptWithNonce = 0;
+      inlineScriptWithNonce < bootstrapScripts.length;
+      inlineScriptWithNonce++
+    )
+      (externalRuntimeConfig = bootstrapScripts[inlineScriptWithNonce]),
+        (importMap = externalRuntimeScript = void 0),
+        (maxHeadersLength = {
+          rel: "preload",
+          as: "script",
+          fetchPriority: "low",
+          nonce: nonce
+        }),
+        "string" === typeof externalRuntimeConfig
+          ? (maxHeadersLength.href = idPrefix = externalRuntimeConfig)
+          : ((maxHeadersLength.href = idPrefix = externalRuntimeConfig.src),
+            (maxHeadersLength.integrity = importMap =
+              "string" === typeof externalRuntimeConfig.integrity
+                ? externalRuntimeConfig.integrity
+                : void 0),
+            (maxHeadersLength.crossOrigin = externalRuntimeScript =
+              "string" === typeof externalRuntimeConfig ||
+              null == externalRuntimeConfig.crossOrigin
+                ? void 0
+                : "use-credentials" === externalRuntimeConfig.crossOrigin
+                  ? "use-credentials"
+                  : "")),
+        (externalRuntimeConfig = resumableState),
+        (bootstrapScriptContent = idPrefix),
+        (externalRuntimeConfig.scriptResources[bootstrapScriptContent] = null),
+        (externalRuntimeConfig.moduleScriptResources[bootstrapScriptContent] =
+          null),
+        (externalRuntimeConfig = []),
+        pushLinkImpl(externalRuntimeConfig, maxHeadersLength),
+        onHeaders.bootstrapScripts.add(externalRuntimeConfig),
+        bootstrapChunks.push(
+          startScriptSrc,
           stringToChunk(escapeTextForBrowser(idPrefix))
-        );
-      "string" === typeof inlineScriptWithNonce &&
-        externalRuntimeConfig.push(
-          scriptCrossOrigin,
-          stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
-        );
-      externalRuntimeConfig.push(endAsyncScript);
-    }
+        ),
+        nonce &&
+          bootstrapChunks.push(
+            scriptNonce,
+            stringToChunk(escapeTextForBrowser(nonce))
+          ),
+        "string" === typeof importMap &&
+          bootstrapChunks.push(
+            scriptIntegirty,
+            stringToChunk(escapeTextForBrowser(importMap))
+          ),
+        "string" === typeof externalRuntimeScript &&
+          bootstrapChunks.push(
+            scriptCrossOrigin,
+            stringToChunk(escapeTextForBrowser(externalRuntimeScript))
+          ),
+        bootstrapChunks.push(endAsyncScript);
   if (void 0 !== bootstrapModules)
     for (
       bootstrapScripts = 0;
       bootstrapScripts < bootstrapModules.length;
       bootstrapScripts++
     )
-      (bootstrapScriptContent = bootstrapModules[bootstrapScripts]),
-        (inlineScriptWithNonce = maxHeadersLength = void 0),
-        (idPrefix = {
+      (maxHeadersLength = bootstrapModules[bootstrapScripts]),
+        (externalRuntimeScript = idPrefix = void 0),
+        (importMap = {
           rel: "modulepreload",
           fetchPriority: "low",
           nonce: nonce
         }),
-        "string" === typeof bootstrapScriptContent
-          ? (idPrefix.href = importMap = bootstrapScriptContent)
-          : ((idPrefix.href = importMap = bootstrapScriptContent.src),
-            (idPrefix.integrity = inlineScriptWithNonce =
-              "string" === typeof bootstrapScriptContent.integrity
-                ? bootstrapScriptContent.integrity
+        "string" === typeof maxHeadersLength
+          ? (importMap.href = inlineScriptWithNonce = maxHeadersLength)
+          : ((importMap.href = inlineScriptWithNonce = maxHeadersLength.src),
+            (importMap.integrity = externalRuntimeScript =
+              "string" === typeof maxHeadersLength.integrity
+                ? maxHeadersLength.integrity
                 : void 0),
-            (idPrefix.crossOrigin = maxHeadersLength =
-              "string" === typeof bootstrapScriptContent ||
-              null == bootstrapScriptContent.crossOrigin
+            (importMap.crossOrigin = idPrefix =
+              "string" === typeof maxHeadersLength ||
+              null == maxHeadersLength.crossOrigin
                 ? void 0
-                : "use-credentials" === bootstrapScriptContent.crossOrigin
+                : "use-credentials" === maxHeadersLength.crossOrigin
                   ? "use-credentials"
                   : "")),
-        (bootstrapScriptContent = resumableState),
-        (scriptConfig = importMap),
-        (bootstrapScriptContent.scriptResources[scriptConfig] = null),
-        (bootstrapScriptContent.moduleScriptResources[scriptConfig] = null),
-        (bootstrapScriptContent = []),
-        pushLinkImpl(bootstrapScriptContent, idPrefix),
-        onHeaders.bootstrapScripts.add(bootstrapScriptContent),
-        externalRuntimeConfig.push(
+        (maxHeadersLength = resumableState),
+        (externalRuntimeConfig = inlineScriptWithNonce),
+        (maxHeadersLength.scriptResources[externalRuntimeConfig] = null),
+        (maxHeadersLength.moduleScriptResources[externalRuntimeConfig] = null),
+        (maxHeadersLength = []),
+        pushLinkImpl(maxHeadersLength, importMap),
+        onHeaders.bootstrapScripts.add(maxHeadersLength),
+        bootstrapChunks.push(
           startModuleSrc,
-          stringToChunk(escapeTextForBrowser(importMap))
+          stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
         ),
         nonce &&
-          externalRuntimeConfig.push(
+          bootstrapChunks.push(
             scriptNonce,
             stringToChunk(escapeTextForBrowser(nonce))
           ),
-        "string" === typeof inlineScriptWithNonce &&
-          externalRuntimeConfig.push(
+        "string" === typeof externalRuntimeScript &&
+          bootstrapChunks.push(
             scriptIntegirty,
-            stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
+            stringToChunk(escapeTextForBrowser(externalRuntimeScript))
           ),
-        "string" === typeof maxHeadersLength &&
-          externalRuntimeConfig.push(
+        "string" === typeof idPrefix &&
+          bootstrapChunks.push(
             scriptCrossOrigin,
-            stringToChunk(escapeTextForBrowser(maxHeadersLength))
+            stringToChunk(escapeTextForBrowser(idPrefix))
           ),
-        externalRuntimeConfig.push(endAsyncScript);
+        bootstrapChunks.push(endAsyncScript);
   return onHeaders;
 }
 function createResumableState(
@@ -560,10 +587,12 @@ function createResumableState(
   bootstrapScripts,
   bootstrapModules
 ) {
+  var streamingFormat = 0;
+  void 0 !== externalRuntimeConfig && (streamingFormat = 1);
   return {
     idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
     nextFormID: 0,
-    streamingFormat: 0,
+    streamingFormat: streamingFormat,
     bootstrapScriptContent: bootstrapScriptContent,
     bootstrapScripts: bootstrapScripts,
     bootstrapModules: bootstrapModules,
@@ -580,9 +609,6 @@ function createResumableState(
     moduleScriptResources: {}
   };
 }
-function createPreambleState() {
-  return { htmlChunks: null, headChunks: null, bodyChunks: null };
-}
 function createFormatContext(insertionMode, selectedValue, tagScope) {
   return {
     insertionMode: insertionMode,
@@ -593,9 +619,9 @@ function createFormatContext(insertionMode, selectedValue, tagScope) {
 function createRootFormatContext(namespaceURI) {
   return createFormatContext(
     "http://www.w3.org/2000/svg" === namespaceURI
-      ? 4
+      ? 3
       : "http://www.w3.org/1998/Math/MathML" === namespaceURI
-        ? 5
+        ? 4
         : 0,
     null,
     0
@@ -612,34 +638,33 @@ function getChildFormatContext(parentContext, type, props) {
         parentContext.tagScope
       );
     case "svg":
-      return createFormatContext(4, null, parentContext.tagScope);
+      return createFormatContext(3, null, parentContext.tagScope);
     case "picture":
       return createFormatContext(2, null, parentContext.tagScope | 2);
     case "math":
-      return createFormatContext(5, null, parentContext.tagScope);
+      return createFormatContext(4, null, parentContext.tagScope);
     case "foreignObject":
       return createFormatContext(2, null, parentContext.tagScope);
     case "table":
-      return createFormatContext(6, null, parentContext.tagScope);
+      return createFormatContext(5, null, parentContext.tagScope);
     case "thead":
     case "tbody":
     case "tfoot":
-      return createFormatContext(7, null, parentContext.tagScope);
+      return createFormatContext(6, null, parentContext.tagScope);
     case "colgroup":
-      return createFormatContext(9, null, parentContext.tagScope);
-    case "tr":
       return createFormatContext(8, null, parentContext.tagScope);
-    case "head":
-      if (2 > parentContext.insertionMode)
-        return createFormatContext(3, null, parentContext.tagScope);
-      break;
-    case "html":
-      if (0 === parentContext.insertionMode)
-        return createFormatContext(1, null, parentContext.tagScope);
+    case "tr":
+      return createFormatContext(7, null, parentContext.tagScope);
   }
-  return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode
+  return 5 <= parentContext.insertionMode
     ? createFormatContext(2, null, parentContext.tagScope)
-    : parentContext;
+    : 0 === parentContext.insertionMode
+      ? "html" === type
+        ? createFormatContext(1, null, parentContext.tagScope)
+        : createFormatContext(2, null, parentContext.tagScope)
+      : 1 === parentContext.insertionMode
+        ? createFormatContext(2, null, parentContext.tagScope)
+        : parentContext;
 }
 var textSeparator = stringToPrecomputedChunk("\x3c!-- --\x3e");
 function pushTextInstance(target, text, renderState, textEmbedded) {
@@ -1048,7 +1073,8 @@ var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""'),
     'addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error(\'React form unexpectedly submitted.\')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});'
   );
 function injectFormReplayingRuntime(resumableState, renderState) {
-  0 === (resumableState.instructions & 16) &&
+  0 !== (resumableState.instructions & 16) ||
+    renderState.externalRuntimeScript ||
     ((resumableState.instructions |= 16),
     renderState.bootstrapChunks.unshift(
       renderState.startInlineScript,
@@ -1209,7 +1235,6 @@ function pushStartInstance(
   props,
   resumableState,
   renderState,
-  preambleState,
   hoistableState,
   formatContext,
   textEmbedded,
@@ -1697,7 +1722,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$2;
     case "title":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1716,7 +1741,7 @@ function pushStartInstance(
         href = props.href,
         precedence = props.precedence;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof rel ||
@@ -1798,7 +1823,7 @@ function pushStartInstance(
         "symbol" === typeof asyncProp ||
         props.onLoad ||
         props.onError ||
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1839,7 +1864,7 @@ function pushStartInstance(
       var precedence$jscomp$0 = props.precedence,
         href$jscomp$0 = props.href;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof precedence$jscomp$0 ||
@@ -1948,7 +1973,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$6;
     case "meta":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -2126,13 +2151,10 @@ function pushStartInstance(
     case "missing-glyph":
       break;
     case "head":
-      if (2 > formatContext.insertionMode) {
-        var preamble = preambleState || renderState.preamble;
-        if (preamble.headChunks)
-          throw Error("The `<head>` tag may only be rendered once.");
-        preamble.headChunks = [];
+      if (2 > formatContext.insertionMode && null === renderState.headChunks) {
+        renderState.headChunks = [];
         var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-          preamble.headChunks,
+          renderState.headChunks,
           props,
           "head"
         );
@@ -2143,42 +2165,24 @@ function pushStartInstance(
           "head"
         );
       return JSCompiler_inline_result$jscomp$9;
-    case "body":
-      if (2 > formatContext.insertionMode) {
-        var preamble$jscomp$0 = preambleState || renderState.preamble;
-        if (preamble$jscomp$0.bodyChunks)
-          throw Error("The `<body>` tag may only be rendered once.");
-        preamble$jscomp$0.bodyChunks = [];
-        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          preamble$jscomp$0.bodyChunks,
-          props,
-          "body"
-        );
-      } else
-        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          target$jscomp$0,
-          props,
-          "body"
-        );
-      return JSCompiler_inline_result$jscomp$10;
     case "html":
-      if (0 === formatContext.insertionMode) {
-        var preamble$jscomp$1 = preambleState || renderState.preamble;
-        if (preamble$jscomp$1.htmlChunks)
-          throw Error("The `<html>` tag may only be rendered once.");
-        preamble$jscomp$1.htmlChunks = [doctypeChunk];
-        var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-          preamble$jscomp$1.htmlChunks,
+      if (
+        0 === formatContext.insertionMode &&
+        null === renderState.htmlChunks
+      ) {
+        renderState.htmlChunks = [doctypeChunk];
+        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+          renderState.htmlChunks,
           props,
           "html"
         );
       } else
-        JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
           target$jscomp$0,
           props,
           "html"
         );
-      return JSCompiler_inline_result$jscomp$11;
+      return JSCompiler_inline_result$jscomp$10;
     default:
       if (-1 !== type.indexOf("-")) {
         target$jscomp$0.push(startChunkForTag(type));
@@ -2241,15 +2245,6 @@ function endChunkForTag(tag) {
     endTagCache.set(tag, chunk));
   return chunk;
 }
-function hoistPreambleState(renderState, preambleState) {
-  renderState = renderState.preamble;
-  null === renderState.htmlChunks &&
-    (renderState.htmlChunks = preambleState.htmlChunks);
-  null === renderState.headChunks &&
-    (renderState.headChunks = preambleState.headChunks);
-  null === renderState.bodyChunks &&
-    (renderState.bodyChunks = preambleState.bodyChunks);
-}
 function writeBootstrap(destination, renderState) {
   renderState = renderState.bootstrapChunks;
   for (var i = 0; i < renderState.length - 1; i++)
@@ -2321,7 +2316,6 @@ function writeStartSegment(destination, renderState, formatContext, id) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return (
         writeChunk(destination, startSegmentHTML),
@@ -2329,42 +2323,42 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentHTML2)
       );
-    case 4:
+    case 3:
       return (
         writeChunk(destination, startSegmentSVG),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentSVG2)
       );
-    case 5:
+    case 4:
       return (
         writeChunk(destination, startSegmentMathML),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentMathML2)
       );
-    case 6:
+    case 5:
       return (
         writeChunk(destination, startSegmentTable),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentTable2)
       );
-    case 7:
+    case 6:
       return (
         writeChunk(destination, startSegmentTableBody),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentTableBody2)
       );
-    case 8:
+    case 7:
       return (
         writeChunk(destination, startSegmentTableRow),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, stringToChunk(id.toString(16))),
         writeChunkAndReturn(destination, startSegmentTableRow2)
       );
-    case 9:
+    case 8:
       return (
         writeChunk(destination, startSegmentColGroup),
         writeChunk(destination, renderState.segmentPrefix),
@@ -2379,20 +2373,19 @@ function writeEndSegment(destination, formatContext) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return writeChunkAndReturn(destination, endSegmentHTML);
-    case 4:
+    case 3:
       return writeChunkAndReturn(destination, endSegmentSVG);
-    case 5:
+    case 4:
       return writeChunkAndReturn(destination, endSegmentMathML);
-    case 6:
+    case 5:
       return writeChunkAndReturn(destination, endSegmentTable);
-    case 7:
+    case 6:
       return writeChunkAndReturn(destination, endSegmentTableBody);
-    case 8:
+    case 7:
       return writeChunkAndReturn(destination, endSegmentTableRow);
-    case 9:
+    case 8:
       return writeChunkAndReturn(destination, endSegmentColGroup);
     default:
       throw Error("Unknown insertion mode. This is a bug in React.");
@@ -2403,10 +2396,12 @@ var completeSegmentScript1Full = stringToPrecomputedChunk(
   ),
   completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'),
   completeSegmentScript2 = stringToPrecomputedChunk('","'),
-  completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>');
-stringToPrecomputedChunk('<template data-rsi="" data-sid="');
-stringToPrecomputedChunk('" data-pid="');
-var completeBoundaryScript1Full = stringToPrecomputedChunk(
+  completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>'),
+  completeSegmentData1 = stringToPrecomputedChunk(
+    '<template data-rsi="" data-sid="'
+  ),
+  completeSegmentData2 = stringToPrecomputedChunk('" data-pid="'),
+  completeBoundaryScript1Full = stringToPrecomputedChunk(
     '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
   ),
   completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'),
@@ -2420,20 +2415,26 @@ var completeBoundaryScript1Full = stringToPrecomputedChunk(
   completeBoundaryScript2 = stringToPrecomputedChunk('","'),
   completeBoundaryScript3a = stringToPrecomputedChunk('",'),
   completeBoundaryScript3b = stringToPrecomputedChunk('"'),
-  completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-stringToPrecomputedChunk('<template data-rci="" data-bid="');
-stringToPrecomputedChunk('<template data-rri="" data-bid="');
-stringToPrecomputedChunk('" data-sid="');
-stringToPrecomputedChunk('" data-sty="');
-var clientRenderScript1Full = stringToPrecomputedChunk(
+  completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+  completeBoundaryData1 = stringToPrecomputedChunk(
+    '<template data-rci="" data-bid="'
+  ),
+  completeBoundaryWithStylesData1 = stringToPrecomputedChunk(
+    '<template data-rri="" data-bid="'
+  ),
+  completeBoundaryData2 = stringToPrecomputedChunk('" data-sid="'),
+  completeBoundaryData3a = stringToPrecomputedChunk('" data-sty="'),
+  clientRenderScript1Full = stringToPrecomputedChunk(
     '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
   ),
   clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'),
   clientRenderScript1A = stringToPrecomputedChunk('"'),
   clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","),
-  clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-stringToPrecomputedChunk('<template data-rxi="" data-bid="');
-stringToPrecomputedChunk('" data-dgst="');
+  clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+  clientRenderData1 = stringToPrecomputedChunk(
+    '<template data-rxi="" data-bid="'
+  ),
+  clientRenderData2 = stringToPrecomputedChunk('" data-dgst="');
 stringToPrecomputedChunk('" data-msg="');
 stringToPrecomputedChunk('" data-stck="');
 stringToPrecomputedChunk('" data-cstck="');
@@ -2711,6 +2712,115 @@ function writeStyleResourceAttributeInJS(destination, name, value) {
     stringToChunk(escapeJSObjectForInstructionScripts(name))
   );
 }
+function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+  writeChunk(destination, arrayFirstOpenBracket);
+  var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
+  hoistableState.stylesheets.forEach(function (resource) {
+    if (2 !== resource.state)
+      if (3 === resource.state)
+        writeChunk(destination, nextArrayOpenBrackChunk),
+          writeChunk(
+            destination,
+            stringToChunk(
+              escapeTextForBrowser(JSON.stringify("" + resource.props.href))
+            )
+          ),
+          writeChunk(destination, arrayCloseBracket),
+          (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);
+      else {
+        writeChunk(destination, nextArrayOpenBrackChunk);
+        var precedence = resource.props["data-precedence"],
+          props = resource.props,
+          coercedHref = sanitizeURL("" + resource.props.href);
+        writeChunk(
+          destination,
+          stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref)))
+        );
+        precedence = "" + precedence;
+        writeChunk(destination, arrayInterstitial);
+        writeChunk(
+          destination,
+          stringToChunk(escapeTextForBrowser(JSON.stringify(precedence)))
+        );
+        for (var propKey in props)
+          if (
+            hasOwnProperty.call(props, propKey) &&
+            ((precedence = props[propKey]), null != precedence)
+          )
+            switch (propKey) {
+              case "href":
+              case "rel":
+              case "precedence":
+              case "data-precedence":
+                break;
+              case "children":
+              case "dangerouslySetInnerHTML":
+                throw Error(
+                  "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                );
+              default:
+                writeStyleResourceAttributeInAttr(
+                  destination,
+                  propKey,
+                  precedence
+                );
+            }
+        writeChunk(destination, arrayCloseBracket);
+        nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
+        resource.state = 3;
+      }
+  });
+  writeChunk(destination, arrayCloseBracket);
+}
+function writeStyleResourceAttributeInAttr(destination, name, value) {
+  var attributeName = name.toLowerCase();
+  switch (typeof value) {
+    case "function":
+    case "symbol":
+      return;
+  }
+  switch (name) {
+    case "innerHTML":
+    case "dangerouslySetInnerHTML":
+    case "suppressContentEditableWarning":
+    case "suppressHydrationWarning":
+    case "style":
+    case "ref":
+      return;
+    case "className":
+      attributeName = "class";
+      name = "" + value;
+      break;
+    case "hidden":
+      if (!1 === value) return;
+      name = "";
+      break;
+    case "src":
+    case "href":
+      value = sanitizeURL(value);
+      name = "" + value;
+      break;
+    default:
+      if (
+        (2 < name.length &&
+          ("o" === name[0] || "O" === name[0]) &&
+          ("n" === name[1] || "N" === name[1])) ||
+        !isAttributeNameSafe(name)
+      )
+        return;
+      name = "" + value;
+  }
+  writeChunk(destination, arrayInterstitial);
+  writeChunk(
+    destination,
+    stringToChunk(escapeTextForBrowser(JSON.stringify(attributeName)))
+  );
+  writeChunk(destination, arrayInterstitial);
+  writeChunk(
+    destination,
+    stringToChunk(escapeTextForBrowser(JSON.stringify(name)))
+  );
+}
 function createHoistableState() {
   return { styles: new Set(), stylesheets: new Set() };
 }
@@ -3140,6 +3250,8 @@ function getComponentNameFromType(type) {
       return "Suspense";
     case REACT_SUSPENSE_LIST_TYPE:
       return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
   }
   if ("object" === typeof type)
     switch (type.$$typeof) {
@@ -3482,6 +3594,11 @@ function dispatchAction(componentIdentity, queue, action) {
       queue.next = componentIdentity;
     }
 }
+function throwOnUseEffectEventCall() {
+  throw Error(
+    "A function wrapped in useEffectEvent can't be called during rendering."
+  );
+}
 function unsupportedStartTransition() {
   throw Error("startTransition cannot be called during server rendering.");
 }
@@ -3556,8 +3673,15 @@ function unwrapThenable(thenable) {
   null === thenableState && (thenableState = []);
   return trackUsedThenable(thenableState, thenable, index);
 }
-function unsupportedRefresh() {
-  throw Error("Cache cannot be refreshed during server rendering.");
+function readPreviousThenableFromState() {
+  var index = thenableIndexCounter;
+  thenableIndexCounter += 1;
+  if (null !== thenableState)
+    return (
+      (index = thenableState[index]),
+      (index = void 0 === index ? void 0 : index.value),
+      index
+    );
 }
 function noop$1() {}
 var HooksDispatcher = {
@@ -3644,13 +3768,8 @@ var HooksDispatcher = {
       resolveCurrentlyRenderingComponent();
       return sharedNotPendingObject;
     },
-    useMemoCache: function (size) {
-      for (var data = Array(size), i = 0; i < size; i++)
-        data[i] = REACT_MEMO_CACHE_SENTINEL;
-      return data;
-    },
-    useCacheRefresh: function () {
-      return unsupportedRefresh;
+    useEffectEvent: function () {
+      return throwOnUseEffectEventCall;
     }
   },
   currentResumableState = null,
@@ -3852,6 +3971,8 @@ function describeComponentStackByType(type) {
       return describeBuiltInComponentFrame("SuspenseList");
     case REACT_SUSPENSE_TYPE:
       return describeBuiltInComponentFrame("Suspense");
+    case REACT_VIEW_TRANSITION_TYPE:
+      return describeBuiltInComponentFrame("ViewTransition");
   }
   return "";
 }
@@ -3911,7 +4032,7 @@ function RequestInstance(
   this.status = 10;
   this.fatalError = null;
   this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-  this.completedPreambleSegments = this.completedRootSegment = null;
+  this.completedRootSegment = null;
   this.abortableTasks = abortSet;
   this.pingedTasks = [];
   this.clientRenderedBoundaries = [];
@@ -3970,7 +4091,6 @@ function createRequest(
     null,
     renderState,
     null,
-    null,
     resumableState.abortableTasks,
     null,
     rootFormatContext,
@@ -4017,65 +4137,168 @@ function createPrerenderRequest(
   };
   return children;
 }
-var currentRequest = null;
-function resolveRequest() {
-  if (currentRequest) return currentRequest;
-  if (supportsRequestStorage) {
-    var store = requestStorage.getStore();
-    if (store) return store;
-  }
-  return null;
-}
-function pingTask(request, task) {
-  request.pingedTasks.push(task);
-  1 === request.pingedTasks.length &&
-    ((request.flushScheduled = null !== request.destination),
-    null !== request.trackedPostpones || 10 === request.status
-      ? scheduleMicrotask(function () {
-          return performWork(request);
-        })
-      : setTimeout(function () {
-          return performWork(request);
-        }, 0));
-}
-function createSuspenseBoundary(
-  request,
-  fallbackAbortableTasks,
-  contentPreamble,
-  fallbackPreamble
+function resumeRequest(
+  children,
+  postponedState,
+  renderState,
+  onError,
+  onAllReady,
+  onShellReady,
+  onShellError,
+  onFatalError,
+  onPostpone
 ) {
-  return {
-    status: 0,
-    rootSegmentID: -1,
-    parentFlushed: !1,
-    pendingTasks: 0,
-    completedSegments: [],
-    byteSize: 0,
-    fallbackAbortableTasks: fallbackAbortableTasks,
-    errorDigest: null,
-    contentState: createHoistableState(),
-    fallbackState: createHoistableState(),
-    contentPreamble: contentPreamble,
-    fallbackPreamble: fallbackPreamble,
-    trackedContentKeyPath: null,
-    trackedFallbackNode: null
-  };
-}
-function createRenderTask(
-  request,
-  thenableState,
-  node,
-  childIndex,
-  blockedBoundary,
-  blockedSegment,
-  blockedPreamble,
-  hoistableState,
-  abortSet,
-  keyPath,
-  formatContext,
-  context,
-  treeContext,
-  componentStack,
+  renderState = new RequestInstance(
+    postponedState.resumableState,
+    renderState,
+    postponedState.rootFormatContext,
+    postponedState.progressiveChunkSize,
+    onError,
+    onAllReady,
+    onShellReady,
+    onShellError,
+    onFatalError,
+    onPostpone,
+    null
+  );
+  renderState.nextSegmentId = postponedState.nextSegmentId;
+  if ("number" === typeof postponedState.replaySlots)
+    return (
+      (onError = postponedState.replaySlots),
+      (onAllReady = createPendingSegment(
+        renderState,
+        0,
+        null,
+        postponedState.rootFormatContext,
+        !1,
+        !1
+      )),
+      (onAllReady.id = onError),
+      (onAllReady.parentFlushed = !0),
+      (children = createRenderTask(
+        renderState,
+        null,
+        children,
+        -1,
+        null,
+        onAllReady,
+        null,
+        renderState.abortableTasks,
+        null,
+        postponedState.rootFormatContext,
+        null,
+        emptyTreeContext,
+        null,
+        !1
+      )),
+      pushComponentStack(children),
+      renderState.pingedTasks.push(children),
+      renderState
+    );
+  children = createReplayTask(
+    renderState,
+    null,
+    {
+      nodes: postponedState.replayNodes,
+      slots: postponedState.replaySlots,
+      pendingTasks: 0
+    },
+    children,
+    -1,
+    null,
+    null,
+    renderState.abortableTasks,
+    null,
+    postponedState.rootFormatContext,
+    null,
+    emptyTreeContext,
+    null,
+    !1
+  );
+  pushComponentStack(children);
+  renderState.pingedTasks.push(children);
+  return renderState;
+}
+function resumeAndPrerenderRequest(
+  children,
+  postponedState,
+  renderState,
+  onError,
+  onAllReady,
+  onShellReady,
+  onShellError,
+  onFatalError,
+  onPostpone
+) {
+  children = resumeRequest(
+    children,
+    postponedState,
+    renderState,
+    onError,
+    onAllReady,
+    onShellReady,
+    onShellError,
+    onFatalError,
+    onPostpone
+  );
+  children.trackedPostpones = {
+    workingMap: new Map(),
+    rootNodes: [],
+    rootSlots: null
+  };
+  return children;
+}
+var currentRequest = null;
+function resolveRequest() {
+  if (currentRequest) return currentRequest;
+  if (supportsRequestStorage) {
+    var store = requestStorage.getStore();
+    if (store) return store;
+  }
+  return null;
+}
+function pingTask(request, task) {
+  request.pingedTasks.push(task);
+  1 === request.pingedTasks.length &&
+    ((request.flushScheduled = null !== request.destination),
+    null !== request.trackedPostpones || 10 === request.status
+      ? scheduleMicrotask(function () {
+          return performWork(request);
+        })
+      : setTimeout(function () {
+          return performWork(request);
+        }, 0));
+}
+function createSuspenseBoundary(request, fallbackAbortableTasks) {
+  return {
+    status: 0,
+    rootSegmentID: -1,
+    parentFlushed: !1,
+    pendingTasks: 0,
+    completedSegments: [],
+    byteSize: 0,
+    fallbackAbortableTasks: fallbackAbortableTasks,
+    errorDigest: null,
+    contentState: createHoistableState(),
+    fallbackState: createHoistableState(),
+    trackedContentKeyPath: null,
+    trackedFallbackNode: null
+  };
+}
+function createRenderTask(
+  request,
+  thenableState,
+  node,
+  childIndex,
+  blockedBoundary,
+  blockedSegment,
+  hoistableState,
+  abortSet,
+  keyPath,
+  formatContext,
+  context,
+  treeContext,
+  componentStack,
   isFallback
 ) {
   request.allPendingTasks++;
@@ -4091,7 +4314,6 @@ function createRenderTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: blockedSegment,
-    blockedPreamble: blockedPreamble,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -4135,7 +4357,6 @@ function createReplayTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: null,
-    blockedPreamble: null,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -4159,12 +4380,11 @@ function createPendingSegment(
 ) {
   return {
     status: 0,
-    parentFlushed: !1,
     id: -1,
     index: index,
+    parentFlushed: !1,
     chunks: [],
     children: [],
-    preambleChildren: [],
     parentFormatContext: parentFormatContext,
     boundary: boundary,
     lastPushedText: lastPushedText,
@@ -4206,6 +4426,10 @@ function getThrownInfo(node$jscomp$0) {
     });
   return errorInfo;
 }
+function logPostpone(request, reason, postponeInfo) {
+  request = request.onPostpone;
+  request(reason, postponeInfo);
+}
 function logRecoverableError(request, error, errorInfo) {
   request = request.onError;
   error = request(error, errorInfo);
@@ -4287,9 +4511,9 @@ function renderElement(request, task, keyPath, type, props, ref) {
       var defaultProps = type.defaultProps;
       if (defaultProps) {
         newProps === props && (newProps = assign({}, newProps, props));
-        for (var propName$33 in defaultProps)
-          void 0 === newProps[propName$33] &&
-            (newProps[propName$33] = defaultProps[propName$33]);
+        for (var propName$34 in defaultProps)
+          void 0 === newProps[propName$34] &&
+            (newProps[propName$34] = defaultProps[propName$34]);
       }
       props = newProps;
       newProps = emptyContextObject;
@@ -4349,16 +4573,16 @@ function renderElement(request, task, keyPath, type, props, ref) {
             defaultProps = ref ? type[0] : newProps.state;
             initialState = !0;
             for (ref = ref ? 1 : 0; ref < type.length; ref++)
-              (propName$33 = type[ref]),
-                (propName$33 =
-                  "function" === typeof propName$33
-                    ? propName$33.call(newProps, defaultProps, props, void 0)
-                    : propName$33),
-                null != propName$33 &&
+              (propName$34 = type[ref]),
+                (propName$34 =
+                  "function" === typeof propName$34
+                    ? propName$34.call(newProps, defaultProps, props, void 0)
+                    : propName$34),
+                null != propName$34 &&
                   (initialState
                     ? ((initialState = !1),
-                      (defaultProps = assign({}, defaultProps, propName$33)))
-                    : assign(defaultProps, propName$33));
+                      (defaultProps = assign({}, defaultProps, propName$34)))
+                    : assign(defaultProps, propName$34));
             newProps.state = defaultProps;
           }
         else defaultProps.queue = null;
@@ -4392,13 +4616,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
         (task.formatContext = defaultProps),
         (task.keyPath = initialState);
     else {
-      ref = pushStartInstance(
+      initialState = pushStartInstance(
         newProps.chunks,
         type,
         props,
         request.resumableState,
         request.renderState,
-        task.blockedPreamble,
         task.hoistableState,
         task.formatContext,
         newProps.lastPushedText,
@@ -4406,42 +4629,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
       );
       newProps.lastPushedText = !1;
       defaultProps = task.formatContext;
-      initialState = task.keyPath;
+      ref = task.keyPath;
+      task.formatContext = getChildFormatContext(defaultProps, type, props);
       task.keyPath = keyPath;
-      3 ===
-      (task.formatContext = getChildFormatContext(defaultProps, type, props))
-        .insertionMode
-        ? ((keyPath = createPendingSegment(
-            request,
-            0,
-            null,
-            task.formatContext,
-            !1,
-            !1
-          )),
-          newProps.preambleChildren.push(keyPath),
-          (keyPath = createRenderTask(
-            request,
-            null,
-            ref,
-            -1,
-            task.blockedBoundary,
-            keyPath,
-            task.blockedPreamble,
-            task.hoistableState,
-            request.abortableTasks,
-            task.keyPath,
-            task.formatContext,
-            task.context,
-            task.treeContext,
-            task.componentStack,
-            task.isFallback
-          )),
-          pushComponentStack(keyPath),
-          request.pingedTasks.push(keyPath))
-        : renderNode(request, task, ref, -1);
+      renderNode(request, task, initialState, -1);
       task.formatContext = defaultProps;
-      task.keyPath = initialState;
+      task.keyPath = ref;
       a: {
         task = newProps.chunks;
         request = request.resumableState;
@@ -4476,9 +4669,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
               request.hasHtml = !0;
               break a;
             }
-            break;
-          case "head":
-            if (1 >= defaultProps.insertionMode) break a;
         }
         task.push(endChunkForTag(type));
       }
@@ -4509,6 +4699,11 @@ function renderElement(request, task, keyPath, type, props, ref) {
         task.keyPath = type;
         return;
       case REACT_VIEW_TRANSITION_TYPE:
+        type = task.keyPath;
+        task.keyPath = keyPath;
+        renderNodeDestructive(request, task, props.children, -1);
+        task.keyPath = type;
+        return;
       case REACT_SCOPE_TYPE:
         throw Error("ReactDOMServer does not yet support scope components.");
       case REACT_SUSPENSE_TYPE:
@@ -4523,34 +4718,25 @@ function renderElement(request, task, keyPath, type, props, ref) {
           }
         } else {
           type = task.keyPath;
-          var parentBoundary = task.blockedBoundary;
-          ref = task.blockedPreamble;
-          var parentHoistableState = task.hoistableState;
-          propName$33 = task.blockedSegment;
-          propName = props.fallback;
+          var parentBoundary = task.blockedBoundary,
+            parentHoistableState = task.hoistableState;
+          ref = task.blockedSegment;
+          propName$34 = props.fallback;
           props = props.children;
           var fallbackAbortSet = new Set();
-          var newBoundary =
-            2 > task.formatContext.insertionMode
-              ? createSuspenseBoundary(
-                  request,
-                  fallbackAbortSet,
-                  createPreambleState(),
-                  createPreambleState()
-                )
-              : createSuspenseBoundary(request, fallbackAbortSet, null, null);
+          propName = createSuspenseBoundary(request, fallbackAbortSet);
           null !== request.trackedPostpones &&
-            (newBoundary.trackedContentKeyPath = keyPath);
+            (propName.trackedContentKeyPath = keyPath);
           var boundarySegment = createPendingSegment(
             request,
-            propName$33.chunks.length,
-            newBoundary,
+            ref.chunks.length,
+            propName,
             task.formatContext,
             !1,
             !1
           );
-          propName$33.children.push(boundarySegment);
-          propName$33.lastPushedText = !1;
+          ref.children.push(boundarySegment);
+          ref.lastPushedText = !1;
           var contentRootSegment = createPendingSegment(
             request,
             0,
@@ -4564,13 +4750,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
             newProps = [keyPath[0], "Suspense Fallback", keyPath[2]];
             defaultProps = [newProps[1], newProps[2], [], null];
             request.trackedPostpones.workingMap.set(newProps, defaultProps);
-            newBoundary.trackedFallbackNode = defaultProps;
+            propName.trackedFallbackNode = defaultProps;
             task.blockedSegment = boundarySegment;
-            task.blockedPreamble = newBoundary.fallbackPreamble;
             task.keyPath = newProps;
             boundarySegment.status = 6;
             try {
-              renderNode(request, task, propName, -1),
+              renderNode(request, task, propName$34, -1),
                 boundarySegment.lastPushedText &&
                   boundarySegment.textEmbedded &&
                   boundarySegment.chunks.push(textSeparator),
@@ -4581,19 +4766,16 @@ function renderElement(request, task, keyPath, type, props, ref) {
                 thrownValue)
               );
             } finally {
-              (task.blockedSegment = propName$33),
-                (task.blockedPreamble = ref),
-                (task.keyPath = type);
+              (task.blockedSegment = ref), (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
               props,
               -1,
-              newBoundary,
+              propName,
               contentRootSegment,
-              newBoundary.contentPreamble,
-              newBoundary.contentState,
+              propName.contentState,
               task.abortSet,
               keyPath,
               task.formatContext,
@@ -4605,9 +4787,8 @@ function renderElement(request, task, keyPath, type, props, ref) {
             pushComponentStack(task);
             request.pingedTasks.push(task);
           } else {
-            task.blockedBoundary = newBoundary;
-            task.blockedPreamble = newBoundary.contentPreamble;
-            task.hoistableState = newBoundary.contentState;
+            task.blockedBoundary = propName;
+            task.hoistableState = propName.contentState;
             task.blockedSegment = contentRootSegment;
             task.keyPath = keyPath;
             contentRootSegment.status = 6;
@@ -4618,46 +4799,46 @@ function renderElement(request, task, keyPath, type, props, ref) {
                   contentRootSegment.textEmbedded &&
                   contentRootSegment.chunks.push(textSeparator),
                 (contentRootSegment.status = 1),
-                queueCompletedSegment(newBoundary, contentRootSegment),
-                0 === newBoundary.pendingTasks && 0 === newBoundary.status)
+                queueCompletedSegment(propName, contentRootSegment),
+                0 === propName.pendingTasks && 0 === propName.status)
               ) {
-                newBoundary.status = 1;
-                0 === request.pendingRootTasks &&
-                  task.blockedPreamble &&
-                  preparePreamble(request);
+                propName.status = 1;
                 break a;
               }
-            } catch (thrownValue$28) {
-              (newBoundary.status = 4),
+            } catch (thrownValue$29) {
+              (propName.status = 4),
                 12 === request.status
                   ? ((contentRootSegment.status = 3),
                     (newProps = request.fatalError))
                   : ((contentRootSegment.status = 4),
-                    (newProps = thrownValue$28)),
+                    (newProps = thrownValue$29)),
                 (defaultProps = getThrownInfo(task.componentStack)),
-                (initialState = logRecoverableError(
-                  request,
-                  newProps,
-                  defaultProps
-                )),
-                (newBoundary.errorDigest = initialState),
-                untrackBoundary(request, newBoundary);
+                "object" === typeof newProps &&
+                null !== newProps &&
+                newProps.$$typeof === REACT_POSTPONE_TYPE
+                  ? (logPostpone(request, newProps.message, defaultProps),
+                    (initialState = "POSTPONE"))
+                  : (initialState = logRecoverableError(
+                      request,
+                      newProps,
+                      defaultProps
+                    )),
+                (propName.errorDigest = initialState),
+                untrackBoundary(request, propName);
             } finally {
               (task.blockedBoundary = parentBoundary),
-                (task.blockedPreamble = ref),
                 (task.hoistableState = parentHoistableState),
-                (task.blockedSegment = propName$33),
+                (task.blockedSegment = ref),
                 (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
-              propName,
+              propName$34,
               -1,
               parentBoundary,
               boundarySegment,
-              newBoundary.fallbackPreamble,
-              newBoundary.fallbackState,
+              propName.fallbackState,
               fallbackAbortSet,
               [keyPath[0], "Suspense Fallback", keyPath[2]],
               task.formatContext,
@@ -4676,9 +4857,9 @@ function renderElement(request, task, keyPath, type, props, ref) {
       switch (type.$$typeof) {
         case REACT_FORWARD_REF_TYPE:
           if ("ref" in props)
-            for (newBoundary in ((newProps = {}), props))
-              "ref" !== newBoundary &&
-                (newProps[newBoundary] = props[newBoundary]);
+            for (boundarySegment in ((newProps = {}), props))
+              "ref" !== boundarySegment &&
+                (newProps[boundarySegment] = props[boundarySegment]);
           else newProps = props;
           type = renderWithHooks(
             request,
@@ -4850,16 +5031,13 @@ function retryNode(request, task) {
                         );
                       task.replay.pendingTasks--;
                       props = getThrownInfo(task.componentStack);
-                      key = task.blockedBoundary;
-                      type = x;
-                      props = logRecoverableError(request, type, props);
-                      abortRemainingReplayNodes(
+                      erroredReplay(
                         request,
-                        key,
+                        task.blockedBoundary,
+                        x,
+                        props,
                         childNodes,
-                        name,
-                        type,
-                        props
+                        name
                       );
                     }
                     task.replay = replay;
@@ -4871,9 +5049,9 @@ function retryNode(request, task) {
                           ">. The tree doesn't match so React will fallback to client rendering."
                       );
                     b: {
-                      replay = void 0;
-                      type = node$jscomp$0[5];
-                      ref = node$jscomp$0[2];
+                      type = void 0;
+                      ref = node$jscomp$0[5];
+                      replay = node$jscomp$0[2];
                       name = node$jscomp$0[3];
                       keyOrIndex =
                         null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
@@ -4883,30 +5061,20 @@ function retryNode(request, task) {
                         previousReplaySet = task.replay,
                         parentBoundary = task.blockedBoundary,
                         parentHoistableState = task.hoistableState,
-                        content = props.children,
-                        fallback = props.fallback,
-                        fallbackAbortSet = new Set();
-                      props =
-                        2 > task.formatContext.insertionMode
-                          ? createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              createPreambleState(),
-                              createPreambleState()
-                            )
-                          : createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              null,
-                              null
-                            );
-                      props.parentFlushed = !0;
-                      props.rootSegmentID = type;
-                      task.blockedBoundary = props;
-                      task.hoistableState = props.contentState;
+                        content = props.children;
+                      props = props.fallback;
+                      var fallbackAbortSet = new Set(),
+                        resumedBoundary = createSuspenseBoundary(
+                          request,
+                          fallbackAbortSet
+                        );
+                      resumedBoundary.parentFlushed = !0;
+                      resumedBoundary.rootSegmentID = ref;
+                      task.blockedBoundary = resumedBoundary;
+                      task.hoistableState = resumedBoundary.contentState;
                       task.keyPath = key;
                       task.replay = {
-                        nodes: ref,
+                        nodes: replay,
                         slots: name,
                         pendingTasks: 1
                       };
@@ -4920,22 +5088,32 @@ function retryNode(request, task) {
                             "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                           );
                         task.replay.pendingTasks--;
-                        if (0 === props.pendingTasks && 0 === props.status) {
-                          props.status = 1;
-                          request.completedBoundaries.push(props);
+                        if (
+                          0 === resumedBoundary.pendingTasks &&
+                          0 === resumedBoundary.status
+                        ) {
+                          resumedBoundary.status = 1;
+                          request.completedBoundaries.push(resumedBoundary);
                           break b;
                         }
                       } catch (error) {
-                        (props.status = 4),
+                        (resumedBoundary.status = 4),
                           (childNodes = getThrownInfo(task.componentStack)),
-                          (replay = logRecoverableError(
-                            request,
-                            error,
-                            childNodes
-                          )),
-                          (props.errorDigest = replay),
+                          "object" === typeof error &&
+                          null !== error &&
+                          error.$$typeof === REACT_POSTPONE_TYPE
+                            ? (logPostpone(request, error.message, childNodes),
+                              (type = "POSTPONE"))
+                            : (type = logRecoverableError(
+                                request,
+                                error,
+                                childNodes
+                              )),
+                          (resumedBoundary.errorDigest = type),
                           task.replay.pendingTasks--,
-                          request.clientRenderedBoundaries.push(props);
+                          request.clientRenderedBoundaries.push(
+                            resumedBoundary
+                          );
                       } finally {
                         (task.blockedBoundary = parentBoundary),
                           (task.hoistableState = parentHoistableState),
@@ -4950,10 +5128,10 @@ function retryNode(request, task) {
                           slots: node$jscomp$0,
                           pendingTasks: 0
                         },
-                        fallback,
+                        props,
                         -1,
                         parentBoundary,
-                        props.fallbackState,
+                        resumedBoundary.fallbackState,
                         fallbackAbortSet,
                         [key[0], "Suspense Fallback", key[2]],
                         task.formatContext,
@@ -5004,6 +5182,31 @@ function retryNode(request, task) {
         }
         return;
       }
+      if (
+        "function" === typeof node[ASYNC_ITERATOR] &&
+        (childNodes = node[ASYNC_ITERATOR]())
+      ) {
+        props = task.thenableState;
+        task.thenableState = null;
+        thenableIndexCounter = 0;
+        thenableState = props;
+        props = [];
+        key = !1;
+        if (childNodes === node)
+          for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+            if (node.done) {
+              key = !0;
+              break;
+            }
+            props.push(node.value);
+            node = readPreviousThenableFromState();
+          }
+        if (!key)
+          for (node = unwrapThenable(childNodes.next()); !node.done; )
+            props.push(node.value), (node = unwrapThenable(childNodes.next()));
+        renderChildrenArray(request, task, props, childIndex);
+        return;
+      }
       if ("function" === typeof node.then)
         return (
           (task.thenableState = null),
@@ -5016,32 +5219,32 @@ function retryNode(request, task) {
           node._currentValue,
           childIndex
         );
-      childIndex = Object.prototype.toString.call(node);
+      request = Object.prototype.toString.call(node);
       throw Error(
         "Objects are not valid as a React child (found: " +
-          ("[object Object]" === childIndex
+          ("[object Object]" === request
             ? "object with keys {" + Object.keys(node).join(", ") + "}"
-            : childIndex) +
+            : request) +
           "). If you meant to render a collection of children, use an array instead."
       );
     }
     if ("string" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
     else if ("number" === typeof node || "bigint" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             "" + node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
   }
 }
@@ -5078,16 +5281,13 @@ function renderChildrenArray(request, task, children, childIndex) {
             throw x;
           task.replay.pendingTasks--;
           children = getThrownInfo(task.componentStack);
-          var boundary = task.blockedBoundary,
-            error = x;
-          children = logRecoverableError(request, error, children);
-          abortRemainingReplayNodes(
+          erroredReplay(
             request,
-            boundary,
+            task.blockedBoundary,
+            x,
+            children,
             childIndex,
-            node,
-            error,
-            children
+            node
           );
         }
         task.replay = replay;
@@ -5104,14 +5304,15 @@ function renderChildrenArray(request, task, children, childIndex) {
     null !== task.replay &&
     ((j = task.replay.slots), null !== j && "object" === typeof j)
   ) {
-    for (childIndex = 0; childIndex < replayNodes; childIndex++)
-      (node = children[childIndex]),
-        (task.treeContext = pushTreeContext(replay, replayNodes, childIndex)),
-        (boundary = j[childIndex]),
-        "number" === typeof boundary
-          ? (resumeNode(request, task, boundary, node, childIndex),
-            delete j[childIndex])
-          : renderNode(request, task, node, childIndex);
+    for (childIndex = 0; childIndex < replayNodes; childIndex++) {
+      node = children[childIndex];
+      task.treeContext = pushTreeContext(replay, replayNodes, childIndex);
+      var resumeSegmentID = j[childIndex];
+      "number" === typeof resumeSegmentID
+        ? (resumeNode(request, task, resumeSegmentID, node, childIndex),
+          delete j[childIndex])
+        : renderNode(request, task, node, childIndex);
+    }
     task.treeContext = replay;
     task.keyPath = prevKeyPath;
     return;
@@ -5123,6 +5324,105 @@ function renderChildrenArray(request, task, children, childIndex) {
   task.treeContext = replay;
   task.keyPath = prevKeyPath;
 }
+function trackPostpone(request, trackedPostpones, task, segment) {
+  segment.status = 5;
+  var keyPath = task.keyPath,
+    boundary = task.blockedBoundary;
+  if (null === boundary)
+    (segment.id = request.nextSegmentId++),
+      (trackedPostpones.rootSlots = segment.id),
+      null !== request.completedRootSegment &&
+        (request.completedRootSegment.status = 5);
+  else {
+    if (null !== boundary && 0 === boundary.status) {
+      boundary.status = 5;
+      boundary.rootSegmentID = request.nextSegmentId++;
+      var boundaryKeyPath = boundary.trackedContentKeyPath;
+      if (null === boundaryKeyPath)
+        throw Error(
+          "It should not be possible to postpone at the root. This is a bug in React."
+        );
+      var fallbackReplayNode = boundary.trackedFallbackNode,
+        children = [];
+      if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+        -1 === segment.id &&
+          (segment.id = segment.parentFlushed
+            ? boundary.rootSegmentID
+            : request.nextSegmentId++);
+        segment = [
+          boundaryKeyPath[1],
+          boundaryKeyPath[2],
+          children,
+          segment.id,
+          fallbackReplayNode,
+          boundary.rootSegmentID
+        ];
+        trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+        addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+        return;
+      }
+      var boundaryNode$45 = trackedPostpones.workingMap.get(boundaryKeyPath);
+      void 0 === boundaryNode$45
+        ? ((boundaryNode$45 = [
+            boundaryKeyPath[1],
+            boundaryKeyPath[2],
+            children,
+            null,
+            fallbackReplayNode,
+            boundary.rootSegmentID
+          ]),
+          trackedPostpones.workingMap.set(boundaryKeyPath, boundaryNode$45),
+          addToReplayParent(
+            boundaryNode$45,
+            boundaryKeyPath[0],
+            trackedPostpones
+          ))
+        : ((boundaryKeyPath = boundaryNode$45),
+          (boundaryKeyPath[4] = fallbackReplayNode),
+          (boundaryKeyPath[5] = boundary.rootSegmentID));
+    }
+    -1 === segment.id &&
+      (segment.id =
+        segment.parentFlushed && null !== boundary
+          ? boundary.rootSegmentID
+          : request.nextSegmentId++);
+    if (-1 === task.childIndex)
+      null === keyPath
+        ? (trackedPostpones.rootSlots = segment.id)
+        : ((task = trackedPostpones.workingMap.get(keyPath)),
+          void 0 === task
+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+              addToReplayParent(task, keyPath[0], trackedPostpones))
+            : (task[3] = segment.id));
+    else {
+      if (null === keyPath)
+        if (((request = trackedPostpones.rootSlots), null === request))
+          request = trackedPostpones.rootSlots = {};
+        else {
+          if ("number" === typeof request)
+            throw Error(
+              "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+            );
+        }
+      else if (
+        ((boundary = trackedPostpones.workingMap),
+        (boundaryKeyPath = boundary.get(keyPath)),
+        void 0 === boundaryKeyPath)
+      )
+        (request = {}),
+          (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+          boundary.set(keyPath, boundaryKeyPath),
+          addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+      else if (((request = boundaryKeyPath[3]), null === request))
+        request = boundaryKeyPath[3] = {};
+      else if ("number" === typeof request)
+        throw Error(
+          "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+        );
+      request[task.childIndex] = segment.id;
+    }
+  }
+}
 function untrackBoundary(request, boundary) {
   request = request.trackedPostpones;
   null !== request &&
@@ -5169,7 +5469,6 @@ function spawnNewSuspendedRenderTask(request, task, thenableState) {
     task.childIndex,
     task.blockedBoundary,
     newSegment,
-    task.blockedPreamble,
     task.hoistableState,
     task.abortSet,
     task.keyPath,
@@ -5193,13 +5492,14 @@ function renderNode(request, task, node, childIndex) {
     } catch (thrownValue) {
       if (
         (resetHooksState(),
-        (node =
+        (childIndex =
           thrownValue === SuspenseException
             ? getSuspendedThenable()
             : thrownValue),
-        "object" === typeof node && null !== node)
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -5211,7 +5511,7 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedReplayTask(request, task, node);
           request.pingedTasks.push(node);
@@ -5230,18 +5530,19 @@ function renderNode(request, task, node, childIndex) {
       chunkLength = segment.chunks.length;
     try {
       return renderNodeDestructive(request, task, node, childIndex);
-    } catch (thrownValue$48) {
+    } catch (thrownValue$57) {
       if (
         (resetHooksState(),
         (segment.children.length = childrenLength),
         (segment.chunks.length = chunkLength),
-        (node =
-          thrownValue$48 === SuspenseException
+        (childIndex =
+          thrownValue$57 === SuspenseException
             ? getSuspendedThenable()
-            : thrownValue$48),
-        "object" === typeof node && null !== node)
+            : thrownValue$57),
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -5253,7 +5554,35 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if (
+          childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+          null !== request.trackedPostpones &&
+          null !== task.blockedBoundary
+        ) {
+          node = request.trackedPostpones;
+          segment = getThrownInfo(task.componentStack);
+          logPostpone(request, childIndex.message, segment);
+          childIndex = task.blockedSegment;
+          segment = createPendingSegment(
+            request,
+            childIndex.chunks.length,
+            null,
+            task.formatContext,
+            childIndex.lastPushedText,
+            !0
+          );
+          childIndex.children.push(segment);
+          childIndex.lastPushedText = !1;
+          trackPostpone(request, node, task, segment);
+          task.formatContext = previousFormatContext;
+          task.context = previousContext;
+          task.keyPath = previousKeyPath;
+          task.treeContext = previousTreeContext;
+          task.componentStack = previousComponentStack;
+          switchContext(previousContext);
+          return;
+        }
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedRenderTask(request, task, node);
           request.pingedTasks.push(node);
@@ -5273,7 +5602,29 @@ function renderNode(request, task, node, childIndex) {
   task.keyPath = previousKeyPath;
   task.treeContext = previousTreeContext;
   switchContext(previousContext);
-  throw node;
+  throw childIndex;
+}
+function erroredReplay(
+  request,
+  boundary,
+  error,
+  errorInfo,
+  replayNodes,
+  resumeSlots
+) {
+  "object" === typeof error &&
+  null !== error &&
+  error.$$typeof === REACT_POSTPONE_TYPE
+    ? (logPostpone(request, error.message, errorInfo), (errorInfo = "POSTPONE"))
+    : (errorInfo = logRecoverableError(request, error, errorInfo));
+  abortRemainingReplayNodes(
+    request,
+    boundary,
+    replayNodes,
+    resumeSlots,
+    error,
+    errorInfo
+  );
 }
 function abortTaskSoft(task) {
   var boundary = task.blockedBoundary;
@@ -5303,12 +5654,7 @@ function abortRemainingReplayNodes(
       node = node[5];
       var request = request$jscomp$0,
         errorDigest = errorDigest$jscomp$0,
-        resumedBoundary = createSuspenseBoundary(
-          request,
-          new Set(),
-          null,
-          null
-        );
+        resumedBoundary = createSuspenseBoundary(request, new Set());
       resumedBoundary.parentFlushed = !0;
       resumedBoundary.rootSegmentID = node;
       resumedBoundary.status = 4;
@@ -5338,44 +5684,100 @@ function abortTask(task, request, error) {
     if (6 === segment.status) return;
     segment.status = 3;
   }
-  segment = getThrownInfo(task.componentStack);
+  var errorInfo = getThrownInfo(task.componentStack);
   if (null === boundary) {
     if (13 !== request.status && 14 !== request.status) {
       boundary = task.replay;
       if (null === boundary) {
-        logRecoverableError(request, error, segment);
-        fatalError(request, error);
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? ((boundary = request.trackedPostpones),
+            null !== boundary && null !== segment
+              ? (logPostpone(request, error.message, errorInfo),
+                trackPostpone(request, boundary, task, segment),
+                finishedTask(request, null, segment))
+              : ((task = Error(
+                  "The render was aborted with postpone when the shell is incomplete. Reason: " +
+                    error.message
+                )),
+                logRecoverableError(request, task, errorInfo),
+                fatalError(request, task)))
+          : null !== request.trackedPostpones && null !== segment
+            ? ((boundary = request.trackedPostpones),
+              logRecoverableError(request, error, errorInfo),
+              trackPostpone(request, boundary, task, segment),
+              finishedTask(request, null, segment))
+            : (logRecoverableError(request, error, errorInfo),
+              fatalError(request, error));
         return;
       }
       boundary.pendingTasks--;
       0 === boundary.pendingTasks &&
         0 < boundary.nodes.length &&
-        ((task = logRecoverableError(request, error, segment)),
+        ("object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? (logPostpone(request, error.message, errorInfo),
+            (errorInfo = "POSTPONE"))
+          : (errorInfo = logRecoverableError(request, error, errorInfo)),
         abortRemainingReplayNodes(
           request,
           null,
           boundary.nodes,
           boundary.slots,
           error,
-          task
+          errorInfo
         ));
       request.pendingRootTasks--;
       0 === request.pendingRootTasks && completeShell(request);
     }
-  } else
-    boundary.pendingTasks--,
-      4 !== boundary.status &&
-        ((boundary.status = 4),
-        (task = logRecoverableError(request, error, segment)),
-        (boundary.status = 4),
-        (boundary.errorDigest = task),
-        untrackBoundary(request, boundary),
-        boundary.parentFlushed &&
-          request.clientRenderedBoundaries.push(boundary)),
-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-        return abortTask(fallbackTask, request, error);
-      }),
-      boundary.fallbackAbortableTasks.clear();
+  } else {
+    boundary.pendingTasks--;
+    var trackedPostpones$60 = request.trackedPostpones;
+    if (4 !== boundary.status) {
+      if (null !== trackedPostpones$60 && null !== segment)
+        return (
+          "object" === typeof error &&
+          null !== error &&
+          error.$$typeof === REACT_POSTPONE_TYPE
+            ? logPostpone(request, error.message, errorInfo)
+            : logRecoverableError(request, error, errorInfo),
+          trackPostpone(request, trackedPostpones$60, task, segment),
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          }),
+          boundary.fallbackAbortableTasks.clear(),
+          finishedTask(request, boundary, segment)
+        );
+      boundary.status = 4;
+      if (
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+      ) {
+        logPostpone(request, error.message, errorInfo);
+        if (null !== request.trackedPostpones && null !== segment) {
+          trackPostpone(request, request.trackedPostpones, task, segment);
+          finishedTask(request, task.blockedBoundary, segment);
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          });
+          boundary.fallbackAbortableTasks.clear();
+          return;
+        }
+        errorInfo = "POSTPONE";
+      } else errorInfo = logRecoverableError(request, error, errorInfo);
+      boundary.status = 4;
+      boundary.errorDigest = errorInfo;
+      untrackBoundary(request, boundary);
+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
+    }
+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+      return abortTask(fallbackTask, request, error);
+    });
+    boundary.fallbackAbortableTasks.clear();
+  }
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
@@ -5442,7 +5844,6 @@ function safelyEmitEarlyPreloads(request, shellComplete) {
 }
 function completeShell(request) {
   null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-  null === request.trackedPostpones && preparePreamble(request);
   request.onShellError = noop;
   request = request.onShellReady;
   request();
@@ -5455,7 +5856,6 @@ function completeAll(request) {
       : null === request.completedRootSegment ||
           5 !== request.completedRootSegment.status
   );
-  preparePreamble(request);
   request = request.onAllReady;
   request();
 }
@@ -5496,11 +5896,7 @@ function finishedTask(request, boundary, segment) {
               request.completedBoundaries.push(boundary),
             1 === boundary.status &&
               (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),
-              boundary.fallbackAbortableTasks.clear(),
-              0 === request.pendingRootTasks &&
-                null === request.trackedPostpones &&
-                null !== boundary.contentPreamble &&
-                preparePreamble(request)))
+              boundary.fallbackAbortableTasks.clear()))
           : null !== segment &&
             segment.parentFlushed &&
             1 === segment.status &&
@@ -5511,23 +5907,23 @@ function finishedTask(request, boundary, segment) {
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
-function performWork(request$jscomp$2) {
-  if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
+function performWork(request$jscomp$1) {
+  if (14 !== request$jscomp$1.status && 13 !== request$jscomp$1.status) {
     var prevContext = currentActiveSnapshot,
       prevDispatcher = ReactSharedInternals.H;
     ReactSharedInternals.H = HooksDispatcher;
     var prevAsyncDispatcher = ReactSharedInternals.A;
     ReactSharedInternals.A = DefaultAsyncDispatcher;
     var prevRequest = currentRequest;
-    currentRequest = request$jscomp$2;
+    currentRequest = request$jscomp$1;
     var prevResumableState = currentResumableState;
-    currentResumableState = request$jscomp$2.resumableState;
+    currentResumableState = request$jscomp$1.resumableState;
     try {
-      var pingedTasks = request$jscomp$2.pingedTasks,
+      var pingedTasks = request$jscomp$1.pingedTasks,
         i;
       for (i = 0; i < pingedTasks.length; i++) {
         var task = pingedTasks[i],
-          request = request$jscomp$2,
+          request = request$jscomp$1,
           segment = task.blockedSegment;
         if (null === segment) {
           var request$jscomp$0 = request;
@@ -5571,27 +5967,15 @@ function performWork(request$jscomp$2) {
                 task.replay.pendingTasks--;
                 task.abortSet.delete(task);
                 var errorInfo = getThrownInfo(task.componentStack);
-                request = void 0;
-                var request$jscomp$1 = request$jscomp$0,
-                  boundary = task.blockedBoundary,
-                  error$jscomp$0 =
-                    12 === request$jscomp$0.status
-                      ? request$jscomp$0.fatalError
-                      : x,
-                  replayNodes = task.replay.nodes,
-                  resumeSlots = task.replay.slots;
-                request = logRecoverableError(
-                  request$jscomp$1,
-                  error$jscomp$0,
-                  errorInfo
-                );
-                abortRemainingReplayNodes(
-                  request$jscomp$1,
-                  boundary,
-                  replayNodes,
-                  resumeSlots,
-                  error$jscomp$0,
-                  request
+                erroredReplay(
+                  request$jscomp$0,
+                  task.blockedBoundary,
+                  12 === request$jscomp$0.status
+                    ? request$jscomp$0.fatalError
+                    : x,
+                  errorInfo,
+                  task.replay.nodes,
+                  task.replay.slots
                 );
                 request$jscomp$0.pendingRootTasks--;
                 0 === request$jscomp$0.pendingRootTasks &&
@@ -5603,78 +5987,124 @@ function performWork(request$jscomp$2) {
             } finally {
             }
           }
-        } else if (
-          ((request$jscomp$0 = void 0),
-          (request$jscomp$1 = segment),
-          0 === request$jscomp$1.status)
-        ) {
-          request$jscomp$1.status = 6;
-          switchContext(task.context);
-          var childrenLength = request$jscomp$1.children.length,
-            chunkLength = request$jscomp$1.chunks.length;
-          try {
-            retryNode(request, task),
-              request$jscomp$1.lastPushedText &&
-                request$jscomp$1.textEmbedded &&
-                request$jscomp$1.chunks.push(textSeparator),
-              task.abortSet.delete(task),
-              (request$jscomp$1.status = 1),
-              finishedTask(request, task.blockedBoundary, request$jscomp$1);
-          } catch (thrownValue) {
-            resetHooksState();
-            request$jscomp$1.children.length = childrenLength;
-            request$jscomp$1.chunks.length = chunkLength;
-            var x$jscomp$0 =
-              thrownValue === SuspenseException
-                ? getSuspendedThenable()
-                : 12 === request.status
-                  ? request.fatalError
-                  : thrownValue;
-            if (
-              "object" === typeof x$jscomp$0 &&
-              null !== x$jscomp$0 &&
-              "function" === typeof x$jscomp$0.then
-            ) {
-              request$jscomp$1.status = 0;
-              task.thenableState = getThenableStateAfterSuspending();
-              var ping$jscomp$0 = task.ping;
-              x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-            } else {
-              var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
-              task.abortSet.delete(task);
-              request$jscomp$1.status = 4;
-              var boundary$jscomp$0 = task.blockedBoundary;
-              request$jscomp$0 = logRecoverableError(
-                request,
-                x$jscomp$0,
-                errorInfo$jscomp$0
-              );
-              null === boundary$jscomp$0
-                ? fatalError(request, x$jscomp$0)
-                : (boundary$jscomp$0.pendingTasks--,
-                  4 !== boundary$jscomp$0.status &&
-                    ((boundary$jscomp$0.status = 4),
-                    (boundary$jscomp$0.errorDigest = request$jscomp$0),
-                    untrackBoundary(request, boundary$jscomp$0),
-                    boundary$jscomp$0.parentFlushed &&
-                      request.clientRenderedBoundaries.push(boundary$jscomp$0),
-                    0 === request.pendingRootTasks &&
-                      null === request.trackedPostpones &&
-                      null !== boundary$jscomp$0.contentPreamble &&
-                      preparePreamble(request)));
-              request.allPendingTasks--;
-              0 === request.allPendingTasks && completeAll(request);
+        } else
+          a: {
+            request$jscomp$0 = void 0;
+            var segment$jscomp$0 = segment;
+            if (0 === segment$jscomp$0.status) {
+              segment$jscomp$0.status = 6;
+              switchContext(task.context);
+              var childrenLength = segment$jscomp$0.children.length,
+                chunkLength = segment$jscomp$0.chunks.length;
+              try {
+                retryNode(request, task),
+                  segment$jscomp$0.lastPushedText &&
+                    segment$jscomp$0.textEmbedded &&
+                    segment$jscomp$0.chunks.push(textSeparator),
+                  task.abortSet.delete(task),
+                  (segment$jscomp$0.status = 1),
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+              } catch (thrownValue) {
+                resetHooksState();
+                segment$jscomp$0.children.length = childrenLength;
+                segment$jscomp$0.chunks.length = chunkLength;
+                var x$jscomp$0 =
+                  thrownValue === SuspenseException
+                    ? getSuspendedThenable()
+                    : 12 === request.status
+                      ? request.fatalError
+                      : thrownValue;
+                if (
+                  12 === request.status &&
+                  null !== request.trackedPostpones
+                ) {
+                  var trackedPostpones = request.trackedPostpones,
+                    thrownInfo = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? logPostpone(request, x$jscomp$0.message, thrownInfo)
+                    : logRecoverableError(request, x$jscomp$0, thrownInfo);
+                  trackPostpone(
+                    request,
+                    trackedPostpones,
+                    task,
+                    segment$jscomp$0
+                  );
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+                } else {
+                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0) {
+                    if ("function" === typeof x$jscomp$0.then) {
+                      segment$jscomp$0.status = 0;
+                      task.thenableState = getThenableStateAfterSuspending();
+                      var ping$jscomp$0 = task.ping;
+                      x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                      break a;
+                    }
+                    if (
+                      null !== request.trackedPostpones &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ) {
+                      var trackedPostpones$64 = request.trackedPostpones;
+                      task.abortSet.delete(task);
+                      var postponeInfo = getThrownInfo(task.componentStack);
+                      logPostpone(request, x$jscomp$0.message, postponeInfo);
+                      trackPostpone(
+                        request,
+                        trackedPostpones$64,
+                        task,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                      break a;
+                    }
+                  }
+                  var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  segment$jscomp$0.status = 4;
+                  var boundary = task.blockedBoundary;
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        x$jscomp$0.message,
+                        errorInfo$jscomp$0
+                      ),
+                      (request$jscomp$0 = "POSTPONE"))
+                    : (request$jscomp$0 = logRecoverableError(
+                        request,
+                        x$jscomp$0,
+                        errorInfo$jscomp$0
+                      ));
+                  null === boundary
+                    ? fatalError(request, x$jscomp$0)
+                    : (boundary.pendingTasks--,
+                      4 !== boundary.status &&
+                        ((boundary.status = 4),
+                        (boundary.errorDigest = request$jscomp$0),
+                        untrackBoundary(request, boundary),
+                        boundary.parentFlushed &&
+                          request.clientRenderedBoundaries.push(boundary)));
+                  request.allPendingTasks--;
+                  0 === request.allPendingTasks && completeAll(request);
+                }
+              } finally {
+              }
             }
-          } finally {
           }
-        }
       }
       pingedTasks.splice(0, i);
-      null !== request$jscomp$2.destination &&
-        flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
+      null !== request$jscomp$1.destination &&
+        flushCompletedQueues(request$jscomp$1, request$jscomp$1.destination);
     } catch (error) {
-      logRecoverableError(request$jscomp$2, error, {}),
-        fatalError(request$jscomp$2, error);
+      logRecoverableError(request$jscomp$1, error, {}),
+        fatalError(request$jscomp$1, error);
     } finally {
       (currentResumableState = prevResumableState),
         (ReactSharedInternals.H = prevDispatcher),
@@ -5684,85 +6114,6 @@ function performWork(request$jscomp$2) {
     }
   }
 }
-function preparePreambleFromSubtree(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  segment.preambleChildren.length &&
-    collectedPreambleSegments.push(segment.preambleChildren);
-  for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-    pendingPreambles =
-      preparePreambleFromSegment(
-        request,
-        segment.children[i],
-        collectedPreambleSegments
-      ) || pendingPreambles;
-  return pendingPreambles;
-}
-function preparePreambleFromSegment(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  var boundary = segment.boundary;
-  if (null === boundary)
-    return preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    );
-  var preamble = boundary.contentPreamble,
-    fallbackPreamble = boundary.fallbackPreamble;
-  if (null === preamble || null === fallbackPreamble) return !1;
-  switch (boundary.status) {
-    case 1:
-      hoistPreambleState(request.renderState, preamble);
-      segment = boundary.completedSegments[0];
-      if (!segment)
-        throw Error(
-          "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
-        );
-      return preparePreambleFromSubtree(
-        request,
-        segment,
-        collectedPreambleSegments
-      );
-    case 5:
-      if (null !== request.trackedPostpones) return !0;
-    case 4:
-      if (1 === segment.status)
-        return (
-          hoistPreambleState(request.renderState, fallbackPreamble),
-          preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          )
-        );
-    default:
-      return !0;
-  }
-}
-function preparePreamble(request) {
-  if (
-    request.completedRootSegment &&
-    null === request.completedPreambleSegments
-  ) {
-    var collectedPreambleSegments = [],
-      hasPendingPreambles = preparePreambleFromSegment(
-        request,
-        request.completedRootSegment,
-        collectedPreambleSegments
-      ),
-      preamble = request.renderState.preamble;
-    if (
-      !1 === hasPendingPreambles ||
-      (preamble.headChunks && preamble.bodyChunks)
-    )
-      request.completedPreambleSegments = collectedPreambleSegments;
-  }
-}
 function flushSubtree(request, destination, segment, hoistableState) {
   segment.parentFlushed = !0;
   switch (segment.status) {
@@ -5895,31 +6246,46 @@ function flushCompletedBoundary(request, destination, boundary) {
   boundary = boundary.contentState;
   var requiresStyleInsertion = request.stylesToHoist;
   request.stylesToHoist = !1;
-  writeChunk(destination, request.startInlineScript);
-  requiresStyleInsertion
-    ? 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 10),
-        writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))
-      : 0 === (completedSegments.instructions & 8)
-        ? ((completedSegments.instructions |= 8),
-          writeChunk(destination, completeBoundaryWithStylesScript1FullPartial))
-        : writeChunk(destination, completeBoundaryWithStylesScript1Partial)
-    : 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 2),
-        writeChunk(destination, completeBoundaryScript1Full))
-      : writeChunk(destination, completeBoundaryScript1Partial);
+  var scriptFormat = 0 === completedSegments.streamingFormat;
+  scriptFormat
+    ? (writeChunk(destination, request.startInlineScript),
+      requiresStyleInsertion
+        ? 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 10),
+            writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))
+          : 0 === (completedSegments.instructions & 8)
+            ? ((completedSegments.instructions |= 8),
+              writeChunk(
+                destination,
+                completeBoundaryWithStylesScript1FullPartial
+              ))
+            : writeChunk(destination, completeBoundaryWithStylesScript1Partial)
+        : 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 2),
+            writeChunk(destination, completeBoundaryScript1Full))
+          : writeChunk(destination, completeBoundaryScript1Partial))
+    : requiresStyleInsertion
+      ? writeChunk(destination, completeBoundaryWithStylesData1)
+      : writeChunk(destination, completeBoundaryData1);
   completedSegments = stringToChunk(i.toString(16));
   writeChunk(destination, request.boundaryPrefix);
   writeChunk(destination, completedSegments);
-  writeChunk(destination, completeBoundaryScript2);
+  scriptFormat
+    ? writeChunk(destination, completeBoundaryScript2)
+    : writeChunk(destination, completeBoundaryData2);
   writeChunk(destination, request.segmentPrefix);
   writeChunk(destination, completedSegments);
   requiresStyleInsertion
-    ? (writeChunk(destination, completeBoundaryScript3a),
-      writeStyleResourceDependenciesInJS(destination, boundary))
-    : writeChunk(destination, completeBoundaryScript3b);
-  boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
-  return writeBootstrap(destination, request) && boundary;
+    ? scriptFormat
+      ? (writeChunk(destination, completeBoundaryScript3a),
+        writeStyleResourceDependenciesInJS(destination, boundary))
+      : (writeChunk(destination, completeBoundaryData3a),
+        writeStyleResourceDependenciesInAttr(destination, boundary))
+    : scriptFormat && writeChunk(destination, completeBoundaryScript3b);
+  completedSegments = scriptFormat
+    ? writeChunkAndReturn(destination, completeBoundaryScriptEnd)
+    : writeChunkAndReturn(destination, dataElementQuotedEnd);
+  return writeBootstrap(destination, request) && completedSegments;
 }
 function flushPartiallyCompletedSegment(
   request,
@@ -5942,18 +6308,24 @@ function flushPartiallyCompletedSegment(
   flushSegmentContainer(request, destination, segment, hoistableState);
   boundary = request.resumableState;
   request = request.renderState;
-  writeChunk(destination, request.startInlineScript);
-  0 === (boundary.instructions & 1)
-    ? ((boundary.instructions |= 1),
-      writeChunk(destination, completeSegmentScript1Full))
-    : writeChunk(destination, completeSegmentScript1Partial);
+  (segment = 0 === boundary.streamingFormat)
+    ? (writeChunk(destination, request.startInlineScript),
+      0 === (boundary.instructions & 1)
+        ? ((boundary.instructions |= 1),
+          writeChunk(destination, completeSegmentScript1Full))
+        : writeChunk(destination, completeSegmentScript1Partial))
+    : writeChunk(destination, completeSegmentData1);
   writeChunk(destination, request.segmentPrefix);
   segmentID = stringToChunk(segmentID.toString(16));
   writeChunk(destination, segmentID);
-  writeChunk(destination, completeSegmentScript2);
+  segment
+    ? writeChunk(destination, completeSegmentScript2)
+    : writeChunk(destination, completeSegmentData2);
   writeChunk(destination, request.placeholderPrefix);
   writeChunk(destination, segmentID);
-  destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
+  destination = segment
+    ? writeChunkAndReturn(destination, completeSegmentScriptEnd)
+    : writeChunkAndReturn(destination, dataElementQuotedEnd);
   return destination;
 }
 function flushCompletedQueues(request, destination) {
@@ -5965,12 +6337,22 @@ function flushCompletedQueues(request, destination) {
         completedRootSegment = request.completedRootSegment;
       if (null !== completedRootSegment) {
         if (5 === completedRootSegment.status) return;
-        var completedPreambleSegments = request.completedPreambleSegments;
-        if (null === completedPreambleSegments) return;
-        var renderState = request.renderState,
-          preamble = renderState.preamble,
-          htmlChunks = preamble.htmlChunks,
-          headChunks = preamble.headChunks,
+        var renderState = request.renderState;
+        if (
+          (0 !== request.allPendingTasks ||
+            null !== request.trackedPostpones) &&
+          renderState.externalRuntimeScript
+        ) {
+          var _renderState$external = renderState.externalRuntimeScript,
+            resumableState = request.resumableState,
+            src = _renderState$external.src,
+            chunks = _renderState$external.chunks;
+          resumableState.scriptResources.hasOwnProperty(src) ||
+            ((resumableState.scriptResources[src] = null),
+            renderState.scripts.add(chunks));
+        }
+        var htmlChunks = renderState.htmlChunks,
+          headChunks = renderState.headChunks,
           i$jscomp$0;
         if (htmlChunks) {
           for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -6011,27 +6393,10 @@ function flushCompletedQueues(request, destination) {
         var hoistableChunks = renderState.hoistableChunks;
         for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
           writeChunk(destination, hoistableChunks[i$jscomp$0]);
-        for (
-          renderState = hoistableChunks.length = 0;
-          renderState < completedPreambleSegments.length;
-          renderState++
-        ) {
-          var segments = completedPreambleSegments[renderState];
-          for (preamble = 0; preamble < segments.length; preamble++)
-            flushSegment(request, destination, segments[preamble], null);
-        }
-        var preamble$jscomp$0 = request.renderState.preamble,
-          headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-        (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) &&
+        hoistableChunks.length = 0;
+        htmlChunks &&
+          null === headChunks &&
           writeChunk(destination, endChunkForTag("head"));
-        var bodyChunks = preamble$jscomp$0.bodyChunks;
-        if (bodyChunks)
-          for (
-            completedPreambleSegments = 0;
-            completedPreambleSegments < bodyChunks.length;
-            completedPreambleSegments++
-          )
-            writeChunk(destination, bodyChunks[completedPreambleSegments]);
         flushSegment(request, destination, completedRootSegment, null);
         request.completedRootSegment = null;
         writeBootstrap(destination, request.renderState);
@@ -6072,36 +6437,44 @@ function flushCompletedQueues(request, destination) {
       for (i = 0; i < clientRenderedBoundaries.length; i++) {
         var boundary = clientRenderedBoundaries[i];
         renderState$jscomp$0 = destination;
-        var resumableState = request.resumableState,
+        var resumableState$jscomp$0 = request.resumableState,
           renderState$jscomp$1 = request.renderState,
           id = boundary.rootSegmentID,
-          errorDigest = boundary.errorDigest;
-        writeChunk(
-          renderState$jscomp$0,
-          renderState$jscomp$1.startInlineScript
-        );
-        0 === (resumableState.instructions & 4)
-          ? ((resumableState.instructions |= 4),
-            writeChunk(renderState$jscomp$0, clientRenderScript1Full))
-          : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
+          errorDigest = boundary.errorDigest,
+          scriptFormat = 0 === resumableState$jscomp$0.streamingFormat;
+        scriptFormat
+          ? (writeChunk(
+              renderState$jscomp$0,
+              renderState$jscomp$1.startInlineScript
+            ),
+            0 === (resumableState$jscomp$0.instructions & 4)
+              ? ((resumableState$jscomp$0.instructions |= 4),
+                writeChunk(renderState$jscomp$0, clientRenderScript1Full))
+              : writeChunk(renderState$jscomp$0, clientRenderScript1Partial))
+          : writeChunk(renderState$jscomp$0, clientRenderData1);
         writeChunk(renderState$jscomp$0, renderState$jscomp$1.boundaryPrefix);
         writeChunk(renderState$jscomp$0, stringToChunk(id.toString(16)));
-        writeChunk(renderState$jscomp$0, clientRenderScript1A);
+        scriptFormat && writeChunk(renderState$jscomp$0, clientRenderScript1A);
         errorDigest &&
-          (writeChunk(
-            renderState$jscomp$0,
-            clientRenderErrorScriptArgInterstitial
-          ),
-          writeChunk(
-            renderState$jscomp$0,
-            stringToChunk(
-              escapeJSStringsForInstructionScripts(errorDigest || "")
-            )
-          ));
-        var JSCompiler_inline_result = writeChunkAndReturn(
-          renderState$jscomp$0,
-          clientRenderScriptEnd
-        );
+          (scriptFormat
+            ? (writeChunk(
+                renderState$jscomp$0,
+                clientRenderErrorScriptArgInterstitial
+              ),
+              writeChunk(
+                renderState$jscomp$0,
+                stringToChunk(
+                  escapeJSStringsForInstructionScripts(errorDigest || "")
+                )
+              ))
+            : (writeChunk(renderState$jscomp$0, clientRenderData2),
+              writeChunk(
+                renderState$jscomp$0,
+                stringToChunk(escapeTextForBrowser(errorDigest || ""))
+              )));
+        var JSCompiler_inline_result = scriptFormat
+          ? writeChunkAndReturn(renderState$jscomp$0, clientRenderScriptEnd)
+          : writeChunkAndReturn(renderState$jscomp$0, dataElementQuotedEnd);
         if (!JSCompiler_inline_result) {
           request.destination = null;
           i++;
@@ -6126,11 +6499,11 @@ function flushCompletedQueues(request, destination) {
       writtenBytes = 0;
       var partialBoundaries = request.partialBoundaries;
       for (i = 0; i < partialBoundaries.length; i++) {
-        var boundary$51 = partialBoundaries[i];
+        var boundary$67 = partialBoundaries[i];
         a: {
           clientRenderedBoundaries = request;
           boundary = destination;
-          var completedSegments = boundary$51.completedSegments;
+          var completedSegments = boundary$67.completedSegments;
           for (
             JSCompiler_inline_result = 0;
             JSCompiler_inline_result < completedSegments.length;
@@ -6140,7 +6513,7 @@ function flushCompletedQueues(request, destination) {
               !flushPartiallyCompletedSegment(
                 clientRenderedBoundaries,
                 boundary,
-                boundary$51,
+                boundary$67,
                 completedSegments[JSCompiler_inline_result]
               )
             ) {
@@ -6152,7 +6525,7 @@ function flushCompletedQueues(request, destination) {
           completedSegments.splice(0, JSCompiler_inline_result);
           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
             boundary,
-            boundary$51.contentState,
+            boundary$67.contentState,
             clientRenderedBoundaries.renderState
           );
         }
@@ -6180,9 +6553,10 @@ function flushCompletedQueues(request, destination) {
     0 === request.clientRenderedBoundaries.length &&
     0 === request.completedBoundaries.length
       ? ((request.flushScheduled = !1),
-        (i = request.resumableState),
-        i.hasBody && writeChunk(destination, endChunkForTag("body")),
-        i.hasHtml && writeChunk(destination, endChunkForTag("html")),
+        null === request.trackedPostpones &&
+          ((i = request.resumableState),
+          i.hasBody && writeChunk(destination, endChunkForTag("body")),
+          i.hasHtml && writeChunk(destination, endChunkForTag("html"))),
         completeWriting(destination),
         (request.status = 14),
         destination.close(),
@@ -6259,17 +6633,68 @@ function abort(request, reason) {
     }
     null !== request.destination &&
       flushCompletedQueues(request, request.destination);
-  } catch (error$53) {
-    logRecoverableError(request, error$53, {}), fatalError(request, error$53);
+  } catch (error$69) {
+    logRecoverableError(request, error$69, {}), fatalError(request, error$69);
+  }
+}
+function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+  if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+  else {
+    var workingMap = trackedPostpones.workingMap,
+      parentNode = workingMap.get(parentKeyPath);
+    void 0 === parentNode &&
+      ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+      workingMap.set(parentKeyPath, parentNode),
+      addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+    parentNode[2].push(node);
   }
 }
+function getPostponedState(request) {
+  var trackedPostpones = request.trackedPostpones;
+  if (
+    null === trackedPostpones ||
+    (0 === trackedPostpones.rootNodes.length &&
+      null === trackedPostpones.rootSlots)
+  )
+    return (request.trackedPostpones = null);
+  if (
+    null !== request.completedRootSegment &&
+    5 === request.completedRootSegment.status
+  ) {
+    var resumableState = request.resumableState,
+      renderState = request.renderState;
+    resumableState.nextFormID = 0;
+    resumableState.hasBody = !1;
+    resumableState.hasHtml = !1;
+    resumableState.unknownResources = { font: renderState.resets.font };
+    resumableState.dnsResources = renderState.resets.dns;
+    resumableState.connectResources = renderState.resets.connect;
+    resumableState.imageResources = renderState.resets.image;
+    resumableState.styleResources = renderState.resets.style;
+    resumableState.scriptResources = {};
+    resumableState.moduleUnknownResources = {};
+    resumableState.moduleScriptResources = {};
+  } else
+    (resumableState = request.resumableState),
+      (resumableState.bootstrapScriptContent = void 0),
+      (resumableState.bootstrapScripts = void 0),
+      (resumableState.bootstrapModules = void 0);
+  return {
+    nextSegmentId: request.nextSegmentId,
+    rootFormatContext: request.rootFormatContext,
+    progressiveChunkSize: request.progressiveChunkSize,
+    resumableState: request.resumableState,
+    replayNodes: trackedPostpones.rootNodes,
+    replaySlots: trackedPostpones.rootSlots
+  };
+}
 function ensureCorrectIsomorphicReactVersion() {
   var isomorphicReactPackageVersion = React.version;
-  if ("19.1.0-canary-c492f975-20250128" !== isomorphicReactPackageVersion)
+  if ("19.1.0-experimental-b3a95caf-20250113" !== isomorphicReactPackageVersion)
     throw Error(
       'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
         (isomorphicReactPackageVersion +
-          "\n  - react-dom:  19.1.0-canary-c492f975-20250128\nLearn more: https://react.dev/warnings/version-mismatch")
+          "\n  - react-dom:  19.1.0-experimental-b3a95caf-20250113\nLearn more: https://react.dev/warnings/version-mismatch")
     );
 }
 ensureCorrectIsomorphicReactVersion();
@@ -6304,22 +6729,21 @@ exports.prerender = function (children, options) {
         options ? options.progressiveChunkSize : void 0,
         options ? options.onError : void 0,
         function () {
-          var result = {
-            prelude: new ReadableStream(
-              {
-                type: "bytes",
-                pull: function (controller) {
-                  startFlowing(request, controller);
-                },
-                cancel: function (reason) {
-                  request.destination = null;
-                  abort(request, reason);
-                }
+          var stream = new ReadableStream(
+            {
+              type: "bytes",
+              pull: function (controller) {
+                startFlowing(request, controller);
               },
-              { highWaterMark: 0 }
-            )
-          };
-          resolve(result);
+              cancel: function (reason) {
+                request.destination = null;
+                abort(request, reason);
+              }
+            },
+            { highWaterMark: 0 }
+          );
+          stream = { postponed: getPostponedState(request), prelude: stream };
+          resolve(stream);
         },
         void 0,
         void 0,
@@ -6415,4 +6839,113 @@ exports.renderToReadableStream = function (children, options) {
     startWork(request);
   });
 };
-exports.version = "19.1.0-canary-c492f975-20250128";
+exports.resume = function (children, postponedState, options) {
+  return new Promise(function (resolve, reject) {
+    var onFatalError,
+      onAllReady,
+      allReady = new Promise(function (res, rej) {
+        onAllReady = res;
+        onFatalError = rej;
+      }),
+      request = resumeRequest(
+        children,
+        postponedState,
+        createRenderState(
+          postponedState.resumableState,
+          options ? options.nonce : void 0,
+          void 0,
+          void 0,
+          void 0,
+          void 0
+        ),
+        options ? options.onError : void 0,
+        onAllReady,
+        function () {
+          var stream = new ReadableStream(
+            {
+              type: "bytes",
+              pull: function (controller) {
+                startFlowing(request, controller);
+              },
+              cancel: function (reason) {
+                request.destination = null;
+                abort(request, reason);
+              }
+            },
+            { highWaterMark: 0 }
+          );
+          stream.allReady = allReady;
+          resolve(stream);
+        },
+        function (error) {
+          allReady.catch(function () {});
+          reject(error);
+        },
+        onFatalError,
+        options ? options.onPostpone : void 0
+      );
+    if (options && options.signal) {
+      var signal = options.signal;
+      if (signal.aborted) abort(request, signal.reason);
+      else {
+        var listener = function () {
+          abort(request, signal.reason);
+          signal.removeEventListener("abort", listener);
+        };
+        signal.addEventListener("abort", listener);
+      }
+    }
+    startWork(request);
+  });
+};
+exports.resumeAndPrerender = function (children, postponedState, options) {
+  return new Promise(function (resolve, reject) {
+    var request = resumeAndPrerenderRequest(
+      children,
+      postponedState,
+      createRenderState(
+        postponedState.resumableState,
+        options ? options.nonce : void 0,
+        void 0,
+        void 0,
+        void 0,
+        void 0
+      ),
+      options ? options.onError : void 0,
+      function () {
+        var stream = new ReadableStream(
+          {
+            type: "bytes",
+            pull: function (controller) {
+              startFlowing(request, controller);
+            },
+            cancel: function (reason) {
+              request.destination = null;
+              abort(request, reason);
+            }
+          },
+          { highWaterMark: 0 }
+        );
+        stream = { postponed: getPostponedState(request), prelude: stream };
+        resolve(stream);
+      },
+      void 0,
+      void 0,
+      reject,
+      options ? options.onPostpone : void 0
+    );
+    if (options && options.signal) {
+      var signal = options.signal;
+      if (signal.aborted) abort(request, signal.reason);
+      else {
+        var listener = function () {
+          abort(request, signal.reason);
+          signal.removeEventListener("abort", listener);
+        };
+        signal.addEventListener("abort", listener);
+      }
+    }
+    startWork(request);
+  });
+};
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
diff --git a/node_modules/react-dom/cjs/react-dom-server.node.development.js b/node_modules/react-dom/cjs/react-dom-server.node.development.js
index e703dee..551547d 100644
--- a/node_modules/react-dom/cjs/react-dom-server.node.development.js
+++ b/node_modules/react-dom/cjs/react-dom-server.node.development.js
@@ -57,6 +57,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (type.$$typeof) {
@@ -752,24 +754,47 @@
             : stringToPrecomputedChunk(
                 '<script nonce="' + escapeTextForBrowser(nonce) + '">'
               ),
-        idPrefix = resumableState.idPrefix;
-      externalRuntimeConfig = [];
-      var bootstrapScriptContent = resumableState.bootstrapScriptContent,
+        idPrefix = resumableState.idPrefix,
+        bootstrapChunks = [],
+        externalRuntimeScript = null,
+        bootstrapScriptContent = resumableState.bootstrapScriptContent,
         bootstrapScripts = resumableState.bootstrapScripts,
         bootstrapModules = resumableState.bootstrapModules;
       void 0 !== bootstrapScriptContent &&
-        externalRuntimeConfig.push(
+        bootstrapChunks.push(
           inlineScriptWithNonce,
           escapeEntireInlineScriptContent(bootstrapScriptContent),
           endInlineScript
         );
-      bootstrapScriptContent = [];
+      void 0 !== externalRuntimeConfig &&
+        ("string" === typeof externalRuntimeConfig
+          ? ((externalRuntimeScript = {
+              src: externalRuntimeConfig,
+              chunks: []
+            }),
+            pushScriptImpl(externalRuntimeScript.chunks, {
+              src: externalRuntimeConfig,
+              async: !0,
+              integrity: void 0,
+              nonce: nonce
+            }))
+          : ((externalRuntimeScript = {
+              src: externalRuntimeConfig.src,
+              chunks: []
+            }),
+            pushScriptImpl(externalRuntimeScript.chunks, {
+              src: externalRuntimeConfig.src,
+              async: !0,
+              integrity: externalRuntimeConfig.integrity,
+              nonce: nonce
+            })));
+      externalRuntimeConfig = [];
       void 0 !== importMap &&
-        (bootstrapScriptContent.push(importMapScriptStart),
-        bootstrapScriptContent.push(
+        (externalRuntimeConfig.push(importMapScriptStart),
+        externalRuntimeConfig.push(
           escapeEntireInlineScriptContent(JSON.stringify(importMap))
         ),
-        bootstrapScriptContent.push(importMapScriptEnd));
+        externalRuntimeConfig.push(importMapScriptEnd));
       onHeaders &&
         "number" === typeof maxHeadersLength &&
         0 >= maxHeadersLength &&
@@ -792,10 +817,11 @@
         segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
         boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
         startInlineScript: inlineScriptWithNonce,
-        preamble: createPreambleState(),
-        externalRuntimeScript: null,
-        bootstrapChunks: externalRuntimeConfig,
-        importMapChunks: bootstrapScriptContent,
+        htmlChunks: null,
+        headChunks: null,
+        externalRuntimeScript: externalRuntimeScript,
+        bootstrapChunks: bootstrapChunks,
+        importMapChunks: externalRuntimeConfig,
         onHeaders: onHeaders,
         headers: importMap,
         resets: {
@@ -826,109 +852,106 @@
         stylesToHoist: !1
       };
       if (void 0 !== bootstrapScripts)
-        for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
-          maxHeadersLength = bootstrapScripts[importMap];
-          bootstrapScriptContent = idPrefix = void 0;
-          var props = {
-            rel: "preload",
-            as: "script",
-            fetchPriority: "low",
-            nonce: nonce
-          };
-          "string" === typeof maxHeadersLength
-            ? (props.href = inlineScriptWithNonce = maxHeadersLength)
-            : ((props.href = inlineScriptWithNonce = maxHeadersLength.src),
-              (props.integrity = bootstrapScriptContent =
-                "string" === typeof maxHeadersLength.integrity
-                  ? maxHeadersLength.integrity
-                  : void 0),
-              (props.crossOrigin = idPrefix =
-                "string" === typeof maxHeadersLength ||
-                null == maxHeadersLength.crossOrigin
-                  ? void 0
-                  : "use-credentials" === maxHeadersLength.crossOrigin
-                    ? "use-credentials"
-                    : ""));
-          preloadBootstrapScriptOrModule(
-            resumableState,
-            onHeaders,
-            inlineScriptWithNonce,
-            props
-          );
-          externalRuntimeConfig.push(
-            startScriptSrc,
-            escapeTextForBrowser(inlineScriptWithNonce)
-          );
-          nonce &&
-            externalRuntimeConfig.push(
-              scriptNonce,
-              escapeTextForBrowser(nonce)
-            );
-          "string" === typeof bootstrapScriptContent &&
-            externalRuntimeConfig.push(
-              scriptIntegirty,
-              escapeTextForBrowser(bootstrapScriptContent)
-            );
-          "string" === typeof idPrefix &&
-            externalRuntimeConfig.push(
-              scriptCrossOrigin,
-              escapeTextForBrowser(idPrefix)
-            );
-          externalRuntimeConfig.push(endAsyncScript);
-        }
+        for (
+          inlineScriptWithNonce = 0;
+          inlineScriptWithNonce < bootstrapScripts.length;
+          inlineScriptWithNonce++
+        )
+          (idPrefix = bootstrapScripts[inlineScriptWithNonce]),
+            (maxHeadersLength = importMap = void 0),
+            (externalRuntimeConfig = {
+              rel: "preload",
+              as: "script",
+              fetchPriority: "low",
+              nonce: nonce
+            }),
+            "string" === typeof idPrefix
+              ? (externalRuntimeConfig.href = externalRuntimeScript = idPrefix)
+              : ((externalRuntimeConfig.href = externalRuntimeScript =
+                  idPrefix.src),
+                (externalRuntimeConfig.integrity = maxHeadersLength =
+                  "string" === typeof idPrefix.integrity
+                    ? idPrefix.integrity
+                    : void 0),
+                (externalRuntimeConfig.crossOrigin = importMap =
+                  "string" === typeof idPrefix || null == idPrefix.crossOrigin
+                    ? void 0
+                    : "use-credentials" === idPrefix.crossOrigin
+                      ? "use-credentials"
+                      : "")),
+            preloadBootstrapScriptOrModule(
+              resumableState,
+              onHeaders,
+              externalRuntimeScript,
+              externalRuntimeConfig
+            ),
+            bootstrapChunks.push(
+              startScriptSrc,
+              escapeTextForBrowser(externalRuntimeScript)
+            ),
+            nonce &&
+              bootstrapChunks.push(scriptNonce, escapeTextForBrowser(nonce)),
+            "string" === typeof maxHeadersLength &&
+              bootstrapChunks.push(
+                scriptIntegirty,
+                escapeTextForBrowser(maxHeadersLength)
+              ),
+            "string" === typeof importMap &&
+              bootstrapChunks.push(
+                scriptCrossOrigin,
+                escapeTextForBrowser(importMap)
+              ),
+            bootstrapChunks.push(endAsyncScript);
       if (void 0 !== bootstrapModules)
         for (
           bootstrapScripts = 0;
           bootstrapScripts < bootstrapModules.length;
           bootstrapScripts++
         )
-          (importMap = bootstrapModules[bootstrapScripts]),
-            (idPrefix = inlineScriptWithNonce = void 0),
-            (bootstrapScriptContent = {
+          (inlineScriptWithNonce = bootstrapModules[bootstrapScripts]),
+            (importMap = externalRuntimeScript = void 0),
+            (maxHeadersLength = {
               rel: "modulepreload",
               fetchPriority: "low",
               nonce: nonce
             }),
-            "string" === typeof importMap
-              ? (bootstrapScriptContent.href = maxHeadersLength = importMap)
-              : ((bootstrapScriptContent.href = maxHeadersLength =
-                  importMap.src),
-                (bootstrapScriptContent.integrity = idPrefix =
-                  "string" === typeof importMap.integrity
-                    ? importMap.integrity
+            "string" === typeof inlineScriptWithNonce
+              ? (maxHeadersLength.href = idPrefix = inlineScriptWithNonce)
+              : ((maxHeadersLength.href = idPrefix = inlineScriptWithNonce.src),
+                (maxHeadersLength.integrity = importMap =
+                  "string" === typeof inlineScriptWithNonce.integrity
+                    ? inlineScriptWithNonce.integrity
                     : void 0),
-                (bootstrapScriptContent.crossOrigin = inlineScriptWithNonce =
-                  "string" === typeof importMap || null == importMap.crossOrigin
+                (maxHeadersLength.crossOrigin = externalRuntimeScript =
+                  "string" === typeof inlineScriptWithNonce ||
+                  null == inlineScriptWithNonce.crossOrigin
                     ? void 0
-                    : "use-credentials" === importMap.crossOrigin
+                    : "use-credentials" === inlineScriptWithNonce.crossOrigin
                       ? "use-credentials"
                       : "")),
             preloadBootstrapScriptOrModule(
               resumableState,
               onHeaders,
-              maxHeadersLength,
-              bootstrapScriptContent
+              idPrefix,
+              maxHeadersLength
             ),
-            externalRuntimeConfig.push(
+            bootstrapChunks.push(
               startModuleSrc,
-              escapeTextForBrowser(maxHeadersLength)
+              escapeTextForBrowser(idPrefix)
             ),
             nonce &&
-              externalRuntimeConfig.push(
-                scriptNonce,
-                escapeTextForBrowser(nonce)
-              ),
-            "string" === typeof idPrefix &&
-              externalRuntimeConfig.push(
+              bootstrapChunks.push(scriptNonce, escapeTextForBrowser(nonce)),
+            "string" === typeof importMap &&
+              bootstrapChunks.push(
                 scriptIntegirty,
-                escapeTextForBrowser(idPrefix)
+                escapeTextForBrowser(importMap)
               ),
-            "string" === typeof inlineScriptWithNonce &&
-              externalRuntimeConfig.push(
+            "string" === typeof externalRuntimeScript &&
+              bootstrapChunks.push(
                 scriptCrossOrigin,
-                escapeTextForBrowser(inlineScriptWithNonce)
+                escapeTextForBrowser(externalRuntimeScript)
               ),
-            externalRuntimeConfig.push(endAsyncScript);
+            bootstrapChunks.push(endAsyncScript);
       return onHeaders;
     }
     function createResumableState(
@@ -938,10 +961,12 @@
       bootstrapScripts,
       bootstrapModules
     ) {
+      var streamingFormat = ScriptStreamingFormat;
+      void 0 !== externalRuntimeConfig && (streamingFormat = 1);
       return {
         idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
         nextFormID: 0,
-        streamingFormat: 0,
+        streamingFormat: streamingFormat,
         bootstrapScriptContent: bootstrapScriptContent,
         bootstrapScripts: bootstrapScripts,
         bootstrapModules: bootstrapModules,
@@ -958,9 +983,6 @@
         moduleScriptResources: {}
       };
     }
-    function createPreambleState() {
-      return { htmlChunks: null, headChunks: null, bodyChunks: null };
-    }
     function createFormatContext(insertionMode, selectedValue, tagScope) {
       return {
         insertionMode: insertionMode,
@@ -1031,26 +1053,16 @@
             null,
             parentContext.tagScope
           );
-        case "head":
-          if (parentContext.insertionMode < HTML_MODE)
-            return createFormatContext(
-              HTML_HEAD_MODE,
-              null,
-              parentContext.tagScope
-            );
-          break;
-        case "html":
-          if (parentContext.insertionMode === ROOT_HTML_MODE)
-            return createFormatContext(
-              HTML_HTML_MODE,
-              null,
-              parentContext.tagScope
-            );
       }
-      return parentContext.insertionMode >= HTML_TABLE_MODE ||
-        parentContext.insertionMode < HTML_MODE
+      return parentContext.insertionMode >= HTML_TABLE_MODE
         ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
-        : parentContext;
+        : parentContext.insertionMode === ROOT_HTML_MODE
+          ? "html" === type
+            ? createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope)
+            : createFormatContext(HTML_MODE, null, parentContext.tagScope)
+          : parentContext.insertionMode === HTML_HTML_MODE
+            ? createFormatContext(HTML_MODE, null, parentContext.tagScope)
+            : parentContext;
     }
     function pushTextInstance(target, text, renderState, textEmbedded) {
       if ("" === text) return textEmbedded;
@@ -1561,7 +1573,8 @@
       return content;
     }
     function injectFormReplayingRuntime(resumableState, renderState) {
-      (resumableState.instructions & 16) === NothingSent &&
+      (resumableState.instructions & 16) !== NothingSent ||
+        renderState.externalRuntimeScript ||
         ((resumableState.instructions |= 16),
         renderState.bootstrapChunks.unshift(
           renderState.startInlineScript,
@@ -1726,7 +1739,6 @@
       props,
       resumableState,
       renderState,
-      preambleState,
       hoistableState,
       formatContext,
       textEmbedded,
@@ -2881,13 +2893,13 @@
         case "missing-glyph":
           break;
         case "head":
-          if (formatContext.insertionMode < HTML_MODE) {
-            var preamble = preambleState || renderState.preamble;
-            if (preamble.headChunks)
-              throw Error("The `<head>` tag may only be rendered once.");
-            preamble.headChunks = [];
+          if (
+            formatContext.insertionMode < HTML_MODE &&
+            null === renderState.headChunks
+          ) {
+            renderState.headChunks = [];
             var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-              preamble.headChunks,
+              renderState.headChunks,
               props,
               "head"
             );
@@ -2898,42 +2910,24 @@
               "head"
             );
           return JSCompiler_inline_result$jscomp$9;
-        case "body":
-          if (formatContext.insertionMode < HTML_MODE) {
-            var preamble$jscomp$0 = preambleState || renderState.preamble;
-            if (preamble$jscomp$0.bodyChunks)
-              throw Error("The `<body>` tag may only be rendered once.");
-            preamble$jscomp$0.bodyChunks = [];
-            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-              preamble$jscomp$0.bodyChunks,
-              props,
-              "body"
-            );
-          } else
-            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-              target$jscomp$0,
-              props,
-              "body"
-            );
-          return JSCompiler_inline_result$jscomp$10;
         case "html":
-          if (formatContext.insertionMode === ROOT_HTML_MODE) {
-            var preamble$jscomp$1 = preambleState || renderState.preamble;
-            if (preamble$jscomp$1.htmlChunks)
-              throw Error("The `<html>` tag may only be rendered once.");
-            preamble$jscomp$1.htmlChunks = [doctypeChunk];
-            var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-              preamble$jscomp$1.htmlChunks,
+          if (
+            formatContext.insertionMode === ROOT_HTML_MODE &&
+            null === renderState.htmlChunks
+          ) {
+            renderState.htmlChunks = [doctypeChunk];
+            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+              renderState.htmlChunks,
               props,
               "html"
             );
           } else
-            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
               target$jscomp$0,
               props,
               "html"
             );
-          return JSCompiler_inline_result$jscomp$11;
+          return JSCompiler_inline_result$jscomp$10;
         default:
           if (-1 !== type.indexOf("-")) {
             target$jscomp$0.push(startChunkForTag(type));
@@ -3001,15 +2995,6 @@
         endTagCache.set(tag, chunk));
       return chunk;
     }
-    function hoistPreambleState(renderState, preambleState) {
-      renderState = renderState.preamble;
-      null === renderState.htmlChunks &&
-        (renderState.htmlChunks = preambleState.htmlChunks);
-      null === renderState.headChunks &&
-        (renderState.headChunks = preambleState.headChunks);
-      null === renderState.bodyChunks &&
-        (renderState.bodyChunks = preambleState.bodyChunks);
-    }
     function writeBootstrap(destination, renderState) {
       renderState = renderState.bootstrapChunks;
       for (var i = 0; i < renderState.length - 1; i++)
@@ -3034,7 +3019,6 @@
       switch (formatContext.insertionMode) {
         case ROOT_HTML_MODE:
         case HTML_HTML_MODE:
-        case HTML_HEAD_MODE:
         case HTML_MODE:
           return (
             writeChunk(destination, startSegmentHTML),
@@ -3092,7 +3076,6 @@
       switch (formatContext.insertionMode) {
         case ROOT_HTML_MODE:
         case HTML_HTML_MODE:
-        case HTML_HEAD_MODE:
         case HTML_MODE:
           return writeChunkAndReturn(destination, endSegmentHTML);
         case SVG_MODE:
@@ -3378,6 +3361,116 @@
       writeChunk(destination, arrayInterstitial);
       writeChunk(destination, escapeJSObjectForInstructionScripts(name));
     }
+    function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+      writeChunk(destination, arrayFirstOpenBracket);
+      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
+      hoistableState.stylesheets.forEach(function (resource) {
+        if (resource.state !== PREAMBLE)
+          if (resource.state === LATE)
+            writeChunk(destination, nextArrayOpenBrackChunk),
+              (resource = resource.props.href),
+              checkAttributeStringCoercion(resource, "href"),
+              writeChunk(
+                destination,
+                escapeTextForBrowser(JSON.stringify("" + resource))
+              ),
+              writeChunk(destination, arrayCloseBracket),
+              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);
+          else {
+            writeChunk(destination, nextArrayOpenBrackChunk);
+            var precedence = resource.props["data-precedence"],
+              props = resource.props,
+              coercedHref = sanitizeURL("" + resource.props.href);
+            writeChunk(
+              destination,
+              escapeTextForBrowser(JSON.stringify(coercedHref))
+            );
+            checkAttributeStringCoercion(precedence, "precedence");
+            precedence = "" + precedence;
+            writeChunk(destination, arrayInterstitial);
+            writeChunk(
+              destination,
+              escapeTextForBrowser(JSON.stringify(precedence))
+            );
+            for (var propKey in props)
+              if (
+                hasOwnProperty.call(props, propKey) &&
+                ((precedence = props[propKey]), null != precedence)
+              )
+                switch (propKey) {
+                  case "href":
+                  case "rel":
+                  case "precedence":
+                  case "data-precedence":
+                    break;
+                  case "children":
+                  case "dangerouslySetInnerHTML":
+                    throw Error(
+                      "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                    );
+                  default:
+                    writeStyleResourceAttributeInAttr(
+                      destination,
+                      propKey,
+                      precedence
+                    );
+                }
+            writeChunk(destination, arrayCloseBracket);
+            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
+            resource.state = LATE;
+          }
+      });
+      writeChunk(destination, arrayCloseBracket);
+    }
+    function writeStyleResourceAttributeInAttr(destination, name, value) {
+      var attributeName = name.toLowerCase();
+      switch (typeof value) {
+        case "function":
+        case "symbol":
+          return;
+      }
+      switch (name) {
+        case "innerHTML":
+        case "dangerouslySetInnerHTML":
+        case "suppressContentEditableWarning":
+        case "suppressHydrationWarning":
+        case "style":
+        case "ref":
+          return;
+        case "className":
+          attributeName = "class";
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+          break;
+        case "hidden":
+          if (!1 === value) return;
+          name = "";
+          break;
+        case "src":
+        case "href":
+          value = sanitizeURL(value);
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+          break;
+        default:
+          if (
+            (2 < name.length &&
+              ("o" === name[0] || "O" === name[0]) &&
+              ("n" === name[1] || "N" === name[1])) ||
+            !isAttributeNameSafe(name)
+          )
+            return;
+          checkAttributeStringCoercion(value, attributeName);
+          name = "" + value;
+      }
+      writeChunk(destination, arrayInterstitial);
+      writeChunk(
+        destination,
+        escapeTextForBrowser(JSON.stringify(attributeName))
+      );
+      writeChunk(destination, arrayInterstitial);
+      writeChunk(destination, escapeTextForBrowser(JSON.stringify(name)));
+    }
     function createHoistableState() {
       return { styles: new Set(), stylesheets: new Set() };
     }
@@ -3504,6 +3597,8 @@
           return "Suspense";
         case REACT_SUSPENSE_LIST_TYPE:
           return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
       }
       if ("object" === typeof type)
         switch (
@@ -3880,6 +3975,11 @@
           queue.next = componentIdentity;
         }
     }
+    function throwOnUseEffectEventCall() {
+      throw Error(
+        "A function wrapped in useEffectEvent can't be called during rendering."
+      );
+    }
     function unsupportedStartTransition() {
       throw Error("startTransition cannot be called during server rendering.");
     }
@@ -3957,8 +4057,15 @@
       null === thenableState && (thenableState = []);
       return trackUsedThenable(thenableState, thenable, index);
     }
-    function unsupportedRefresh() {
-      throw Error("Cache cannot be refreshed during server rendering.");
+    function readPreviousThenableFromState() {
+      var index = thenableIndexCounter;
+      thenableIndexCounter += 1;
+      if (null !== thenableState)
+        return (
+          (index = thenableState[index]),
+          (index = void 0 === index ? void 0 : index.value),
+          index
+        );
     }
     function noop$1() {}
     function disabledLog() {}
@@ -4186,6 +4293,27 @@
       "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
       return sampleLines;
     }
+    function formatOwnerStack(error) {
+      var prevPrepareStackTrace = Error.prepareStackTrace;
+      Error.prepareStackTrace = prepareStackTrace;
+      error = error.stack;
+      Error.prepareStackTrace = prevPrepareStackTrace;
+      error.startsWith("Error: react-stack-top-frame\n") &&
+        (error = error.slice(29));
+      prevPrepareStackTrace = error.indexOf("\n");
+      -1 !== prevPrepareStackTrace &&
+        (error = error.slice(prevPrepareStackTrace + 1));
+      prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
+      -1 !== prevPrepareStackTrace &&
+        (prevPrepareStackTrace = error.lastIndexOf(
+          "\n",
+          prevPrepareStackTrace
+        ));
+      if (-1 !== prevPrepareStackTrace)
+        error = error.slice(0, prevPrepareStackTrace);
+      else return "";
+      return error;
+    }
     function describeComponentStackByType(type) {
       if ("string" === typeof type) return describeBuiltInComponentFrame(type);
       if ("function" === typeof type)
@@ -4222,21 +4350,11 @@
           return describeBuiltInComponentFrame("SuspenseList");
         case REACT_SUSPENSE_TYPE:
           return describeBuiltInComponentFrame("Suspense");
+        case REACT_VIEW_TRANSITION_TYPE:
+          return describeBuiltInComponentFrame("ViewTransition");
       }
       return "";
     }
-    function getStackByComponentStackNode(componentStack) {
-      try {
-        var info = "";
-        do
-          (info += describeComponentStackByType(componentStack.type)),
-            (componentStack = componentStack.parent);
-        while (componentStack);
-        return info;
-      } catch (x) {
-        return "\nError generating stack: " + x.message + "\n" + x.stack;
-      }
-    }
     function defaultErrorHandler(error) {
       if (
         "object" === typeof error &&
@@ -4293,7 +4411,7 @@
       this.status = 10;
       this.fatalError = null;
       this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-      this.completedPreambleSegments = this.completedRootSegment = null;
+      this.completedRootSegment = null;
       this.abortableTasks = abortSet;
       this.pingedTasks = [];
       this.clientRenderedBoundaries = [];
@@ -4353,14 +4471,15 @@
         null,
         renderState,
         null,
-        null,
         resumableState.abortableTasks,
         null,
         rootFormatContext,
         null,
         emptyTreeContext,
         null,
-        !1
+        !1,
+        emptyContextObject,
+        null
       );
       pushComponentStack(children);
       resumableState.pingedTasks.push(children);
@@ -4400,6 +4519,121 @@
       };
       return children;
     }
+    function resumeRequest(
+      children,
+      postponedState,
+      renderState,
+      onError,
+      onAllReady,
+      onShellReady,
+      onShellError,
+      onFatalError,
+      onPostpone
+    ) {
+      renderState = new RequestInstance(
+        postponedState.resumableState,
+        renderState,
+        postponedState.rootFormatContext,
+        postponedState.progressiveChunkSize,
+        onError,
+        onAllReady,
+        onShellReady,
+        onShellError,
+        onFatalError,
+        onPostpone,
+        null
+      );
+      renderState.nextSegmentId = postponedState.nextSegmentId;
+      if ("number" === typeof postponedState.replaySlots)
+        return (
+          (onError = postponedState.replaySlots),
+          (onAllReady = createPendingSegment(
+            renderState,
+            0,
+            null,
+            postponedState.rootFormatContext,
+            !1,
+            !1
+          )),
+          (onAllReady.id = onError),
+          (onAllReady.parentFlushed = !0),
+          (children = createRenderTask(
+            renderState,
+            null,
+            children,
+            -1,
+            null,
+            onAllReady,
+            null,
+            renderState.abortableTasks,
+            null,
+            postponedState.rootFormatContext,
+            null,
+            emptyTreeContext,
+            null,
+            !1,
+            emptyContextObject,
+            null
+          )),
+          pushComponentStack(children),
+          renderState.pingedTasks.push(children),
+          renderState
+        );
+      children = createReplayTask(
+        renderState,
+        null,
+        {
+          nodes: postponedState.replayNodes,
+          slots: postponedState.replaySlots,
+          pendingTasks: 0
+        },
+        children,
+        -1,
+        null,
+        null,
+        renderState.abortableTasks,
+        null,
+        postponedState.rootFormatContext,
+        null,
+        emptyTreeContext,
+        null,
+        !1,
+        emptyContextObject,
+        null
+      );
+      pushComponentStack(children);
+      renderState.pingedTasks.push(children);
+      return renderState;
+    }
+    function resumeAndPrerenderRequest(
+      children,
+      postponedState,
+      renderState,
+      onError,
+      onAllReady,
+      onShellReady,
+      onShellError,
+      onFatalError,
+      onPostpone
+    ) {
+      children = resumeRequest(
+        children,
+        postponedState,
+        renderState,
+        onError,
+        onAllReady,
+        onShellReady,
+        onShellError,
+        onFatalError,
+        onPostpone
+      );
+      children.trackedPostpones = {
+        workingMap: new Map(),
+        rootNodes: [],
+        rootSlots: null
+      };
+      return children;
+    }
     function resolveRequest() {
       if (currentRequest) return currentRequest;
       var store = requestStorage.getStore();
@@ -4417,12 +4651,7 @@
               return performWork(request);
             }));
     }
-    function createSuspenseBoundary(
-      request,
-      fallbackAbortableTasks,
-      contentPreamble,
-      fallbackPreamble
-    ) {
+    function createSuspenseBoundary(request, fallbackAbortableTasks) {
       return {
         status: PENDING,
         rootSegmentID: -1,
@@ -4434,8 +4663,6 @@
         errorDigest: null,
         contentState: createHoistableState(),
         fallbackState: createHoistableState(),
-        contentPreamble: contentPreamble,
-        fallbackPreamble: fallbackPreamble,
         trackedContentKeyPath: null,
         trackedFallbackNode: null,
         errorMessage: null,
@@ -4450,7 +4677,6 @@
       childIndex,
       blockedBoundary,
       blockedSegment,
-      blockedPreamble,
       hoistableState,
       abortSet,
       keyPath,
@@ -4458,7 +4684,9 @@
       context,
       treeContext,
       componentStack,
-      isFallback
+      isFallback,
+      legacyContext,
+      debugTask
     ) {
       request.allPendingTasks++;
       null === blockedBoundary
@@ -4473,7 +4701,6 @@
         },
         blockedBoundary: blockedBoundary,
         blockedSegment: blockedSegment,
-        blockedPreamble: blockedPreamble,
         hoistableState: hoistableState,
         abortSet: abortSet,
         keyPath: keyPath,
@@ -4484,6 +4711,7 @@
         thenableState: thenableState,
         isFallback: isFallback
       };
+      task.debugTask = debugTask;
       abortSet.add(task);
       return task;
     }
@@ -4501,7 +4729,9 @@
       context,
       treeContext,
       componentStack,
-      isFallback
+      isFallback,
+      legacyContext,
+      debugTask
     ) {
       request.allPendingTasks++;
       null === blockedBoundary
@@ -4517,7 +4747,6 @@
         },
         blockedBoundary: blockedBoundary,
         blockedSegment: null,
-        blockedPreamble: null,
         hoistableState: hoistableState,
         abortSet: abortSet,
         keyPath: keyPath,
@@ -4528,6 +4757,7 @@
         thenableState: thenableState,
         isFallback: isFallback
       };
+      task.debugTask = debugTask;
       abortSet.add(task);
       return task;
     }
@@ -4541,12 +4771,11 @@
     ) {
       return {
         status: PENDING,
-        parentFlushed: !1,
         id: -1,
         index: index,
+        parentFlushed: !1,
         chunks: [],
         children: [],
-        preambleChildren: [],
         parentFormatContext: parentFormatContext,
         boundary: boundary,
         lastPushedText: lastPushedText,
@@ -4554,22 +4783,63 @@
       };
     }
     function getCurrentStackInDEV() {
-      return null === currentTaskInDEV ||
-        null === currentTaskInDEV.componentStack
-        ? ""
-        : getStackByComponentStackNode(currentTaskInDEV.componentStack);
+      if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
+        return "";
+      var componentStack = currentTaskInDEV.componentStack;
+      try {
+        var info = "";
+        if ("string" === typeof componentStack.type)
+          info += describeBuiltInComponentFrame(componentStack.type);
+        else if ("function" === typeof componentStack.type) {
+          if (!componentStack.owner) {
+            var JSCompiler_temp_const = info,
+              fn = componentStack.type,
+              name = fn ? fn.displayName || fn.name : "";
+            var JSCompiler_inline_result = name
+              ? describeBuiltInComponentFrame(name)
+              : "";
+            info = JSCompiler_temp_const + JSCompiler_inline_result;
+          }
+        } else
+          componentStack.owner ||
+            (info += describeComponentStackByType(componentStack.type));
+        for (; componentStack; )
+          (JSCompiler_temp_const = null),
+            null != componentStack.debugStack
+              ? (JSCompiler_temp_const = formatOwnerStack(
+                  componentStack.debugStack
+                ))
+              : ((JSCompiler_inline_result = componentStack),
+                null != JSCompiler_inline_result.stack &&
+                  (JSCompiler_temp_const =
+                    "string" !== typeof JSCompiler_inline_result.stack
+                      ? (JSCompiler_inline_result.stack = formatOwnerStack(
+                          JSCompiler_inline_result.stack
+                        ))
+                      : JSCompiler_inline_result.stack)),
+            (componentStack = componentStack.owner) &&
+              JSCompiler_temp_const &&
+              (info += "\n" + JSCompiler_temp_const);
+        var JSCompiler_inline_result$jscomp$0 = info;
+      } catch (x) {
+        JSCompiler_inline_result$jscomp$0 =
+          "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+      return JSCompiler_inline_result$jscomp$0;
     }
     function pushServerComponentStack(task, debugInfo) {
       if (null != debugInfo)
         for (var i = 0; i < debugInfo.length; i++) {
           var componentInfo = debugInfo[i];
           "string" === typeof componentInfo.name &&
-            (task.componentStack = {
+            void 0 !== componentInfo.debugStack &&
+            ((task.componentStack = {
               parent: task.componentStack,
               type: componentInfo,
               owner: componentInfo.owner,
-              stack: null
-            });
+              stack: componentInfo.debugStack
+            }),
+            (task.debugTask = componentInfo.debugTask));
         }
     }
     function pushComponentStack(task) {
@@ -4578,13 +4848,15 @@
         switch (node.$$typeof) {
           case REACT_ELEMENT_TYPE:
             var type = node.type,
-              owner = node._owner;
+              owner = node._owner,
+              stack = node._debugStack;
             pushServerComponentStack(task, node._debugInfo);
+            task.debugTask = node._debugTask;
             task.componentStack = {
               parent: task.componentStack,
               type: type,
               owner: owner,
-              stack: null
+              stack: stack
             };
             break;
           case REACT_LAZY_TYPE:
@@ -4595,14 +4867,24 @@
               pushServerComponentStack(task, node._debugInfo);
         }
     }
-    function getThrownInfo(node) {
+    function getThrownInfo(node$jscomp$0) {
       var errorInfo = {};
-      node &&
+      node$jscomp$0 &&
         Object.defineProperty(errorInfo, "componentStack", {
           configurable: !0,
           enumerable: !0,
           get: function () {
-            var stack = getStackByComponentStackNode(node);
+            try {
+              var info = "",
+                node = node$jscomp$0;
+              do
+                (info += describeComponentStackByType(node.type)),
+                  (node = node.parent);
+              while (node);
+              var stack = info;
+            } catch (x) {
+              stack = "\nError generating stack: " + x.message + "\n" + x.stack;
+            }
             Object.defineProperty(errorInfo, "componentStack", {
               value: stack
             });
@@ -4633,9 +4915,17 @@
       boundary.errorStack = null !== error ? wasAborted + error : null;
       boundary.errorComponentStack = thrownInfo.componentStack;
     }
-    function logRecoverableError(request, error, errorInfo) {
+    function logPostpone(request, reason, postponeInfo, debugTask) {
+      request = request.onPostpone;
+      debugTask
+        ? debugTask.run(request.bind(null, reason, postponeInfo))
+        : request(reason, postponeInfo);
+    }
+    function logRecoverableError(request, error, errorInfo, debugTask) {
       request = request.onError;
-      error = request(error, errorInfo);
+      error = debugTask
+        ? debugTask.run(request.bind(null, error, errorInfo))
+        : request(error, errorInfo);
       if (null != error && "string" !== typeof error)
         console.error(
           'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
@@ -4643,11 +4933,13 @@
         );
       else return error;
     }
-    function fatalError(request, error) {
-      var onShellError = request.onShellError,
-        onFatalError = request.onFatalError;
-      onShellError(error);
-      onFatalError(error);
+    function fatalError(request, error, errorInfo, debugTask) {
+      errorInfo = request.onShellError;
+      var onFatalError = request.onFatalError;
+      debugTask
+        ? (debugTask.run(errorInfo.bind(null, error)),
+          debugTask.run(onFatalError.bind(null, error)))
+        : (errorInfo(error), onFatalError(error));
       null !== request.destination
         ? ((request.status = CLOSED), request.destination.destroy(error))
         : ((request.status = 13), (request.fatalError = error));
@@ -5186,7 +5478,6 @@
             props,
             request.resumableState,
             request.renderState,
-            task.blockedPreamble,
             task.hoistableState,
             task.formatContext,
             segment.lastPushedText,
@@ -5195,43 +5486,9 @@
           segment.lastPushedText = !1;
           var _prevContext = task.formatContext,
             _prevKeyPath2 = task.keyPath;
+          task.formatContext = getChildFormatContext(_prevContext, type, props);
           task.keyPath = keyPath;
-          if (
-            (task.formatContext = getChildFormatContext(
-              _prevContext,
-              type,
-              props
-            )).insertionMode === HTML_HEAD_MODE
-          ) {
-            var preambleSegment = createPendingSegment(
-              request,
-              0,
-              null,
-              task.formatContext,
-              !1,
-              !1
-            );
-            segment.preambleChildren.push(preambleSegment);
-            var preambleTask = createRenderTask(
-              request,
-              null,
-              _children,
-              -1,
-              task.blockedBoundary,
-              preambleSegment,
-              task.blockedPreamble,
-              task.hoistableState,
-              request.abortableTasks,
-              task.keyPath,
-              task.formatContext,
-              task.context,
-              task.treeContext,
-              task.componentStack,
-              task.isFallback
-            );
-            pushComponentStack(preambleTask);
-            request.pingedTasks.push(preambleTask);
-          } else renderNode(request, task, _children, -1);
+          renderNode(request, task, _children, -1);
           task.formatContext = _prevContext;
           task.keyPath = _prevKeyPath2;
           a: {
@@ -5268,9 +5525,6 @@
                   resumableState.hasHtml = !0;
                   break a;
                 }
-                break;
-              case "head":
-                if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;
             }
             target.push(endChunkForTag(type));
           }
@@ -5302,6 +5556,11 @@
             task.keyPath = _prevKeyPath3;
             return;
           case REACT_VIEW_TRANSITION_TYPE:
+            var _prevKeyPath4 = task.keyPath;
+            task.keyPath = keyPath;
+            renderNodeDestructive(request, task, props.children, -1);
+            task.keyPath = _prevKeyPath4;
+            return;
           case REACT_SCOPE_TYPE:
             throw Error(
               "ReactDOMServer does not yet support scope components."
@@ -5319,26 +5578,12 @@
             } else {
               var prevKeyPath$jscomp$3 = task.keyPath,
                 parentBoundary = task.blockedBoundary,
-                parentPreamble = task.blockedPreamble,
                 parentHoistableState = task.hoistableState,
                 parentSegment = task.blockedSegment,
                 fallback = props.fallback,
                 content = props.children,
-                fallbackAbortSet = new Set();
-              var newBoundary =
-                task.formatContext.insertionMode < HTML_MODE
-                  ? createSuspenseBoundary(
-                      request,
-                      fallbackAbortSet,
-                      createPreambleState(),
-                      createPreambleState()
-                    )
-                  : createSuspenseBoundary(
-                      request,
-                      fallbackAbortSet,
-                      null,
-                      null
-                    );
+                fallbackAbortSet = new Set(),
+                newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
               null !== request.trackedPostpones &&
                 (newBoundary.trackedContentKeyPath = keyPath);
               var boundarySegment = createPendingSegment(
@@ -5378,7 +5623,6 @@
                 );
                 newBoundary.trackedFallbackNode = fallbackReplayNode;
                 task.blockedSegment = boundarySegment;
-                task.blockedPreamble = newBoundary.fallbackPreamble;
                 task.keyPath = fallbackKeyPath;
                 boundarySegment.status = 6;
                 try {
@@ -5394,7 +5638,6 @@
                   );
                 } finally {
                   (task.blockedSegment = parentSegment),
-                    (task.blockedPreamble = parentPreamble),
                     (task.keyPath = prevKeyPath$jscomp$3);
                 }
                 var suspendedPrimaryTask = createRenderTask(
@@ -5404,7 +5647,6 @@
                   -1,
                   newBoundary,
                   contentRootSegment,
-                  newBoundary.contentPreamble,
                   newBoundary.contentState,
                   task.abortSet,
                   keyPath,
@@ -5412,13 +5654,14 @@
                   task.context,
                   task.treeContext,
                   task.componentStack,
-                  task.isFallback
+                  task.isFallback,
+                  emptyContextObject,
+                  task.debugTask
                 );
                 pushComponentStack(suspendedPrimaryTask);
                 request.pingedTasks.push(suspendedPrimaryTask);
               } else {
                 task.blockedBoundary = newBoundary;
-                task.blockedPreamble = newBoundary.contentPreamble;
                 task.hoistableState = newBoundary.contentState;
                 task.blockedSegment = contentRootSegment;
                 task.keyPath = keyPath;
@@ -5435,9 +5678,6 @@
                       newBoundary.status === PENDING)
                   ) {
                     newBoundary.status = COMPLETED;
-                    0 === request.pendingRootTasks &&
-                      task.blockedPreamble &&
-                      preparePreamble(request);
                     break a;
                   }
                 } catch (thrownValue$2) {
@@ -5448,11 +5688,25 @@
                   } else
                     (contentRootSegment.status = 4), (error = thrownValue$2);
                   var thrownInfo = getThrownInfo(task.componentStack);
-                  var errorDigest = logRecoverableError(
-                    request,
-                    error,
-                    thrownInfo
-                  );
+                  if (
+                    "object" === typeof error &&
+                    null !== error &&
+                    error.$$typeof === REACT_POSTPONE_TYPE
+                  ) {
+                    logPostpone(
+                      request,
+                      error.message,
+                      thrownInfo,
+                      task.debugTask
+                    );
+                    var errorDigest = "POSTPONE";
+                  } else
+                    errorDigest = logRecoverableError(
+                      request,
+                      error,
+                      thrownInfo,
+                      task.debugTask
+                    );
                   encodeErrorForBoundary(
                     newBoundary,
                     errorDigest,
@@ -5463,7 +5717,6 @@
                   untrackBoundary(request, newBoundary);
                 } finally {
                   (task.blockedBoundary = parentBoundary),
-                    (task.blockedPreamble = parentPreamble),
                     (task.hoistableState = parentHoistableState),
                     (task.blockedSegment = parentSegment),
                     (task.keyPath = prevKeyPath$jscomp$3);
@@ -5475,7 +5728,6 @@
                   -1,
                   parentBoundary,
                   boundarySegment,
-                  newBoundary.fallbackPreamble,
                   newBoundary.fallbackState,
                   fallbackAbortSet,
                   [keyPath[0], "Suspense Fallback", keyPath[2]],
@@ -5483,7 +5735,9 @@
                   task.context,
                   task.treeContext,
                   task.componentStack,
-                  !0
+                  !0,
+                  emptyContextObject,
+                  task.debugTask
                 );
                 pushComponentStack(suspendedFallbackTask);
                 request.pingedTasks.push(suspendedFallbackTask);
@@ -5635,15 +5889,186 @@
         (task.replay = prevReplay), (task.blockedSegment = null);
       }
     }
+    function replayElement(
+      request,
+      task,
+      keyPath,
+      name,
+      keyOrIndex,
+      childIndex,
+      type,
+      props,
+      ref,
+      replay
+    ) {
+      childIndex = replay.nodes;
+      for (var i = 0; i < childIndex.length; i++) {
+        var node = childIndex[i];
+        if (keyOrIndex === node[1]) {
+          if (4 === node.length) {
+            if (null !== name && name !== node[0])
+              throw Error(
+                "Expected the resume to render <" +
+                  node[0] +
+                  "> in this slot but instead it rendered <" +
+                  name +
+                  ">. The tree doesn't match so React will fallback to client rendering."
+              );
+            var childNodes = node[2];
+            node = node[3];
+            name = task.node;
+            task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
+            try {
+              renderElement(request, task, keyPath, type, props, ref);
+              if (
+                1 === task.replay.pendingTasks &&
+                0 < task.replay.nodes.length
+              )
+                throw Error(
+                  "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+                );
+              task.replay.pendingTasks--;
+            } catch (x) {
+              if (
+                "object" === typeof x &&
+                null !== x &&
+                (x === SuspenseException || "function" === typeof x.then)
+              )
+                throw (task.node === name && (task.replay = replay), x);
+              task.replay.pendingTasks--;
+              props = getThrownInfo(task.componentStack);
+              erroredReplay(
+                request,
+                task.blockedBoundary,
+                x,
+                props,
+                childNodes,
+                node,
+                task.debugTask
+              );
+            }
+            task.replay = replay;
+          } else {
+            if (type !== REACT_SUSPENSE_TYPE)
+              throw Error(
+                "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
+                  (getComponentNameFromType(type) || "Unknown") +
+                  ">. The tree doesn't match so React will fallback to client rendering."
+              );
+            a: {
+              replay = void 0;
+              type = node[5];
+              ref = node[2];
+              name = node[3];
+              keyOrIndex = null === node[4] ? [] : node[4][2];
+              node = null === node[4] ? null : node[4][3];
+              var prevKeyPath = task.keyPath,
+                previousReplaySet = task.replay,
+                parentBoundary = task.blockedBoundary,
+                parentHoistableState = task.hoistableState,
+                content = props.children;
+              props = props.fallback;
+              var fallbackAbortSet = new Set(),
+                resumedBoundary = createSuspenseBoundary(
+                  request,
+                  fallbackAbortSet
+                );
+              resumedBoundary.parentFlushed = !0;
+              resumedBoundary.rootSegmentID = type;
+              task.blockedBoundary = resumedBoundary;
+              task.hoistableState = resumedBoundary.contentState;
+              task.keyPath = keyPath;
+              task.replay = { nodes: ref, slots: name, pendingTasks: 1 };
+              try {
+                renderNode(request, task, content, -1);
+                if (
+                  1 === task.replay.pendingTasks &&
+                  0 < task.replay.nodes.length
+                )
+                  throw Error(
+                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
+                  );
+                task.replay.pendingTasks--;
+                if (
+                  0 === resumedBoundary.pendingTasks &&
+                  resumedBoundary.status === PENDING
+                ) {
+                  resumedBoundary.status = COMPLETED;
+                  request.completedBoundaries.push(resumedBoundary);
+                  break a;
+                }
+              } catch (error) {
+                (resumedBoundary.status = CLIENT_RENDERED),
+                  (childNodes = getThrownInfo(task.componentStack)),
+                  "object" === typeof error &&
+                  null !== error &&
+                  error.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        error.message,
+                        childNodes,
+                        task.debugTask
+                      ),
+                      (replay = "POSTPONE"))
+                    : (replay = logRecoverableError(
+                        request,
+                        error,
+                        childNodes,
+                        task.debugTask
+                      )),
+                  encodeErrorForBoundary(
+                    resumedBoundary,
+                    replay,
+                    error,
+                    childNodes,
+                    !1
+                  ),
+                  task.replay.pendingTasks--,
+                  request.clientRenderedBoundaries.push(resumedBoundary);
+              } finally {
+                (task.blockedBoundary = parentBoundary),
+                  (task.hoistableState = parentHoistableState),
+                  (task.replay = previousReplaySet),
+                  (task.keyPath = prevKeyPath);
+              }
+              props = createReplayTask(
+                request,
+                null,
+                { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
+                props,
+                -1,
+                parentBoundary,
+                resumedBoundary.fallbackState,
+                fallbackAbortSet,
+                [keyPath[0], "Suspense Fallback", keyPath[2]],
+                task.formatContext,
+                task.context,
+                task.treeContext,
+                task.componentStack,
+                !0,
+                emptyContextObject,
+                task.debugTask
+              );
+              pushComponentStack(props);
+              request.pingedTasks.push(props);
+            }
+          }
+          childIndex.splice(i, 1);
+          break;
+        }
+      }
+    }
     function renderNodeDestructive(request, task, node, childIndex) {
       null !== task.replay && "number" === typeof task.replay.slots
         ? resumeNode(request, task, task.replay.slots, node, childIndex)
         : ((task.node = node),
           (task.childIndex = childIndex),
           (node = task.componentStack),
+          (childIndex = task.debugTask),
           pushComponentStack(task),
           retryNode(request, task),
-          (task.componentStack = node));
+          (task.componentStack = node),
+          (task.debugTask = childIndex));
     }
     function retryNode(request, task) {
       var node = task.node,
@@ -5653,178 +6078,56 @@
           switch (node.$$typeof) {
             case REACT_ELEMENT_TYPE:
               var type = node.type,
-                key = node.key,
-                props = node.props;
-              node = props.ref;
-              var ref = void 0 !== node ? node : null,
-                name = getComponentNameFromType(type),
-                keyOrIndex =
-                  null == key ? (-1 === childIndex ? 0 : childIndex) : key,
-                keyPath = [task.keyPath, name, keyOrIndex];
-              if (null !== task.replay) {
-                var replay = task.replay;
-                childIndex = replay.nodes;
-                for (node = 0; node < childIndex.length; node++)
-                  if (((key = childIndex[node]), keyOrIndex === key[1])) {
-                    if (4 === key.length) {
-                      if (null !== name && name !== key[0])
-                        throw Error(
-                          "Expected the resume to render <" +
-                            key[0] +
-                            "> in this slot but instead it rendered <" +
-                            name +
-                            ">. The tree doesn't match so React will fallback to client rendering."
-                        );
-                      var childNodes = key[2];
-                      key = key[3];
-                      name = task.node;
-                      task.replay = {
-                        nodes: childNodes,
-                        slots: key,
-                        pendingTasks: 1
-                      };
-                      try {
-                        renderElement(request, task, keyPath, type, props, ref);
-                        if (
-                          1 === task.replay.pendingTasks &&
-                          0 < task.replay.nodes.length
-                        )
-                          throw Error(
-                            "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                          );
-                        task.replay.pendingTasks--;
-                      } catch (x) {
-                        if (
-                          "object" === typeof x &&
-                          null !== x &&
-                          (x === SuspenseException ||
-                            "function" === typeof x.then)
-                        )
-                          throw (
-                            (task.node === name && (task.replay = replay), x)
-                          );
-                        task.replay.pendingTasks--;
-                        props = getThrownInfo(task.componentStack);
-                        erroredReplay(
-                          request,
-                          task.blockedBoundary,
-                          x,
-                          props,
-                          childNodes,
-                          key
-                        );
-                      }
-                      task.replay = replay;
-                    } else {
-                      if (type !== REACT_SUSPENSE_TYPE)
-                        throw Error(
-                          "Expected the resume to render <Suspense> in this slot but instead it rendered <" +
-                            (getComponentNameFromType(type) || "Unknown") +
-                            ">. The tree doesn't match so React will fallback to client rendering."
-                        );
-                      a: {
-                        type = void 0;
-                        ref = key[5];
-                        replay = key[2];
-                        name = key[3];
-                        keyOrIndex = null === key[4] ? [] : key[4][2];
-                        key = null === key[4] ? null : key[4][3];
-                        var prevKeyPath = task.keyPath,
-                          previousReplaySet = task.replay,
-                          parentBoundary = task.blockedBoundary,
-                          parentHoistableState = task.hoistableState,
-                          content = props.children,
-                          fallback = props.fallback,
-                          fallbackAbortSet = new Set();
-                        props =
-                          task.formatContext.insertionMode < HTML_MODE
-                            ? createSuspenseBoundary(
-                                request,
-                                fallbackAbortSet,
-                                createPreambleState(),
-                                createPreambleState()
-                              )
-                            : createSuspenseBoundary(
-                                request,
-                                fallbackAbortSet,
-                                null,
-                                null
-                              );
-                        props.parentFlushed = !0;
-                        props.rootSegmentID = ref;
-                        task.blockedBoundary = props;
-                        task.hoistableState = props.contentState;
-                        task.keyPath = keyPath;
-                        task.replay = {
-                          nodes: replay,
-                          slots: name,
-                          pendingTasks: 1
-                        };
-                        try {
-                          renderNode(request, task, content, -1);
-                          if (
-                            1 === task.replay.pendingTasks &&
-                            0 < task.replay.nodes.length
-                          )
-                            throw Error(
-                              "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
-                            );
-                          task.replay.pendingTasks--;
-                          if (
-                            0 === props.pendingTasks &&
-                            props.status === PENDING
-                          ) {
-                            props.status = COMPLETED;
-                            request.completedBoundaries.push(props);
-                            break a;
-                          }
-                        } catch (error) {
-                          (props.status = CLIENT_RENDERED),
-                            (childNodes = getThrownInfo(task.componentStack)),
-                            (type = logRecoverableError(
-                              request,
-                              error,
-                              childNodes
-                            )),
-                            encodeErrorForBoundary(
-                              props,
-                              type,
-                              error,
-                              childNodes,
-                              !1
-                            ),
-                            task.replay.pendingTasks--,
-                            request.clientRenderedBoundaries.push(props);
-                        } finally {
-                          (task.blockedBoundary = parentBoundary),
-                            (task.hoistableState = parentHoistableState),
-                            (task.replay = previousReplaySet),
-                            (task.keyPath = prevKeyPath);
-                        }
-                        childNodes = createReplayTask(
-                          request,
-                          null,
-                          { nodes: keyOrIndex, slots: key, pendingTasks: 0 },
-                          fallback,
-                          -1,
-                          parentBoundary,
-                          props.fallbackState,
-                          fallbackAbortSet,
-                          [keyPath[0], "Suspense Fallback", keyPath[2]],
-                          task.formatContext,
-                          task.context,
-                          task.treeContext,
-                          task.componentStack,
-                          !0
-                        );
-                        pushComponentStack(childNodes);
-                        request.pingedTasks.push(childNodes);
-                      }
-                    }
-                    childIndex.splice(node, 1);
-                    break;
-                  }
-              } else renderElement(request, task, keyPath, type, props, ref);
+                key = node.key;
+              node = node.props;
+              var refProp = node.ref;
+              refProp = void 0 !== refProp ? refProp : null;
+              var debugTask = task.debugTask,
+                name = getComponentNameFromType(type);
+              key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;
+              var keyPath = [task.keyPath, name, key];
+              null !== task.replay
+                ? debugTask
+                  ? debugTask.run(
+                      replayElement.bind(
+                        null,
+                        request,
+                        task,
+                        keyPath,
+                        name,
+                        key,
+                        childIndex,
+                        type,
+                        node,
+                        refProp,
+                        task.replay
+                      )
+                    )
+                  : replayElement(
+                      request,
+                      task,
+                      keyPath,
+                      name,
+                      key,
+                      childIndex,
+                      type,
+                      node,
+                      refProp,
+                      task.replay
+                    )
+                : debugTask
+                  ? debugTask.run(
+                      renderElement.bind(
+                        null,
+                        request,
+                        task,
+                        keyPath,
+                        type,
+                        node,
+                        refProp
+                      )
+                    )
+                  : renderElement(request, task, keyPath, type, node, refProp);
               return;
             case REACT_PORTAL_TYPE:
               throw Error(
@@ -5841,21 +6144,20 @@
             return;
           }
           null === node || "object" !== typeof node
-            ? (props = null)
-            : ((childNodes =
+            ? (key = null)
+            : ((type =
                 (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||
                 node["@@iterator"]),
-              (props = "function" === typeof childNodes ? childNodes : null));
-          if (props && (childNodes = props.call(node))) {
-            if (childNodes === node) {
+              (key = "function" === typeof type ? type : null));
+          if (key && (type = key.call(node))) {
+            if (type === node) {
               if (
                 -1 !== childIndex ||
                 null === task.componentStack ||
                 "function" !== typeof task.componentStack.type ||
                 "[object GeneratorFunction]" !==
                   Object.prototype.toString.call(task.componentStack.type) ||
-                "[object Generator]" !==
-                  Object.prototype.toString.call(childNodes)
+                "[object Generator]" !== Object.prototype.toString.call(type)
               )
                 didWarnAboutGenerators ||
                   console.error(
@@ -5863,21 +6165,59 @@
                   ),
                   (didWarnAboutGenerators = !0);
             } else
-              node.entries !== props ||
+              node.entries !== key ||
                 didWarnAboutMaps ||
                 (console.error(
                   "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                 ),
                 (didWarnAboutMaps = !0));
-            node = childNodes.next();
+            node = type.next();
             if (!node.done) {
-              props = [];
-              do props.push(node.value), (node = childNodes.next());
+              key = [];
+              do key.push(node.value), (node = type.next());
               while (!node.done);
-              renderChildrenArray(request, task, props, childIndex);
+              renderChildrenArray(request, task, key, childIndex);
             }
             return;
           }
+          if (
+            "function" === typeof node[ASYNC_ITERATOR] &&
+            (type = node[ASYNC_ITERATOR]())
+          ) {
+            type !== node ||
+              (-1 === childIndex &&
+                null !== task.componentStack &&
+                "function" === typeof task.componentStack.type &&
+                "[object AsyncGeneratorFunction]" ===
+                  Object.prototype.toString.call(task.componentStack.type) &&
+                "[object AsyncGenerator]" ===
+                  Object.prototype.toString.call(type)) ||
+              (didWarnAboutGenerators ||
+                console.error(
+                  "Using AsyncIterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You can use an AsyncIterable that can iterate multiple times over the same items."
+                ),
+              (didWarnAboutGenerators = !0));
+            key = task.thenableState;
+            task.thenableState = null;
+            thenableIndexCounter = 0;
+            thenableState = key;
+            key = [];
+            refProp = !1;
+            if (type === node)
+              for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+                if (node.done) {
+                  refProp = !0;
+                  break;
+                }
+                key.push(node.value);
+                node = readPreviousThenableFromState();
+              }
+            if (!refProp)
+              for (node = unwrapThenable(type.next()); !node.done; )
+                key.push(node.value), (node = unwrapThenable(type.next()));
+            renderChildrenArray(request, task, key, childIndex);
+            return;
+          }
           if ("function" === typeof node.then)
             return (
               (task.thenableState = null),
@@ -5895,39 +6235,39 @@
               node._currentValue,
               childIndex
             );
-          childIndex = Object.prototype.toString.call(node);
+          request = Object.prototype.toString.call(node);
           throw Error(
             "Objects are not valid as a React child (found: " +
-              ("[object Object]" === childIndex
+              ("[object Object]" === request
                 ? "object with keys {" + Object.keys(node).join(", ") + "}"
-                : childIndex) +
+                : request) +
               "). If you meant to render a collection of children, use an array instead."
           );
         }
         "string" === typeof node
-          ? ((childIndex = task.blockedSegment),
-            null !== childIndex &&
-              (childIndex.lastPushedText = pushTextInstance(
-                childIndex.chunks,
+          ? ((task = task.blockedSegment),
+            null !== task &&
+              (task.lastPushedText = pushTextInstance(
+                task.chunks,
                 node,
                 request.renderState,
-                childIndex.lastPushedText
+                task.lastPushedText
               )))
           : "number" === typeof node || "bigint" === typeof node
-            ? ((childIndex = task.blockedSegment),
-              null !== childIndex &&
-                (childIndex.lastPushedText = pushTextInstance(
-                  childIndex.chunks,
+            ? ((task = task.blockedSegment),
+              null !== task &&
+                (task.lastPushedText = pushTextInstance(
+                  task.chunks,
                   "" + node,
                   request.renderState,
-                  childIndex.lastPushedText
+                  task.lastPushedText
                 )))
             : ("function" === typeof node &&
-                ((childIndex = node.displayName || node.name || "Component"),
+                ((request = node.displayName || node.name || "Component"),
                 console.error(
                   "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
-                  childIndex,
-                  childIndex
+                  request,
+                  request
                 )),
               "symbol" === typeof node &&
                 console.error(
@@ -5939,6 +6279,7 @@
     function renderChildrenArray(request$jscomp$0, task, children, childIndex) {
       var prevKeyPath = task.keyPath,
         previousComponentStack = task.componentStack;
+      var previousDebugTask = task.debugTask;
       pushServerComponentStack(task, task.node._debugInfo);
       if (
         -1 !== childIndex &&
@@ -5980,7 +6321,8 @@
                 x,
                 children,
                 childIndex,
-                node
+                node,
+                task.debugTask
               );
             }
             task.replay = replay;
@@ -5990,6 +6332,7 @@
         }
         task.keyPath = prevKeyPath;
         task.componentStack = previousComponentStack;
+        task.debugTask = previousDebugTask;
         return;
       }
       replay = task.treeContext;
@@ -6016,6 +6359,7 @@
         task.treeContext = replay;
         task.keyPath = prevKeyPath;
         task.componentStack = previousComponentStack;
+        task.debugTask = previousDebugTask;
         return;
       }
       for (j = 0; j < replayNodes; j++) {
@@ -6074,7 +6418,7 @@
               parent: node.componentStack,
               type: resumeSegmentID.type,
               owner: resumeSegmentID._owner,
-              stack: null
+              stack: resumeSegmentID._debugStack
             };
             console.error(
               'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
@@ -6090,6 +6434,106 @@
       task.treeContext = replay;
       task.keyPath = prevKeyPath;
       task.componentStack = previousComponentStack;
+      task.debugTask = previousDebugTask;
+    }
+    function trackPostpone(request, trackedPostpones, task, segment) {
+      segment.status = POSTPONED;
+      var keyPath = task.keyPath,
+        boundary = task.blockedBoundary;
+      if (null === boundary)
+        (segment.id = request.nextSegmentId++),
+          (trackedPostpones.rootSlots = segment.id),
+          null !== request.completedRootSegment &&
+            (request.completedRootSegment.status = POSTPONED);
+      else {
+        if (null !== boundary && boundary.status === PENDING) {
+          boundary.status = POSTPONED;
+          boundary.rootSegmentID = request.nextSegmentId++;
+          var boundaryKeyPath = boundary.trackedContentKeyPath;
+          if (null === boundaryKeyPath)
+            throw Error(
+              "It should not be possible to postpone at the root. This is a bug in React."
+            );
+          var fallbackReplayNode = boundary.trackedFallbackNode,
+            children = [];
+          if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+            -1 === segment.id &&
+              (segment.id = segment.parentFlushed
+                ? boundary.rootSegmentID
+                : request.nextSegmentId++);
+            segment = [
+              boundaryKeyPath[1],
+              boundaryKeyPath[2],
+              children,
+              segment.id,
+              fallbackReplayNode,
+              boundary.rootSegmentID
+            ];
+            trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+            addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+            return;
+          }
+          var _boundaryNode = trackedPostpones.workingMap.get(boundaryKeyPath);
+          void 0 === _boundaryNode
+            ? ((_boundaryNode = [
+                boundaryKeyPath[1],
+                boundaryKeyPath[2],
+                children,
+                null,
+                fallbackReplayNode,
+                boundary.rootSegmentID
+              ]),
+              trackedPostpones.workingMap.set(boundaryKeyPath, _boundaryNode),
+              addToReplayParent(
+                _boundaryNode,
+                boundaryKeyPath[0],
+                trackedPostpones
+              ))
+            : ((boundaryKeyPath = _boundaryNode),
+              (boundaryKeyPath[4] = fallbackReplayNode),
+              (boundaryKeyPath[5] = boundary.rootSegmentID));
+        }
+        -1 === segment.id &&
+          (segment.id =
+            segment.parentFlushed && null !== boundary
+              ? boundary.rootSegmentID
+              : request.nextSegmentId++);
+        if (-1 === task.childIndex)
+          null === keyPath
+            ? (trackedPostpones.rootSlots = segment.id)
+            : ((task = trackedPostpones.workingMap.get(keyPath)),
+              void 0 === task
+                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+                  addToReplayParent(task, keyPath[0], trackedPostpones))
+                : (task[3] = segment.id));
+        else {
+          if (null === keyPath)
+            if (((request = trackedPostpones.rootSlots), null === request))
+              request = trackedPostpones.rootSlots = {};
+            else {
+              if ("number" === typeof request)
+                throw Error(
+                  "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+                );
+            }
+          else if (
+            ((boundary = trackedPostpones.workingMap),
+            (boundaryKeyPath = boundary.get(keyPath)),
+            void 0 === boundaryKeyPath)
+          )
+            (request = {}),
+              (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+              boundary.set(keyPath, boundaryKeyPath),
+              addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+          else if (((request = boundaryKeyPath[3]), null === request))
+            request = boundaryKeyPath[3] = {};
+          else if ("number" === typeof request)
+            throw Error(
+              "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+            );
+          request[task.childIndex] = segment.id;
+        }
+      }
     }
     function untrackBoundary(request, boundary) {
       request = request.trackedPostpones;
@@ -6115,7 +6559,9 @@
         task.context,
         task.treeContext,
         task.componentStack,
-        task.isFallback
+        task.isFallback,
+        emptyContextObject,
+        task.debugTask
       );
     }
     function spawnNewSuspendedRenderTask(request, task, thenableState) {
@@ -6137,7 +6583,6 @@
         task.childIndex,
         task.blockedBoundary,
         newSegment,
-        task.blockedPreamble,
         task.hoistableState,
         task.abortSet,
         task.keyPath,
@@ -6145,7 +6590,9 @@
         task.context,
         task.treeContext,
         task.componentStack,
-        task.isFallback
+        task.isFallback,
+        emptyContextObject,
+        task.debugTask
       );
     }
     function renderNode(request, task, node, childIndex) {
@@ -6154,6 +6601,7 @@
         previousKeyPath = task.keyPath,
         previousTreeContext = task.treeContext,
         previousComponentStack = task.componentStack,
+        previousDebugTask = task.debugTask,
         segment = task.blockedSegment;
       if (null === segment)
         try {
@@ -6161,13 +6609,14 @@
         } catch (thrownValue) {
           if (
             (resetHooksState(),
-            (node =
+            (childIndex =
               thrownValue === SuspenseException
                 ? getSuspendedThenable()
                 : thrownValue),
-            "object" === typeof node && null !== node)
+            "object" === typeof childIndex && null !== childIndex)
           ) {
-            if ("function" === typeof node.then) {
+            if ("function" === typeof childIndex.then) {
+              node = childIndex;
               childIndex = getThenableStateAfterSuspending();
               request = spawnNewSuspendedReplayTask(
                 request,
@@ -6180,10 +6629,11 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
-            if ("Maximum call stack size exceeded" === node.message) {
+            if ("Maximum call stack size exceeded" === childIndex.message) {
               node = getThenableStateAfterSuspending();
               node = spawnNewSuspendedReplayTask(request, task, node);
               request.pingedTasks.push(node);
@@ -6192,6 +6642,7 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
@@ -6207,13 +6658,14 @@
             (resetHooksState(),
             (segment.children.length = childrenLength),
             (segment.chunks.length = chunkLength),
-            (node =
+            (childIndex =
               thrownValue$3 === SuspenseException
                 ? getSuspendedThenable()
                 : thrownValue$3),
-            "object" === typeof node && null !== node)
+            "object" === typeof childIndex && null !== childIndex)
           ) {
-            if ("function" === typeof node.then) {
+            if ("function" === typeof childIndex.then) {
+              node = childIndex;
               childIndex = getThenableStateAfterSuspending();
               request = spawnNewSuspendedRenderTask(
                 request,
@@ -6226,10 +6678,40 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
-            if ("Maximum call stack size exceeded" === node.message) {
+            if (
+              childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+              null !== request.trackedPostpones &&
+              null !== task.blockedBoundary
+            ) {
+              node = request.trackedPostpones;
+              segment = getThrownInfo(task.componentStack);
+              logPostpone(request, childIndex.message, segment, task.debugTask);
+              childIndex = task.blockedSegment;
+              segment = createPendingSegment(
+                request,
+                childIndex.chunks.length,
+                null,
+                task.formatContext,
+                childIndex.lastPushedText,
+                !0
+              );
+              childIndex.children.push(segment);
+              childIndex.lastPushedText = !1;
+              trackPostpone(request, node, task, segment);
+              task.formatContext = previousFormatContext;
+              task.context = previousContext;
+              task.keyPath = previousKeyPath;
+              task.treeContext = previousTreeContext;
+              task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
+              switchContext(previousContext);
+              return;
+            }
+            if ("Maximum call stack size exceeded" === childIndex.message) {
               node = getThenableStateAfterSuspending();
               node = spawnNewSuspendedRenderTask(request, task, node);
               request.pingedTasks.push(node);
@@ -6238,6 +6720,7 @@
               task.keyPath = previousKeyPath;
               task.treeContext = previousTreeContext;
               task.componentStack = previousComponentStack;
+              task.debugTask = previousDebugTask;
               switchContext(previousContext);
               return;
             }
@@ -6249,7 +6732,7 @@
       task.keyPath = previousKeyPath;
       task.treeContext = previousTreeContext;
       switchContext(previousContext);
-      throw node;
+      throw childIndex;
     }
     function erroredReplay(
       request,
@@ -6257,16 +6740,27 @@
       error,
       errorInfo,
       replayNodes,
-      resumeSlots
+      resumeSlots,
+      debugTask
     ) {
-      var errorDigest = logRecoverableError(request, error, errorInfo);
+      "object" === typeof error &&
+      null !== error &&
+      error.$$typeof === REACT_POSTPONE_TYPE
+        ? (logPostpone(request, error.message, errorInfo, debugTask),
+          (debugTask = "POSTPONE"))
+        : (debugTask = logRecoverableError(
+            request,
+            error,
+            errorInfo,
+            debugTask
+          ));
       abortRemainingReplayNodes(
         request,
         boundary,
         replayNodes,
         resumeSlots,
         error,
-        errorDigest,
+        debugTask,
         errorInfo,
         !1
       );
@@ -6306,12 +6800,7 @@
             errorDigest = errorDigest$jscomp$0,
             errorInfo = errorInfo$jscomp$0,
             wasAborted = aborted,
-            resumedBoundary = createSuspenseBoundary(
-              request,
-              new Set(),
-              null,
-              null
-            );
+            resumedBoundary = createSuspenseBoundary(request, new Set());
           resumedBoundary.parentFlushed = !0;
           resumedBoundary.rootSegmentID = node;
           resumedBoundary.status = CLIENT_RENDERED;
@@ -6354,19 +6843,43 @@
         if (6 === segment.status) return;
         segment.status = 3;
       }
-      segment = getThrownInfo(task.componentStack);
+      var errorInfo = getThrownInfo(task.componentStack);
       if (null === boundary) {
         if (13 !== request.status && request.status !== CLOSED) {
           boundary = task.replay;
           if (null === boundary) {
-            logRecoverableError(request, error, segment);
-            fatalError(request, error);
+            "object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+              ? ((boundary = request.trackedPostpones),
+                null !== boundary && null !== segment
+                  ? (logPostpone(request, error.message, errorInfo, null),
+                    trackPostpone(request, boundary, task, segment),
+                    finishedTask(request, null, segment))
+                  : ((task = Error(
+                      "The render was aborted with postpone when the shell is incomplete. Reason: " +
+                        error.message
+                    )),
+                    logRecoverableError(request, task, errorInfo, null),
+                    fatalError(request, task, errorInfo, null)))
+              : null !== request.trackedPostpones && null !== segment
+                ? ((boundary = request.trackedPostpones),
+                  logRecoverableError(request, error, errorInfo, null),
+                  trackPostpone(request, boundary, task, segment),
+                  finishedTask(request, null, segment))
+                : (logRecoverableError(request, error, errorInfo, null),
+                  fatalError(request, error, errorInfo, null));
             return;
           }
           boundary.pendingTasks--;
           0 === boundary.pendingTasks &&
             0 < boundary.nodes.length &&
-            ((task = logRecoverableError(request, error, segment)),
+            ("object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+              ? (logPostpone(request, error.message, errorInfo, null),
+                (task = "POSTPONE"))
+              : (task = logRecoverableError(request, error, errorInfo, null)),
             abortRemainingReplayNodes(
               request,
               null,
@@ -6374,26 +6887,59 @@
               boundary.slots,
               error,
               task,
-              segment,
+              errorInfo,
               !0
             ));
           request.pendingRootTasks--;
           0 === request.pendingRootTasks && completeShell(request);
         }
-      } else
-        boundary.pendingTasks--,
-          boundary.status !== CLIENT_RENDERED &&
-            ((boundary.status = CLIENT_RENDERED),
-            (task = logRecoverableError(request, error, segment)),
-            (boundary.status = CLIENT_RENDERED),
-            encodeErrorForBoundary(boundary, task, error, segment, !0),
-            untrackBoundary(request, boundary),
-            boundary.parentFlushed &&
-              request.clientRenderedBoundaries.push(boundary)),
-          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-            return abortTask(fallbackTask, request, error);
-          }),
-          boundary.fallbackAbortableTasks.clear();
+      } else {
+        boundary.pendingTasks--;
+        var _trackedPostpones2 = request.trackedPostpones;
+        if (boundary.status !== CLIENT_RENDERED) {
+          if (null !== _trackedPostpones2 && null !== segment)
+            return (
+              "object" === typeof error &&
+              null !== error &&
+              error.$$typeof === REACT_POSTPONE_TYPE
+                ? logPostpone(request, error.message, errorInfo, null)
+                : logRecoverableError(request, error, errorInfo, null),
+              trackPostpone(request, _trackedPostpones2, task, segment),
+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+                return abortTask(fallbackTask, request, error);
+              }),
+              boundary.fallbackAbortableTasks.clear(),
+              finishedTask(request, boundary, segment)
+            );
+          boundary.status = CLIENT_RENDERED;
+          if (
+            "object" === typeof error &&
+            null !== error &&
+            error.$$typeof === REACT_POSTPONE_TYPE
+          ) {
+            logPostpone(request, error.message, errorInfo, null);
+            if (null !== request.trackedPostpones && null !== segment) {
+              trackPostpone(request, request.trackedPostpones, task, segment);
+              finishedTask(request, task.blockedBoundary, segment);
+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+                return abortTask(fallbackTask, request, error);
+              });
+              boundary.fallbackAbortableTasks.clear();
+              return;
+            }
+            task = "POSTPONE";
+          } else task = logRecoverableError(request, error, errorInfo, null);
+          boundary.status = CLIENT_RENDERED;
+          encodeErrorForBoundary(boundary, task, error, errorInfo, !0);
+          untrackBoundary(request, boundary);
+          boundary.parentFlushed &&
+            request.clientRenderedBoundaries.push(boundary);
+        }
+        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+          return abortTask(fallbackTask, request, error);
+        });
+        boundary.fallbackAbortableTasks.clear();
+      }
       request.allPendingTasks--;
       0 === request.allPendingTasks && completeAll(request);
     }
@@ -6459,12 +7005,11 @@
           }
         }
       } catch (error) {
-        logRecoverableError(request, error, {});
+        logRecoverableError(request, error, {}, null);
       }
     }
     function completeShell(request) {
       null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-      null === request.trackedPostpones && preparePreamble(request);
       request.onShellError = noop;
       request = request.onShellReady;
       request();
@@ -6477,7 +7022,6 @@
           : null === request.completedRootSegment ||
               request.completedRootSegment.status !== POSTPONED
       );
-      preparePreamble(request);
       request = request.onAllReady;
       request();
     }
@@ -6522,11 +7066,7 @@
                     abortTaskSoft,
                     request
                   ),
-                  boundary.fallbackAbortableTasks.clear(),
-                  0 === request.pendingRootTasks &&
-                    null === request.trackedPostpones &&
-                    null !== boundary.contentPreamble &&
-                    preparePreamble(request)))
+                  boundary.fallbackAbortableTasks.clear()))
               : null !== segment &&
                 segment.parentFlushed &&
                 segment.status === COMPLETED &&
@@ -6614,7 +7154,8 @@
                         : x,
                       errorInfo,
                       request.replay.nodes,
-                      request.replay.slots
+                      request.replay.slots,
+                      request.debugTask
                     );
                     request$jscomp$0.pendingRootTasks--;
                     0 === request$jscomp$0.pendingRootTasks &&
@@ -6627,88 +7168,168 @@
                   currentTaskInDEV = prevTaskInDEV;
                 }
               }
-            } else {
-              request$jscomp$0 = prevTaskInDEV = void 0;
-              var task$jscomp$0 = task,
-                segment$jscomp$0 = segment;
-              if (segment$jscomp$0.status === PENDING) {
-                segment$jscomp$0.status = 6;
-                switchContext(task$jscomp$0.context);
-                request$jscomp$0 = currentTaskInDEV;
-                currentTaskInDEV = task$jscomp$0;
-                var childrenLength = segment$jscomp$0.children.length,
-                  chunkLength = segment$jscomp$0.chunks.length;
-                try {
-                  retryNode(request, task$jscomp$0),
-                    segment$jscomp$0.lastPushedText &&
-                      segment$jscomp$0.textEmbedded &&
-                      segment$jscomp$0.chunks.push(textSeparator),
-                    task$jscomp$0.abortSet.delete(task$jscomp$0),
-                    (segment$jscomp$0.status = COMPLETED),
-                    finishedTask(
-                      request,
-                      task$jscomp$0.blockedBoundary,
-                      segment$jscomp$0
-                    );
-                } catch (thrownValue) {
-                  resetHooksState();
-                  segment$jscomp$0.children.length = childrenLength;
-                  segment$jscomp$0.chunks.length = chunkLength;
-                  var x$jscomp$0 =
-                    thrownValue === SuspenseException
-                      ? getSuspendedThenable()
-                      : 12 === request.status
-                        ? request.fatalError
-                        : thrownValue;
-                  if (
-                    "object" === typeof x$jscomp$0 &&
-                    null !== x$jscomp$0 &&
-                    "function" === typeof x$jscomp$0.then
-                  ) {
-                    segment$jscomp$0.status = PENDING;
-                    task$jscomp$0.thenableState =
-                      getThenableStateAfterSuspending();
-                    var ping$jscomp$0 = task$jscomp$0.ping;
-                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-                  } else {
-                    var errorInfo$jscomp$0 = getThrownInfo(
-                      task$jscomp$0.componentStack
-                    );
-                    task$jscomp$0.abortSet.delete(task$jscomp$0);
-                    segment$jscomp$0.status = 4;
-                    var boundary = task$jscomp$0.blockedBoundary;
-                    prevTaskInDEV = logRecoverableError(
-                      request,
-                      x$jscomp$0,
-                      errorInfo$jscomp$0
-                    );
-                    null === boundary
-                      ? fatalError(request, x$jscomp$0)
-                      : (boundary.pendingTasks--,
-                        boundary.status !== CLIENT_RENDERED &&
-                          ((boundary.status = CLIENT_RENDERED),
-                          encodeErrorForBoundary(
-                            boundary,
-                            prevTaskInDEV,
+            } else
+              a: {
+                request$jscomp$0 = prevTaskInDEV = void 0;
+                var task$jscomp$0 = task,
+                  segment$jscomp$0 = segment;
+                if (segment$jscomp$0.status === PENDING) {
+                  segment$jscomp$0.status = 6;
+                  switchContext(task$jscomp$0.context);
+                  request$jscomp$0 = currentTaskInDEV;
+                  currentTaskInDEV = task$jscomp$0;
+                  var childrenLength = segment$jscomp$0.children.length,
+                    chunkLength = segment$jscomp$0.chunks.length;
+                  try {
+                    retryNode(request, task$jscomp$0),
+                      segment$jscomp$0.lastPushedText &&
+                        segment$jscomp$0.textEmbedded &&
+                        segment$jscomp$0.chunks.push(textSeparator),
+                      task$jscomp$0.abortSet.delete(task$jscomp$0),
+                      (segment$jscomp$0.status = COMPLETED),
+                      finishedTask(
+                        request,
+                        task$jscomp$0.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                  } catch (thrownValue) {
+                    resetHooksState();
+                    segment$jscomp$0.children.length = childrenLength;
+                    segment$jscomp$0.chunks.length = chunkLength;
+                    var x$jscomp$0 =
+                      thrownValue === SuspenseException
+                        ? getSuspendedThenable()
+                        : 12 === request.status
+                          ? request.fatalError
+                          : thrownValue;
+                    if (
+                      12 === request.status &&
+                      null !== request.trackedPostpones
+                    ) {
+                      var trackedPostpones = request.trackedPostpones,
+                        thrownInfo = getThrownInfo(
+                          task$jscomp$0.componentStack
+                        );
+                      task$jscomp$0.abortSet.delete(task$jscomp$0);
+                      "object" === typeof x$jscomp$0 &&
+                      null !== x$jscomp$0 &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ? logPostpone(
+                            request,
+                            x$jscomp$0.message,
+                            thrownInfo,
+                            task$jscomp$0.debugTask
+                          )
+                        : logRecoverableError(
+                            request,
                             x$jscomp$0,
+                            thrownInfo,
+                            task$jscomp$0.debugTask
+                          );
+                      trackPostpone(
+                        request,
+                        trackedPostpones,
+                        task$jscomp$0,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task$jscomp$0.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                    } else {
+                      if (
+                        "object" === typeof x$jscomp$0 &&
+                        null !== x$jscomp$0
+                      ) {
+                        if ("function" === typeof x$jscomp$0.then) {
+                          segment$jscomp$0.status = PENDING;
+                          task$jscomp$0.thenableState =
+                            getThenableStateAfterSuspending();
+                          var ping$jscomp$0 = task$jscomp$0.ping;
+                          x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                          break a;
+                        }
+                        if (
+                          null !== request.trackedPostpones &&
+                          x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ) {
+                          var _trackedPostpones3 = request.trackedPostpones;
+                          task$jscomp$0.abortSet.delete(task$jscomp$0);
+                          var postponeInfo = getThrownInfo(
+                            task$jscomp$0.componentStack
+                          );
+                          logPostpone(
+                            request,
+                            x$jscomp$0.message,
+                            postponeInfo,
+                            task$jscomp$0.debugTask
+                          );
+                          trackPostpone(
+                            request,
+                            _trackedPostpones3,
+                            task$jscomp$0,
+                            segment$jscomp$0
+                          );
+                          finishedTask(
+                            request,
+                            task$jscomp$0.blockedBoundary,
+                            segment$jscomp$0
+                          );
+                          break a;
+                        }
+                      }
+                      var errorInfo$jscomp$0 = getThrownInfo(
+                        task$jscomp$0.componentStack
+                      );
+                      task$jscomp$0.abortSet.delete(task$jscomp$0);
+                      segment$jscomp$0.status = 4;
+                      var boundary = task$jscomp$0.blockedBoundary,
+                        debugTask = task$jscomp$0.debugTask;
+                      "object" === typeof x$jscomp$0 &&
+                      null !== x$jscomp$0 &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                        ? (logPostpone(
+                            request,
+                            x$jscomp$0.message,
                             errorInfo$jscomp$0,
-                            !1
+                            debugTask
                           ),
-                          untrackBoundary(request, boundary),
-                          boundary.parentFlushed &&
-                            request.clientRenderedBoundaries.push(boundary),
-                          0 === request.pendingRootTasks &&
-                            null === request.trackedPostpones &&
-                            null !== boundary.contentPreamble &&
-                            preparePreamble(request)));
-                    request.allPendingTasks--;
-                    0 === request.allPendingTasks && completeAll(request);
+                          (prevTaskInDEV = "POSTPONE"))
+                        : (prevTaskInDEV = logRecoverableError(
+                            request,
+                            x$jscomp$0,
+                            errorInfo$jscomp$0,
+                            debugTask
+                          ));
+                      null === boundary
+                        ? fatalError(
+                            request,
+                            x$jscomp$0,
+                            errorInfo$jscomp$0,
+                            debugTask
+                          )
+                        : (boundary.pendingTasks--,
+                          boundary.status !== CLIENT_RENDERED &&
+                            ((boundary.status = CLIENT_RENDERED),
+                            encodeErrorForBoundary(
+                              boundary,
+                              prevTaskInDEV,
+                              x$jscomp$0,
+                              errorInfo$jscomp$0,
+                              !1
+                            ),
+                            untrackBoundary(request, boundary),
+                            boundary.parentFlushed &&
+                              request.clientRenderedBoundaries.push(boundary)));
+                      request.allPendingTasks--;
+                      0 === request.allPendingTasks && completeAll(request);
+                    }
+                  } finally {
+                    currentTaskInDEV = request$jscomp$0;
                   }
-                } finally {
-                  currentTaskInDEV = request$jscomp$0;
                 }
               }
-            }
           }
           pingedTasks.splice(0, i);
           null !== request$jscomp$1.destination &&
@@ -6717,8 +7338,9 @@
               request$jscomp$1.destination
             );
         } catch (error) {
-          logRecoverableError(request$jscomp$1, error, {}),
-            fatalError(request$jscomp$1, error);
+          (pingedTasks = {}),
+            logRecoverableError(request$jscomp$1, error, pingedTasks, null),
+            fatalError(request$jscomp$1, error, pingedTasks, null);
         } finally {
           (currentResumableState = prevResumableState),
             (ReactSharedInternals.H = prevDispatcher),
@@ -6729,85 +7351,6 @@
         }
       }
     }
-    function preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    ) {
-      segment.preambleChildren.length &&
-        collectedPreambleSegments.push(segment.preambleChildren);
-      for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-        pendingPreambles =
-          preparePreambleFromSegment(
-            request,
-            segment.children[i],
-            collectedPreambleSegments
-          ) || pendingPreambles;
-      return pendingPreambles;
-    }
-    function preparePreambleFromSegment(
-      request,
-      segment,
-      collectedPreambleSegments
-    ) {
-      var boundary = segment.boundary;
-      if (null === boundary)
-        return preparePreambleFromSubtree(
-          request,
-          segment,
-          collectedPreambleSegments
-        );
-      var preamble = boundary.contentPreamble,
-        fallbackPreamble = boundary.fallbackPreamble;
-      if (null === preamble || null === fallbackPreamble) return !1;
-      switch (boundary.status) {
-        case COMPLETED:
-          hoistPreambleState(request.renderState, preamble);
-          segment = boundary.completedSegments[0];
-          if (!segment)
-            throw Error(
-              "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
-            );
-          return preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          );
-        case POSTPONED:
-          if (null !== request.trackedPostpones) return !0;
-        case CLIENT_RENDERED:
-          if (segment.status === COMPLETED)
-            return (
-              hoistPreambleState(request.renderState, fallbackPreamble),
-              preparePreambleFromSubtree(
-                request,
-                segment,
-                collectedPreambleSegments
-              )
-            );
-        default:
-          return !0;
-      }
-    }
-    function preparePreamble(request) {
-      if (
-        request.completedRootSegment &&
-        null === request.completedPreambleSegments
-      ) {
-        var collectedPreambleSegments = [],
-          hasPendingPreambles = preparePreambleFromSegment(
-            request,
-            request.completedRootSegment,
-            collectedPreambleSegments
-          ),
-          preamble = request.renderState.preamble;
-        if (
-          !1 === hasPendingPreambles ||
-          (preamble.headChunks && preamble.bodyChunks)
-        )
-          request.completedPreambleSegments = collectedPreambleSegments;
-      }
-    }
     function flushSubtree(request, destination, segment, hoistableState) {
       segment.parentFlushed = !0;
       switch (segment.status) {
@@ -6973,40 +7516,64 @@
       boundary = boundary.contentState;
       var requiresStyleInsertion = request.stylesToHoist;
       request.stylesToHoist = !1;
-      writeChunk(destination, request.startInlineScript);
-      requiresStyleInsertion
-        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-          NothingSent
-          ? ((completedSegments.instructions =
-              completedSegments.instructions |
-              SentStyleInsertionFunction |
-              SentCompleteBoundaryFunction),
-            writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))
-          : (completedSegments.instructions & SentStyleInsertionFunction) ===
+      var scriptFormat =
+        completedSegments.streamingFormat === ScriptStreamingFormat;
+      scriptFormat
+        ? (writeChunk(destination, request.startInlineScript),
+          requiresStyleInsertion
+            ? (completedSegments.instructions &
+                SentCompleteBoundaryFunction) ===
               NothingSent
-            ? ((completedSegments.instructions |= SentStyleInsertionFunction),
-              writeChunk(
-                destination,
-                completeBoundaryWithStylesScript1FullPartial
-              ))
-            : writeChunk(destination, completeBoundaryWithStylesScript1Partial)
-        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===
-            NothingSent
-          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),
-            writeChunk(destination, completeBoundaryScript1Full))
-          : writeChunk(destination, completeBoundaryScript1Partial);
+              ? ((completedSegments.instructions =
+                  completedSegments.instructions |
+                  SentStyleInsertionFunction |
+                  SentCompleteBoundaryFunction),
+                writeChunk(
+                  destination,
+                  completeBoundaryWithStylesScript1FullBoth
+                ))
+              : (completedSegments.instructions &
+                    SentStyleInsertionFunction) ===
+                  NothingSent
+                ? ((completedSegments.instructions |=
+                    SentStyleInsertionFunction),
+                  writeChunk(
+                    destination,
+                    completeBoundaryWithStylesScript1FullPartial
+                  ))
+                : writeChunk(
+                    destination,
+                    completeBoundaryWithStylesScript1Partial
+                  )
+            : (completedSegments.instructions &
+                  SentCompleteBoundaryFunction) ===
+                NothingSent
+              ? ((completedSegments.instructions |=
+                  SentCompleteBoundaryFunction),
+                writeChunk(destination, completeBoundaryScript1Full))
+              : writeChunk(destination, completeBoundaryScript1Partial))
+        : requiresStyleInsertion
+          ? writeChunk(destination, completeBoundaryWithStylesData1)
+          : writeChunk(destination, completeBoundaryData1);
       completedSegments = i.toString(16);
       writeChunk(destination, request.boundaryPrefix);
       writeChunk(destination, completedSegments);
-      writeChunk(destination, completeBoundaryScript2);
+      scriptFormat
+        ? writeChunk(destination, completeBoundaryScript2)
+        : writeChunk(destination, completeBoundaryData2);
       writeChunk(destination, request.segmentPrefix);
       writeChunk(destination, completedSegments);
       requiresStyleInsertion
-        ? (writeChunk(destination, completeBoundaryScript3a),
-          writeStyleResourceDependenciesInJS(destination, boundary))
-        : writeChunk(destination, completeBoundaryScript3b);
-      boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
-      return writeBootstrap(destination, request) && boundary;
+        ? scriptFormat
+          ? (writeChunk(destination, completeBoundaryScript3a),
+            writeStyleResourceDependenciesInJS(destination, boundary))
+          : (writeChunk(destination, completeBoundaryData3a),
+            writeStyleResourceDependenciesInAttr(destination, boundary))
+        : scriptFormat && writeChunk(destination, completeBoundaryScript3b);
+      completedSegments = scriptFormat
+        ? writeChunkAndReturn(destination, completeBoundaryScriptEnd)
+        : writeChunkAndReturn(destination, completeBoundaryDataEnd);
+      return writeBootstrap(destination, request) && completedSegments;
     }
     function flushPartiallyCompletedSegment(
       request,
@@ -7039,18 +7606,24 @@
       flushSegmentContainer(request, destination, segment, hoistableState);
       boundary = request.resumableState;
       request = request.renderState;
-      writeChunk(destination, request.startInlineScript);
-      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
-        ? ((boundary.instructions |= SentCompleteSegmentFunction),
-          writeChunk(destination, completeSegmentScript1Full))
-        : writeChunk(destination, completeSegmentScript1Partial);
+      (segment = boundary.streamingFormat === ScriptStreamingFormat)
+        ? (writeChunk(destination, request.startInlineScript),
+          (boundary.instructions & SentCompleteSegmentFunction) === NothingSent
+            ? ((boundary.instructions |= SentCompleteSegmentFunction),
+              writeChunk(destination, completeSegmentScript1Full))
+            : writeChunk(destination, completeSegmentScript1Partial))
+        : writeChunk(destination, completeSegmentData1);
       writeChunk(destination, request.segmentPrefix);
       segmentID = segmentID.toString(16);
       writeChunk(destination, segmentID);
-      writeChunk(destination, completeSegmentScript2);
+      segment
+        ? writeChunk(destination, completeSegmentScript2)
+        : writeChunk(destination, completeSegmentData2);
       writeChunk(destination, request.placeholderPrefix);
       writeChunk(destination, segmentID);
-      destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
+      destination = segment
+        ? writeChunkAndReturn(destination, completeSegmentScriptEnd)
+        : writeChunkAndReturn(destination, completeSegmentDataEnd);
       return destination;
     }
     function flushCompletedQueues(request, destination) {
@@ -7063,12 +7636,22 @@
             completedRootSegment = request.completedRootSegment;
           if (null !== completedRootSegment) {
             if (completedRootSegment.status === POSTPONED) return;
-            var completedPreambleSegments = request.completedPreambleSegments;
-            if (null === completedPreambleSegments) return;
-            var renderState = request.renderState,
-              preamble = renderState.preamble,
-              htmlChunks = preamble.htmlChunks,
-              headChunks = preamble.headChunks,
+            var renderState = request.renderState;
+            if (
+              (0 !== request.allPendingTasks ||
+                null !== request.trackedPostpones) &&
+              renderState.externalRuntimeScript
+            ) {
+              var _renderState$external = renderState.externalRuntimeScript,
+                resumableState = request.resumableState,
+                src = _renderState$external.src,
+                chunks = _renderState$external.chunks;
+              resumableState.scriptResources.hasOwnProperty(src) ||
+                ((resumableState.scriptResources[src] = EXISTS),
+                renderState.scripts.add(chunks));
+            }
+            var htmlChunks = renderState.htmlChunks,
+              headChunks = renderState.headChunks,
               i$jscomp$0;
             if (htmlChunks) {
               for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -7129,27 +7712,10 @@
               i$jscomp$0++
             )
               writeChunk(destination, hoistableChunks[i$jscomp$0]);
-            for (
-              renderState = hoistableChunks.length = 0;
-              renderState < completedPreambleSegments.length;
-              renderState++
-            ) {
-              var segments = completedPreambleSegments[renderState];
-              for (preamble = 0; preamble < segments.length; preamble++)
-                flushSegment(request, destination, segments[preamble], null);
-            }
-            var preamble$jscomp$0 = request.renderState.preamble,
-              headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-            (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) &&
+            hoistableChunks.length = 0;
+            htmlChunks &&
+              null === headChunks &&
               writeChunk(destination, endChunkForTag("head"));
-            var bodyChunks = preamble$jscomp$0.bodyChunks;
-            if (bodyChunks)
-              for (
-                completedPreambleSegments = 0;
-                completedPreambleSegments < bodyChunks.length;
-                completedPreambleSegments++
-              )
-                writeChunk(destination, bodyChunks[completedPreambleSegments]);
             flushSegment(request, destination, completedRootSegment, null);
             request.completedRootSegment = null;
             writeBootstrap(destination, request.renderState);
@@ -7196,73 +7762,107 @@
           for (i = 0; i < clientRenderedBoundaries.length; i++) {
             var boundary = clientRenderedBoundaries[i];
             renderState$jscomp$0 = destination;
-            var resumableState = request.resumableState,
+            var resumableState$jscomp$0 = request.resumableState,
               renderState$jscomp$1 = request.renderState,
               id = boundary.rootSegmentID,
               errorDigest = boundary.errorDigest,
               errorMessage = boundary.errorMessage,
               errorStack = boundary.errorStack,
-              errorComponentStack = boundary.errorComponentStack;
-            writeChunk(
-              renderState$jscomp$0,
-              renderState$jscomp$1.startInlineScript
-            );
-            (resumableState.instructions & SentClientRenderFunction) ===
-            NothingSent
-              ? ((resumableState.instructions |= SentClientRenderFunction),
-                writeChunk(renderState$jscomp$0, clientRenderScript1Full))
-              : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
+              errorComponentStack = boundary.errorComponentStack,
+              scriptFormat =
+                resumableState$jscomp$0.streamingFormat ===
+                ScriptStreamingFormat;
+            scriptFormat
+              ? (writeChunk(
+                  renderState$jscomp$0,
+                  renderState$jscomp$1.startInlineScript
+                ),
+                (resumableState$jscomp$0.instructions &
+                  SentClientRenderFunction) ===
+                NothingSent
+                  ? ((resumableState$jscomp$0.instructions |=
+                      SentClientRenderFunction),
+                    writeChunk(renderState$jscomp$0, clientRenderScript1Full))
+                  : writeChunk(
+                      renderState$jscomp$0,
+                      clientRenderScript1Partial
+                    ))
+              : writeChunk(renderState$jscomp$0, clientRenderData1);
             writeChunk(
               renderState$jscomp$0,
               renderState$jscomp$1.boundaryPrefix
             );
             writeChunk(renderState$jscomp$0, id.toString(16));
-            writeChunk(renderState$jscomp$0, clientRenderScript1A);
+            scriptFormat &&
+              writeChunk(renderState$jscomp$0, clientRenderScript1A);
             if (
               errorDigest ||
               errorMessage ||
               errorStack ||
               errorComponentStack
             )
-              writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-                writeChunk(
-                  renderState$jscomp$0,
-                  escapeJSStringsForInstructionScripts(errorDigest || "")
-                );
+              scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    escapeJSStringsForInstructionScripts(errorDigest || "")
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData2),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    escapeTextForBrowser(errorDigest || "")
+                  ));
             if (errorMessage || errorStack || errorComponentStack)
-              writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-                writeChunk(
-                  renderState$jscomp$0,
-                  escapeJSStringsForInstructionScripts(errorMessage || "")
-                );
+              scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    escapeJSStringsForInstructionScripts(errorMessage || "")
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData3),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    escapeTextForBrowser(errorMessage || "")
+                  ));
             if (errorStack || errorComponentStack)
-              writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-                writeChunk(
-                  renderState$jscomp$0,
-                  escapeJSStringsForInstructionScripts(errorStack || "")
-                );
+              scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    escapeJSStringsForInstructionScripts(errorStack || "")
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData4),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    escapeTextForBrowser(errorStack || "")
+                  ));
             errorComponentStack &&
-              (writeChunk(
-                renderState$jscomp$0,
-                clientRenderErrorScriptArgInterstitial
-              ),
-              writeChunk(
-                renderState$jscomp$0,
-                escapeJSStringsForInstructionScripts(errorComponentStack)
-              ));
-            var JSCompiler_inline_result = writeChunkAndReturn(
-              renderState$jscomp$0,
-              clientRenderScriptEnd
-            );
+              (scriptFormat
+                ? (writeChunk(
+                    renderState$jscomp$0,
+                    clientRenderErrorScriptArgInterstitial
+                  ),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    escapeJSStringsForInstructionScripts(errorComponentStack)
+                  ))
+                : (writeChunk(renderState$jscomp$0, clientRenderData5),
+                  writeChunk(
+                    renderState$jscomp$0,
+                    escapeTextForBrowser(errorComponentStack)
+                  )));
+            var JSCompiler_inline_result = scriptFormat
+              ? writeChunkAndReturn(renderState$jscomp$0, clientRenderScriptEnd)
+              : writeChunkAndReturn(renderState$jscomp$0, clientRenderDataEnd);
             if (!JSCompiler_inline_result) {
               request.destination = null;
               i++;
@@ -7348,9 +7948,10 @@
         0 === request.clientRenderedBoundaries.length &&
         0 === request.completedBoundaries.length
           ? ((request.flushScheduled = !1),
-            (i = request.resumableState),
-            i.hasBody && writeChunk(destination, endChunkForTag("body")),
-            i.hasHtml && writeChunk(destination, endChunkForTag("html")),
+            null === request.trackedPostpones &&
+              ((i = request.resumableState),
+              i.hasBody && writeChunk(destination, endChunkForTag("body")),
+              i.hasHtml && writeChunk(destination, endChunkForTag("html"))),
             completeWriting(destination),
             flushBuffered(destination),
             0 !== request.abortableTasks.size &&
@@ -7401,7 +8002,9 @@
         try {
           flushCompletedQueues(request, destination);
         } catch (error) {
-          logRecoverableError(request, error, {}), fatalError(request, error);
+          (destination = {}),
+            logRecoverableError(request, error, destination, null),
+            fatalError(request, error, destination, null);
         }
       }
     }
@@ -7427,16 +8030,69 @@
         null !== request.destination &&
           flushCompletedQueues(request, request.destination);
       } catch (error$4) {
-        logRecoverableError(request, error$4, {}), fatalError(request, error$4);
+        (reason = {}),
+          logRecoverableError(request, error$4, reason, null),
+          fatalError(request, error$4, reason, null);
+      }
+    }
+    function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+      if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+      else {
+        var workingMap = trackedPostpones.workingMap,
+          parentNode = workingMap.get(parentKeyPath);
+        void 0 === parentNode &&
+          ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+          workingMap.set(parentKeyPath, parentNode),
+          addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+        parentNode[2].push(node);
       }
     }
+    function getPostponedState(request) {
+      var trackedPostpones = request.trackedPostpones;
+      if (
+        null === trackedPostpones ||
+        (0 === trackedPostpones.rootNodes.length &&
+          null === trackedPostpones.rootSlots)
+      )
+        return (request.trackedPostpones = null);
+      if (
+        null !== request.completedRootSegment &&
+        request.completedRootSegment.status === POSTPONED
+      ) {
+        var resumableState = request.resumableState,
+          renderState = request.renderState;
+        resumableState.nextFormID = 0;
+        resumableState.hasBody = !1;
+        resumableState.hasHtml = !1;
+        resumableState.unknownResources = { font: renderState.resets.font };
+        resumableState.dnsResources = renderState.resets.dns;
+        resumableState.connectResources = renderState.resets.connect;
+        resumableState.imageResources = renderState.resets.image;
+        resumableState.styleResources = renderState.resets.style;
+        resumableState.scriptResources = {};
+        resumableState.moduleUnknownResources = {};
+        resumableState.moduleScriptResources = {};
+      } else
+        (resumableState = request.resumableState),
+          (resumableState.bootstrapScriptContent = void 0),
+          (resumableState.bootstrapScripts = void 0),
+          (resumableState.bootstrapModules = void 0);
+      return {
+        nextSegmentId: request.nextSegmentId,
+        rootFormatContext: request.rootFormatContext,
+        progressiveChunkSize: request.progressiveChunkSize,
+        resumableState: request.resumableState,
+        replayNodes: trackedPostpones.rootNodes,
+        replaySlots: trackedPostpones.rootSlots
+      };
+    }
     function ensureCorrectIsomorphicReactVersion() {
       var isomorphicReactPackageVersion = React.version;
-      if ("19.1.0-canary-c492f975-20250128" !== isomorphicReactPackageVersion)
+      if ("19.1.0-experimental-b3a95caf-20250113" !== isomorphicReactPackageVersion)
         throw Error(
           'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
             (isomorphicReactPackageVersion +
-              "\n  - react-dom:  19.1.0-canary-c492f975-20250128\nLearn more: https://react.dev/warnings/version-mismatch")
+              "\n  - react-dom:  19.1.0-experimental-b3a95caf-20250113\nLearn more: https://react.dev/warnings/version-mismatch")
         );
     }
     function createDrainHandler(destination, request) {
@@ -7480,6 +8136,26 @@
         options ? options.formState : void 0
       );
     }
+    function resumeRequestImpl(children, postponedState, options) {
+      return resumeRequest(
+        children,
+        postponedState,
+        createRenderState(
+          postponedState.resumableState,
+          options ? options.nonce : void 0,
+          void 0,
+          void 0,
+          void 0,
+          void 0
+        ),
+        options ? options.onError : void 0,
+        options ? options.onAllReady : void 0,
+        options ? options.onShellReady : void 0,
+        options ? options.onShellError : void 0,
+        void 0,
+        options ? options.onPostpone : void 0
+      );
+    }
     function createFakeWritable(readable) {
       return {
         write: function (chunk) {
@@ -7515,9 +8191,10 @@
       REACT_SCOPE_TYPE = Symbol.for("react.scope"),
       REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
       REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-      REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+      REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
       REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
       MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+      ASYNC_ITERATOR = Symbol.asyncIterator,
       isArrayImpl = Array.isArray,
       jsxPropsParents = new WeakMap(),
       jsxChildrenParents = new WeakMap(),
@@ -8564,7 +9241,8 @@
         } else previousDispatcher.M(src, options);
       }
     };
-    var NothingSent = 0,
+    var ScriptStreamingFormat = 0,
+      NothingSent = 0,
       SentCompleteSegmentFunction = 1,
       SentCompleteBoundaryFunction = 2,
       SentClientRenderFunction = 4,
@@ -8572,8 +9250,8 @@
       EXISTS = null,
       PRELOAD_NO_CREDS = [];
     Object.freeze(PRELOAD_NO_CREDS);
-    stringToPrecomputedChunk('"></template>');
-    var startInlineScript = stringToPrecomputedChunk("<script>"),
+    var dataElementQuotedEnd = stringToPrecomputedChunk('"></template>'),
+      startInlineScript = stringToPrecomputedChunk("<script>"),
       endInlineScript = stringToPrecomputedChunk("\x3c/script>"),
       startScriptSrc = stringToPrecomputedChunk('<script src="'),
       startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'),
@@ -8590,13 +9268,12 @@
     var ROOT_HTML_MODE = 0,
       HTML_HTML_MODE = 1,
       HTML_MODE = 2,
-      HTML_HEAD_MODE = 3,
-      SVG_MODE = 4,
-      MATHML_MODE = 5,
-      HTML_TABLE_MODE = 6,
-      HTML_TABLE_BODY_MODE = 7,
-      HTML_TABLE_ROW_MODE = 8,
-      HTML_COLGROUP_MODE = 9,
+      SVG_MODE = 3,
+      MATHML_MODE = 4,
+      HTML_TABLE_MODE = 5,
+      HTML_TABLE_BODY_MODE = 6,
+      HTML_TABLE_ROW_MODE = 7,
+      HTML_COLGROUP_MODE = 8,
       textSeparator = stringToPrecomputedChunk("\x3c!-- --\x3e"),
       styleNameCache = new Map(),
       styleAttributeStart = stringToPrecomputedChunk(' style="'),
@@ -8696,10 +9373,13 @@
       ),
       completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'),
       completeSegmentScript2 = stringToPrecomputedChunk('","'),
-      completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>');
-    stringToPrecomputedChunk('<template data-rsi="" data-sid="');
-    stringToPrecomputedChunk('" data-pid="');
-    var completeBoundaryScript1Full = stringToPrecomputedChunk(
+      completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>'),
+      completeSegmentData1 = stringToPrecomputedChunk(
+        '<template data-rsi="" data-sid="'
+      ),
+      completeSegmentData2 = stringToPrecomputedChunk('" data-pid="'),
+      completeSegmentDataEnd = dataElementQuotedEnd,
+      completeBoundaryScript1Full = stringToPrecomputedChunk(
         '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
       ),
       completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'),
@@ -8714,24 +9394,32 @@
       completeBoundaryScript2 = stringToPrecomputedChunk('","'),
       completeBoundaryScript3a = stringToPrecomputedChunk('",'),
       completeBoundaryScript3b = stringToPrecomputedChunk('"'),
-      completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-    stringToPrecomputedChunk('<template data-rci="" data-bid="');
-    stringToPrecomputedChunk('<template data-rri="" data-bid="');
-    stringToPrecomputedChunk('" data-sid="');
-    stringToPrecomputedChunk('" data-sty="');
-    var clientRenderScript1Full = stringToPrecomputedChunk(
+      completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+      completeBoundaryData1 = stringToPrecomputedChunk(
+        '<template data-rci="" data-bid="'
+      ),
+      completeBoundaryWithStylesData1 = stringToPrecomputedChunk(
+        '<template data-rri="" data-bid="'
+      ),
+      completeBoundaryData2 = stringToPrecomputedChunk('" data-sid="'),
+      completeBoundaryData3a = stringToPrecomputedChunk('" data-sty="'),
+      completeBoundaryDataEnd = dataElementQuotedEnd,
+      clientRenderScript1Full = stringToPrecomputedChunk(
         '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
       ),
       clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'),
       clientRenderScript1A = stringToPrecomputedChunk('"'),
       clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","),
-      clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-    stringToPrecomputedChunk('<template data-rxi="" data-bid="');
-    stringToPrecomputedChunk('" data-dgst="');
-    stringToPrecomputedChunk('" data-msg="');
-    stringToPrecomputedChunk('" data-stck="');
-    stringToPrecomputedChunk('" data-cstck="');
-    var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g,
+      clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+      clientRenderData1 = stringToPrecomputedChunk(
+        '<template data-rxi="" data-bid="'
+      ),
+      clientRenderData2 = stringToPrecomputedChunk('" data-dgst="'),
+      clientRenderData3 = stringToPrecomputedChunk('" data-msg="'),
+      clientRenderData4 = stringToPrecomputedChunk('" data-stck="'),
+      clientRenderData5 = stringToPrecomputedChunk('" data-cstck="'),
+      clientRenderDataEnd = dataElementQuotedEnd,
+      regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g,
       regexForJSStringsInScripts = /[&><\u2028\u2029]/g,
       lateStyleTagResourceOpen1 = stringToPrecomputedChunk(
         '<style media="not all" data-precedence="'
@@ -8918,13 +9606,8 @@
           resolveCurrentlyRenderingComponent();
           return NotPending;
         },
-        useMemoCache: function (size) {
-          for (var data = Array(size), i = 0; i < size; i++)
-            data[i] = REACT_MEMO_CACHE_SENTINEL;
-          return data;
-        },
-        useCacheRefresh: function () {
-          return unsupportedRefresh;
+        useEffectEvent: function () {
+          return throwOnUseEffectEventCall;
         }
       },
       currentResumableState = null,
@@ -9021,7 +9704,11 @@
                   }
                 }),
                 writable = createFakeWritable(readable);
-              resolve({ prelude: readable });
+              readable = {
+                postponed: getPostponedState(request),
+                prelude: readable
+              };
+              resolve(readable);
             },
             void 0,
             void 0,
@@ -9081,5 +9768,90 @@
         }
       };
     };
-    exports.version = "19.1.0-canary-c492f975-20250128";
+    exports.resumeAndPrerenderToNodeStream = function (
+      children,
+      postponedState,
+      options
+    ) {
+      return new Promise(function (resolve, reject) {
+        var request = resumeAndPrerenderRequest(
+          children,
+          postponedState,
+          createRenderState(
+            postponedState.resumableState,
+            options ? options.nonce : void 0,
+            void 0,
+            void 0,
+            void 0,
+            void 0
+          ),
+          options ? options.onError : void 0,
+          function () {
+            var readable = new stream.Readable({
+                read: function () {
+                  startFlowing(request, writable);
+                }
+              }),
+              writable = createFakeWritable(readable);
+            readable = {
+              postponed: getPostponedState(request),
+              prelude: readable
+            };
+            resolve(readable);
+          },
+          void 0,
+          void 0,
+          reject,
+          options ? options.onPostpone : void 0
+        );
+        if (options && options.signal) {
+          var signal = options.signal;
+          if (signal.aborted) abort(request, signal.reason);
+          else {
+            var listener = function () {
+              abort(request, signal.reason);
+              signal.removeEventListener("abort", listener);
+            };
+            signal.addEventListener("abort", listener);
+          }
+        }
+        startWork(request);
+      });
+    };
+    exports.resumeToPipeableStream = function (
+      children,
+      postponedState,
+      options
+    ) {
+      var request = resumeRequestImpl(children, postponedState, options),
+        hasStartedFlowing = !1;
+      startWork(request);
+      return {
+        pipe: function (destination) {
+          if (hasStartedFlowing)
+            throw Error(
+              "React currently only supports piping to one writable stream."
+            );
+          hasStartedFlowing = !0;
+          startFlowing(request, destination);
+          destination.on("drain", createDrainHandler(destination, request));
+          destination.on(
+            "error",
+            createCancelHandler(
+              request,
+              "The destination stream errored while writing data."
+            )
+          );
+          destination.on(
+            "close",
+            createCancelHandler(request, "The destination stream closed early.")
+          );
+          return destination;
+        },
+        abort: function (reason) {
+          abort(request, reason);
+        }
+      };
+    };
+    exports.version = "19.1.0-experimental-b3a95caf-20250113";
   })();
diff --git a/node_modules/react-dom/cjs/react-dom-server.node.production.js b/node_modules/react-dom/cjs/react-dom-server.node.production.js
index 7d7fb32..6921b3f 100644
--- a/node_modules/react-dom/cjs/react-dom-server.node.production.js
+++ b/node_modules/react-dom/cjs/react-dom-server.node.production.js
@@ -31,9 +31,10 @@ var util = require("util"),
   REACT_SCOPE_TYPE = Symbol.for("react.scope"),
   REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
   REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"),
-  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
   REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
   MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+  ASYNC_ITERATOR = Symbol.asyncIterator,
   isArrayImpl = Array.isArray,
   scheduleMicrotask = queueMicrotask;
 function flushBuffered(destination) {
@@ -297,9 +298,9 @@ ReactDOMSharedInternals.d = {
   S: preinitStyle,
   M: preinitModuleScript
 };
-var PRELOAD_NO_CREDS = [];
-stringToPrecomputedChunk('"></template>');
-var startInlineScript = stringToPrecomputedChunk("<script>"),
+var PRELOAD_NO_CREDS = [],
+  dataElementQuotedEnd = stringToPrecomputedChunk('"></template>'),
+  startInlineScript = stringToPrecomputedChunk("<script>"),
   endInlineScript = stringToPrecomputedChunk("\x3c/script>"),
   startScriptSrc = stringToPrecomputedChunk('<script src="'),
   startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'),
@@ -329,24 +330,44 @@ function createRenderState(
         : stringToPrecomputedChunk(
             '<script nonce="' + escapeTextForBrowser(nonce) + '">'
           ),
-    idPrefix = resumableState.idPrefix;
-  externalRuntimeConfig = [];
-  var bootstrapScriptContent = resumableState.bootstrapScriptContent,
+    idPrefix = resumableState.idPrefix,
+    bootstrapChunks = [],
+    externalRuntimeScript = null,
+    bootstrapScriptContent = resumableState.bootstrapScriptContent,
     bootstrapScripts = resumableState.bootstrapScripts,
     bootstrapModules = resumableState.bootstrapModules;
   void 0 !== bootstrapScriptContent &&
-    externalRuntimeConfig.push(
+    bootstrapChunks.push(
       inlineScriptWithNonce,
       ("" + bootstrapScriptContent).replace(scriptRegex, scriptReplacer),
       endInlineScript
     );
-  bootstrapScriptContent = [];
+  void 0 !== externalRuntimeConfig &&
+    ("string" === typeof externalRuntimeConfig
+      ? ((externalRuntimeScript = { src: externalRuntimeConfig, chunks: [] }),
+        pushScriptImpl(externalRuntimeScript.chunks, {
+          src: externalRuntimeConfig,
+          async: !0,
+          integrity: void 0,
+          nonce: nonce
+        }))
+      : ((externalRuntimeScript = {
+          src: externalRuntimeConfig.src,
+          chunks: []
+        }),
+        pushScriptImpl(externalRuntimeScript.chunks, {
+          src: externalRuntimeConfig.src,
+          async: !0,
+          integrity: externalRuntimeConfig.integrity,
+          nonce: nonce
+        })));
+  externalRuntimeConfig = [];
   void 0 !== importMap &&
-    (bootstrapScriptContent.push(importMapScriptStart),
-    bootstrapScriptContent.push(
+    (externalRuntimeConfig.push(importMapScriptStart),
+    externalRuntimeConfig.push(
       ("" + JSON.stringify(importMap)).replace(scriptRegex, scriptReplacer)
     ),
-    bootstrapScriptContent.push(importMapScriptEnd));
+    externalRuntimeConfig.push(importMapScriptEnd));
   importMap = onHeaders
     ? {
         preconnects: "",
@@ -361,10 +382,11 @@ function createRenderState(
     segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
     boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
     startInlineScript: inlineScriptWithNonce,
-    preamble: createPreambleState(),
-    externalRuntimeScript: null,
-    bootstrapChunks: externalRuntimeConfig,
-    importMapChunks: bootstrapScriptContent,
+    htmlChunks: null,
+    headChunks: null,
+    externalRuntimeScript: externalRuntimeScript,
+    bootstrapChunks: bootstrapChunks,
+    importMapChunks: externalRuntimeConfig,
     onHeaders: onHeaders,
     headers: importMap,
     resets: {
@@ -395,104 +417,104 @@ function createRenderState(
     stylesToHoist: !1
   };
   if (void 0 !== bootstrapScripts)
-    for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
-      var scriptConfig = bootstrapScripts[importMap];
-      idPrefix = inlineScriptWithNonce = void 0;
-      bootstrapScriptContent = {
-        rel: "preload",
-        as: "script",
-        fetchPriority: "low",
-        nonce: nonce
-      };
-      "string" === typeof scriptConfig
-        ? (bootstrapScriptContent.href = maxHeadersLength = scriptConfig)
-        : ((bootstrapScriptContent.href = maxHeadersLength = scriptConfig.src),
-          (bootstrapScriptContent.integrity = idPrefix =
-            "string" === typeof scriptConfig.integrity
-              ? scriptConfig.integrity
-              : void 0),
-          (bootstrapScriptContent.crossOrigin = inlineScriptWithNonce =
-            "string" === typeof scriptConfig || null == scriptConfig.crossOrigin
-              ? void 0
-              : "use-credentials" === scriptConfig.crossOrigin
-                ? "use-credentials"
-                : ""));
-      scriptConfig = resumableState;
-      var href = maxHeadersLength;
-      scriptConfig.scriptResources[href] = null;
-      scriptConfig.moduleScriptResources[href] = null;
-      scriptConfig = [];
-      pushLinkImpl(scriptConfig, bootstrapScriptContent);
-      onHeaders.bootstrapScripts.add(scriptConfig);
-      externalRuntimeConfig.push(
-        startScriptSrc,
-        escapeTextForBrowser(maxHeadersLength)
-      );
-      nonce &&
-        externalRuntimeConfig.push(scriptNonce, escapeTextForBrowser(nonce));
-      "string" === typeof idPrefix &&
-        externalRuntimeConfig.push(
-          scriptIntegirty,
-          escapeTextForBrowser(idPrefix)
-        );
-      "string" === typeof inlineScriptWithNonce &&
-        externalRuntimeConfig.push(
-          scriptCrossOrigin,
-          escapeTextForBrowser(inlineScriptWithNonce)
-        );
-      externalRuntimeConfig.push(endAsyncScript);
-    }
+    for (
+      inlineScriptWithNonce = 0;
+      inlineScriptWithNonce < bootstrapScripts.length;
+      inlineScriptWithNonce++
+    )
+      (externalRuntimeConfig = bootstrapScripts[inlineScriptWithNonce]),
+        (importMap = externalRuntimeScript = void 0),
+        (maxHeadersLength = {
+          rel: "preload",
+          as: "script",
+          fetchPriority: "low",
+          nonce: nonce
+        }),
+        "string" === typeof externalRuntimeConfig
+          ? (maxHeadersLength.href = idPrefix = externalRuntimeConfig)
+          : ((maxHeadersLength.href = idPrefix = externalRuntimeConfig.src),
+            (maxHeadersLength.integrity = importMap =
+              "string" === typeof externalRuntimeConfig.integrity
+                ? externalRuntimeConfig.integrity
+                : void 0),
+            (maxHeadersLength.crossOrigin = externalRuntimeScript =
+              "string" === typeof externalRuntimeConfig ||
+              null == externalRuntimeConfig.crossOrigin
+                ? void 0
+                : "use-credentials" === externalRuntimeConfig.crossOrigin
+                  ? "use-credentials"
+                  : "")),
+        (externalRuntimeConfig = resumableState),
+        (bootstrapScriptContent = idPrefix),
+        (externalRuntimeConfig.scriptResources[bootstrapScriptContent] = null),
+        (externalRuntimeConfig.moduleScriptResources[bootstrapScriptContent] =
+          null),
+        (externalRuntimeConfig = []),
+        pushLinkImpl(externalRuntimeConfig, maxHeadersLength),
+        onHeaders.bootstrapScripts.add(externalRuntimeConfig),
+        bootstrapChunks.push(startScriptSrc, escapeTextForBrowser(idPrefix)),
+        nonce && bootstrapChunks.push(scriptNonce, escapeTextForBrowser(nonce)),
+        "string" === typeof importMap &&
+          bootstrapChunks.push(
+            scriptIntegirty,
+            escapeTextForBrowser(importMap)
+          ),
+        "string" === typeof externalRuntimeScript &&
+          bootstrapChunks.push(
+            scriptCrossOrigin,
+            escapeTextForBrowser(externalRuntimeScript)
+          ),
+        bootstrapChunks.push(endAsyncScript);
   if (void 0 !== bootstrapModules)
     for (
       bootstrapScripts = 0;
       bootstrapScripts < bootstrapModules.length;
       bootstrapScripts++
     )
-      (bootstrapScriptContent = bootstrapModules[bootstrapScripts]),
-        (inlineScriptWithNonce = maxHeadersLength = void 0),
-        (idPrefix = {
+      (maxHeadersLength = bootstrapModules[bootstrapScripts]),
+        (externalRuntimeScript = idPrefix = void 0),
+        (importMap = {
           rel: "modulepreload",
           fetchPriority: "low",
           nonce: nonce
         }),
-        "string" === typeof bootstrapScriptContent
-          ? (idPrefix.href = importMap = bootstrapScriptContent)
-          : ((idPrefix.href = importMap = bootstrapScriptContent.src),
-            (idPrefix.integrity = inlineScriptWithNonce =
-              "string" === typeof bootstrapScriptContent.integrity
-                ? bootstrapScriptContent.integrity
+        "string" === typeof maxHeadersLength
+          ? (importMap.href = inlineScriptWithNonce = maxHeadersLength)
+          : ((importMap.href = inlineScriptWithNonce = maxHeadersLength.src),
+            (importMap.integrity = externalRuntimeScript =
+              "string" === typeof maxHeadersLength.integrity
+                ? maxHeadersLength.integrity
                 : void 0),
-            (idPrefix.crossOrigin = maxHeadersLength =
-              "string" === typeof bootstrapScriptContent ||
-              null == bootstrapScriptContent.crossOrigin
+            (importMap.crossOrigin = idPrefix =
+              "string" === typeof maxHeadersLength ||
+              null == maxHeadersLength.crossOrigin
                 ? void 0
-                : "use-credentials" === bootstrapScriptContent.crossOrigin
+                : "use-credentials" === maxHeadersLength.crossOrigin
                   ? "use-credentials"
                   : "")),
-        (bootstrapScriptContent = resumableState),
-        (scriptConfig = importMap),
-        (bootstrapScriptContent.scriptResources[scriptConfig] = null),
-        (bootstrapScriptContent.moduleScriptResources[scriptConfig] = null),
-        (bootstrapScriptContent = []),
-        pushLinkImpl(bootstrapScriptContent, idPrefix),
-        onHeaders.bootstrapScripts.add(bootstrapScriptContent),
-        externalRuntimeConfig.push(
+        (maxHeadersLength = resumableState),
+        (externalRuntimeConfig = inlineScriptWithNonce),
+        (maxHeadersLength.scriptResources[externalRuntimeConfig] = null),
+        (maxHeadersLength.moduleScriptResources[externalRuntimeConfig] = null),
+        (maxHeadersLength = []),
+        pushLinkImpl(maxHeadersLength, importMap),
+        onHeaders.bootstrapScripts.add(maxHeadersLength),
+        bootstrapChunks.push(
           startModuleSrc,
-          escapeTextForBrowser(importMap)
+          escapeTextForBrowser(inlineScriptWithNonce)
         ),
-        nonce &&
-          externalRuntimeConfig.push(scriptNonce, escapeTextForBrowser(nonce)),
-        "string" === typeof inlineScriptWithNonce &&
-          externalRuntimeConfig.push(
+        nonce && bootstrapChunks.push(scriptNonce, escapeTextForBrowser(nonce)),
+        "string" === typeof externalRuntimeScript &&
+          bootstrapChunks.push(
             scriptIntegirty,
-            escapeTextForBrowser(inlineScriptWithNonce)
+            escapeTextForBrowser(externalRuntimeScript)
           ),
-        "string" === typeof maxHeadersLength &&
-          externalRuntimeConfig.push(
+        "string" === typeof idPrefix &&
+          bootstrapChunks.push(
             scriptCrossOrigin,
-            escapeTextForBrowser(maxHeadersLength)
+            escapeTextForBrowser(idPrefix)
           ),
-        externalRuntimeConfig.push(endAsyncScript);
+        bootstrapChunks.push(endAsyncScript);
   return onHeaders;
 }
 function createResumableState(
@@ -502,10 +524,12 @@ function createResumableState(
   bootstrapScripts,
   bootstrapModules
 ) {
+  var streamingFormat = 0;
+  void 0 !== externalRuntimeConfig && (streamingFormat = 1);
   return {
     idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
     nextFormID: 0,
-    streamingFormat: 0,
+    streamingFormat: streamingFormat,
     bootstrapScriptContent: bootstrapScriptContent,
     bootstrapScripts: bootstrapScripts,
     bootstrapModules: bootstrapModules,
@@ -522,9 +546,6 @@ function createResumableState(
     moduleScriptResources: {}
   };
 }
-function createPreambleState() {
-  return { htmlChunks: null, headChunks: null, bodyChunks: null };
-}
 function createFormatContext(insertionMode, selectedValue, tagScope) {
   return {
     insertionMode: insertionMode,
@@ -535,9 +556,9 @@ function createFormatContext(insertionMode, selectedValue, tagScope) {
 function createRootFormatContext(namespaceURI) {
   return createFormatContext(
     "http://www.w3.org/2000/svg" === namespaceURI
-      ? 4
+      ? 3
       : "http://www.w3.org/1998/Math/MathML" === namespaceURI
-        ? 5
+        ? 4
         : 0,
     null,
     0
@@ -554,34 +575,33 @@ function getChildFormatContext(parentContext, type, props) {
         parentContext.tagScope
       );
     case "svg":
-      return createFormatContext(4, null, parentContext.tagScope);
+      return createFormatContext(3, null, parentContext.tagScope);
     case "picture":
       return createFormatContext(2, null, parentContext.tagScope | 2);
     case "math":
-      return createFormatContext(5, null, parentContext.tagScope);
+      return createFormatContext(4, null, parentContext.tagScope);
     case "foreignObject":
       return createFormatContext(2, null, parentContext.tagScope);
     case "table":
-      return createFormatContext(6, null, parentContext.tagScope);
+      return createFormatContext(5, null, parentContext.tagScope);
     case "thead":
     case "tbody":
     case "tfoot":
-      return createFormatContext(7, null, parentContext.tagScope);
+      return createFormatContext(6, null, parentContext.tagScope);
     case "colgroup":
-      return createFormatContext(9, null, parentContext.tagScope);
-    case "tr":
       return createFormatContext(8, null, parentContext.tagScope);
-    case "head":
-      if (2 > parentContext.insertionMode)
-        return createFormatContext(3, null, parentContext.tagScope);
-      break;
-    case "html":
-      if (0 === parentContext.insertionMode)
-        return createFormatContext(1, null, parentContext.tagScope);
+    case "tr":
+      return createFormatContext(7, null, parentContext.tagScope);
   }
-  return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode
+  return 5 <= parentContext.insertionMode
     ? createFormatContext(2, null, parentContext.tagScope)
-    : parentContext;
+    : 0 === parentContext.insertionMode
+      ? "html" === type
+        ? createFormatContext(1, null, parentContext.tagScope)
+        : createFormatContext(2, null, parentContext.tagScope)
+      : 1 === parentContext.insertionMode
+        ? createFormatContext(2, null, parentContext.tagScope)
+        : parentContext;
 }
 var textSeparator = stringToPrecomputedChunk("\x3c!-- --\x3e");
 function pushTextInstance(target, text, renderState, textEmbedded) {
@@ -976,7 +996,8 @@ var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""'),
     'addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error(\'React form unexpectedly submitted.\')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});'
   );
 function injectFormReplayingRuntime(resumableState, renderState) {
-  0 === (resumableState.instructions & 16) &&
+  0 !== (resumableState.instructions & 16) ||
+    renderState.externalRuntimeScript ||
     ((resumableState.instructions |= 16),
     renderState.bootstrapChunks.unshift(
       renderState.startInlineScript,
@@ -1135,7 +1156,6 @@ function pushStartInstance(
   props,
   resumableState,
   renderState,
-  preambleState,
   hoistableState,
   formatContext,
   textEmbedded,
@@ -1615,7 +1635,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$2;
     case "title":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1634,7 +1654,7 @@ function pushStartInstance(
         href = props.href,
         precedence = props.precedence;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof rel ||
@@ -1716,7 +1736,7 @@ function pushStartInstance(
         "symbol" === typeof asyncProp ||
         props.onLoad ||
         props.onError ||
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -1757,7 +1777,7 @@ function pushStartInstance(
       var precedence$jscomp$0 = props.precedence,
         href$jscomp$0 = props.href;
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp ||
         "string" !== typeof precedence$jscomp$0 ||
@@ -1860,7 +1880,7 @@ function pushStartInstance(
       return JSCompiler_inline_result$jscomp$6;
     case "meta":
       if (
-        4 === formatContext.insertionMode ||
+        3 === formatContext.insertionMode ||
         formatContext.tagScope & 1 ||
         null != props.itemProp
       )
@@ -2038,13 +2058,10 @@ function pushStartInstance(
     case "missing-glyph":
       break;
     case "head":
-      if (2 > formatContext.insertionMode) {
-        var preamble = preambleState || renderState.preamble;
-        if (preamble.headChunks)
-          throw Error("The `<head>` tag may only be rendered once.");
-        preamble.headChunks = [];
+      if (2 > formatContext.insertionMode && null === renderState.headChunks) {
+        renderState.headChunks = [];
         var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
-          preamble.headChunks,
+          renderState.headChunks,
           props,
           "head"
         );
@@ -2055,42 +2072,24 @@ function pushStartInstance(
           "head"
         );
       return JSCompiler_inline_result$jscomp$9;
-    case "body":
-      if (2 > formatContext.insertionMode) {
-        var preamble$jscomp$0 = preambleState || renderState.preamble;
-        if (preamble$jscomp$0.bodyChunks)
-          throw Error("The `<body>` tag may only be rendered once.");
-        preamble$jscomp$0.bodyChunks = [];
-        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          preamble$jscomp$0.bodyChunks,
-          props,
-          "body"
-        );
-      } else
-        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
-          target$jscomp$0,
-          props,
-          "body"
-        );
-      return JSCompiler_inline_result$jscomp$10;
     case "html":
-      if (0 === formatContext.insertionMode) {
-        var preamble$jscomp$1 = preambleState || renderState.preamble;
-        if (preamble$jscomp$1.htmlChunks)
-          throw Error("The `<html>` tag may only be rendered once.");
-        preamble$jscomp$1.htmlChunks = [doctypeChunk];
-        var JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
-          preamble$jscomp$1.htmlChunks,
+      if (
+        0 === formatContext.insertionMode &&
+        null === renderState.htmlChunks
+      ) {
+        renderState.htmlChunks = [doctypeChunk];
+        var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
+          renderState.htmlChunks,
           props,
           "html"
         );
       } else
-        JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
+        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
           target$jscomp$0,
           props,
           "html"
         );
-      return JSCompiler_inline_result$jscomp$11;
+      return JSCompiler_inline_result$jscomp$10;
     default:
       if (-1 !== type.indexOf("-")) {
         target$jscomp$0.push(startChunkForTag(type));
@@ -2153,15 +2152,6 @@ function endChunkForTag(tag) {
     endTagCache.set(tag, chunk));
   return chunk;
 }
-function hoistPreambleState(renderState, preambleState) {
-  renderState = renderState.preamble;
-  null === renderState.htmlChunks &&
-    (renderState.htmlChunks = preambleState.htmlChunks);
-  null === renderState.headChunks &&
-    (renderState.headChunks = preambleState.headChunks);
-  null === renderState.bodyChunks &&
-    (renderState.bodyChunks = preambleState.bodyChunks);
-}
 function writeBootstrap(destination, renderState) {
   renderState = renderState.bootstrapChunks;
   for (var i = 0; i < renderState.length - 1; i++)
@@ -2233,7 +2223,6 @@ function writeStartSegment(destination, renderState, formatContext, id) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return (
         writeChunk(destination, startSegmentHTML),
@@ -2241,42 +2230,42 @@ function writeStartSegment(destination, renderState, formatContext, id) {
         writeChunk(destination, id.toString(16)),
         writeChunkAndReturn(destination, startSegmentHTML2)
       );
-    case 4:
+    case 3:
       return (
         writeChunk(destination, startSegmentSVG),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, id.toString(16)),
         writeChunkAndReturn(destination, startSegmentSVG2)
       );
-    case 5:
+    case 4:
       return (
         writeChunk(destination, startSegmentMathML),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, id.toString(16)),
         writeChunkAndReturn(destination, startSegmentMathML2)
       );
-    case 6:
+    case 5:
       return (
         writeChunk(destination, startSegmentTable),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, id.toString(16)),
         writeChunkAndReturn(destination, startSegmentTable2)
       );
-    case 7:
+    case 6:
       return (
         writeChunk(destination, startSegmentTableBody),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, id.toString(16)),
         writeChunkAndReturn(destination, startSegmentTableBody2)
       );
-    case 8:
+    case 7:
       return (
         writeChunk(destination, startSegmentTableRow),
         writeChunk(destination, renderState.segmentPrefix),
         writeChunk(destination, id.toString(16)),
         writeChunkAndReturn(destination, startSegmentTableRow2)
       );
-    case 9:
+    case 8:
       return (
         writeChunk(destination, startSegmentColGroup),
         writeChunk(destination, renderState.segmentPrefix),
@@ -2291,20 +2280,19 @@ function writeEndSegment(destination, formatContext) {
   switch (formatContext.insertionMode) {
     case 0:
     case 1:
-    case 3:
     case 2:
       return writeChunkAndReturn(destination, endSegmentHTML);
-    case 4:
+    case 3:
       return writeChunkAndReturn(destination, endSegmentSVG);
-    case 5:
+    case 4:
       return writeChunkAndReturn(destination, endSegmentMathML);
-    case 6:
+    case 5:
       return writeChunkAndReturn(destination, endSegmentTable);
-    case 7:
+    case 6:
       return writeChunkAndReturn(destination, endSegmentTableBody);
-    case 8:
+    case 7:
       return writeChunkAndReturn(destination, endSegmentTableRow);
-    case 9:
+    case 8:
       return writeChunkAndReturn(destination, endSegmentColGroup);
     default:
       throw Error("Unknown insertion mode. This is a bug in React.");
@@ -2315,10 +2303,12 @@ var completeSegmentScript1Full = stringToPrecomputedChunk(
   ),
   completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'),
   completeSegmentScript2 = stringToPrecomputedChunk('","'),
-  completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>');
-stringToPrecomputedChunk('<template data-rsi="" data-sid="');
-stringToPrecomputedChunk('" data-pid="');
-var completeBoundaryScript1Full = stringToPrecomputedChunk(
+  completeSegmentScriptEnd = stringToPrecomputedChunk('")\x3c/script>'),
+  completeSegmentData1 = stringToPrecomputedChunk(
+    '<template data-rsi="" data-sid="'
+  ),
+  completeSegmentData2 = stringToPrecomputedChunk('" data-pid="'),
+  completeBoundaryScript1Full = stringToPrecomputedChunk(
     '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
   ),
   completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'),
@@ -2332,20 +2322,26 @@ var completeBoundaryScript1Full = stringToPrecomputedChunk(
   completeBoundaryScript2 = stringToPrecomputedChunk('","'),
   completeBoundaryScript3a = stringToPrecomputedChunk('",'),
   completeBoundaryScript3b = stringToPrecomputedChunk('"'),
-  completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-stringToPrecomputedChunk('<template data-rci="" data-bid="');
-stringToPrecomputedChunk('<template data-rri="" data-bid="');
-stringToPrecomputedChunk('" data-sid="');
-stringToPrecomputedChunk('" data-sty="');
-var clientRenderScript1Full = stringToPrecomputedChunk(
+  completeBoundaryScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+  completeBoundaryData1 = stringToPrecomputedChunk(
+    '<template data-rci="" data-bid="'
+  ),
+  completeBoundaryWithStylesData1 = stringToPrecomputedChunk(
+    '<template data-rri="" data-bid="'
+  ),
+  completeBoundaryData2 = stringToPrecomputedChunk('" data-sid="'),
+  completeBoundaryData3a = stringToPrecomputedChunk('" data-sty="'),
+  clientRenderScript1Full = stringToPrecomputedChunk(
     '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
   ),
   clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'),
   clientRenderScript1A = stringToPrecomputedChunk('"'),
   clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","),
-  clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>");
-stringToPrecomputedChunk('<template data-rxi="" data-bid="');
-stringToPrecomputedChunk('" data-dgst="');
+  clientRenderScriptEnd = stringToPrecomputedChunk(")\x3c/script>"),
+  clientRenderData1 = stringToPrecomputedChunk(
+    '<template data-rxi="" data-bid="'
+  ),
+  clientRenderData2 = stringToPrecomputedChunk('" data-dgst="');
 stringToPrecomputedChunk('" data-msg="');
 stringToPrecomputedChunk('" data-stck="');
 stringToPrecomputedChunk('" data-cstck="');
@@ -2615,6 +2611,107 @@ function writeStyleResourceAttributeInJS(destination, name, value) {
   writeChunk(destination, arrayInterstitial);
   writeChunk(destination, escapeJSObjectForInstructionScripts(name));
 }
+function writeStyleResourceDependenciesInAttr(destination, hoistableState) {
+  writeChunk(destination, arrayFirstOpenBracket);
+  var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
+  hoistableState.stylesheets.forEach(function (resource) {
+    if (2 !== resource.state)
+      if (3 === resource.state)
+        writeChunk(destination, nextArrayOpenBrackChunk),
+          writeChunk(
+            destination,
+            escapeTextForBrowser(JSON.stringify("" + resource.props.href))
+          ),
+          writeChunk(destination, arrayCloseBracket),
+          (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);
+      else {
+        writeChunk(destination, nextArrayOpenBrackChunk);
+        var precedence = resource.props["data-precedence"],
+          props = resource.props,
+          coercedHref = sanitizeURL("" + resource.props.href);
+        writeChunk(
+          destination,
+          escapeTextForBrowser(JSON.stringify(coercedHref))
+        );
+        precedence = "" + precedence;
+        writeChunk(destination, arrayInterstitial);
+        writeChunk(
+          destination,
+          escapeTextForBrowser(JSON.stringify(precedence))
+        );
+        for (var propKey in props)
+          if (
+            hasOwnProperty.call(props, propKey) &&
+            ((precedence = props[propKey]), null != precedence)
+          )
+            switch (propKey) {
+              case "href":
+              case "rel":
+              case "precedence":
+              case "data-precedence":
+                break;
+              case "children":
+              case "dangerouslySetInnerHTML":
+                throw Error(
+                  "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                );
+              default:
+                writeStyleResourceAttributeInAttr(
+                  destination,
+                  propKey,
+                  precedence
+                );
+            }
+        writeChunk(destination, arrayCloseBracket);
+        nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
+        resource.state = 3;
+      }
+  });
+  writeChunk(destination, arrayCloseBracket);
+}
+function writeStyleResourceAttributeInAttr(destination, name, value) {
+  var attributeName = name.toLowerCase();
+  switch (typeof value) {
+    case "function":
+    case "symbol":
+      return;
+  }
+  switch (name) {
+    case "innerHTML":
+    case "dangerouslySetInnerHTML":
+    case "suppressContentEditableWarning":
+    case "suppressHydrationWarning":
+    case "style":
+    case "ref":
+      return;
+    case "className":
+      attributeName = "class";
+      name = "" + value;
+      break;
+    case "hidden":
+      if (!1 === value) return;
+      name = "";
+      break;
+    case "src":
+    case "href":
+      value = sanitizeURL(value);
+      name = "" + value;
+      break;
+    default:
+      if (
+        (2 < name.length &&
+          ("o" === name[0] || "O" === name[0]) &&
+          ("n" === name[1] || "N" === name[1])) ||
+        !isAttributeNameSafe(name)
+      )
+        return;
+      name = "" + value;
+  }
+  writeChunk(destination, arrayInterstitial);
+  writeChunk(destination, escapeTextForBrowser(JSON.stringify(attributeName)));
+  writeChunk(destination, arrayInterstitial);
+  writeChunk(destination, escapeTextForBrowser(JSON.stringify(name)));
+}
 function createHoistableState() {
   return { styles: new Set(), stylesheets: new Set() };
 }
@@ -3043,6 +3140,8 @@ function getComponentNameFromType(type) {
       return "Suspense";
     case REACT_SUSPENSE_LIST_TYPE:
       return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
   }
   if ("object" === typeof type)
     switch (type.$$typeof) {
@@ -3385,6 +3484,11 @@ function dispatchAction(componentIdentity, queue, action) {
       queue.next = componentIdentity;
     }
 }
+function throwOnUseEffectEventCall() {
+  throw Error(
+    "A function wrapped in useEffectEvent can't be called during rendering."
+  );
+}
 function unsupportedStartTransition() {
   throw Error("startTransition cannot be called during server rendering.");
 }
@@ -3456,8 +3560,15 @@ function unwrapThenable(thenable) {
   null === thenableState && (thenableState = []);
   return trackUsedThenable(thenableState, thenable, index);
 }
-function unsupportedRefresh() {
-  throw Error("Cache cannot be refreshed during server rendering.");
+function readPreviousThenableFromState() {
+  var index = thenableIndexCounter;
+  thenableIndexCounter += 1;
+  if (null !== thenableState)
+    return (
+      (index = thenableState[index]),
+      (index = void 0 === index ? void 0 : index.value),
+      index
+    );
 }
 function noop$1() {}
 var HooksDispatcher = {
@@ -3544,13 +3655,8 @@ var HooksDispatcher = {
       resolveCurrentlyRenderingComponent();
       return sharedNotPendingObject;
     },
-    useMemoCache: function (size) {
-      for (var data = Array(size), i = 0; i < size; i++)
-        data[i] = REACT_MEMO_CACHE_SENTINEL;
-      return data;
-    },
-    useCacheRefresh: function () {
-      return unsupportedRefresh;
+    useEffectEvent: function () {
+      return throwOnUseEffectEventCall;
     }
   },
   currentResumableState = null,
@@ -3752,6 +3858,8 @@ function describeComponentStackByType(type) {
       return describeBuiltInComponentFrame("SuspenseList");
     case REACT_SUSPENSE_TYPE:
       return describeBuiltInComponentFrame("Suspense");
+    case REACT_VIEW_TRANSITION_TYPE:
+      return describeBuiltInComponentFrame("ViewTransition");
   }
   return "";
 }
@@ -3811,7 +3919,7 @@ function RequestInstance(
   this.status = 10;
   this.fatalError = null;
   this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
-  this.completedPreambleSegments = this.completedRootSegment = null;
+  this.completedRootSegment = null;
   this.abortableTasks = abortSet;
   this.pingedTasks = [];
   this.clientRenderedBoundaries = [];
@@ -3870,7 +3978,6 @@ function createRequest(
     null,
     renderState,
     null,
-    null,
     resumableState.abortableTasks,
     null,
     rootFormatContext,
@@ -3917,6 +4024,117 @@ function createPrerenderRequest(
   };
   return children;
 }
+function resumeRequest(
+  children,
+  postponedState,
+  renderState,
+  onError,
+  onAllReady,
+  onShellReady,
+  onShellError,
+  onFatalError,
+  onPostpone
+) {
+  renderState = new RequestInstance(
+    postponedState.resumableState,
+    renderState,
+    postponedState.rootFormatContext,
+    postponedState.progressiveChunkSize,
+    onError,
+    onAllReady,
+    onShellReady,
+    onShellError,
+    onFatalError,
+    onPostpone,
+    null
+  );
+  renderState.nextSegmentId = postponedState.nextSegmentId;
+  if ("number" === typeof postponedState.replaySlots)
+    return (
+      (onError = postponedState.replaySlots),
+      (onAllReady = createPendingSegment(
+        renderState,
+        0,
+        null,
+        postponedState.rootFormatContext,
+        !1,
+        !1
+      )),
+      (onAllReady.id = onError),
+      (onAllReady.parentFlushed = !0),
+      (children = createRenderTask(
+        renderState,
+        null,
+        children,
+        -1,
+        null,
+        onAllReady,
+        null,
+        renderState.abortableTasks,
+        null,
+        postponedState.rootFormatContext,
+        null,
+        emptyTreeContext,
+        null,
+        !1
+      )),
+      pushComponentStack(children),
+      renderState.pingedTasks.push(children),
+      renderState
+    );
+  children = createReplayTask(
+    renderState,
+    null,
+    {
+      nodes: postponedState.replayNodes,
+      slots: postponedState.replaySlots,
+      pendingTasks: 0
+    },
+    children,
+    -1,
+    null,
+    null,
+    renderState.abortableTasks,
+    null,
+    postponedState.rootFormatContext,
+    null,
+    emptyTreeContext,
+    null,
+    !1
+  );
+  pushComponentStack(children);
+  renderState.pingedTasks.push(children);
+  return renderState;
+}
+function resumeAndPrerenderRequest(
+  children,
+  postponedState,
+  renderState,
+  onError,
+  onAllReady,
+  onShellReady,
+  onShellError,
+  onFatalError,
+  onPostpone
+) {
+  children = resumeRequest(
+    children,
+    postponedState,
+    renderState,
+    onError,
+    onAllReady,
+    onShellReady,
+    onShellError,
+    onFatalError,
+    onPostpone
+  );
+  children.trackedPostpones = {
+    workingMap: new Map(),
+    rootNodes: [],
+    rootSlots: null
+  };
+  return children;
+}
 var currentRequest = null;
 function resolveRequest() {
   if (currentRequest) return currentRequest;
@@ -3935,12 +4153,7 @@ function pingTask(request, task) {
           return performWork(request);
         }));
 }
-function createSuspenseBoundary(
-  request,
-  fallbackAbortableTasks,
-  contentPreamble,
-  fallbackPreamble
-) {
+function createSuspenseBoundary(request, fallbackAbortableTasks) {
   return {
     status: 0,
     rootSegmentID: -1,
@@ -3952,8 +4165,6 @@ function createSuspenseBoundary(
     errorDigest: null,
     contentState: createHoistableState(),
     fallbackState: createHoistableState(),
-    contentPreamble: contentPreamble,
-    fallbackPreamble: fallbackPreamble,
     trackedContentKeyPath: null,
     trackedFallbackNode: null
   };
@@ -3965,7 +4176,6 @@ function createRenderTask(
   childIndex,
   blockedBoundary,
   blockedSegment,
-  blockedPreamble,
   hoistableState,
   abortSet,
   keyPath,
@@ -3988,7 +4198,6 @@ function createRenderTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: blockedSegment,
-    blockedPreamble: blockedPreamble,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -4032,7 +4241,6 @@ function createReplayTask(
     },
     blockedBoundary: blockedBoundary,
     blockedSegment: null,
-    blockedPreamble: null,
     hoistableState: hoistableState,
     abortSet: abortSet,
     keyPath: keyPath,
@@ -4056,12 +4264,11 @@ function createPendingSegment(
 ) {
   return {
     status: 0,
-    parentFlushed: !1,
     id: -1,
     index: index,
+    parentFlushed: !1,
     chunks: [],
     children: [],
-    preambleChildren: [],
     parentFormatContext: parentFormatContext,
     boundary: boundary,
     lastPushedText: lastPushedText,
@@ -4103,6 +4310,10 @@ function getThrownInfo(node$jscomp$0) {
     });
   return errorInfo;
 }
+function logPostpone(request, reason, postponeInfo) {
+  request = request.onPostpone;
+  request(reason, postponeInfo);
+}
 function logRecoverableError(request, error, errorInfo) {
   request = request.onError;
   error = request(error, errorInfo);
@@ -4184,9 +4395,9 @@ function renderElement(request, task, keyPath, type, props, ref) {
       var defaultProps = type.defaultProps;
       if (defaultProps) {
         newProps === props && (newProps = assign({}, newProps, props));
-        for (var propName$33 in defaultProps)
-          void 0 === newProps[propName$33] &&
-            (newProps[propName$33] = defaultProps[propName$33]);
+        for (var propName$34 in defaultProps)
+          void 0 === newProps[propName$34] &&
+            (newProps[propName$34] = defaultProps[propName$34]);
       }
       props = newProps;
       newProps = emptyContextObject;
@@ -4246,16 +4457,16 @@ function renderElement(request, task, keyPath, type, props, ref) {
             defaultProps = ref ? type[0] : newProps.state;
             initialState = !0;
             for (ref = ref ? 1 : 0; ref < type.length; ref++)
-              (propName$33 = type[ref]),
-                (propName$33 =
-                  "function" === typeof propName$33
-                    ? propName$33.call(newProps, defaultProps, props, void 0)
-                    : propName$33),
-                null != propName$33 &&
+              (propName$34 = type[ref]),
+                (propName$34 =
+                  "function" === typeof propName$34
+                    ? propName$34.call(newProps, defaultProps, props, void 0)
+                    : propName$34),
+                null != propName$34 &&
                   (initialState
                     ? ((initialState = !1),
-                      (defaultProps = assign({}, defaultProps, propName$33)))
-                    : assign(defaultProps, propName$33));
+                      (defaultProps = assign({}, defaultProps, propName$34)))
+                    : assign(defaultProps, propName$34));
             newProps.state = defaultProps;
           }
         else defaultProps.queue = null;
@@ -4289,13 +4500,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
         (task.formatContext = defaultProps),
         (task.keyPath = initialState);
     else {
-      ref = pushStartInstance(
+      initialState = pushStartInstance(
         newProps.chunks,
         type,
         props,
         request.resumableState,
         request.renderState,
-        task.blockedPreamble,
         task.hoistableState,
         task.formatContext,
         newProps.lastPushedText,
@@ -4303,42 +4513,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
       );
       newProps.lastPushedText = !1;
       defaultProps = task.formatContext;
-      initialState = task.keyPath;
+      ref = task.keyPath;
+      task.formatContext = getChildFormatContext(defaultProps, type, props);
       task.keyPath = keyPath;
-      3 ===
-      (task.formatContext = getChildFormatContext(defaultProps, type, props))
-        .insertionMode
-        ? ((keyPath = createPendingSegment(
-            request,
-            0,
-            null,
-            task.formatContext,
-            !1,
-            !1
-          )),
-          newProps.preambleChildren.push(keyPath),
-          (keyPath = createRenderTask(
-            request,
-            null,
-            ref,
-            -1,
-            task.blockedBoundary,
-            keyPath,
-            task.blockedPreamble,
-            task.hoistableState,
-            request.abortableTasks,
-            task.keyPath,
-            task.formatContext,
-            task.context,
-            task.treeContext,
-            task.componentStack,
-            task.isFallback
-          )),
-          pushComponentStack(keyPath),
-          request.pingedTasks.push(keyPath))
-        : renderNode(request, task, ref, -1);
+      renderNode(request, task, initialState, -1);
       task.formatContext = defaultProps;
-      task.keyPath = initialState;
+      task.keyPath = ref;
       a: {
         task = newProps.chunks;
         request = request.resumableState;
@@ -4373,9 +4553,6 @@ function renderElement(request, task, keyPath, type, props, ref) {
               request.hasHtml = !0;
               break a;
             }
-            break;
-          case "head":
-            if (1 >= defaultProps.insertionMode) break a;
         }
         task.push(endChunkForTag(type));
       }
@@ -4406,6 +4583,11 @@ function renderElement(request, task, keyPath, type, props, ref) {
         task.keyPath = type;
         return;
       case REACT_VIEW_TRANSITION_TYPE:
+        type = task.keyPath;
+        task.keyPath = keyPath;
+        renderNodeDestructive(request, task, props.children, -1);
+        task.keyPath = type;
+        return;
       case REACT_SCOPE_TYPE:
         throw Error("ReactDOMServer does not yet support scope components.");
       case REACT_SUSPENSE_TYPE:
@@ -4420,34 +4602,25 @@ function renderElement(request, task, keyPath, type, props, ref) {
           }
         } else {
           type = task.keyPath;
-          var parentBoundary = task.blockedBoundary;
-          ref = task.blockedPreamble;
-          var parentHoistableState = task.hoistableState;
-          propName$33 = task.blockedSegment;
-          propName = props.fallback;
+          var parentBoundary = task.blockedBoundary,
+            parentHoistableState = task.hoistableState;
+          ref = task.blockedSegment;
+          propName$34 = props.fallback;
           props = props.children;
           var fallbackAbortSet = new Set();
-          var newBoundary =
-            2 > task.formatContext.insertionMode
-              ? createSuspenseBoundary(
-                  request,
-                  fallbackAbortSet,
-                  createPreambleState(),
-                  createPreambleState()
-                )
-              : createSuspenseBoundary(request, fallbackAbortSet, null, null);
+          propName = createSuspenseBoundary(request, fallbackAbortSet);
           null !== request.trackedPostpones &&
-            (newBoundary.trackedContentKeyPath = keyPath);
+            (propName.trackedContentKeyPath = keyPath);
           var boundarySegment = createPendingSegment(
             request,
-            propName$33.chunks.length,
-            newBoundary,
+            ref.chunks.length,
+            propName,
             task.formatContext,
             !1,
             !1
           );
-          propName$33.children.push(boundarySegment);
-          propName$33.lastPushedText = !1;
+          ref.children.push(boundarySegment);
+          ref.lastPushedText = !1;
           var contentRootSegment = createPendingSegment(
             request,
             0,
@@ -4461,13 +4634,12 @@ function renderElement(request, task, keyPath, type, props, ref) {
             newProps = [keyPath[0], "Suspense Fallback", keyPath[2]];
             defaultProps = [newProps[1], newProps[2], [], null];
             request.trackedPostpones.workingMap.set(newProps, defaultProps);
-            newBoundary.trackedFallbackNode = defaultProps;
+            propName.trackedFallbackNode = defaultProps;
             task.blockedSegment = boundarySegment;
-            task.blockedPreamble = newBoundary.fallbackPreamble;
             task.keyPath = newProps;
             boundarySegment.status = 6;
             try {
-              renderNode(request, task, propName, -1),
+              renderNode(request, task, propName$34, -1),
                 boundarySegment.lastPushedText &&
                   boundarySegment.textEmbedded &&
                   boundarySegment.chunks.push(textSeparator),
@@ -4478,19 +4650,16 @@ function renderElement(request, task, keyPath, type, props, ref) {
                 thrownValue)
               );
             } finally {
-              (task.blockedSegment = propName$33),
-                (task.blockedPreamble = ref),
-                (task.keyPath = type);
+              (task.blockedSegment = ref), (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
               props,
               -1,
-              newBoundary,
+              propName,
               contentRootSegment,
-              newBoundary.contentPreamble,
-              newBoundary.contentState,
+              propName.contentState,
               task.abortSet,
               keyPath,
               task.formatContext,
@@ -4502,9 +4671,8 @@ function renderElement(request, task, keyPath, type, props, ref) {
             pushComponentStack(task);
             request.pingedTasks.push(task);
           } else {
-            task.blockedBoundary = newBoundary;
-            task.blockedPreamble = newBoundary.contentPreamble;
-            task.hoistableState = newBoundary.contentState;
+            task.blockedBoundary = propName;
+            task.hoistableState = propName.contentState;
             task.blockedSegment = contentRootSegment;
             task.keyPath = keyPath;
             contentRootSegment.status = 6;
@@ -4515,46 +4683,46 @@ function renderElement(request, task, keyPath, type, props, ref) {
                   contentRootSegment.textEmbedded &&
                   contentRootSegment.chunks.push(textSeparator),
                 (contentRootSegment.status = 1),
-                queueCompletedSegment(newBoundary, contentRootSegment),
-                0 === newBoundary.pendingTasks && 0 === newBoundary.status)
+                queueCompletedSegment(propName, contentRootSegment),
+                0 === propName.pendingTasks && 0 === propName.status)
               ) {
-                newBoundary.status = 1;
-                0 === request.pendingRootTasks &&
-                  task.blockedPreamble &&
-                  preparePreamble(request);
+                propName.status = 1;
                 break a;
               }
-            } catch (thrownValue$28) {
-              (newBoundary.status = 4),
+            } catch (thrownValue$29) {
+              (propName.status = 4),
                 12 === request.status
                   ? ((contentRootSegment.status = 3),
                     (newProps = request.fatalError))
                   : ((contentRootSegment.status = 4),
-                    (newProps = thrownValue$28)),
+                    (newProps = thrownValue$29)),
                 (defaultProps = getThrownInfo(task.componentStack)),
-                (initialState = logRecoverableError(
-                  request,
-                  newProps,
-                  defaultProps
-                )),
-                (newBoundary.errorDigest = initialState),
-                untrackBoundary(request, newBoundary);
+                "object" === typeof newProps &&
+                null !== newProps &&
+                newProps.$$typeof === REACT_POSTPONE_TYPE
+                  ? (logPostpone(request, newProps.message, defaultProps),
+                    (initialState = "POSTPONE"))
+                  : (initialState = logRecoverableError(
+                      request,
+                      newProps,
+                      defaultProps
+                    )),
+                (propName.errorDigest = initialState),
+                untrackBoundary(request, propName);
             } finally {
               (task.blockedBoundary = parentBoundary),
-                (task.blockedPreamble = ref),
                 (task.hoistableState = parentHoistableState),
-                (task.blockedSegment = propName$33),
+                (task.blockedSegment = ref),
                 (task.keyPath = type);
             }
             task = createRenderTask(
               request,
               null,
-              propName,
+              propName$34,
               -1,
               parentBoundary,
               boundarySegment,
-              newBoundary.fallbackPreamble,
-              newBoundary.fallbackState,
+              propName.fallbackState,
               fallbackAbortSet,
               [keyPath[0], "Suspense Fallback", keyPath[2]],
               task.formatContext,
@@ -4573,9 +4741,9 @@ function renderElement(request, task, keyPath, type, props, ref) {
       switch (type.$$typeof) {
         case REACT_FORWARD_REF_TYPE:
           if ("ref" in props)
-            for (newBoundary in ((newProps = {}), props))
-              "ref" !== newBoundary &&
-                (newProps[newBoundary] = props[newBoundary]);
+            for (boundarySegment in ((newProps = {}), props))
+              "ref" !== boundarySegment &&
+                (newProps[boundarySegment] = props[boundarySegment]);
           else newProps = props;
           type = renderWithHooks(
             request,
@@ -4747,16 +4915,13 @@ function retryNode(request, task) {
                         );
                       task.replay.pendingTasks--;
                       props = getThrownInfo(task.componentStack);
-                      key = task.blockedBoundary;
-                      type = x;
-                      props = logRecoverableError(request, type, props);
-                      abortRemainingReplayNodes(
+                      erroredReplay(
                         request,
-                        key,
+                        task.blockedBoundary,
+                        x,
+                        props,
                         childNodes,
-                        name,
-                        type,
-                        props
+                        name
                       );
                     }
                     task.replay = replay;
@@ -4768,9 +4933,9 @@ function retryNode(request, task) {
                           ">. The tree doesn't match so React will fallback to client rendering."
                       );
                     b: {
-                      replay = void 0;
-                      type = node$jscomp$0[5];
-                      ref = node$jscomp$0[2];
+                      type = void 0;
+                      ref = node$jscomp$0[5];
+                      replay = node$jscomp$0[2];
                       name = node$jscomp$0[3];
                       keyOrIndex =
                         null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
@@ -4780,30 +4945,20 @@ function retryNode(request, task) {
                         previousReplaySet = task.replay,
                         parentBoundary = task.blockedBoundary,
                         parentHoistableState = task.hoistableState,
-                        content = props.children,
-                        fallback = props.fallback,
-                        fallbackAbortSet = new Set();
-                      props =
-                        2 > task.formatContext.insertionMode
-                          ? createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              createPreambleState(),
-                              createPreambleState()
-                            )
-                          : createSuspenseBoundary(
-                              request,
-                              fallbackAbortSet,
-                              null,
-                              null
-                            );
-                      props.parentFlushed = !0;
-                      props.rootSegmentID = type;
-                      task.blockedBoundary = props;
-                      task.hoistableState = props.contentState;
+                        content = props.children;
+                      props = props.fallback;
+                      var fallbackAbortSet = new Set(),
+                        resumedBoundary = createSuspenseBoundary(
+                          request,
+                          fallbackAbortSet
+                        );
+                      resumedBoundary.parentFlushed = !0;
+                      resumedBoundary.rootSegmentID = ref;
+                      task.blockedBoundary = resumedBoundary;
+                      task.hoistableState = resumedBoundary.contentState;
                       task.keyPath = key;
                       task.replay = {
-                        nodes: ref,
+                        nodes: replay,
                         slots: name,
                         pendingTasks: 1
                       };
@@ -4817,22 +4972,32 @@ function retryNode(request, task) {
                             "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                           );
                         task.replay.pendingTasks--;
-                        if (0 === props.pendingTasks && 0 === props.status) {
-                          props.status = 1;
-                          request.completedBoundaries.push(props);
+                        if (
+                          0 === resumedBoundary.pendingTasks &&
+                          0 === resumedBoundary.status
+                        ) {
+                          resumedBoundary.status = 1;
+                          request.completedBoundaries.push(resumedBoundary);
                           break b;
                         }
                       } catch (error) {
-                        (props.status = 4),
+                        (resumedBoundary.status = 4),
                           (childNodes = getThrownInfo(task.componentStack)),
-                          (replay = logRecoverableError(
-                            request,
-                            error,
-                            childNodes
-                          )),
-                          (props.errorDigest = replay),
+                          "object" === typeof error &&
+                          null !== error &&
+                          error.$$typeof === REACT_POSTPONE_TYPE
+                            ? (logPostpone(request, error.message, childNodes),
+                              (type = "POSTPONE"))
+                            : (type = logRecoverableError(
+                                request,
+                                error,
+                                childNodes
+                              )),
+                          (resumedBoundary.errorDigest = type),
                           task.replay.pendingTasks--,
-                          request.clientRenderedBoundaries.push(props);
+                          request.clientRenderedBoundaries.push(
+                            resumedBoundary
+                          );
                       } finally {
                         (task.blockedBoundary = parentBoundary),
                           (task.hoistableState = parentHoistableState),
@@ -4847,10 +5012,10 @@ function retryNode(request, task) {
                           slots: node$jscomp$0,
                           pendingTasks: 0
                         },
-                        fallback,
+                        props,
                         -1,
                         parentBoundary,
-                        props.fallbackState,
+                        resumedBoundary.fallbackState,
                         fallbackAbortSet,
                         [key[0], "Suspense Fallback", key[2]],
                         task.formatContext,
@@ -4901,6 +5066,31 @@ function retryNode(request, task) {
         }
         return;
       }
+      if (
+        "function" === typeof node[ASYNC_ITERATOR] &&
+        (childNodes = node[ASYNC_ITERATOR]())
+      ) {
+        props = task.thenableState;
+        task.thenableState = null;
+        thenableIndexCounter = 0;
+        thenableState = props;
+        props = [];
+        key = !1;
+        if (childNodes === node)
+          for (node = readPreviousThenableFromState(); void 0 !== node; ) {
+            if (node.done) {
+              key = !0;
+              break;
+            }
+            props.push(node.value);
+            node = readPreviousThenableFromState();
+          }
+        if (!key)
+          for (node = unwrapThenable(childNodes.next()); !node.done; )
+            props.push(node.value), (node = unwrapThenable(childNodes.next()));
+        renderChildrenArray(request, task, props, childIndex);
+        return;
+      }
       if ("function" === typeof node.then)
         return (
           (task.thenableState = null),
@@ -4913,32 +5103,32 @@ function retryNode(request, task) {
           node._currentValue,
           childIndex
         );
-      childIndex = Object.prototype.toString.call(node);
+      request = Object.prototype.toString.call(node);
       throw Error(
         "Objects are not valid as a React child (found: " +
-          ("[object Object]" === childIndex
+          ("[object Object]" === request
             ? "object with keys {" + Object.keys(node).join(", ") + "}"
-            : childIndex) +
+            : request) +
           "). If you meant to render a collection of children, use an array instead."
       );
     }
     if ("string" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
     else if ("number" === typeof node || "bigint" === typeof node)
-      (childIndex = task.blockedSegment),
-        null !== childIndex &&
-          (childIndex.lastPushedText = pushTextInstance(
-            childIndex.chunks,
+      (task = task.blockedSegment),
+        null !== task &&
+          (task.lastPushedText = pushTextInstance(
+            task.chunks,
             "" + node,
             request.renderState,
-            childIndex.lastPushedText
+            task.lastPushedText
           ));
   }
 }
@@ -4975,16 +5165,13 @@ function renderChildrenArray(request, task, children, childIndex) {
             throw x;
           task.replay.pendingTasks--;
           children = getThrownInfo(task.componentStack);
-          var boundary = task.blockedBoundary,
-            error = x;
-          children = logRecoverableError(request, error, children);
-          abortRemainingReplayNodes(
+          erroredReplay(
             request,
-            boundary,
+            task.blockedBoundary,
+            x,
+            children,
             childIndex,
-            node,
-            error,
-            children
+            node
           );
         }
         task.replay = replay;
@@ -5001,14 +5188,15 @@ function renderChildrenArray(request, task, children, childIndex) {
     null !== task.replay &&
     ((j = task.replay.slots), null !== j && "object" === typeof j)
   ) {
-    for (childIndex = 0; childIndex < replayNodes; childIndex++)
-      (node = children[childIndex]),
-        (task.treeContext = pushTreeContext(replay, replayNodes, childIndex)),
-        (boundary = j[childIndex]),
-        "number" === typeof boundary
-          ? (resumeNode(request, task, boundary, node, childIndex),
-            delete j[childIndex])
-          : renderNode(request, task, node, childIndex);
+    for (childIndex = 0; childIndex < replayNodes; childIndex++) {
+      node = children[childIndex];
+      task.treeContext = pushTreeContext(replay, replayNodes, childIndex);
+      var resumeSegmentID = j[childIndex];
+      "number" === typeof resumeSegmentID
+        ? (resumeNode(request, task, resumeSegmentID, node, childIndex),
+          delete j[childIndex])
+        : renderNode(request, task, node, childIndex);
+    }
     task.treeContext = replay;
     task.keyPath = prevKeyPath;
     return;
@@ -5020,6 +5208,105 @@ function renderChildrenArray(request, task, children, childIndex) {
   task.treeContext = replay;
   task.keyPath = prevKeyPath;
 }
+function trackPostpone(request, trackedPostpones, task, segment) {
+  segment.status = 5;
+  var keyPath = task.keyPath,
+    boundary = task.blockedBoundary;
+  if (null === boundary)
+    (segment.id = request.nextSegmentId++),
+      (trackedPostpones.rootSlots = segment.id),
+      null !== request.completedRootSegment &&
+        (request.completedRootSegment.status = 5);
+  else {
+    if (null !== boundary && 0 === boundary.status) {
+      boundary.status = 5;
+      boundary.rootSegmentID = request.nextSegmentId++;
+      var boundaryKeyPath = boundary.trackedContentKeyPath;
+      if (null === boundaryKeyPath)
+        throw Error(
+          "It should not be possible to postpone at the root. This is a bug in React."
+        );
+      var fallbackReplayNode = boundary.trackedFallbackNode,
+        children = [];
+      if (boundaryKeyPath === keyPath && -1 === task.childIndex) {
+        -1 === segment.id &&
+          (segment.id = segment.parentFlushed
+            ? boundary.rootSegmentID
+            : request.nextSegmentId++);
+        segment = [
+          boundaryKeyPath[1],
+          boundaryKeyPath[2],
+          children,
+          segment.id,
+          fallbackReplayNode,
+          boundary.rootSegmentID
+        ];
+        trackedPostpones.workingMap.set(boundaryKeyPath, segment);
+        addToReplayParent(segment, boundaryKeyPath[0], trackedPostpones);
+        return;
+      }
+      var boundaryNode$45 = trackedPostpones.workingMap.get(boundaryKeyPath);
+      void 0 === boundaryNode$45
+        ? ((boundaryNode$45 = [
+            boundaryKeyPath[1],
+            boundaryKeyPath[2],
+            children,
+            null,
+            fallbackReplayNode,
+            boundary.rootSegmentID
+          ]),
+          trackedPostpones.workingMap.set(boundaryKeyPath, boundaryNode$45),
+          addToReplayParent(
+            boundaryNode$45,
+            boundaryKeyPath[0],
+            trackedPostpones
+          ))
+        : ((boundaryKeyPath = boundaryNode$45),
+          (boundaryKeyPath[4] = fallbackReplayNode),
+          (boundaryKeyPath[5] = boundary.rootSegmentID));
+    }
+    -1 === segment.id &&
+      (segment.id =
+        segment.parentFlushed && null !== boundary
+          ? boundary.rootSegmentID
+          : request.nextSegmentId++);
+    if (-1 === task.childIndex)
+      null === keyPath
+        ? (trackedPostpones.rootSlots = segment.id)
+        : ((task = trackedPostpones.workingMap.get(keyPath)),
+          void 0 === task
+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),
+              addToReplayParent(task, keyPath[0], trackedPostpones))
+            : (task[3] = segment.id));
+    else {
+      if (null === keyPath)
+        if (((request = trackedPostpones.rootSlots), null === request))
+          request = trackedPostpones.rootSlots = {};
+        else {
+          if ("number" === typeof request)
+            throw Error(
+              "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+            );
+        }
+      else if (
+        ((boundary = trackedPostpones.workingMap),
+        (boundaryKeyPath = boundary.get(keyPath)),
+        void 0 === boundaryKeyPath)
+      )
+        (request = {}),
+          (boundaryKeyPath = [keyPath[1], keyPath[2], [], request]),
+          boundary.set(keyPath, boundaryKeyPath),
+          addToReplayParent(boundaryKeyPath, keyPath[0], trackedPostpones);
+      else if (((request = boundaryKeyPath[3]), null === request))
+        request = boundaryKeyPath[3] = {};
+      else if ("number" === typeof request)
+        throw Error(
+          "It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React."
+        );
+      request[task.childIndex] = segment.id;
+    }
+  }
+}
 function untrackBoundary(request, boundary) {
   request = request.trackedPostpones;
   null !== request &&
@@ -5066,7 +5353,6 @@ function spawnNewSuspendedRenderTask(request, task, thenableState) {
     task.childIndex,
     task.blockedBoundary,
     newSegment,
-    task.blockedPreamble,
     task.hoistableState,
     task.abortSet,
     task.keyPath,
@@ -5090,13 +5376,14 @@ function renderNode(request, task, node, childIndex) {
     } catch (thrownValue) {
       if (
         (resetHooksState(),
-        (node =
+        (childIndex =
           thrownValue === SuspenseException
             ? getSuspendedThenable()
             : thrownValue),
-        "object" === typeof node && null !== node)
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -5108,7 +5395,7 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedReplayTask(request, task, node);
           request.pingedTasks.push(node);
@@ -5127,18 +5414,19 @@ function renderNode(request, task, node, childIndex) {
       chunkLength = segment.chunks.length;
     try {
       return renderNodeDestructive(request, task, node, childIndex);
-    } catch (thrownValue$48) {
+    } catch (thrownValue$57) {
       if (
         (resetHooksState(),
         (segment.children.length = childrenLength),
         (segment.chunks.length = chunkLength),
-        (node =
-          thrownValue$48 === SuspenseException
+        (childIndex =
+          thrownValue$57 === SuspenseException
             ? getSuspendedThenable()
-            : thrownValue$48),
-        "object" === typeof node && null !== node)
+            : thrownValue$57),
+        "object" === typeof childIndex && null !== childIndex)
       ) {
-        if ("function" === typeof node.then) {
+        if ("function" === typeof childIndex.then) {
+          node = childIndex;
           childIndex = getThenableStateAfterSuspending();
           request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;
           node.then(request, request);
@@ -5150,7 +5438,35 @@ function renderNode(request, task, node, childIndex) {
           switchContext(previousContext);
           return;
         }
-        if ("Maximum call stack size exceeded" === node.message) {
+        if (
+          childIndex.$$typeof === REACT_POSTPONE_TYPE &&
+          null !== request.trackedPostpones &&
+          null !== task.blockedBoundary
+        ) {
+          node = request.trackedPostpones;
+          segment = getThrownInfo(task.componentStack);
+          logPostpone(request, childIndex.message, segment);
+          childIndex = task.blockedSegment;
+          segment = createPendingSegment(
+            request,
+            childIndex.chunks.length,
+            null,
+            task.formatContext,
+            childIndex.lastPushedText,
+            !0
+          );
+          childIndex.children.push(segment);
+          childIndex.lastPushedText = !1;
+          trackPostpone(request, node, task, segment);
+          task.formatContext = previousFormatContext;
+          task.context = previousContext;
+          task.keyPath = previousKeyPath;
+          task.treeContext = previousTreeContext;
+          task.componentStack = previousComponentStack;
+          switchContext(previousContext);
+          return;
+        }
+        if ("Maximum call stack size exceeded" === childIndex.message) {
           node = getThenableStateAfterSuspending();
           node = spawnNewSuspendedRenderTask(request, task, node);
           request.pingedTasks.push(node);
@@ -5170,7 +5486,29 @@ function renderNode(request, task, node, childIndex) {
   task.keyPath = previousKeyPath;
   task.treeContext = previousTreeContext;
   switchContext(previousContext);
-  throw node;
+  throw childIndex;
+}
+function erroredReplay(
+  request,
+  boundary,
+  error,
+  errorInfo,
+  replayNodes,
+  resumeSlots
+) {
+  "object" === typeof error &&
+  null !== error &&
+  error.$$typeof === REACT_POSTPONE_TYPE
+    ? (logPostpone(request, error.message, errorInfo), (errorInfo = "POSTPONE"))
+    : (errorInfo = logRecoverableError(request, error, errorInfo));
+  abortRemainingReplayNodes(
+    request,
+    boundary,
+    replayNodes,
+    resumeSlots,
+    error,
+    errorInfo
+  );
 }
 function abortTaskSoft(task) {
   var boundary = task.blockedBoundary;
@@ -5200,12 +5538,7 @@ function abortRemainingReplayNodes(
       node = node[5];
       var request = request$jscomp$0,
         errorDigest = errorDigest$jscomp$0,
-        resumedBoundary = createSuspenseBoundary(
-          request,
-          new Set(),
-          null,
-          null
-        );
+        resumedBoundary = createSuspenseBoundary(request, new Set());
       resumedBoundary.parentFlushed = !0;
       resumedBoundary.rootSegmentID = node;
       resumedBoundary.status = 4;
@@ -5235,44 +5568,100 @@ function abortTask(task, request, error) {
     if (6 === segment.status) return;
     segment.status = 3;
   }
-  segment = getThrownInfo(task.componentStack);
+  var errorInfo = getThrownInfo(task.componentStack);
   if (null === boundary) {
     if (13 !== request.status && 14 !== request.status) {
       boundary = task.replay;
       if (null === boundary) {
-        logRecoverableError(request, error, segment);
-        fatalError(request, error);
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? ((boundary = request.trackedPostpones),
+            null !== boundary && null !== segment
+              ? (logPostpone(request, error.message, errorInfo),
+                trackPostpone(request, boundary, task, segment),
+                finishedTask(request, null, segment))
+              : ((task = Error(
+                  "The render was aborted with postpone when the shell is incomplete. Reason: " +
+                    error.message
+                )),
+                logRecoverableError(request, task, errorInfo),
+                fatalError(request, task)))
+          : null !== request.trackedPostpones && null !== segment
+            ? ((boundary = request.trackedPostpones),
+              logRecoverableError(request, error, errorInfo),
+              trackPostpone(request, boundary, task, segment),
+              finishedTask(request, null, segment))
+            : (logRecoverableError(request, error, errorInfo),
+              fatalError(request, error));
         return;
       }
       boundary.pendingTasks--;
       0 === boundary.pendingTasks &&
         0 < boundary.nodes.length &&
-        ((task = logRecoverableError(request, error, segment)),
+        ("object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+          ? (logPostpone(request, error.message, errorInfo),
+            (errorInfo = "POSTPONE"))
+          : (errorInfo = logRecoverableError(request, error, errorInfo)),
         abortRemainingReplayNodes(
           request,
           null,
           boundary.nodes,
           boundary.slots,
           error,
-          task
+          errorInfo
         ));
       request.pendingRootTasks--;
       0 === request.pendingRootTasks && completeShell(request);
     }
-  } else
-    boundary.pendingTasks--,
-      4 !== boundary.status &&
-        ((boundary.status = 4),
-        (task = logRecoverableError(request, error, segment)),
-        (boundary.status = 4),
-        (boundary.errorDigest = task),
-        untrackBoundary(request, boundary),
-        boundary.parentFlushed &&
-          request.clientRenderedBoundaries.push(boundary)),
-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
-        return abortTask(fallbackTask, request, error);
-      }),
-      boundary.fallbackAbortableTasks.clear();
+  } else {
+    boundary.pendingTasks--;
+    var trackedPostpones$60 = request.trackedPostpones;
+    if (4 !== boundary.status) {
+      if (null !== trackedPostpones$60 && null !== segment)
+        return (
+          "object" === typeof error &&
+          null !== error &&
+          error.$$typeof === REACT_POSTPONE_TYPE
+            ? logPostpone(request, error.message, errorInfo)
+            : logRecoverableError(request, error, errorInfo),
+          trackPostpone(request, trackedPostpones$60, task, segment),
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          }),
+          boundary.fallbackAbortableTasks.clear(),
+          finishedTask(request, boundary, segment)
+        );
+      boundary.status = 4;
+      if (
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+      ) {
+        logPostpone(request, error.message, errorInfo);
+        if (null !== request.trackedPostpones && null !== segment) {
+          trackPostpone(request, request.trackedPostpones, task, segment);
+          finishedTask(request, task.blockedBoundary, segment);
+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+            return abortTask(fallbackTask, request, error);
+          });
+          boundary.fallbackAbortableTasks.clear();
+          return;
+        }
+        errorInfo = "POSTPONE";
+      } else errorInfo = logRecoverableError(request, error, errorInfo);
+      boundary.status = 4;
+      boundary.errorDigest = errorInfo;
+      untrackBoundary(request, boundary);
+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
+    }
+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
+      return abortTask(fallbackTask, request, error);
+    });
+    boundary.fallbackAbortableTasks.clear();
+  }
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
@@ -5339,7 +5728,6 @@ function safelyEmitEarlyPreloads(request, shellComplete) {
 }
 function completeShell(request) {
   null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);
-  null === request.trackedPostpones && preparePreamble(request);
   request.onShellError = noop;
   request = request.onShellReady;
   request();
@@ -5352,7 +5740,6 @@ function completeAll(request) {
       : null === request.completedRootSegment ||
           5 !== request.completedRootSegment.status
   );
-  preparePreamble(request);
   request = request.onAllReady;
   request();
 }
@@ -5393,11 +5780,7 @@ function finishedTask(request, boundary, segment) {
               request.completedBoundaries.push(boundary),
             1 === boundary.status &&
               (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),
-              boundary.fallbackAbortableTasks.clear(),
-              0 === request.pendingRootTasks &&
-                null === request.trackedPostpones &&
-                null !== boundary.contentPreamble &&
-                preparePreamble(request)))
+              boundary.fallbackAbortableTasks.clear()))
           : null !== segment &&
             segment.parentFlushed &&
             1 === segment.status &&
@@ -5408,23 +5791,23 @@ function finishedTask(request, boundary, segment) {
   request.allPendingTasks--;
   0 === request.allPendingTasks && completeAll(request);
 }
-function performWork(request$jscomp$2) {
-  if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
+function performWork(request$jscomp$1) {
+  if (14 !== request$jscomp$1.status && 13 !== request$jscomp$1.status) {
     var prevContext = currentActiveSnapshot,
       prevDispatcher = ReactSharedInternals.H;
     ReactSharedInternals.H = HooksDispatcher;
     var prevAsyncDispatcher = ReactSharedInternals.A;
     ReactSharedInternals.A = DefaultAsyncDispatcher;
     var prevRequest = currentRequest;
-    currentRequest = request$jscomp$2;
+    currentRequest = request$jscomp$1;
     var prevResumableState = currentResumableState;
-    currentResumableState = request$jscomp$2.resumableState;
+    currentResumableState = request$jscomp$1.resumableState;
     try {
-      var pingedTasks = request$jscomp$2.pingedTasks,
+      var pingedTasks = request$jscomp$1.pingedTasks,
         i;
       for (i = 0; i < pingedTasks.length; i++) {
         var task = pingedTasks[i],
-          request = request$jscomp$2,
+          request = request$jscomp$1,
           segment = task.blockedSegment;
         if (null === segment) {
           var request$jscomp$0 = request;
@@ -5468,27 +5851,15 @@ function performWork(request$jscomp$2) {
                 task.replay.pendingTasks--;
                 task.abortSet.delete(task);
                 var errorInfo = getThrownInfo(task.componentStack);
-                request = void 0;
-                var request$jscomp$1 = request$jscomp$0,
-                  boundary = task.blockedBoundary,
-                  error$jscomp$0 =
-                    12 === request$jscomp$0.status
-                      ? request$jscomp$0.fatalError
-                      : x,
-                  replayNodes = task.replay.nodes,
-                  resumeSlots = task.replay.slots;
-                request = logRecoverableError(
-                  request$jscomp$1,
-                  error$jscomp$0,
-                  errorInfo
-                );
-                abortRemainingReplayNodes(
-                  request$jscomp$1,
-                  boundary,
-                  replayNodes,
-                  resumeSlots,
-                  error$jscomp$0,
-                  request
+                erroredReplay(
+                  request$jscomp$0,
+                  task.blockedBoundary,
+                  12 === request$jscomp$0.status
+                    ? request$jscomp$0.fatalError
+                    : x,
+                  errorInfo,
+                  task.replay.nodes,
+                  task.replay.slots
                 );
                 request$jscomp$0.pendingRootTasks--;
                 0 === request$jscomp$0.pendingRootTasks &&
@@ -5500,78 +5871,124 @@ function performWork(request$jscomp$2) {
             } finally {
             }
           }
-        } else if (
-          ((request$jscomp$0 = void 0),
-          (request$jscomp$1 = segment),
-          0 === request$jscomp$1.status)
-        ) {
-          request$jscomp$1.status = 6;
-          switchContext(task.context);
-          var childrenLength = request$jscomp$1.children.length,
-            chunkLength = request$jscomp$1.chunks.length;
-          try {
-            retryNode(request, task),
-              request$jscomp$1.lastPushedText &&
-                request$jscomp$1.textEmbedded &&
-                request$jscomp$1.chunks.push(textSeparator),
-              task.abortSet.delete(task),
-              (request$jscomp$1.status = 1),
-              finishedTask(request, task.blockedBoundary, request$jscomp$1);
-          } catch (thrownValue) {
-            resetHooksState();
-            request$jscomp$1.children.length = childrenLength;
-            request$jscomp$1.chunks.length = chunkLength;
-            var x$jscomp$0 =
-              thrownValue === SuspenseException
-                ? getSuspendedThenable()
-                : 12 === request.status
-                  ? request.fatalError
-                  : thrownValue;
-            if (
-              "object" === typeof x$jscomp$0 &&
-              null !== x$jscomp$0 &&
-              "function" === typeof x$jscomp$0.then
-            ) {
-              request$jscomp$1.status = 0;
-              task.thenableState = getThenableStateAfterSuspending();
-              var ping$jscomp$0 = task.ping;
-              x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
-            } else {
-              var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
-              task.abortSet.delete(task);
-              request$jscomp$1.status = 4;
-              var boundary$jscomp$0 = task.blockedBoundary;
-              request$jscomp$0 = logRecoverableError(
-                request,
-                x$jscomp$0,
-                errorInfo$jscomp$0
-              );
-              null === boundary$jscomp$0
-                ? fatalError(request, x$jscomp$0)
-                : (boundary$jscomp$0.pendingTasks--,
-                  4 !== boundary$jscomp$0.status &&
-                    ((boundary$jscomp$0.status = 4),
-                    (boundary$jscomp$0.errorDigest = request$jscomp$0),
-                    untrackBoundary(request, boundary$jscomp$0),
-                    boundary$jscomp$0.parentFlushed &&
-                      request.clientRenderedBoundaries.push(boundary$jscomp$0),
-                    0 === request.pendingRootTasks &&
-                      null === request.trackedPostpones &&
-                      null !== boundary$jscomp$0.contentPreamble &&
-                      preparePreamble(request)));
-              request.allPendingTasks--;
-              0 === request.allPendingTasks && completeAll(request);
+        } else
+          a: {
+            request$jscomp$0 = void 0;
+            var segment$jscomp$0 = segment;
+            if (0 === segment$jscomp$0.status) {
+              segment$jscomp$0.status = 6;
+              switchContext(task.context);
+              var childrenLength = segment$jscomp$0.children.length,
+                chunkLength = segment$jscomp$0.chunks.length;
+              try {
+                retryNode(request, task),
+                  segment$jscomp$0.lastPushedText &&
+                    segment$jscomp$0.textEmbedded &&
+                    segment$jscomp$0.chunks.push(textSeparator),
+                  task.abortSet.delete(task),
+                  (segment$jscomp$0.status = 1),
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+              } catch (thrownValue) {
+                resetHooksState();
+                segment$jscomp$0.children.length = childrenLength;
+                segment$jscomp$0.chunks.length = chunkLength;
+                var x$jscomp$0 =
+                  thrownValue === SuspenseException
+                    ? getSuspendedThenable()
+                    : 12 === request.status
+                      ? request.fatalError
+                      : thrownValue;
+                if (
+                  12 === request.status &&
+                  null !== request.trackedPostpones
+                ) {
+                  var trackedPostpones = request.trackedPostpones,
+                    thrownInfo = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? logPostpone(request, x$jscomp$0.message, thrownInfo)
+                    : logRecoverableError(request, x$jscomp$0, thrownInfo);
+                  trackPostpone(
+                    request,
+                    trackedPostpones,
+                    task,
+                    segment$jscomp$0
+                  );
+                  finishedTask(request, task.blockedBoundary, segment$jscomp$0);
+                } else {
+                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0) {
+                    if ("function" === typeof x$jscomp$0.then) {
+                      segment$jscomp$0.status = 0;
+                      task.thenableState = getThenableStateAfterSuspending();
+                      var ping$jscomp$0 = task.ping;
+                      x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
+                      break a;
+                    }
+                    if (
+                      null !== request.trackedPostpones &&
+                      x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ) {
+                      var trackedPostpones$64 = request.trackedPostpones;
+                      task.abortSet.delete(task);
+                      var postponeInfo = getThrownInfo(task.componentStack);
+                      logPostpone(request, x$jscomp$0.message, postponeInfo);
+                      trackPostpone(
+                        request,
+                        trackedPostpones$64,
+                        task,
+                        segment$jscomp$0
+                      );
+                      finishedTask(
+                        request,
+                        task.blockedBoundary,
+                        segment$jscomp$0
+                      );
+                      break a;
+                    }
+                  }
+                  var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
+                  task.abortSet.delete(task);
+                  segment$jscomp$0.status = 4;
+                  var boundary = task.blockedBoundary;
+                  "object" === typeof x$jscomp$0 &&
+                  null !== x$jscomp$0 &&
+                  x$jscomp$0.$$typeof === REACT_POSTPONE_TYPE
+                    ? (logPostpone(
+                        request,
+                        x$jscomp$0.message,
+                        errorInfo$jscomp$0
+                      ),
+                      (request$jscomp$0 = "POSTPONE"))
+                    : (request$jscomp$0 = logRecoverableError(
+                        request,
+                        x$jscomp$0,
+                        errorInfo$jscomp$0
+                      ));
+                  null === boundary
+                    ? fatalError(request, x$jscomp$0)
+                    : (boundary.pendingTasks--,
+                      4 !== boundary.status &&
+                        ((boundary.status = 4),
+                        (boundary.errorDigest = request$jscomp$0),
+                        untrackBoundary(request, boundary),
+                        boundary.parentFlushed &&
+                          request.clientRenderedBoundaries.push(boundary)));
+                  request.allPendingTasks--;
+                  0 === request.allPendingTasks && completeAll(request);
+                }
+              } finally {
+              }
             }
-          } finally {
           }
-        }
       }
       pingedTasks.splice(0, i);
-      null !== request$jscomp$2.destination &&
-        flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
+      null !== request$jscomp$1.destination &&
+        flushCompletedQueues(request$jscomp$1, request$jscomp$1.destination);
     } catch (error) {
-      logRecoverableError(request$jscomp$2, error, {}),
-        fatalError(request$jscomp$2, error);
+      logRecoverableError(request$jscomp$1, error, {}),
+        fatalError(request$jscomp$1, error);
     } finally {
       (currentResumableState = prevResumableState),
         (ReactSharedInternals.H = prevDispatcher),
@@ -5581,85 +5998,6 @@ function performWork(request$jscomp$2) {
     }
   }
 }
-function preparePreambleFromSubtree(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  segment.preambleChildren.length &&
-    collectedPreambleSegments.push(segment.preambleChildren);
-  for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)
-    pendingPreambles =
-      preparePreambleFromSegment(
-        request,
-        segment.children[i],
-        collectedPreambleSegments
-      ) || pendingPreambles;
-  return pendingPreambles;
-}
-function preparePreambleFromSegment(
-  request,
-  segment,
-  collectedPreambleSegments
-) {
-  var boundary = segment.boundary;
-  if (null === boundary)
-    return preparePreambleFromSubtree(
-      request,
-      segment,
-      collectedPreambleSegments
-    );
-  var preamble = boundary.contentPreamble,
-    fallbackPreamble = boundary.fallbackPreamble;
-  if (null === preamble || null === fallbackPreamble) return !1;
-  switch (boundary.status) {
-    case 1:
-      hoistPreambleState(request.renderState, preamble);
-      segment = boundary.completedSegments[0];
-      if (!segment)
-        throw Error(
-          "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
-        );
-      return preparePreambleFromSubtree(
-        request,
-        segment,
-        collectedPreambleSegments
-      );
-    case 5:
-      if (null !== request.trackedPostpones) return !0;
-    case 4:
-      if (1 === segment.status)
-        return (
-          hoistPreambleState(request.renderState, fallbackPreamble),
-          preparePreambleFromSubtree(
-            request,
-            segment,
-            collectedPreambleSegments
-          )
-        );
-    default:
-      return !0;
-  }
-}
-function preparePreamble(request) {
-  if (
-    request.completedRootSegment &&
-    null === request.completedPreambleSegments
-  ) {
-    var collectedPreambleSegments = [],
-      hasPendingPreambles = preparePreambleFromSegment(
-        request,
-        request.completedRootSegment,
-        collectedPreambleSegments
-      ),
-      preamble = request.renderState.preamble;
-    if (
-      !1 === hasPendingPreambles ||
-      (preamble.headChunks && preamble.bodyChunks)
-    )
-      request.completedPreambleSegments = collectedPreambleSegments;
-  }
-}
 function flushSubtree(request, destination, segment, hoistableState) {
   segment.parentFlushed = !0;
   switch (segment.status) {
@@ -5792,31 +6130,46 @@ function flushCompletedBoundary(request, destination, boundary) {
   boundary = boundary.contentState;
   var requiresStyleInsertion = request.stylesToHoist;
   request.stylesToHoist = !1;
-  writeChunk(destination, request.startInlineScript);
-  requiresStyleInsertion
-    ? 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 10),
-        writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))
-      : 0 === (completedSegments.instructions & 8)
-        ? ((completedSegments.instructions |= 8),
-          writeChunk(destination, completeBoundaryWithStylesScript1FullPartial))
-        : writeChunk(destination, completeBoundaryWithStylesScript1Partial)
-    : 0 === (completedSegments.instructions & 2)
-      ? ((completedSegments.instructions |= 2),
-        writeChunk(destination, completeBoundaryScript1Full))
-      : writeChunk(destination, completeBoundaryScript1Partial);
+  var scriptFormat = 0 === completedSegments.streamingFormat;
+  scriptFormat
+    ? (writeChunk(destination, request.startInlineScript),
+      requiresStyleInsertion
+        ? 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 10),
+            writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))
+          : 0 === (completedSegments.instructions & 8)
+            ? ((completedSegments.instructions |= 8),
+              writeChunk(
+                destination,
+                completeBoundaryWithStylesScript1FullPartial
+              ))
+            : writeChunk(destination, completeBoundaryWithStylesScript1Partial)
+        : 0 === (completedSegments.instructions & 2)
+          ? ((completedSegments.instructions |= 2),
+            writeChunk(destination, completeBoundaryScript1Full))
+          : writeChunk(destination, completeBoundaryScript1Partial))
+    : requiresStyleInsertion
+      ? writeChunk(destination, completeBoundaryWithStylesData1)
+      : writeChunk(destination, completeBoundaryData1);
   completedSegments = i.toString(16);
   writeChunk(destination, request.boundaryPrefix);
   writeChunk(destination, completedSegments);
-  writeChunk(destination, completeBoundaryScript2);
+  scriptFormat
+    ? writeChunk(destination, completeBoundaryScript2)
+    : writeChunk(destination, completeBoundaryData2);
   writeChunk(destination, request.segmentPrefix);
   writeChunk(destination, completedSegments);
   requiresStyleInsertion
-    ? (writeChunk(destination, completeBoundaryScript3a),
-      writeStyleResourceDependenciesInJS(destination, boundary))
-    : writeChunk(destination, completeBoundaryScript3b);
-  boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
-  return writeBootstrap(destination, request) && boundary;
+    ? scriptFormat
+      ? (writeChunk(destination, completeBoundaryScript3a),
+        writeStyleResourceDependenciesInJS(destination, boundary))
+      : (writeChunk(destination, completeBoundaryData3a),
+        writeStyleResourceDependenciesInAttr(destination, boundary))
+    : scriptFormat && writeChunk(destination, completeBoundaryScript3b);
+  completedSegments = scriptFormat
+    ? writeChunkAndReturn(destination, completeBoundaryScriptEnd)
+    : writeChunkAndReturn(destination, dataElementQuotedEnd);
+  return writeBootstrap(destination, request) && completedSegments;
 }
 function flushPartiallyCompletedSegment(
   request,
@@ -5839,18 +6192,24 @@ function flushPartiallyCompletedSegment(
   flushSegmentContainer(request, destination, segment, hoistableState);
   boundary = request.resumableState;
   request = request.renderState;
-  writeChunk(destination, request.startInlineScript);
-  0 === (boundary.instructions & 1)
-    ? ((boundary.instructions |= 1),
-      writeChunk(destination, completeSegmentScript1Full))
-    : writeChunk(destination, completeSegmentScript1Partial);
+  (segment = 0 === boundary.streamingFormat)
+    ? (writeChunk(destination, request.startInlineScript),
+      0 === (boundary.instructions & 1)
+        ? ((boundary.instructions |= 1),
+          writeChunk(destination, completeSegmentScript1Full))
+        : writeChunk(destination, completeSegmentScript1Partial))
+    : writeChunk(destination, completeSegmentData1);
   writeChunk(destination, request.segmentPrefix);
   segmentID = segmentID.toString(16);
   writeChunk(destination, segmentID);
-  writeChunk(destination, completeSegmentScript2);
+  segment
+    ? writeChunk(destination, completeSegmentScript2)
+    : writeChunk(destination, completeSegmentData2);
   writeChunk(destination, request.placeholderPrefix);
   writeChunk(destination, segmentID);
-  destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
+  destination = segment
+    ? writeChunkAndReturn(destination, completeSegmentScriptEnd)
+    : writeChunkAndReturn(destination, dataElementQuotedEnd);
   return destination;
 }
 function flushCompletedQueues(request, destination) {
@@ -5863,12 +6222,22 @@ function flushCompletedQueues(request, destination) {
         completedRootSegment = request.completedRootSegment;
       if (null !== completedRootSegment) {
         if (5 === completedRootSegment.status) return;
-        var completedPreambleSegments = request.completedPreambleSegments;
-        if (null === completedPreambleSegments) return;
-        var renderState = request.renderState,
-          preamble = renderState.preamble,
-          htmlChunks = preamble.htmlChunks,
-          headChunks = preamble.headChunks,
+        var renderState = request.renderState;
+        if (
+          (0 !== request.allPendingTasks ||
+            null !== request.trackedPostpones) &&
+          renderState.externalRuntimeScript
+        ) {
+          var _renderState$external = renderState.externalRuntimeScript,
+            resumableState = request.resumableState,
+            src = _renderState$external.src,
+            chunks = _renderState$external.chunks;
+          resumableState.scriptResources.hasOwnProperty(src) ||
+            ((resumableState.scriptResources[src] = null),
+            renderState.scripts.add(chunks));
+        }
+        var htmlChunks = renderState.htmlChunks,
+          headChunks = renderState.headChunks,
           i$jscomp$0;
         if (htmlChunks) {
           for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
@@ -5909,27 +6278,10 @@ function flushCompletedQueues(request, destination) {
         var hoistableChunks = renderState.hoistableChunks;
         for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
           writeChunk(destination, hoistableChunks[i$jscomp$0]);
-        for (
-          renderState = hoistableChunks.length = 0;
-          renderState < completedPreambleSegments.length;
-          renderState++
-        ) {
-          var segments = completedPreambleSegments[renderState];
-          for (preamble = 0; preamble < segments.length; preamble++)
-            flushSegment(request, destination, segments[preamble], null);
-        }
-        var preamble$jscomp$0 = request.renderState.preamble,
-          headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
-        (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) &&
+        hoistableChunks.length = 0;
+        htmlChunks &&
+          null === headChunks &&
           writeChunk(destination, endChunkForTag("head"));
-        var bodyChunks = preamble$jscomp$0.bodyChunks;
-        if (bodyChunks)
-          for (
-            completedPreambleSegments = 0;
-            completedPreambleSegments < bodyChunks.length;
-            completedPreambleSegments++
-          )
-            writeChunk(destination, bodyChunks[completedPreambleSegments]);
         flushSegment(request, destination, completedRootSegment, null);
         request.completedRootSegment = null;
         writeBootstrap(destination, request.renderState);
@@ -5970,34 +6322,42 @@ function flushCompletedQueues(request, destination) {
       for (i = 0; i < clientRenderedBoundaries.length; i++) {
         var boundary = clientRenderedBoundaries[i];
         renderState$jscomp$0 = destination;
-        var resumableState = request.resumableState,
+        var resumableState$jscomp$0 = request.resumableState,
           renderState$jscomp$1 = request.renderState,
           id = boundary.rootSegmentID,
-          errorDigest = boundary.errorDigest;
-        writeChunk(
-          renderState$jscomp$0,
-          renderState$jscomp$1.startInlineScript
-        );
-        0 === (resumableState.instructions & 4)
-          ? ((resumableState.instructions |= 4),
-            writeChunk(renderState$jscomp$0, clientRenderScript1Full))
-          : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
+          errorDigest = boundary.errorDigest,
+          scriptFormat = 0 === resumableState$jscomp$0.streamingFormat;
+        scriptFormat
+          ? (writeChunk(
+              renderState$jscomp$0,
+              renderState$jscomp$1.startInlineScript
+            ),
+            0 === (resumableState$jscomp$0.instructions & 4)
+              ? ((resumableState$jscomp$0.instructions |= 4),
+                writeChunk(renderState$jscomp$0, clientRenderScript1Full))
+              : writeChunk(renderState$jscomp$0, clientRenderScript1Partial))
+          : writeChunk(renderState$jscomp$0, clientRenderData1);
         writeChunk(renderState$jscomp$0, renderState$jscomp$1.boundaryPrefix);
         writeChunk(renderState$jscomp$0, id.toString(16));
-        writeChunk(renderState$jscomp$0, clientRenderScript1A);
+        scriptFormat && writeChunk(renderState$jscomp$0, clientRenderScript1A);
         errorDigest &&
-          (writeChunk(
-            renderState$jscomp$0,
-            clientRenderErrorScriptArgInterstitial
-          ),
-          writeChunk(
-            renderState$jscomp$0,
-            escapeJSStringsForInstructionScripts(errorDigest || "")
-          ));
-        var JSCompiler_inline_result = writeChunkAndReturn(
-          renderState$jscomp$0,
-          clientRenderScriptEnd
-        );
+          (scriptFormat
+            ? (writeChunk(
+                renderState$jscomp$0,
+                clientRenderErrorScriptArgInterstitial
+              ),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeJSStringsForInstructionScripts(errorDigest || "")
+              ))
+            : (writeChunk(renderState$jscomp$0, clientRenderData2),
+              writeChunk(
+                renderState$jscomp$0,
+                escapeTextForBrowser(errorDigest || "")
+              )));
+        var JSCompiler_inline_result = scriptFormat
+          ? writeChunkAndReturn(renderState$jscomp$0, clientRenderScriptEnd)
+          : writeChunkAndReturn(renderState$jscomp$0, dataElementQuotedEnd);
         if (!JSCompiler_inline_result) {
           request.destination = null;
           i++;
@@ -6023,11 +6383,11 @@ function flushCompletedQueues(request, destination) {
       destinationHasCapacity$1 = !0;
       var partialBoundaries = request.partialBoundaries;
       for (i = 0; i < partialBoundaries.length; i++) {
-        var boundary$51 = partialBoundaries[i];
+        var boundary$67 = partialBoundaries[i];
         a: {
           clientRenderedBoundaries = request;
           boundary = destination;
-          var completedSegments = boundary$51.completedSegments;
+          var completedSegments = boundary$67.completedSegments;
           for (
             JSCompiler_inline_result = 0;
             JSCompiler_inline_result < completedSegments.length;
@@ -6037,7 +6397,7 @@ function flushCompletedQueues(request, destination) {
               !flushPartiallyCompletedSegment(
                 clientRenderedBoundaries,
                 boundary,
-                boundary$51,
+                boundary$67,
                 completedSegments[JSCompiler_inline_result]
               )
             ) {
@@ -6049,7 +6409,7 @@ function flushCompletedQueues(request, destination) {
           completedSegments.splice(0, JSCompiler_inline_result);
           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
             boundary,
-            boundary$51.contentState,
+            boundary$67.contentState,
             clientRenderedBoundaries.renderState
           );
         }
@@ -6077,9 +6437,10 @@ function flushCompletedQueues(request, destination) {
     0 === request.clientRenderedBoundaries.length &&
     0 === request.completedBoundaries.length
       ? ((request.flushScheduled = !1),
-        (i = request.resumableState),
-        i.hasBody && writeChunk(destination, endChunkForTag("body")),
-        i.hasHtml && writeChunk(destination, endChunkForTag("html")),
+        null === request.trackedPostpones &&
+          ((i = request.resumableState),
+          i.hasBody && writeChunk(destination, endChunkForTag("body")),
+          i.hasHtml && writeChunk(destination, endChunkForTag("html"))),
         completeWriting(destination),
         flushBuffered(destination),
         (request.status = 14),
@@ -6151,17 +6512,68 @@ function abort(request, reason) {
     }
     null !== request.destination &&
       flushCompletedQueues(request, request.destination);
-  } catch (error$53) {
-    logRecoverableError(request, error$53, {}), fatalError(request, error$53);
+  } catch (error$69) {
+    logRecoverableError(request, error$69, {}), fatalError(request, error$69);
   }
 }
+function addToReplayParent(node, parentKeyPath, trackedPostpones) {
+  if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
+  else {
+    var workingMap = trackedPostpones.workingMap,
+      parentNode = workingMap.get(parentKeyPath);
+    void 0 === parentNode &&
+      ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),
+      workingMap.set(parentKeyPath, parentNode),
+      addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
+    parentNode[2].push(node);
+  }
+}
+function getPostponedState(request) {
+  var trackedPostpones = request.trackedPostpones;
+  if (
+    null === trackedPostpones ||
+    (0 === trackedPostpones.rootNodes.length &&
+      null === trackedPostpones.rootSlots)
+  )
+    return (request.trackedPostpones = null);
+  if (
+    null !== request.completedRootSegment &&
+    5 === request.completedRootSegment.status
+  ) {
+    var resumableState = request.resumableState,
+      renderState = request.renderState;
+    resumableState.nextFormID = 0;
+    resumableState.hasBody = !1;
+    resumableState.hasHtml = !1;
+    resumableState.unknownResources = { font: renderState.resets.font };
+    resumableState.dnsResources = renderState.resets.dns;
+    resumableState.connectResources = renderState.resets.connect;
+    resumableState.imageResources = renderState.resets.image;
+    resumableState.styleResources = renderState.resets.style;
+    resumableState.scriptResources = {};
+    resumableState.moduleUnknownResources = {};
+    resumableState.moduleScriptResources = {};
+  } else
+    (resumableState = request.resumableState),
+      (resumableState.bootstrapScriptContent = void 0),
+      (resumableState.bootstrapScripts = void 0),
+      (resumableState.bootstrapModules = void 0);
+  return {
+    nextSegmentId: request.nextSegmentId,
+    rootFormatContext: request.rootFormatContext,
+    progressiveChunkSize: request.progressiveChunkSize,
+    resumableState: request.resumableState,
+    replayNodes: trackedPostpones.rootNodes,
+    replaySlots: trackedPostpones.rootSlots
+  };
+}
 function ensureCorrectIsomorphicReactVersion() {
   var isomorphicReactPackageVersion = React.version;
-  if ("19.1.0-canary-c492f975-20250128" !== isomorphicReactPackageVersion)
+  if ("19.1.0-experimental-b3a95caf-20250113" !== isomorphicReactPackageVersion)
     throw Error(
       'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
         (isomorphicReactPackageVersion +
-          "\n  - react-dom:  19.1.0-canary-c492f975-20250128\nLearn more: https://react.dev/warnings/version-mismatch")
+          "\n  - react-dom:  19.1.0-experimental-b3a95caf-20250113\nLearn more: https://react.dev/warnings/version-mismatch")
     );
 }
 ensureCorrectIsomorphicReactVersion();
@@ -6206,6 +6618,26 @@ function createRequestImpl(children, options) {
     options ? options.formState : void 0
   );
 }
+function resumeRequestImpl(children, postponedState, options) {
+  return resumeRequest(
+    children,
+    postponedState,
+    createRenderState(
+      postponedState.resumableState,
+      options ? options.nonce : void 0,
+      void 0,
+      void 0,
+      void 0,
+      void 0
+    ),
+    options ? options.onError : void 0,
+    options ? options.onAllReady : void 0,
+    options ? options.onShellReady : void 0,
+    options ? options.onShellError : void 0,
+    void 0,
+    options ? options.onPostpone : void 0
+  );
+}
 ensureCorrectIsomorphicReactVersion();
 function createFakeWritable(readable) {
   return {
@@ -6250,7 +6682,11 @@ exports.prerenderToNodeStream = function (children, options) {
               }
             }),
             writable = createFakeWritable(readable);
-          resolve({ prelude: readable });
+          readable = {
+            postponed: getPostponedState(request),
+            prelude: readable
+          };
+          resolve(readable);
         },
         void 0,
         void 0,
@@ -6310,4 +6746,82 @@ exports.renderToPipeableStream = function (children, options) {
     }
   };
 };
-exports.version = "19.1.0-canary-c492f975-20250128";
+exports.resumeAndPrerenderToNodeStream = function (
+  children,
+  postponedState,
+  options
+) {
+  return new Promise(function (resolve, reject) {
+    var request = resumeAndPrerenderRequest(
+      children,
+      postponedState,
+      createRenderState(
+        postponedState.resumableState,
+        options ? options.nonce : void 0,
+        void 0,
+        void 0,
+        void 0,
+        void 0
+      ),
+      options ? options.onError : void 0,
+      function () {
+        var readable = new stream.Readable({
+            read: function () {
+              startFlowing(request, writable);
+            }
+          }),
+          writable = createFakeWritable(readable);
+        readable = { postponed: getPostponedState(request), prelude: readable };
+        resolve(readable);
+      },
+      void 0,
+      void 0,
+      reject,
+      options ? options.onPostpone : void 0
+    );
+    if (options && options.signal) {
+      var signal = options.signal;
+      if (signal.aborted) abort(request, signal.reason);
+      else {
+        var listener = function () {
+          abort(request, signal.reason);
+          signal.removeEventListener("abort", listener);
+        };
+        signal.addEventListener("abort", listener);
+      }
+    }
+    startWork(request);
+  });
+};
+exports.resumeToPipeableStream = function (children, postponedState, options) {
+  var request = resumeRequestImpl(children, postponedState, options),
+    hasStartedFlowing = !1;
+  startWork(request);
+  return {
+    pipe: function (destination) {
+      if (hasStartedFlowing)
+        throw Error(
+          "React currently only supports piping to one writable stream."
+        );
+      hasStartedFlowing = !0;
+      startFlowing(request, destination);
+      destination.on("drain", createDrainHandler(destination, request));
+      destination.on(
+        "error",
+        createCancelHandler(
+          request,
+          "The destination stream errored while writing data."
+        )
+      );
+      destination.on(
+        "close",
+        createCancelHandler(request, "The destination stream closed early.")
+      );
+      return destination;
+    },
+    abort: function (reason) {
+      abort(request, reason);
+    }
+  };
+};
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
diff --git a/node_modules/react-dom/cjs/react-dom-unstable_testing.development.js b/node_modules/react-dom/cjs/react-dom-unstable_testing.development.js
new file mode 100644
index 0000000..60199b0
--- /dev/null
+++ b/node_modules/react-dom/cjs/react-dom-unstable_testing.development.js
@@ -0,0 +1,27486 @@
+/**
+ * @license React
+ * react-dom-unstable_testing.development.js
+ *
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/*
+ Modernizr 3.0.0pre (Custom Build) | MIT
+*/
+"use strict";
+"production" !== process.env.NODE_ENV &&
+  (function () {
+    function findHook(fiber, id) {
+      for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
+        (fiber = fiber.next), id--;
+      return fiber;
+    }
+    function copyWithSetImpl(obj, path, index, value) {
+      if (index >= path.length) return value;
+      var key = path[index],
+        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
+      updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
+      return updated;
+    }
+    function copyWithRename(obj, oldPath, newPath) {
+      if (oldPath.length !== newPath.length)
+        console.warn("copyWithRename() expects paths of the same length");
+      else {
+        for (var i = 0; i < newPath.length - 1; i++)
+          if (oldPath[i] !== newPath[i]) {
+            console.warn(
+              "copyWithRename() expects paths to be the same except for the deepest key"
+            );
+            return;
+          }
+        return copyWithRenameImpl(obj, oldPath, newPath, 0);
+      }
+    }
+    function copyWithRenameImpl(obj, oldPath, newPath, index) {
+      var oldKey = oldPath[index],
+        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
+      index + 1 === oldPath.length
+        ? ((updated[newPath[index]] = updated[oldKey]),
+          isArrayImpl(updated)
+            ? updated.splice(oldKey, 1)
+            : delete updated[oldKey])
+        : (updated[oldKey] = copyWithRenameImpl(
+            obj[oldKey],
+            oldPath,
+            newPath,
+            index + 1
+          ));
+      return updated;
+    }
+    function copyWithDeleteImpl(obj, path, index) {
+      var key = path[index],
+        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
+      if (index + 1 === path.length)
+        return (
+          isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key],
+          updated
+        );
+      updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
+      return updated;
+    }
+    function shouldSuspendImpl() {
+      return !1;
+    }
+    function shouldErrorImpl() {
+      return null;
+    }
+    function createFiber(tag, pendingProps, key, mode) {
+      return new FiberNode(tag, pendingProps, key, mode);
+    }
+    function warnForMissingKey() {}
+    function warnInvalidHookAccess() {
+      console.error(
+        "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
+      );
+    }
+    function warnInvalidContextAccess() {
+      console.error(
+        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+      );
+    }
+    function noop$2() {}
+    function setToSortedString(set) {
+      var array = [];
+      set.forEach(function (value) {
+        array.push(value);
+      });
+      return array.sort().join(", ");
+    }
+    function scheduleRoot(root, element) {
+      root.context === emptyContextObject &&
+        (updateContainerImpl(root.current, 2, element, root, null, null),
+        flushSyncWork$1());
+    }
+    function scheduleRefresh(root, update) {
+      if (null !== resolveFamily) {
+        var staleFamilies = update.staleFamilies;
+        update = update.updatedFamilies;
+        flushPendingEffects();
+        scheduleFibersWithFamiliesRecursively(
+          root.current,
+          update,
+          staleFamilies
+        );
+        flushSyncWork$1();
+      }
+    }
+    function setRefreshHandler(handler) {
+      resolveFamily = handler;
+    }
+    function isValidContainer(node) {
+      return !(
+        !node ||
+        (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
+      );
+    }
+    function getNearestMountedFiber(fiber) {
+      var node = fiber,
+        nearestMounted = fiber;
+      if (fiber.alternate) for (; node.return; ) node = node.return;
+      else {
+        fiber = node;
+        do
+          (node = fiber),
+            0 !== (node.flags & 4098) && (nearestMounted = node.return),
+            (fiber = node.return);
+        while (fiber);
+      }
+      return 3 === node.tag ? nearestMounted : null;
+    }
+    function getSuspenseInstanceFromFiber(fiber) {
+      if (13 === fiber.tag) {
+        var suspenseState = fiber.memoizedState;
+        null === suspenseState &&
+          ((fiber = fiber.alternate),
+          null !== fiber && (suspenseState = fiber.memoizedState));
+        if (null !== suspenseState) return suspenseState.dehydrated;
+      }
+      return null;
+    }
+    function assertIsMounted(fiber) {
+      if (getNearestMountedFiber(fiber) !== fiber)
+        throw Error("Unable to find node on an unmounted component.");
+    }
+    function findCurrentFiberUsingSlowPath(fiber) {
+      var alternate = fiber.alternate;
+      if (!alternate) {
+        alternate = getNearestMountedFiber(fiber);
+        if (null === alternate)
+          throw Error("Unable to find node on an unmounted component.");
+        return alternate !== fiber ? null : fiber;
+      }
+      for (var a = fiber, b = alternate; ; ) {
+        var parentA = a.return;
+        if (null === parentA) break;
+        var parentB = parentA.alternate;
+        if (null === parentB) {
+          b = parentA.return;
+          if (null !== b) {
+            a = b;
+            continue;
+          }
+          break;
+        }
+        if (parentA.child === parentB.child) {
+          for (parentB = parentA.child; parentB; ) {
+            if (parentB === a) return assertIsMounted(parentA), fiber;
+            if (parentB === b) return assertIsMounted(parentA), alternate;
+            parentB = parentB.sibling;
+          }
+          throw Error("Unable to find node on an unmounted component.");
+        }
+        if (a.return !== b.return) (a = parentA), (b = parentB);
+        else {
+          for (var didFindChild = !1, _child = parentA.child; _child; ) {
+            if (_child === a) {
+              didFindChild = !0;
+              a = parentA;
+              b = parentB;
+              break;
+            }
+            if (_child === b) {
+              didFindChild = !0;
+              b = parentA;
+              a = parentB;
+              break;
+            }
+            _child = _child.sibling;
+          }
+          if (!didFindChild) {
+            for (_child = parentB.child; _child; ) {
+              if (_child === a) {
+                didFindChild = !0;
+                a = parentB;
+                b = parentA;
+                break;
+              }
+              if (_child === b) {
+                didFindChild = !0;
+                b = parentB;
+                a = parentA;
+                break;
+              }
+              _child = _child.sibling;
+            }
+            if (!didFindChild)
+              throw Error(
+                "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
+              );
+          }
+        }
+        if (a.alternate !== b)
+          throw Error(
+            "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
+          );
+      }
+      if (3 !== a.tag)
+        throw Error("Unable to find node on an unmounted component.");
+      return a.stateNode.current === a ? fiber : alternate;
+    }
+    function findCurrentHostFiberImpl(node) {
+      var tag = node.tag;
+      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
+      for (node = node.child; null !== node; ) {
+        tag = findCurrentHostFiberImpl(node);
+        if (null !== tag) return tag;
+        node = node.sibling;
+      }
+      return null;
+    }
+    function getIteratorFn(maybeIterable) {
+      if (null === maybeIterable || "object" !== typeof maybeIterable)
+        return null;
+      maybeIterable =
+        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
+        maybeIterable["@@iterator"];
+      return "function" === typeof maybeIterable ? maybeIterable : null;
+    }
+    function getComponentNameFromType(type) {
+      if (null == type) return null;
+      if ("function" === typeof type)
+        return type.$$typeof === REACT_CLIENT_REFERENCE
+          ? null
+          : type.displayName || type.name || null;
+      if ("string" === typeof type) return type;
+      switch (type) {
+        case REACT_FRAGMENT_TYPE:
+          return "Fragment";
+        case REACT_PORTAL_TYPE:
+          return "Portal";
+        case REACT_PROFILER_TYPE:
+          return "Profiler";
+        case REACT_STRICT_MODE_TYPE:
+          return "StrictMode";
+        case REACT_SUSPENSE_TYPE:
+          return "Suspense";
+        case REACT_SUSPENSE_LIST_TYPE:
+          return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
+      }
+      if ("object" === typeof type)
+        switch (
+          ("number" === typeof type.tag &&
+            console.error(
+              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
+            ),
+          type.$$typeof)
+        ) {
+          case REACT_CONTEXT_TYPE:
+            return (type.displayName || "Context") + ".Provider";
+          case REACT_CONSUMER_TYPE:
+            return (type._context.displayName || "Context") + ".Consumer";
+          case REACT_FORWARD_REF_TYPE:
+            var innerType = type.render;
+            type = type.displayName;
+            type ||
+              ((type = innerType.displayName || innerType.name || ""),
+              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
+            return type;
+          case REACT_MEMO_TYPE:
+            return (
+              (innerType = type.displayName || null),
+              null !== innerType
+                ? innerType
+                : getComponentNameFromType(type.type) || "Memo"
+            );
+          case REACT_LAZY_TYPE:
+            innerType = type._payload;
+            type = type._init;
+            try {
+              return getComponentNameFromType(type(innerType));
+            } catch (x) {}
+        }
+      return null;
+    }
+    function getComponentNameFromOwner(owner) {
+      return "number" === typeof owner.tag
+        ? getComponentNameFromFiber(owner)
+        : "string" === typeof owner.name
+          ? owner.name
+          : null;
+    }
+    function getComponentNameFromFiber(fiber) {
+      var type = fiber.type;
+      switch (fiber.tag) {
+        case 24:
+          return "Cache";
+        case 9:
+          return (type._context.displayName || "Context") + ".Consumer";
+        case 10:
+          return (type.displayName || "Context") + ".Provider";
+        case 18:
+          return "DehydratedFragment";
+        case 11:
+          return (
+            (fiber = type.render),
+            (fiber = fiber.displayName || fiber.name || ""),
+            type.displayName ||
+              ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef")
+          );
+        case 7:
+          return "Fragment";
+        case 26:
+        case 27:
+        case 5:
+          return type;
+        case 4:
+          return "Portal";
+        case 3:
+          return "Root";
+        case 6:
+          return "Text";
+        case 16:
+          return getComponentNameFromType(type);
+        case 8:
+          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
+        case 22:
+          return "Offscreen";
+        case 12:
+          return "Profiler";
+        case 21:
+          return "Scope";
+        case 13:
+          return "Suspense";
+        case 19:
+          return "SuspenseList";
+        case 25:
+          return "TracingMarker";
+        case 30:
+          return "ViewTransition";
+        case 1:
+        case 0:
+        case 14:
+        case 15:
+          if ("function" === typeof type)
+            return type.displayName || type.name || null;
+          if ("string" === typeof type) return type;
+          break;
+        case 29:
+          type = fiber._debugInfo;
+          if (null != type)
+            for (var i = type.length - 1; 0 <= i; i--)
+              if ("string" === typeof type[i].name) return type[i].name;
+          if (null !== fiber.return)
+            return getComponentNameFromFiber(fiber.return);
+      }
+      return null;
+    }
+    function createCursor(defaultValue) {
+      return { current: defaultValue };
+    }
+    function pop(cursor, fiber) {
+      0 > index$jscomp$0
+        ? console.error("Unexpected pop.")
+        : (fiber !== fiberStack[index$jscomp$0] &&
+            console.error("Unexpected Fiber popped."),
+          (cursor.current = valueStack[index$jscomp$0]),
+          (valueStack[index$jscomp$0] = null),
+          (fiberStack[index$jscomp$0] = null),
+          index$jscomp$0--);
+    }
+    function push(cursor, value, fiber) {
+      index$jscomp$0++;
+      valueStack[index$jscomp$0] = cursor.current;
+      fiberStack[index$jscomp$0] = fiber;
+      cursor.current = value;
+    }
+    function requiredContext(c) {
+      null === c &&
+        console.error(
+          "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
+        );
+      return c;
+    }
+    function pushHostContainer(fiber, nextRootInstance) {
+      push(rootInstanceStackCursor, nextRootInstance, fiber);
+      push(contextFiberStackCursor, fiber, fiber);
+      push(contextStackCursor, null, fiber);
+      var nextRootContext = nextRootInstance.nodeType;
+      switch (nextRootContext) {
+        case 9:
+        case 11:
+          nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
+          nextRootInstance = (nextRootInstance =
+            nextRootInstance.documentElement)
+            ? (nextRootInstance = nextRootInstance.namespaceURI)
+              ? getOwnHostContext(nextRootInstance)
+              : HostContextNamespaceNone
+            : HostContextNamespaceNone;
+          break;
+        default:
+          if (
+            ((nextRootInstance =
+              8 === nextRootContext
+                ? nextRootInstance.parentNode
+                : nextRootInstance),
+            (nextRootContext = nextRootInstance.tagName),
+            (nextRootInstance = nextRootInstance.namespaceURI))
+          )
+            (nextRootInstance = getOwnHostContext(nextRootInstance)),
+              (nextRootInstance = getChildHostContextProd(
+                nextRootInstance,
+                nextRootContext
+              ));
+          else
+            switch (nextRootContext) {
+              case "svg":
+                nextRootInstance = HostContextNamespaceSvg;
+                break;
+              case "math":
+                nextRootInstance = HostContextNamespaceMath;
+                break;
+              default:
+                nextRootInstance = HostContextNamespaceNone;
+            }
+      }
+      nextRootContext = nextRootContext.toLowerCase();
+      nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
+      nextRootContext = {
+        context: nextRootInstance,
+        ancestorInfo: nextRootContext
+      };
+      pop(contextStackCursor, fiber);
+      push(contextStackCursor, nextRootContext, fiber);
+    }
+    function popHostContainer(fiber) {
+      pop(contextStackCursor, fiber);
+      pop(contextFiberStackCursor, fiber);
+      pop(rootInstanceStackCursor, fiber);
+    }
+    function getHostContext() {
+      return requiredContext(contextStackCursor.current);
+    }
+    function pushHostContext(fiber) {
+      null !== fiber.memoizedState &&
+        push(hostTransitionProviderCursor, fiber, fiber);
+      var context = requiredContext(contextStackCursor.current);
+      var type = fiber.type;
+      var nextContext = getChildHostContextProd(context.context, type);
+      type = updatedAncestorInfoDev(context.ancestorInfo, type);
+      nextContext = { context: nextContext, ancestorInfo: type };
+      context !== nextContext &&
+        (push(contextFiberStackCursor, fiber, fiber),
+        push(contextStackCursor, nextContext, fiber));
+    }
+    function popHostContext(fiber) {
+      contextFiberStackCursor.current === fiber &&
+        (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
+      hostTransitionProviderCursor.current === fiber &&
+        (pop(hostTransitionProviderCursor, fiber),
+        (HostTransitionContext._currentValue = NotPendingTransition));
+    }
+    function typeName(value) {
+      return (
+        ("function" === typeof Symbol &&
+          Symbol.toStringTag &&
+          value[Symbol.toStringTag]) ||
+        value.constructor.name ||
+        "Object"
+      );
+    }
+    function willCoercionThrow(value) {
+      try {
+        return testStringCoercion(value), !1;
+      } catch (e) {
+        return !0;
+      }
+    }
+    function testStringCoercion(value) {
+      return "" + value;
+    }
+    function checkAttributeStringCoercion(value, attributeName) {
+      if (willCoercionThrow(value))
+        return (
+          console.error(
+            "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
+            attributeName,
+            typeName(value)
+          ),
+          testStringCoercion(value)
+        );
+    }
+    function checkCSSPropertyStringCoercion(value, propName) {
+      if (willCoercionThrow(value))
+        return (
+          console.error(
+            "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
+            propName,
+            typeName(value)
+          ),
+          testStringCoercion(value)
+        );
+    }
+    function checkFormFieldValueStringCoercion(value) {
+      if (willCoercionThrow(value))
+        return (
+          console.error(
+            "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
+            typeName(value)
+          ),
+          testStringCoercion(value)
+        );
+    }
+    function injectInternals(internals) {
+      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
+      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+      if (hook.isDisabled) return !0;
+      if (!hook.supportsFiber)
+        return (
+          console.error(
+            "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
+          ),
+          !0
+        );
+      try {
+        (rendererID = hook.inject(internals)), (injectedHook = hook);
+      } catch (err) {
+        console.error("React instrumentation encountered an error: %s.", err);
+      }
+      return hook.checkDCE ? !0 : !1;
+    }
+    function setIsStrictModeForDevtools(newIsStrictMode) {
+      "function" === typeof log$1 &&
+        unstable_setDisableYieldValue(newIsStrictMode);
+      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
+        try {
+          injectedHook.setStrictMode(rendererID, newIsStrictMode);
+        } catch (err) {
+          hasLoggedError ||
+            ((hasLoggedError = !0),
+            console.error(
+              "React instrumentation encountered an error: %s",
+              err
+            ));
+        }
+    }
+    function clz32Fallback(x) {
+      x >>>= 0;
+      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
+    }
+    function getHighestPriorityLanes(lanes) {
+      var pendingSyncLanes = lanes & 42;
+      if (0 !== pendingSyncLanes) return pendingSyncLanes;
+      switch (lanes & -lanes) {
+        case 1:
+          return 1;
+        case 2:
+          return 2;
+        case 4:
+          return 4;
+        case 8:
+          return 8;
+        case 16:
+          return 16;
+        case 32:
+          return 32;
+        case 64:
+          return 64;
+        case 128:
+        case 256:
+        case 512:
+        case 1024:
+        case 2048:
+        case 4096:
+        case 8192:
+        case 16384:
+        case 32768:
+        case 65536:
+        case 131072:
+        case 262144:
+        case 524288:
+        case 1048576:
+        case 2097152:
+          return lanes & 4194176;
+        case 4194304:
+        case 8388608:
+        case 16777216:
+        case 33554432:
+          return lanes & 62914560;
+        case 67108864:
+          return 67108864;
+        case 134217728:
+          return 134217728;
+        case 268435456:
+          return 268435456;
+        case 536870912:
+          return 536870912;
+        case 1073741824:
+          return 0;
+        default:
+          return (
+            console.error(
+              "Should have found matching lanes. This is a bug in React."
+            ),
+            lanes
+          );
+      }
+    }
+    function getNextLanes(root, wipLanes, rootHasPendingCommit) {
+      var pendingLanes = root.pendingLanes;
+      if (0 === pendingLanes) return 0;
+      var nextLanes = 0,
+        suspendedLanes = root.suspendedLanes,
+        pingedLanes = root.pingedLanes;
+      root = root.warmLanes;
+      var nonIdlePendingLanes = pendingLanes & 134217727;
+      0 !== nonIdlePendingLanes
+        ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
+          0 !== pendingLanes
+            ? (nextLanes = getHighestPriorityLanes(pendingLanes))
+            : ((pingedLanes &= nonIdlePendingLanes),
+              0 !== pingedLanes
+                ? (nextLanes = getHighestPriorityLanes(pingedLanes))
+                : rootHasPendingCommit ||
+                  ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
+                  0 !== rootHasPendingCommit &&
+                    (nextLanes =
+                      getHighestPriorityLanes(rootHasPendingCommit)))))
+        : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
+          0 !== nonIdlePendingLanes
+            ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
+            : 0 !== pingedLanes
+              ? (nextLanes = getHighestPriorityLanes(pingedLanes))
+              : rootHasPendingCommit ||
+                ((rootHasPendingCommit = pendingLanes & ~root),
+                0 !== rootHasPendingCommit &&
+                  (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
+      return 0 === nextLanes
+        ? 0
+        : 0 !== wipLanes &&
+            wipLanes !== nextLanes &&
+            0 === (wipLanes & suspendedLanes) &&
+            ((suspendedLanes = nextLanes & -nextLanes),
+            (rootHasPendingCommit = wipLanes & -wipLanes),
+            suspendedLanes >= rootHasPendingCommit ||
+              (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194176)))
+          ? wipLanes
+          : nextLanes;
+    }
+    function checkIfRootIsPrerendering(root, renderLanes) {
+      return (
+        0 ===
+        (root.pendingLanes &
+          ~(root.suspendedLanes & ~root.pingedLanes) &
+          renderLanes)
+      );
+    }
+    function computeExpirationTime(lane, currentTime) {
+      switch (lane) {
+        case 1:
+        case 2:
+        case 4:
+        case 8:
+          return currentTime + 250;
+        case 16:
+        case 32:
+        case 64:
+        case 128:
+        case 256:
+        case 512:
+        case 1024:
+        case 2048:
+        case 4096:
+        case 8192:
+        case 16384:
+        case 32768:
+        case 65536:
+        case 131072:
+        case 262144:
+        case 524288:
+        case 1048576:
+        case 2097152:
+          return currentTime + 5e3;
+        case 4194304:
+        case 8388608:
+        case 16777216:
+        case 33554432:
+          return -1;
+        case 67108864:
+        case 134217728:
+        case 268435456:
+        case 536870912:
+        case 1073741824:
+          return -1;
+        default:
+          return (
+            console.error(
+              "Should have found matching lanes. This is a bug in React."
+            ),
+            -1
+          );
+      }
+    }
+    function claimNextTransitionLane() {
+      var lane = nextTransitionLane;
+      nextTransitionLane <<= 1;
+      0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
+      return lane;
+    }
+    function claimNextRetryLane() {
+      var lane = nextRetryLane;
+      nextRetryLane <<= 1;
+      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
+      return lane;
+    }
+    function createLaneMap(initial) {
+      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
+      return laneMap;
+    }
+    function markRootUpdated$1(root, updateLane) {
+      root.pendingLanes |= updateLane;
+      268435456 !== updateLane &&
+        ((root.suspendedLanes = 0),
+        (root.pingedLanes = 0),
+        (root.warmLanes = 0));
+    }
+    function markRootFinished(
+      root,
+      finishedLanes,
+      remainingLanes,
+      spawnedLane,
+      updatedLanes,
+      suspendedRetryLanes
+    ) {
+      var previouslyPendingLanes = root.pendingLanes;
+      root.pendingLanes = remainingLanes;
+      root.suspendedLanes = 0;
+      root.pingedLanes = 0;
+      root.warmLanes = 0;
+      root.expiredLanes &= remainingLanes;
+      root.entangledLanes &= remainingLanes;
+      root.errorRecoveryDisabledLanes &= remainingLanes;
+      root.shellSuspendCounter = 0;
+      var entanglements = root.entanglements,
+        expirationTimes = root.expirationTimes,
+        hiddenUpdates = root.hiddenUpdates;
+      for (
+        remainingLanes = previouslyPendingLanes & ~remainingLanes;
+        0 < remainingLanes;
+
+      ) {
+        var index = 31 - clz32(remainingLanes),
+          lane = 1 << index;
+        entanglements[index] = 0;
+        expirationTimes[index] = -1;
+        var hiddenUpdatesForLane = hiddenUpdates[index];
+        if (null !== hiddenUpdatesForLane)
+          for (
+            hiddenUpdates[index] = null, index = 0;
+            index < hiddenUpdatesForLane.length;
+            index++
+          ) {
+            var update = hiddenUpdatesForLane[index];
+            null !== update && (update.lane &= -536870913);
+          }
+        remainingLanes &= ~lane;
+      }
+      0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
+      0 !== suspendedRetryLanes &&
+        0 === updatedLanes &&
+        0 !== root.tag &&
+        (root.suspendedLanes |=
+          suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
+    }
+    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
+      root.pendingLanes |= spawnedLane;
+      root.suspendedLanes &= ~spawnedLane;
+      var spawnedLaneIndex = 31 - clz32(spawnedLane);
+      root.entangledLanes |= spawnedLane;
+      root.entanglements[spawnedLaneIndex] =
+        root.entanglements[spawnedLaneIndex] |
+        1073741824 |
+        (entangledLanes & 4194218);
+    }
+    function markRootEntangled(root, entangledLanes) {
+      var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
+      for (root = root.entanglements; rootEntangledLanes; ) {
+        var index = 31 - clz32(rootEntangledLanes),
+          lane = 1 << index;
+        (lane & entangledLanes) | (root[index] & entangledLanes) &&
+          (root[index] |= entangledLanes);
+        rootEntangledLanes &= ~lane;
+      }
+    }
+    function getBumpedLaneForHydrationByLane(lane) {
+      switch (lane) {
+        case 2:
+          lane = 1;
+          break;
+        case 8:
+          lane = 4;
+          break;
+        case 32:
+          lane = 16;
+          break;
+        case 128:
+        case 256:
+        case 512:
+        case 1024:
+        case 2048:
+        case 4096:
+        case 8192:
+        case 16384:
+        case 32768:
+        case 65536:
+        case 131072:
+        case 262144:
+        case 524288:
+        case 1048576:
+        case 2097152:
+        case 4194304:
+        case 8388608:
+        case 16777216:
+        case 33554432:
+          lane = 64;
+          break;
+        case 268435456:
+          lane = 134217728;
+          break;
+        default:
+          lane = 0;
+      }
+      return lane;
+    }
+    function addFiberToLanesMap(root, fiber, lanes) {
+      if (isDevToolsPresent)
+        for (root = root.pendingUpdatersLaneMap; 0 < lanes; ) {
+          var index = 31 - clz32(lanes),
+            lane = 1 << index;
+          root[index].add(fiber);
+          lanes &= ~lane;
+        }
+    }
+    function movePendingFibersToMemoized(root, lanes) {
+      if (isDevToolsPresent)
+        for (
+          var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap,
+            memoizedUpdaters = root.memoizedUpdaters;
+          0 < lanes;
+
+        ) {
+          var index = 31 - clz32(lanes);
+          root = 1 << index;
+          index = pendingUpdatersLaneMap[index];
+          0 < index.size &&
+            (index.forEach(function (fiber) {
+              var alternate = fiber.alternate;
+              (null !== alternate && memoizedUpdaters.has(alternate)) ||
+                memoizedUpdaters.add(fiber);
+            }),
+            index.clear());
+          lanes &= ~root;
+        }
+    }
+    function lanesToEventPriority(lanes) {
+      lanes &= -lanes;
+      return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes
+        ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes
+          ? 0 !== (lanes & 134217727)
+            ? DefaultEventPriority
+            : IdleEventPriority
+          : ContinuousEventPriority
+        : DiscreteEventPriority;
+    }
+    function resolveUpdatePriority() {
+      var updatePriority = ReactDOMSharedInternals.p;
+      if (0 !== updatePriority) return updatePriority;
+      updatePriority = window.event;
+      return void 0 === updatePriority
+        ? DefaultEventPriority
+        : getEventPriority(updatePriority.type);
+    }
+    function runWithPriority(priority, fn) {
+      var previousPriority = ReactDOMSharedInternals.p;
+      try {
+        return (ReactDOMSharedInternals.p = priority), fn();
+      } finally {
+        ReactDOMSharedInternals.p = previousPriority;
+      }
+    }
+    function detachDeletedInstance(node) {
+      delete node[internalInstanceKey];
+      delete node[internalPropsKey];
+      delete node[internalEventHandlersKey];
+      delete node[internalEventHandlerListenersKey];
+      delete node[internalEventHandlesSetKey];
+    }
+    function getClosestInstanceFromNode(targetNode) {
+      var targetInst = targetNode[internalInstanceKey];
+      if (targetInst) return targetInst;
+      for (var parentNode = targetNode.parentNode; parentNode; ) {
+        if (
+          (targetInst =
+            parentNode[internalContainerInstanceKey] ||
+            parentNode[internalInstanceKey])
+        ) {
+          parentNode = targetInst.alternate;
+          if (
+            null !== targetInst.child ||
+            (null !== parentNode && null !== parentNode.child)
+          )
+            for (
+              targetNode = getParentSuspenseInstance(targetNode);
+              null !== targetNode;
+
+            ) {
+              if ((parentNode = targetNode[internalInstanceKey]))
+                return parentNode;
+              targetNode = getParentSuspenseInstance(targetNode);
+            }
+          return targetInst;
+        }
+        targetNode = parentNode;
+        parentNode = targetNode.parentNode;
+      }
+      return null;
+    }
+    function getInstanceFromNode(node) {
+      if (
+        (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
+      ) {
+        var tag = node.tag;
+        if (
+          5 === tag ||
+          6 === tag ||
+          13 === tag ||
+          26 === tag ||
+          27 === tag ||
+          3 === tag
+        )
+          return node;
+      }
+      return null;
+    }
+    function getNodeFromInstance(inst) {
+      var tag = inst.tag;
+      if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
+        return inst.stateNode;
+      throw Error("getNodeFromInstance: Invalid argument.");
+    }
+    function getResourcesFromRoot(root) {
+      var resources = root[internalRootNodeResourcesKey];
+      resources ||
+        (resources = root[internalRootNodeResourcesKey] =
+          { hoistableStyles: new Map(), hoistableScripts: new Map() });
+      return resources;
+    }
+    function markNodeAsHoistable(node) {
+      node[internalHoistableMarker] = !0;
+    }
+    function getImplicitRole(element) {
+      var mappedByTag = tagToRoleMappings[element.tagName];
+      if (void 0 !== mappedByTag) return mappedByTag;
+      switch (element.tagName) {
+        case "A":
+        case "AREA":
+        case "LINK":
+          if (element.hasAttribute("href")) return "link";
+          break;
+        case "IMG":
+          if (0 < (element.getAttribute("alt") || "").length) return "img";
+          break;
+        case "INPUT":
+          switch (((mappedByTag = element.type), mappedByTag)) {
+            case "button":
+            case "image":
+            case "reset":
+            case "submit":
+              return "button";
+            case "checkbox":
+            case "radio":
+              return mappedByTag;
+            case "range":
+              return "slider";
+            case "email":
+            case "tel":
+            case "text":
+            case "url":
+              return element.hasAttribute("list") ? "combobox" : "textbox";
+            case "search":
+              return element.hasAttribute("list") ? "combobox" : "searchbox";
+            default:
+              return null;
+          }
+        case "SELECT":
+          return element.hasAttribute("multiple") || 1 < element.size
+            ? "listbox"
+            : "combobox";
+      }
+      return null;
+    }
+    function registerTwoPhaseEvent(registrationName, dependencies) {
+      registerDirectEvent(registrationName, dependencies);
+      registerDirectEvent(registrationName + "Capture", dependencies);
+    }
+    function registerDirectEvent(registrationName, dependencies) {
+      registrationNameDependencies[registrationName] &&
+        console.error(
+          "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
+          registrationName
+        );
+      registrationNameDependencies[registrationName] = dependencies;
+      var lowerCasedName = registrationName.toLowerCase();
+      possibleRegistrationNames[lowerCasedName] = registrationName;
+      "onDoubleClick" === registrationName &&
+        (possibleRegistrationNames.ondblclick = registrationName);
+      for (
+        registrationName = 0;
+        registrationName < dependencies.length;
+        registrationName++
+      )
+        allNativeEvents.add(dependencies[registrationName]);
+    }
+    function checkControlledValueProps(tagName, props) {
+      hasReadOnlyValue[props.type] ||
+        props.onChange ||
+        props.onInput ||
+        props.readOnly ||
+        props.disabled ||
+        null == props.value ||
+        ("select" === tagName
+          ? console.error(
+              "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
+            )
+          : console.error(
+              "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
+            ));
+      props.onChange ||
+        props.readOnly ||
+        props.disabled ||
+        null == props.checked ||
+        console.error(
+          "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
+        );
+    }
+    function isAttributeNameSafe(attributeName) {
+      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
+        return !0;
+      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
+        return !1;
+      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
+        return (validatedAttributeNameCache[attributeName] = !0);
+      illegalAttributeNameCache[attributeName] = !0;
+      console.error("Invalid attribute name: `%s`", attributeName);
+      return !1;
+    }
+    function getValueForAttributeOnCustomComponent(node, name, expected) {
+      if (isAttributeNameSafe(name)) {
+        if (!node.hasAttribute(name)) {
+          switch (typeof expected) {
+            case "symbol":
+            case "object":
+              return expected;
+            case "function":
+              return expected;
+            case "boolean":
+              if (!1 === expected) return expected;
+          }
+          return void 0 === expected ? void 0 : null;
+        }
+        node = node.getAttribute(name);
+        if ("" === node && !0 === expected) return !0;
+        checkAttributeStringCoercion(expected, name);
+        return node === "" + expected ? expected : node;
+      }
+    }
+    function setValueForAttribute(node, name, value) {
+      if (isAttributeNameSafe(name))
+        if (null === value) node.removeAttribute(name);
+        else {
+          switch (typeof value) {
+            case "undefined":
+            case "function":
+            case "symbol":
+              node.removeAttribute(name);
+              return;
+            case "boolean":
+              var prefix = name.toLowerCase().slice(0, 5);
+              if ("data-" !== prefix && "aria-" !== prefix) {
+                node.removeAttribute(name);
+                return;
+              }
+          }
+          checkAttributeStringCoercion(value, name);
+          node.setAttribute(name, "" + value);
+        }
+    }
+    function setValueForKnownAttribute(node, name, value) {
+      if (null === value) node.removeAttribute(name);
+      else {
+        switch (typeof value) {
+          case "undefined":
+          case "function":
+          case "symbol":
+          case "boolean":
+            node.removeAttribute(name);
+            return;
+        }
+        checkAttributeStringCoercion(value, name);
+        node.setAttribute(name, "" + value);
+      }
+    }
+    function setValueForNamespacedAttribute(node, namespace, name, value) {
+      if (null === value) node.removeAttribute(name);
+      else {
+        switch (typeof value) {
+          case "undefined":
+          case "function":
+          case "symbol":
+          case "boolean":
+            node.removeAttribute(name);
+            return;
+        }
+        checkAttributeStringCoercion(value, name);
+        node.setAttributeNS(namespace, name, "" + value);
+      }
+    }
+    function disabledLog() {}
+    function disableLogs() {
+      if (0 === disabledDepth) {
+        prevLog = console.log;
+        prevInfo = console.info;
+        prevWarn = console.warn;
+        prevError = console.error;
+        prevGroup = console.group;
+        prevGroupCollapsed = console.groupCollapsed;
+        prevGroupEnd = console.groupEnd;
+        var props = {
+          configurable: !0,
+          enumerable: !0,
+          value: disabledLog,
+          writable: !0
+        };
+        Object.defineProperties(console, {
+          info: props,
+          log: props,
+          warn: props,
+          error: props,
+          group: props,
+          groupCollapsed: props,
+          groupEnd: props
+        });
+      }
+      disabledDepth++;
+    }
+    function reenableLogs() {
+      disabledDepth--;
+      if (0 === disabledDepth) {
+        var props = { configurable: !0, enumerable: !0, writable: !0 };
+        Object.defineProperties(console, {
+          log: assign({}, props, { value: prevLog }),
+          info: assign({}, props, { value: prevInfo }),
+          warn: assign({}, props, { value: prevWarn }),
+          error: assign({}, props, { value: prevError }),
+          group: assign({}, props, { value: prevGroup }),
+          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
+          groupEnd: assign({}, props, { value: prevGroupEnd })
+        });
+      }
+      0 > disabledDepth &&
+        console.error(
+          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
+        );
+    }
+    function describeBuiltInComponentFrame(name) {
+      if (void 0 === prefix)
+        try {
+          throw Error();
+        } catch (x) {
+          var match = x.stack.trim().match(/\n( *(at )?)/);
+          prefix = (match && match[1]) || "";
+          suffix =
+            -1 < x.stack.indexOf("\n    at")
+              ? " (<anonymous>)"
+              : -1 < x.stack.indexOf("@")
+                ? "@unknown:0:0"
+                : "";
+        }
+      return "\n" + prefix + name + suffix;
+    }
+    function describeNativeComponentFrame(fn, construct) {
+      if (!fn || reentry) return "";
+      var frame = componentFrameCache.get(fn);
+      if (void 0 !== frame) return frame;
+      reentry = !0;
+      frame = Error.prepareStackTrace;
+      Error.prepareStackTrace = void 0;
+      var previousDispatcher = null;
+      previousDispatcher = ReactSharedInternals.H;
+      ReactSharedInternals.H = null;
+      disableLogs();
+      try {
+        var RunInRootFrame = {
+          DetermineComponentFrameRoot: function () {
+            try {
+              if (construct) {
+                var Fake = function () {
+                  throw Error();
+                };
+                Object.defineProperty(Fake.prototype, "props", {
+                  set: function () {
+                    throw Error();
+                  }
+                });
+                if ("object" === typeof Reflect && Reflect.construct) {
+                  try {
+                    Reflect.construct(Fake, []);
+                  } catch (x) {
+                    var control = x;
+                  }
+                  Reflect.construct(fn, [], Fake);
+                } else {
+                  try {
+                    Fake.call();
+                  } catch (x$0) {
+                    control = x$0;
+                  }
+                  fn.call(Fake.prototype);
+                }
+              } else {
+                try {
+                  throw Error();
+                } catch (x$1) {
+                  control = x$1;
+                }
+                (Fake = fn()) &&
+                  "function" === typeof Fake.catch &&
+                  Fake.catch(function () {});
+              }
+            } catch (sample) {
+              if (sample && control && "string" === typeof sample.stack)
+                return [sample.stack, control.stack];
+            }
+            return [null, null];
+          }
+        };
+        RunInRootFrame.DetermineComponentFrameRoot.displayName =
+          "DetermineComponentFrameRoot";
+        var namePropDescriptor = Object.getOwnPropertyDescriptor(
+          RunInRootFrame.DetermineComponentFrameRoot,
+          "name"
+        );
+        namePropDescriptor &&
+          namePropDescriptor.configurable &&
+          Object.defineProperty(
+            RunInRootFrame.DetermineComponentFrameRoot,
+            "name",
+            { value: "DetermineComponentFrameRoot" }
+          );
+        var _RunInRootFrame$Deter =
+            RunInRootFrame.DetermineComponentFrameRoot(),
+          sampleStack = _RunInRootFrame$Deter[0],
+          controlStack = _RunInRootFrame$Deter[1];
+        if (sampleStack && controlStack) {
+          var sampleLines = sampleStack.split("\n"),
+            controlLines = controlStack.split("\n");
+          for (
+            _RunInRootFrame$Deter = namePropDescriptor = 0;
+            namePropDescriptor < sampleLines.length &&
+            !sampleLines[namePropDescriptor].includes(
+              "DetermineComponentFrameRoot"
+            );
+
+          )
+            namePropDescriptor++;
+          for (
+            ;
+            _RunInRootFrame$Deter < controlLines.length &&
+            !controlLines[_RunInRootFrame$Deter].includes(
+              "DetermineComponentFrameRoot"
+            );
+
+          )
+            _RunInRootFrame$Deter++;
+          if (
+            namePropDescriptor === sampleLines.length ||
+            _RunInRootFrame$Deter === controlLines.length
+          )
+            for (
+              namePropDescriptor = sampleLines.length - 1,
+                _RunInRootFrame$Deter = controlLines.length - 1;
+              1 <= namePropDescriptor &&
+              0 <= _RunInRootFrame$Deter &&
+              sampleLines[namePropDescriptor] !==
+                controlLines[_RunInRootFrame$Deter];
+
+            )
+              _RunInRootFrame$Deter--;
+          for (
+            ;
+            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;
+            namePropDescriptor--, _RunInRootFrame$Deter--
+          )
+            if (
+              sampleLines[namePropDescriptor] !==
+              controlLines[_RunInRootFrame$Deter]
+            ) {
+              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
+                do
+                  if (
+                    (namePropDescriptor--,
+                    _RunInRootFrame$Deter--,
+                    0 > _RunInRootFrame$Deter ||
+                      sampleLines[namePropDescriptor] !==
+                        controlLines[_RunInRootFrame$Deter])
+                  ) {
+                    var _frame =
+                      "\n" +
+                      sampleLines[namePropDescriptor].replace(
+                        " at new ",
+                        " at "
+                      );
+                    fn.displayName &&
+                      _frame.includes("<anonymous>") &&
+                      (_frame = _frame.replace("<anonymous>", fn.displayName));
+                    "function" === typeof fn &&
+                      componentFrameCache.set(fn, _frame);
+                    return _frame;
+                  }
+                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
+              }
+              break;
+            }
+        }
+      } finally {
+        (reentry = !1),
+          (ReactSharedInternals.H = previousDispatcher),
+          reenableLogs(),
+          (Error.prepareStackTrace = frame);
+      }
+      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "")
+        ? describeBuiltInComponentFrame(sampleLines)
+        : "";
+      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
+      return sampleLines;
+    }
+    function formatOwnerStack(error) {
+      var prevPrepareStackTrace = Error.prepareStackTrace;
+      Error.prepareStackTrace = void 0;
+      error = error.stack;
+      Error.prepareStackTrace = prevPrepareStackTrace;
+      error.startsWith("Error: react-stack-top-frame\n") &&
+        (error = error.slice(29));
+      prevPrepareStackTrace = error.indexOf("\n");
+      -1 !== prevPrepareStackTrace &&
+        (error = error.slice(prevPrepareStackTrace + 1));
+      prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
+      -1 !== prevPrepareStackTrace &&
+        (prevPrepareStackTrace = error.lastIndexOf(
+          "\n",
+          prevPrepareStackTrace
+        ));
+      if (-1 !== prevPrepareStackTrace)
+        error = error.slice(0, prevPrepareStackTrace);
+      else return "";
+      return error;
+    }
+    function describeFiber(fiber) {
+      switch (fiber.tag) {
+        case 26:
+        case 27:
+        case 5:
+          return describeBuiltInComponentFrame(fiber.type);
+        case 16:
+          return describeBuiltInComponentFrame("Lazy");
+        case 13:
+          return describeBuiltInComponentFrame("Suspense");
+        case 19:
+          return describeBuiltInComponentFrame("SuspenseList");
+        case 0:
+        case 15:
+          return describeNativeComponentFrame(fiber.type, !1);
+        case 11:
+          return describeNativeComponentFrame(fiber.type.render, !1);
+        case 1:
+          return describeNativeComponentFrame(fiber.type, !0);
+        case 30:
+          return describeBuiltInComponentFrame("ViewTransition");
+        default:
+          return "";
+      }
+    }
+    function getStackByFiberInDevAndProd(workInProgress) {
+      try {
+        var info = "";
+        do {
+          info += describeFiber(workInProgress);
+          var debugInfo = workInProgress._debugInfo;
+          if (debugInfo)
+            for (var i = debugInfo.length - 1; 0 <= i; i--) {
+              var entry = debugInfo[i];
+              if ("string" === typeof entry.name) {
+                var JSCompiler_temp_const = info,
+                  env = entry.env;
+                var JSCompiler_inline_result = describeBuiltInComponentFrame(
+                  entry.name + (env ? " [" + env + "]" : "")
+                );
+                info = JSCompiler_temp_const + JSCompiler_inline_result;
+              }
+            }
+          workInProgress = workInProgress.return;
+        } while (workInProgress);
+        return info;
+      } catch (x) {
+        return "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+    }
+    function describeFunctionComponentFrameWithoutLineNumber(fn) {
+      return (fn = fn ? fn.displayName || fn.name : "")
+        ? describeBuiltInComponentFrame(fn)
+        : "";
+    }
+    function getCurrentFiberOwnerNameInDevOrNull() {
+      if (null === current) return null;
+      var owner = current._debugOwner;
+      return null != owner ? getComponentNameFromOwner(owner) : null;
+    }
+    function getCurrentFiberStackInDev() {
+      if (null === current) return "";
+      var workInProgress = current;
+      try {
+        var info = "";
+        6 === workInProgress.tag && (workInProgress = workInProgress.return);
+        switch (workInProgress.tag) {
+          case 26:
+          case 27:
+          case 5:
+            info += describeBuiltInComponentFrame(workInProgress.type);
+            break;
+          case 13:
+            info += describeBuiltInComponentFrame("Suspense");
+            break;
+          case 19:
+            info += describeBuiltInComponentFrame("SuspenseList");
+            break;
+          case 30:
+            info += describeBuiltInComponentFrame("SuspenseList");
+            break;
+          case 0:
+          case 15:
+          case 1:
+            workInProgress._debugOwner ||
+              "" !== info ||
+              (info += describeFunctionComponentFrameWithoutLineNumber(
+                workInProgress.type
+              ));
+            break;
+          case 11:
+            workInProgress._debugOwner ||
+              "" !== info ||
+              (info += describeFunctionComponentFrameWithoutLineNumber(
+                workInProgress.type.render
+              ));
+        }
+        for (; workInProgress; )
+          if ("number" === typeof workInProgress.tag) {
+            var fiber = workInProgress;
+            workInProgress = fiber._debugOwner;
+            var debugStack = fiber._debugStack;
+            workInProgress &&
+              debugStack &&
+              ("string" !== typeof debugStack &&
+                (fiber._debugStack = debugStack = formatOwnerStack(debugStack)),
+              "" !== debugStack && (info += "\n" + debugStack));
+          } else if (null != workInProgress.debugStack) {
+            var ownerStack = workInProgress.debugStack;
+            (workInProgress = workInProgress.owner) &&
+              ownerStack &&
+              (info += "\n" + formatOwnerStack(ownerStack));
+          } else break;
+        var JSCompiler_inline_result = info;
+      } catch (x) {
+        JSCompiler_inline_result =
+          "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+      return JSCompiler_inline_result;
+    }
+    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
+      var previousFiber = current;
+      ReactSharedInternals.getCurrentStack =
+        null === fiber ? null : getCurrentFiberStackInDev;
+      isRendering = !1;
+      current = fiber;
+      try {
+        return null !== fiber && fiber._debugTask
+          ? fiber._debugTask.run(
+              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
+            )
+          : callback(arg0, arg1, arg2, arg3, arg4);
+      } finally {
+        current = previousFiber;
+      }
+      throw Error(
+        "runWithFiberInDEV should never be called in production. This is a bug in React."
+      );
+    }
+    function getToStringValue(value) {
+      switch (typeof value) {
+        case "bigint":
+        case "boolean":
+        case "number":
+        case "string":
+        case "undefined":
+          return value;
+        case "object":
+          return checkFormFieldValueStringCoercion(value), value;
+        default:
+          return "";
+      }
+    }
+    function isCheckable(elem) {
+      var type = elem.type;
+      return (
+        (elem = elem.nodeName) &&
+        "input" === elem.toLowerCase() &&
+        ("checkbox" === type || "radio" === type)
+      );
+    }
+    function trackValueOnNode(node) {
+      var valueField = isCheckable(node) ? "checked" : "value",
+        descriptor = Object.getOwnPropertyDescriptor(
+          node.constructor.prototype,
+          valueField
+        );
+      checkFormFieldValueStringCoercion(node[valueField]);
+      var currentValue = "" + node[valueField];
+      if (
+        !node.hasOwnProperty(valueField) &&
+        "undefined" !== typeof descriptor &&
+        "function" === typeof descriptor.get &&
+        "function" === typeof descriptor.set
+      ) {
+        var get = descriptor.get,
+          set = descriptor.set;
+        Object.defineProperty(node, valueField, {
+          configurable: !0,
+          get: function () {
+            return get.call(this);
+          },
+          set: function (value) {
+            checkFormFieldValueStringCoercion(value);
+            currentValue = "" + value;
+            set.call(this, value);
+          }
+        });
+        Object.defineProperty(node, valueField, {
+          enumerable: descriptor.enumerable
+        });
+        return {
+          getValue: function () {
+            return currentValue;
+          },
+          setValue: function (value) {
+            checkFormFieldValueStringCoercion(value);
+            currentValue = "" + value;
+          },
+          stopTracking: function () {
+            node._valueTracker = null;
+            delete node[valueField];
+          }
+        };
+      }
+    }
+    function track(node) {
+      node._valueTracker || (node._valueTracker = trackValueOnNode(node));
+    }
+    function updateValueIfChanged(node) {
+      if (!node) return !1;
+      var tracker = node._valueTracker;
+      if (!tracker) return !0;
+      var lastValue = tracker.getValue();
+      var value = "";
+      node &&
+        (value = isCheckable(node)
+          ? node.checked
+            ? "true"
+            : "false"
+          : node.value);
+      node = value;
+      return node !== lastValue ? (tracker.setValue(node), !0) : !1;
+    }
+    function getActiveElement(doc) {
+      doc = doc || ("undefined" !== typeof document ? document : void 0);
+      if ("undefined" === typeof doc) return null;
+      try {
+        return doc.activeElement || doc.body;
+      } catch (e) {
+        return doc.body;
+      }
+    }
+    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
+      return value.replace(
+        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
+        function (ch) {
+          return "\\" + ch.charCodeAt(0).toString(16) + " ";
+        }
+      );
+    }
+    function validateInputProps(element, props) {
+      void 0 === props.checked ||
+        void 0 === props.defaultChecked ||
+        didWarnCheckedDefaultChecked ||
+        (console.error(
+          "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
+          getCurrentFiberOwnerNameInDevOrNull() || "A component",
+          props.type
+        ),
+        (didWarnCheckedDefaultChecked = !0));
+      void 0 === props.value ||
+        void 0 === props.defaultValue ||
+        didWarnValueDefaultValue$1 ||
+        (console.error(
+          "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
+          getCurrentFiberOwnerNameInDevOrNull() || "A component",
+          props.type
+        ),
+        (didWarnValueDefaultValue$1 = !0));
+    }
+    function updateInput(
+      element,
+      value,
+      defaultValue,
+      lastDefaultValue,
+      checked,
+      defaultChecked,
+      type,
+      name
+    ) {
+      element.name = "";
+      null != type &&
+      "function" !== typeof type &&
+      "symbol" !== typeof type &&
+      "boolean" !== typeof type
+        ? (checkAttributeStringCoercion(type, "type"), (element.type = type))
+        : element.removeAttribute("type");
+      if (null != value)
+        if ("number" === type) {
+          if ((0 === value && "" === element.value) || element.value != value)
+            element.value = "" + getToStringValue(value);
+        } else
+          element.value !== "" + getToStringValue(value) &&
+            (element.value = "" + getToStringValue(value));
+      else
+        ("submit" !== type && "reset" !== type) ||
+          element.removeAttribute("value");
+      null != value
+        ? setDefaultValue(element, type, getToStringValue(value))
+        : null != defaultValue
+          ? setDefaultValue(element, type, getToStringValue(defaultValue))
+          : null != lastDefaultValue && element.removeAttribute("value");
+      null == checked &&
+        null != defaultChecked &&
+        (element.defaultChecked = !!defaultChecked);
+      null != checked &&
+        (element.checked =
+          checked &&
+          "function" !== typeof checked &&
+          "symbol" !== typeof checked);
+      null != name &&
+      "function" !== typeof name &&
+      "symbol" !== typeof name &&
+      "boolean" !== typeof name
+        ? (checkAttributeStringCoercion(name, "name"),
+          (element.name = "" + getToStringValue(name)))
+        : element.removeAttribute("name");
+    }
+    function initInput(
+      element,
+      value,
+      defaultValue,
+      checked,
+      defaultChecked,
+      type,
+      name,
+      isHydrating
+    ) {
+      null != type &&
+        "function" !== typeof type &&
+        "symbol" !== typeof type &&
+        "boolean" !== typeof type &&
+        (checkAttributeStringCoercion(type, "type"), (element.type = type));
+      if (null != value || null != defaultValue) {
+        if (
+          !(
+            ("submit" !== type && "reset" !== type) ||
+            (void 0 !== value && null !== value)
+          )
+        )
+          return;
+        defaultValue =
+          null != defaultValue ? "" + getToStringValue(defaultValue) : "";
+        value = null != value ? "" + getToStringValue(value) : defaultValue;
+        isHydrating || value === element.value || (element.value = value);
+        element.defaultValue = value;
+      }
+      checked = null != checked ? checked : defaultChecked;
+      checked =
+        "function" !== typeof checked &&
+        "symbol" !== typeof checked &&
+        !!checked;
+      element.checked = isHydrating ? element.checked : !!checked;
+      element.defaultChecked = !!checked;
+      null != name &&
+        "function" !== typeof name &&
+        "symbol" !== typeof name &&
+        "boolean" !== typeof name &&
+        (checkAttributeStringCoercion(name, "name"), (element.name = name));
+    }
+    function setDefaultValue(node, type, value) {
+      ("number" === type && getActiveElement(node.ownerDocument) === node) ||
+        node.defaultValue === "" + value ||
+        (node.defaultValue = "" + value);
+    }
+    function validateOptionProps(element, props) {
+      null == props.value &&
+        ("object" === typeof props.children && null !== props.children
+          ? React.Children.forEach(props.children, function (child) {
+              null == child ||
+                "string" === typeof child ||
+                "number" === typeof child ||
+                "bigint" === typeof child ||
+                didWarnInvalidChild ||
+                ((didWarnInvalidChild = !0),
+                console.error(
+                  "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
+                ));
+            })
+          : null == props.dangerouslySetInnerHTML ||
+            didWarnInvalidInnerHTML ||
+            ((didWarnInvalidInnerHTML = !0),
+            console.error(
+              "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
+            )));
+      null == props.selected ||
+        didWarnSelectedSetOnOption ||
+        (console.error(
+          "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
+        ),
+        (didWarnSelectedSetOnOption = !0));
+    }
+    function getDeclarationErrorAddendum() {
+      var ownerName = getCurrentFiberOwnerNameInDevOrNull();
+      return ownerName
+        ? "\n\nCheck the render method of `" + ownerName + "`."
+        : "";
+    }
+    function updateOptions(node, multiple, propValue, setDefaultSelected) {
+      node = node.options;
+      if (multiple) {
+        multiple = {};
+        for (var i = 0; i < propValue.length; i++)
+          multiple["$" + propValue[i]] = !0;
+        for (propValue = 0; propValue < node.length; propValue++)
+          (i = multiple.hasOwnProperty("$" + node[propValue].value)),
+            node[propValue].selected !== i && (node[propValue].selected = i),
+            i && setDefaultSelected && (node[propValue].defaultSelected = !0);
+      } else {
+        propValue = "" + getToStringValue(propValue);
+        multiple = null;
+        for (i = 0; i < node.length; i++) {
+          if (node[i].value === propValue) {
+            node[i].selected = !0;
+            setDefaultSelected && (node[i].defaultSelected = !0);
+            return;
+          }
+          null !== multiple || node[i].disabled || (multiple = node[i]);
+        }
+        null !== multiple && (multiple.selected = !0);
+      }
+    }
+    function validateSelectProps(element, props) {
+      for (element = 0; element < valuePropNames.length; element++) {
+        var propName = valuePropNames[element];
+        if (null != props[propName]) {
+          var propNameIsArray = isArrayImpl(props[propName]);
+          props.multiple && !propNameIsArray
+            ? console.error(
+                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
+                propName,
+                getDeclarationErrorAddendum()
+              )
+            : !props.multiple &&
+              propNameIsArray &&
+              console.error(
+                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
+                propName,
+                getDeclarationErrorAddendum()
+              );
+        }
+      }
+      void 0 === props.value ||
+        void 0 === props.defaultValue ||
+        didWarnValueDefaultValue ||
+        (console.error(
+          "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
+        ),
+        (didWarnValueDefaultValue = !0));
+    }
+    function validateTextareaProps(element, props) {
+      void 0 === props.value ||
+        void 0 === props.defaultValue ||
+        didWarnValDefaultVal ||
+        (console.error(
+          "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
+          getCurrentFiberOwnerNameInDevOrNull() || "A component"
+        ),
+        (didWarnValDefaultVal = !0));
+      null != props.children &&
+        null == props.value &&
+        console.error(
+          "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
+        );
+    }
+    function updateTextarea(element, value, defaultValue) {
+      if (
+        null != value &&
+        ((value = "" + getToStringValue(value)),
+        value !== element.value && (element.value = value),
+        null == defaultValue)
+      ) {
+        element.defaultValue !== value && (element.defaultValue = value);
+        return;
+      }
+      element.defaultValue =
+        null != defaultValue ? "" + getToStringValue(defaultValue) : "";
+    }
+    function initTextarea(element, value, defaultValue, children) {
+      if (null == value) {
+        if (null != children) {
+          if (null != defaultValue)
+            throw Error(
+              "If you supply `defaultValue` on a <textarea>, do not pass children."
+            );
+          if (isArrayImpl(children)) {
+            if (1 < children.length)
+              throw Error("<textarea> can only have at most one child.");
+            children = children[0];
+          }
+          defaultValue = children;
+        }
+        null == defaultValue && (defaultValue = "");
+        value = defaultValue;
+      }
+      defaultValue = getToStringValue(value);
+      element.defaultValue = defaultValue;
+      children = element.textContent;
+      children === defaultValue &&
+        "" !== children &&
+        null !== children &&
+        (element.value = children);
+    }
+    function findNotableNode(node, indent) {
+      return void 0 === node.serverProps &&
+        0 === node.serverTail.length &&
+        1 === node.children.length &&
+        3 < node.distanceFromLeaf &&
+        node.distanceFromLeaf > 15 - indent
+        ? findNotableNode(node.children[0], indent)
+        : node;
+    }
+    function indentation(indent) {
+      return "  " + "  ".repeat(indent);
+    }
+    function added(indent) {
+      return "+ " + "  ".repeat(indent);
+    }
+    function removed(indent) {
+      return "- " + "  ".repeat(indent);
+    }
+    function describeFiberType(fiber) {
+      switch (fiber.tag) {
+        case 26:
+        case 27:
+        case 5:
+          return fiber.type;
+        case 16:
+          return "Lazy";
+        case 13:
+          return "Suspense";
+        case 19:
+          return "SuspenseList";
+        case 0:
+        case 15:
+          return (fiber = fiber.type), fiber.displayName || fiber.name || null;
+        case 11:
+          return (
+            (fiber = fiber.type.render), fiber.displayName || fiber.name || null
+          );
+        case 1:
+          return (fiber = fiber.type), fiber.displayName || fiber.name || null;
+        default:
+          return null;
+      }
+    }
+    function describeTextNode(content, maxLength) {
+      return needsEscaping.test(content)
+        ? ((content = JSON.stringify(content)),
+          content.length > maxLength - 2
+            ? 8 > maxLength
+              ? '{"..."}'
+              : "{" + content.slice(0, maxLength - 7) + '..."}'
+            : "{" + content + "}")
+        : content.length > maxLength
+          ? 5 > maxLength
+            ? '{"..."}'
+            : content.slice(0, maxLength - 3) + "..."
+          : content;
+    }
+    function describeTextDiff(clientText, serverProps, indent) {
+      var maxLength = 120 - 2 * indent;
+      if (null === serverProps)
+        return added(indent) + describeTextNode(clientText, maxLength) + "\n";
+      if ("string" === typeof serverProps) {
+        for (
+          var firstDiff = 0;
+          firstDiff < serverProps.length &&
+          firstDiff < clientText.length &&
+          serverProps.charCodeAt(firstDiff) ===
+            clientText.charCodeAt(firstDiff);
+          firstDiff++
+        );
+        firstDiff > maxLength - 8 &&
+          10 < firstDiff &&
+          ((clientText = "..." + clientText.slice(firstDiff - 8)),
+          (serverProps = "..." + serverProps.slice(firstDiff - 8)));
+        return (
+          added(indent) +
+          describeTextNode(clientText, maxLength) +
+          "\n" +
+          removed(indent) +
+          describeTextNode(serverProps, maxLength) +
+          "\n"
+        );
+      }
+      return (
+        indentation(indent) + describeTextNode(clientText, maxLength) + "\n"
+      );
+    }
+    function objectName(object) {
+      return Object.prototype.toString
+        .call(object)
+        .replace(/^\[object (.*)\]$/, function (m, p0) {
+          return p0;
+        });
+    }
+    function describeValue(value, maxLength) {
+      switch (typeof value) {
+        case "string":
+          return (
+            (value = JSON.stringify(value)),
+            value.length > maxLength
+              ? 5 > maxLength
+                ? '"..."'
+                : value.slice(0, maxLength - 4) + '..."'
+              : value
+          );
+        case "object":
+          if (null === value) return "null";
+          if (isArrayImpl(value)) return "[...]";
+          if (value.$$typeof === REACT_ELEMENT_TYPE)
+            return (maxLength = getComponentNameFromType(value.type))
+              ? "<" + maxLength + ">"
+              : "<...>";
+          var name = objectName(value);
+          if ("Object" === name) {
+            name = "";
+            maxLength -= 2;
+            for (var propName in value)
+              if (value.hasOwnProperty(propName)) {
+                var jsonPropName = JSON.stringify(propName);
+                jsonPropName !== '"' + propName + '"' &&
+                  (propName = jsonPropName);
+                maxLength -= propName.length - 2;
+                jsonPropName = describeValue(
+                  value[propName],
+                  15 > maxLength ? maxLength : 15
+                );
+                maxLength -= jsonPropName.length;
+                if (0 > maxLength) {
+                  name += "" === name ? "..." : ", ...";
+                  break;
+                }
+                name +=
+                  ("" === name ? "" : ",") + propName + ":" + jsonPropName;
+              }
+            return "{" + name + "}";
+          }
+          return name;
+        case "function":
+          return (maxLength = value.displayName || value.name)
+            ? "function " + maxLength
+            : "function";
+        default:
+          return String(value);
+      }
+    }
+    function describePropValue(value, maxLength) {
+      return "string" !== typeof value || needsEscaping.test(value)
+        ? "{" + describeValue(value, maxLength - 2) + "}"
+        : value.length > maxLength - 2
+          ? 5 > maxLength
+            ? '"..."'
+            : '"' + value.slice(0, maxLength - 5) + '..."'
+          : '"' + value + '"';
+    }
+    function describeExpandedElement(type, props, rowPrefix) {
+      var remainingRowLength = 120 - rowPrefix.length - type.length,
+        properties = [],
+        propName;
+      for (propName in props)
+        if (props.hasOwnProperty(propName) && "children" !== propName) {
+          var propValue = describePropValue(
+            props[propName],
+            120 - rowPrefix.length - propName.length - 1
+          );
+          remainingRowLength -= propName.length + propValue.length + 2;
+          properties.push(propName + "=" + propValue);
+        }
+      return 0 === properties.length
+        ? rowPrefix + "<" + type + ">\n"
+        : 0 < remainingRowLength
+          ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n"
+          : rowPrefix +
+            "<" +
+            type +
+            "\n" +
+            rowPrefix +
+            "  " +
+            properties.join("\n" + rowPrefix + "  ") +
+            "\n" +
+            rowPrefix +
+            ">\n";
+    }
+    function describePropertiesDiff(clientObject, serverObject, indent) {
+      var properties = "",
+        remainingServerProperties = assign({}, serverObject),
+        propName;
+      for (propName in clientObject)
+        if (clientObject.hasOwnProperty(propName)) {
+          delete remainingServerProperties[propName];
+          var maxLength = 120 - 2 * indent - propName.length - 2,
+            clientPropValue = describeValue(clientObject[propName], maxLength);
+          serverObject.hasOwnProperty(propName)
+            ? ((maxLength = describeValue(serverObject[propName], maxLength)),
+              (properties +=
+                added(indent) + propName + ": " + clientPropValue + "\n"),
+              (properties +=
+                removed(indent) + propName + ": " + maxLength + "\n"))
+            : (properties +=
+                added(indent) + propName + ": " + clientPropValue + "\n");
+        }
+      for (var _propName in remainingServerProperties)
+        remainingServerProperties.hasOwnProperty(_propName) &&
+          ((clientObject = describeValue(
+            remainingServerProperties[_propName],
+            120 - 2 * indent - _propName.length - 2
+          )),
+          (properties +=
+            removed(indent) + _propName + ": " + clientObject + "\n"));
+      return properties;
+    }
+    function describeElementDiff(type, clientProps, serverProps, indent) {
+      var content = "",
+        serverPropNames = new Map();
+      for (propName$jscomp$0 in serverProps)
+        serverProps.hasOwnProperty(propName$jscomp$0) &&
+          serverPropNames.set(
+            propName$jscomp$0.toLowerCase(),
+            propName$jscomp$0
+          );
+      if (1 === serverPropNames.size && serverPropNames.has("children"))
+        content += describeExpandedElement(
+          type,
+          clientProps,
+          indentation(indent)
+        );
+      else {
+        for (var _propName2 in clientProps)
+          if (
+            clientProps.hasOwnProperty(_propName2) &&
+            "children" !== _propName2
+          ) {
+            var maxLength$jscomp$0 =
+                120 - 2 * (indent + 1) - _propName2.length - 1,
+              serverPropName = serverPropNames.get(_propName2.toLowerCase());
+            if (void 0 !== serverPropName) {
+              serverPropNames.delete(_propName2.toLowerCase());
+              var propName$jscomp$0 = clientProps[_propName2];
+              serverPropName = serverProps[serverPropName];
+              var clientPropValue = describePropValue(
+                propName$jscomp$0,
+                maxLength$jscomp$0
+              );
+              maxLength$jscomp$0 = describePropValue(
+                serverPropName,
+                maxLength$jscomp$0
+              );
+              "object" === typeof propName$jscomp$0 &&
+              null !== propName$jscomp$0 &&
+              "object" === typeof serverPropName &&
+              null !== serverPropName &&
+              "Object" === objectName(propName$jscomp$0) &&
+              "Object" === objectName(serverPropName) &&
+              (2 < Object.keys(propName$jscomp$0).length ||
+                2 < Object.keys(serverPropName).length ||
+                -1 < clientPropValue.indexOf("...") ||
+                -1 < maxLength$jscomp$0.indexOf("..."))
+                ? (content +=
+                    indentation(indent + 1) +
+                    _propName2 +
+                    "={{\n" +
+                    describePropertiesDiff(
+                      propName$jscomp$0,
+                      serverPropName,
+                      indent + 2
+                    ) +
+                    indentation(indent + 1) +
+                    "}}\n")
+                : ((content +=
+                    added(indent + 1) +
+                    _propName2 +
+                    "=" +
+                    clientPropValue +
+                    "\n"),
+                  (content +=
+                    removed(indent + 1) +
+                    _propName2 +
+                    "=" +
+                    maxLength$jscomp$0 +
+                    "\n"));
+            } else
+              content +=
+                indentation(indent + 1) +
+                _propName2 +
+                "=" +
+                describePropValue(clientProps[_propName2], maxLength$jscomp$0) +
+                "\n";
+          }
+        serverPropNames.forEach(function (propName) {
+          if ("children" !== propName) {
+            var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
+            content +=
+              removed(indent + 1) +
+              propName +
+              "=" +
+              describePropValue(serverProps[propName], maxLength) +
+              "\n";
+          }
+        });
+        content =
+          "" === content
+            ? indentation(indent) + "<" + type + ">\n"
+            : indentation(indent) +
+              "<" +
+              type +
+              "\n" +
+              content +
+              indentation(indent) +
+              ">\n";
+      }
+      type = serverProps.children;
+      clientProps = clientProps.children;
+      if (
+        "string" === typeof type ||
+        "number" === typeof type ||
+        "bigint" === typeof type
+      ) {
+        serverPropNames = "";
+        if (
+          "string" === typeof clientProps ||
+          "number" === typeof clientProps ||
+          "bigint" === typeof clientProps
+        )
+          serverPropNames = "" + clientProps;
+        content += describeTextDiff(serverPropNames, "" + type, indent + 1);
+      } else if (
+        "string" === typeof clientProps ||
+        "number" === typeof clientProps ||
+        "bigint" === typeof clientProps
+      )
+        content =
+          null == type
+            ? content + describeTextDiff("" + clientProps, null, indent + 1)
+            : content + describeTextDiff("" + clientProps, void 0, indent + 1);
+      return content;
+    }
+    function describeSiblingFiber(fiber, indent) {
+      var type = describeFiberType(fiber);
+      if (null === type) {
+        type = "";
+        for (fiber = fiber.child; fiber; )
+          (type += describeSiblingFiber(fiber, indent)),
+            (fiber = fiber.sibling);
+        return type;
+      }
+      return indentation(indent) + "<" + type + ">\n";
+    }
+    function describeNode(node, indent) {
+      var skipToNode = findNotableNode(node, indent);
+      if (
+        skipToNode !== node &&
+        (1 !== node.children.length || node.children[0] !== skipToNode)
+      )
+        return (
+          indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1)
+        );
+      skipToNode = "";
+      var debugInfo = node.fiber._debugInfo;
+      if (debugInfo)
+        for (var i = 0; i < debugInfo.length; i++) {
+          var serverComponentName = debugInfo[i].name;
+          "string" === typeof serverComponentName &&
+            ((skipToNode +=
+              indentation(indent) + "<" + serverComponentName + ">\n"),
+            indent++);
+        }
+      debugInfo = "";
+      i = node.fiber.pendingProps;
+      if (6 === node.fiber.tag)
+        (debugInfo = describeTextDiff(i, node.serverProps, indent)), indent++;
+      else if (
+        ((serverComponentName = describeFiberType(node.fiber)),
+        null !== serverComponentName)
+      )
+        if (void 0 === node.serverProps) {
+          debugInfo = indent;
+          var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2,
+            content = "";
+          for (propName in i)
+            if (i.hasOwnProperty(propName) && "children" !== propName) {
+              var propValue = describePropValue(i[propName], 15);
+              maxLength -= propName.length + propValue.length + 2;
+              if (0 > maxLength) {
+                content += " ...";
+                break;
+              }
+              content += " " + propName + "=" + propValue;
+            }
+          debugInfo =
+            indentation(debugInfo) +
+            "<" +
+            serverComponentName +
+            content +
+            ">\n";
+          indent++;
+        } else
+          null === node.serverProps
+            ? ((debugInfo = describeExpandedElement(
+                serverComponentName,
+                i,
+                added(indent)
+              )),
+              indent++)
+            : "string" === typeof node.serverProps
+              ? console.error(
+                  "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
+                )
+              : ((debugInfo = describeElementDiff(
+                  serverComponentName,
+                  i,
+                  node.serverProps,
+                  indent
+                )),
+                indent++);
+      var propName = "";
+      i = node.fiber.child;
+      for (
+        serverComponentName = 0;
+        i && serverComponentName < node.children.length;
+
+      )
+        (maxLength = node.children[serverComponentName]),
+          maxLength.fiber === i
+            ? ((propName += describeNode(maxLength, indent)),
+              serverComponentName++)
+            : (propName += describeSiblingFiber(i, indent)),
+          (i = i.sibling);
+      i &&
+        0 < node.children.length &&
+        (propName += indentation(indent) + "...\n");
+      i = node.serverTail;
+      null === node.serverProps && indent--;
+      for (node = 0; node < i.length; node++)
+        (serverComponentName = i[node]),
+          (propName =
+            "string" === typeof serverComponentName
+              ? propName +
+                (removed(indent) +
+                  describeTextNode(serverComponentName, 120 - 2 * indent) +
+                  "\n")
+              : propName +
+                describeExpandedElement(
+                  serverComponentName.type,
+                  serverComponentName.props,
+                  removed(indent)
+                ));
+      return skipToNode + debugInfo + propName;
+    }
+    function describeDiff(rootNode) {
+      try {
+        return "\n\n" + describeNode(rootNode, 0);
+      } catch (x) {
+        return "";
+      }
+    }
+    function describeAncestors(ancestor, child, props) {
+      for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
+        fiber === ancestor && (distanceFromLeaf = 0),
+          (node = {
+            fiber: fiber,
+            children: null !== node ? [node] : [],
+            serverProps:
+              fiber === child ? props : fiber === ancestor ? null : void 0,
+            serverTail: [],
+            distanceFromLeaf: distanceFromLeaf
+          }),
+          distanceFromLeaf++,
+          (fiber = fiber.return);
+      return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
+    }
+    function updatedAncestorInfoDev(oldInfo, tag) {
+      oldInfo = assign({}, oldInfo || emptyAncestorInfoDev);
+      var info = { tag: tag };
+      -1 !== inScopeTags.indexOf(tag) &&
+        ((oldInfo.aTagInScope = null),
+        (oldInfo.buttonTagInScope = null),
+        (oldInfo.nobrTagInScope = null));
+      -1 !== buttonScopeTags.indexOf(tag) && (oldInfo.pTagInButtonScope = null);
+      -1 !== specialTags.indexOf(tag) &&
+        "address" !== tag &&
+        "div" !== tag &&
+        "p" !== tag &&
+        ((oldInfo.listItemTagAutoclosing = null),
+        (oldInfo.dlItemTagAutoclosing = null));
+      oldInfo.current = info;
+      "form" === tag && (oldInfo.formTag = info);
+      "a" === tag && (oldInfo.aTagInScope = info);
+      "button" === tag && (oldInfo.buttonTagInScope = info);
+      "nobr" === tag && (oldInfo.nobrTagInScope = info);
+      "p" === tag && (oldInfo.pTagInButtonScope = info);
+      "li" === tag && (oldInfo.listItemTagAutoclosing = info);
+      if ("dd" === tag || "dt" === tag) oldInfo.dlItemTagAutoclosing = info;
+      "#document" === tag || "html" === tag
+        ? (oldInfo.containerTagInScope = null)
+        : oldInfo.containerTagInScope || (oldInfo.containerTagInScope = info);
+      return oldInfo;
+    }
+    function isTagValidWithParent(tag, parentTag) {
+      switch (parentTag) {
+        case "select":
+          return (
+            "hr" === tag ||
+            "option" === tag ||
+            "optgroup" === tag ||
+            "script" === tag ||
+            "template" === tag ||
+            "#text" === tag
+          );
+        case "optgroup":
+          return "option" === tag || "#text" === tag;
+        case "option":
+          return "#text" === tag;
+        case "tr":
+          return (
+            "th" === tag ||
+            "td" === tag ||
+            "style" === tag ||
+            "script" === tag ||
+            "template" === tag
+          );
+        case "tbody":
+        case "thead":
+        case "tfoot":
+          return (
+            "tr" === tag ||
+            "style" === tag ||
+            "script" === tag ||
+            "template" === tag
+          );
+        case "colgroup":
+          return "col" === tag || "template" === tag;
+        case "table":
+          return (
+            "caption" === tag ||
+            "colgroup" === tag ||
+            "tbody" === tag ||
+            "tfoot" === tag ||
+            "thead" === tag ||
+            "style" === tag ||
+            "script" === tag ||
+            "template" === tag
+          );
+        case "head":
+          return (
+            "base" === tag ||
+            "basefont" === tag ||
+            "bgsound" === tag ||
+            "link" === tag ||
+            "meta" === tag ||
+            "title" === tag ||
+            "noscript" === tag ||
+            "noframes" === tag ||
+            "style" === tag ||
+            "script" === tag ||
+            "template" === tag
+          );
+        case "html":
+          return "head" === tag || "body" === tag || "frameset" === tag;
+        case "frameset":
+          return "frame" === tag;
+        case "#document":
+          return "html" === tag;
+      }
+      switch (tag) {
+        case "h1":
+        case "h2":
+        case "h3":
+        case "h4":
+        case "h5":
+        case "h6":
+          return (
+            "h1" !== parentTag &&
+            "h2" !== parentTag &&
+            "h3" !== parentTag &&
+            "h4" !== parentTag &&
+            "h5" !== parentTag &&
+            "h6" !== parentTag
+          );
+        case "rp":
+        case "rt":
+          return -1 === impliedEndTags.indexOf(parentTag);
+        case "body":
+        case "caption":
+        case "col":
+        case "colgroup":
+        case "frameset":
+        case "frame":
+        case "head":
+        case "html":
+        case "tbody":
+        case "td":
+        case "tfoot":
+        case "th":
+        case "thead":
+        case "tr":
+          return null == parentTag;
+      }
+      return !0;
+    }
+    function findInvalidAncestorForTag(tag, ancestorInfo) {
+      switch (tag) {
+        case "address":
+        case "article":
+        case "aside":
+        case "blockquote":
+        case "center":
+        case "details":
+        case "dialog":
+        case "dir":
+        case "div":
+        case "dl":
+        case "fieldset":
+        case "figcaption":
+        case "figure":
+        case "footer":
+        case "header":
+        case "hgroup":
+        case "main":
+        case "menu":
+        case "nav":
+        case "ol":
+        case "p":
+        case "section":
+        case "summary":
+        case "ul":
+        case "pre":
+        case "listing":
+        case "table":
+        case "hr":
+        case "xmp":
+        case "h1":
+        case "h2":
+        case "h3":
+        case "h4":
+        case "h5":
+        case "h6":
+          return ancestorInfo.pTagInButtonScope;
+        case "form":
+          return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
+        case "li":
+          return ancestorInfo.listItemTagAutoclosing;
+        case "dd":
+        case "dt":
+          return ancestorInfo.dlItemTagAutoclosing;
+        case "button":
+          return ancestorInfo.buttonTagInScope;
+        case "a":
+          return ancestorInfo.aTagInScope;
+        case "nobr":
+          return ancestorInfo.nobrTagInScope;
+      }
+      return null;
+    }
+    function findAncestor(parent, tagName) {
+      for (; parent; ) {
+        switch (parent.tag) {
+          case 5:
+          case 26:
+          case 27:
+            if (parent.type === tagName) return parent;
+        }
+        parent = parent.return;
+      }
+      return null;
+    }
+    function validateDOMNesting(childTag, ancestorInfo) {
+      ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
+      var parentInfo = ancestorInfo.current;
+      ancestorInfo = (parentInfo = isTagValidWithParent(
+        childTag,
+        parentInfo && parentInfo.tag
+      )
+        ? null
+        : parentInfo)
+        ? null
+        : findInvalidAncestorForTag(childTag, ancestorInfo);
+      ancestorInfo = parentInfo || ancestorInfo;
+      if (!ancestorInfo) return !0;
+      var ancestorTag = ancestorInfo.tag;
+      ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
+      if (didWarn[ancestorInfo]) return !1;
+      didWarn[ancestorInfo] = !0;
+      var ancestor = (ancestorInfo = current)
+          ? findAncestor(ancestorInfo.return, ancestorTag)
+          : null,
+        ancestorDescription =
+          null !== ancestorInfo && null !== ancestor
+            ? describeAncestors(ancestor, ancestorInfo, null)
+            : "",
+        tagDisplayName = "<" + childTag + ">";
+      parentInfo
+        ? ((parentInfo = ""),
+          "table" === ancestorTag &&
+            "tr" === childTag &&
+            (parentInfo +=
+              " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."),
+          console.error(
+            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
+            tagDisplayName,
+            ancestorTag,
+            parentInfo,
+            ancestorDescription
+          ))
+        : console.error(
+            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
+            tagDisplayName,
+            ancestorTag,
+            ancestorDescription
+          );
+      ancestorInfo &&
+        ((childTag = ancestorInfo.return),
+        null === ancestor ||
+          null === childTag ||
+          (ancestor === childTag &&
+            childTag._debugOwner === ancestorInfo._debugOwner) ||
+          runWithFiberInDEV(ancestor, function () {
+            console.error(
+              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
+              ancestorTag,
+              tagDisplayName
+            );
+          }));
+      return !1;
+    }
+    function validateTextNesting(childText, parentTag) {
+      if (isTagValidWithParent("#text", parentTag)) return !0;
+      var warnKey = "#text|" + parentTag;
+      if (didWarn[warnKey]) return !1;
+      didWarn[warnKey] = !0;
+      var ancestor = (warnKey = current)
+        ? findAncestor(warnKey, parentTag)
+        : null;
+      warnKey =
+        null !== warnKey && null !== ancestor
+          ? describeAncestors(
+              ancestor,
+              warnKey,
+              6 !== warnKey.tag ? { children: null } : null
+            )
+          : "";
+      /\S/.test(childText)
+        ? console.error(
+            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
+            parentTag,
+            warnKey
+          )
+        : console.error(
+            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
+            parentTag,
+            warnKey
+          );
+      return !1;
+    }
+    function setTextContent(node, text) {
+      if (text) {
+        var firstChild = node.firstChild;
+        if (
+          firstChild &&
+          firstChild === node.lastChild &&
+          3 === firstChild.nodeType
+        ) {
+          firstChild.nodeValue = text;
+          return;
+        }
+      }
+      node.textContent = text;
+    }
+    function camelize(string) {
+      return string.replace(hyphenPattern, function (_, character) {
+        return character.toUpperCase();
+      });
+    }
+    function setValueForStyle(style, styleName, value) {
+      var isCustomProperty = 0 === styleName.indexOf("--");
+      isCustomProperty ||
+        (-1 < styleName.indexOf("-")
+          ? (warnedStyleNames.hasOwnProperty(styleName) &&
+              warnedStyleNames[styleName]) ||
+            ((warnedStyleNames[styleName] = !0),
+            console.error(
+              "Unsupported style property %s. Did you mean %s?",
+              styleName,
+              camelize(styleName.replace(msPattern, "ms-"))
+            ))
+          : badVendoredStyleNamePattern.test(styleName)
+            ? (warnedStyleNames.hasOwnProperty(styleName) &&
+                warnedStyleNames[styleName]) ||
+              ((warnedStyleNames[styleName] = !0),
+              console.error(
+                "Unsupported vendor-prefixed style property %s. Did you mean %s?",
+                styleName,
+                styleName.charAt(0).toUpperCase() + styleName.slice(1)
+              ))
+            : !badStyleValueWithSemicolonPattern.test(value) ||
+              (warnedStyleValues.hasOwnProperty(value) &&
+                warnedStyleValues[value]) ||
+              ((warnedStyleValues[value] = !0),
+              console.error(
+                'Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.',
+                styleName,
+                value.replace(badStyleValueWithSemicolonPattern, "")
+              )),
+        "number" === typeof value &&
+          (isNaN(value)
+            ? warnedForNaNValue ||
+              ((warnedForNaNValue = !0),
+              console.error(
+                "`NaN` is an invalid value for the `%s` css style property.",
+                styleName
+              ))
+            : isFinite(value) ||
+              warnedForInfinityValue ||
+              ((warnedForInfinityValue = !0),
+              console.error(
+                "`Infinity` is an invalid value for the `%s` css style property.",
+                styleName
+              ))));
+      null == value || "boolean" === typeof value || "" === value
+        ? isCustomProperty
+          ? style.setProperty(styleName, "")
+          : "float" === styleName
+            ? (style.cssFloat = "")
+            : (style[styleName] = "")
+        : isCustomProperty
+          ? style.setProperty(styleName, value)
+          : "number" !== typeof value ||
+              0 === value ||
+              unitlessNumbers.has(styleName)
+            ? "float" === styleName
+              ? (style.cssFloat = value)
+              : (checkCSSPropertyStringCoercion(value, styleName),
+                (style[styleName] = ("" + value).trim()))
+            : (style[styleName] = value + "px");
+    }
+    function setValueForStyles(node, styles, prevStyles) {
+      if (null != styles && "object" !== typeof styles)
+        throw Error(
+          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
+        );
+      styles && Object.freeze(styles);
+      node = node.style;
+      if (null != prevStyles) {
+        if (styles) {
+          var expandedUpdates = {};
+          if (prevStyles)
+            for (var key in prevStyles)
+              if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
+                for (
+                  var longhands = shorthandToLonghand[key] || [key], i = 0;
+                  i < longhands.length;
+                  i++
+                )
+                  expandedUpdates[longhands[i]] = key;
+          for (var _key in styles)
+            if (
+              styles.hasOwnProperty(_key) &&
+              (!prevStyles || prevStyles[_key] !== styles[_key])
+            )
+              for (
+                key = shorthandToLonghand[_key] || [_key], longhands = 0;
+                longhands < key.length;
+                longhands++
+              )
+                expandedUpdates[key[longhands]] = _key;
+          _key = {};
+          for (var key$jscomp$0 in styles)
+            for (
+              key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0],
+                longhands = 0;
+              longhands < key.length;
+              longhands++
+            )
+              _key[key[longhands]] = key$jscomp$0;
+          key$jscomp$0 = {};
+          for (var _key2 in expandedUpdates)
+            if (
+              ((key = expandedUpdates[_key2]),
+              (longhands = _key[_key2]) &&
+                key !== longhands &&
+                ((i = key + "," + longhands), !key$jscomp$0[i]))
+            ) {
+              key$jscomp$0[i] = !0;
+              i = console;
+              var value = styles[key];
+              i.error.call(
+                i,
+                "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
+                null == value || "boolean" === typeof value || "" === value
+                  ? "Removing"
+                  : "Updating",
+                key,
+                longhands
+              );
+            }
+        }
+        for (var styleName in prevStyles)
+          !prevStyles.hasOwnProperty(styleName) ||
+            (null != styles && styles.hasOwnProperty(styleName)) ||
+            (0 === styleName.indexOf("--")
+              ? node.setProperty(styleName, "")
+              : "float" === styleName
+                ? (node.cssFloat = "")
+                : (node[styleName] = ""),
+            (viewTransitionMutationContext = !0));
+        for (var _styleName in styles)
+          (_key2 = styles[_styleName]),
+            styles.hasOwnProperty(_styleName) &&
+              prevStyles[_styleName] !== _key2 &&
+              (setValueForStyle(node, _styleName, _key2),
+              (viewTransitionMutationContext = !0));
+      } else
+        for (expandedUpdates in styles)
+          styles.hasOwnProperty(expandedUpdates) &&
+            setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
+    }
+    function isCustomElement(tagName) {
+      if (-1 === tagName.indexOf("-")) return !1;
+      switch (tagName) {
+        case "annotation-xml":
+        case "color-profile":
+        case "font-face":
+        case "font-face-src":
+        case "font-face-uri":
+        case "font-face-format":
+        case "font-face-name":
+        case "missing-glyph":
+          return !1;
+        default:
+          return !0;
+      }
+    }
+    function getAttributeAlias(name) {
+      return aliases.get(name) || name;
+    }
+    function validateProperty$1(tagName, name) {
+      if (
+        hasOwnProperty.call(warnedProperties$1, name) &&
+        warnedProperties$1[name]
+      )
+        return !0;
+      if (rARIACamel$1.test(name)) {
+        tagName = "aria-" + name.slice(4).toLowerCase();
+        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
+        if (null == tagName)
+          return (
+            console.error(
+              "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
+              name
+            ),
+            (warnedProperties$1[name] = !0)
+          );
+        if (name !== tagName)
+          return (
+            console.error(
+              "Invalid ARIA attribute `%s`. Did you mean `%s`?",
+              name,
+              tagName
+            ),
+            (warnedProperties$1[name] = !0)
+          );
+      }
+      if (rARIA$1.test(name)) {
+        tagName = name.toLowerCase();
+        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
+        if (null == tagName) return (warnedProperties$1[name] = !0), !1;
+        name !== tagName &&
+          (console.error(
+            "Unknown ARIA attribute `%s`. Did you mean `%s`?",
+            name,
+            tagName
+          ),
+          (warnedProperties$1[name] = !0));
+      }
+      return !0;
+    }
+    function validateProperties$2(type, props) {
+      var invalidProps = [],
+        key;
+      for (key in props)
+        validateProperty$1(type, key) || invalidProps.push(key);
+      props = invalidProps
+        .map(function (prop) {
+          return "`" + prop + "`";
+        })
+        .join(", ");
+      1 === invalidProps.length
+        ? console.error(
+            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
+            props,
+            type
+          )
+        : 1 < invalidProps.length &&
+          console.error(
+            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
+            props,
+            type
+          );
+    }
+    function validateProperty(tagName, name, value, eventRegistry) {
+      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
+        return !0;
+      var lowerCasedName = name.toLowerCase();
+      if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
+        return (
+          console.error(
+            "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
+          ),
+          (warnedProperties[name] = !0)
+        );
+      if (
+        "function" === typeof value &&
+        (("form" === tagName && "action" === name) ||
+          ("input" === tagName && "formAction" === name) ||
+          ("button" === tagName && "formAction" === name))
+      )
+        return !0;
+      if (null != eventRegistry) {
+        tagName = eventRegistry.possibleRegistrationNames;
+        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
+          return !0;
+        eventRegistry = tagName.hasOwnProperty(lowerCasedName)
+          ? tagName[lowerCasedName]
+          : null;
+        if (null != eventRegistry)
+          return (
+            console.error(
+              "Invalid event handler property `%s`. Did you mean `%s`?",
+              name,
+              eventRegistry
+            ),
+            (warnedProperties[name] = !0)
+          );
+        if (EVENT_NAME_REGEX.test(name))
+          return (
+            console.error(
+              "Unknown event handler property `%s`. It will be ignored.",
+              name
+            ),
+            (warnedProperties[name] = !0)
+          );
+      } else if (EVENT_NAME_REGEX.test(name))
+        return (
+          INVALID_EVENT_NAME_REGEX.test(name) &&
+            console.error(
+              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
+              name
+            ),
+          (warnedProperties[name] = !0)
+        );
+      if (rARIA.test(name) || rARIACamel.test(name)) return !0;
+      if ("innerhtml" === lowerCasedName)
+        return (
+          console.error(
+            "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
+          ),
+          (warnedProperties[name] = !0)
+        );
+      if ("aria" === lowerCasedName)
+        return (
+          console.error(
+            "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
+          ),
+          (warnedProperties[name] = !0)
+        );
+      if (
+        "is" === lowerCasedName &&
+        null !== value &&
+        void 0 !== value &&
+        "string" !== typeof value
+      )
+        return (
+          console.error(
+            "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
+            typeof value
+          ),
+          (warnedProperties[name] = !0)
+        );
+      if ("number" === typeof value && isNaN(value))
+        return (
+          console.error(
+            "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
+            name
+          ),
+          (warnedProperties[name] = !0)
+        );
+      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
+        if (
+          ((lowerCasedName = possibleStandardNames[lowerCasedName]),
+          lowerCasedName !== name)
+        )
+          return (
+            console.error(
+              "Invalid DOM property `%s`. Did you mean `%s`?",
+              name,
+              lowerCasedName
+            ),
+            (warnedProperties[name] = !0)
+          );
+      } else if (name !== lowerCasedName)
+        return (
+          console.error(
+            "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
+            name,
+            lowerCasedName
+          ),
+          (warnedProperties[name] = !0)
+        );
+      switch (name) {
+        case "dangerouslySetInnerHTML":
+        case "children":
+        case "style":
+        case "suppressContentEditableWarning":
+        case "suppressHydrationWarning":
+        case "defaultValue":
+        case "defaultChecked":
+        case "innerHTML":
+        case "ref":
+          return !0;
+        case "innerText":
+        case "textContent":
+          return !0;
+      }
+      switch (typeof value) {
+        case "boolean":
+          switch (name) {
+            case "autoFocus":
+            case "checked":
+            case "multiple":
+            case "muted":
+            case "selected":
+            case "contentEditable":
+            case "spellCheck":
+            case "draggable":
+            case "value":
+            case "autoReverse":
+            case "externalResourcesRequired":
+            case "focusable":
+            case "preserveAlpha":
+            case "allowFullScreen":
+            case "async":
+            case "autoPlay":
+            case "controls":
+            case "default":
+            case "defer":
+            case "disabled":
+            case "disablePictureInPicture":
+            case "disableRemotePlayback":
+            case "formNoValidate":
+            case "hidden":
+            case "loop":
+            case "noModule":
+            case "noValidate":
+            case "open":
+            case "playsInline":
+            case "readOnly":
+            case "required":
+            case "reversed":
+            case "scoped":
+            case "seamless":
+            case "itemScope":
+            case "capture":
+            case "download":
+            case "inert":
+              return !0;
+            default:
+              lowerCasedName = name.toLowerCase().slice(0, 5);
+              if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
+                return !0;
+              value
+                ? console.error(
+                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
+                    value,
+                    name,
+                    name,
+                    value,
+                    name
+                  )
+                : console.error(
+                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
+                    value,
+                    name,
+                    name,
+                    value,
+                    name,
+                    name,
+                    name
+                  );
+              return (warnedProperties[name] = !0);
+          }
+        case "function":
+        case "symbol":
+          return (warnedProperties[name] = !0), !1;
+        case "string":
+          if ("false" === value || "true" === value) {
+            switch (name) {
+              case "checked":
+              case "selected":
+              case "multiple":
+              case "muted":
+              case "allowFullScreen":
+              case "async":
+              case "autoPlay":
+              case "controls":
+              case "default":
+              case "defer":
+              case "disabled":
+              case "disablePictureInPicture":
+              case "disableRemotePlayback":
+              case "formNoValidate":
+              case "hidden":
+              case "loop":
+              case "noModule":
+              case "noValidate":
+              case "open":
+              case "playsInline":
+              case "readOnly":
+              case "required":
+              case "reversed":
+              case "scoped":
+              case "seamless":
+              case "itemScope":
+              case "inert":
+                break;
+              default:
+                return !0;
+            }
+            console.error(
+              "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
+              value,
+              name,
+              "false" === value
+                ? "The browser will interpret it as a truthy value."
+                : 'Although this works, it will not work as expected if you pass the string "false".',
+              name,
+              value
+            );
+            warnedProperties[name] = !0;
+          }
+      }
+      return !0;
+    }
+    function warnUnknownProperties(type, props, eventRegistry) {
+      var unknownProps = [],
+        key;
+      for (key in props)
+        validateProperty(type, key, props[key], eventRegistry) ||
+          unknownProps.push(key);
+      props = unknownProps
+        .map(function (prop) {
+          return "`" + prop + "`";
+        })
+        .join(", ");
+      1 === unknownProps.length
+        ? console.error(
+            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
+            props,
+            type
+          )
+        : 1 < unknownProps.length &&
+          console.error(
+            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
+            props,
+            type
+          );
+    }
+    function sanitizeURL(url) {
+      return isJavaScriptProtocol.test("" + url)
+        ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
+        : url;
+    }
+    function getEventTarget(nativeEvent) {
+      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
+      nativeEvent.correspondingUseElement &&
+        (nativeEvent = nativeEvent.correspondingUseElement);
+      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
+    }
+    function restoreStateOfTarget(target) {
+      var internalInstance = getInstanceFromNode(target);
+      if (internalInstance && (target = internalInstance.stateNode)) {
+        var props = target[internalPropsKey] || null;
+        a: switch (
+          ((target = internalInstance.stateNode), internalInstance.type)
+        ) {
+          case "input":
+            updateInput(
+              target,
+              props.value,
+              props.defaultValue,
+              props.defaultValue,
+              props.checked,
+              props.defaultChecked,
+              props.type,
+              props.name
+            );
+            internalInstance = props.name;
+            if ("radio" === props.type && null != internalInstance) {
+              for (props = target; props.parentNode; ) props = props.parentNode;
+              checkAttributeStringCoercion(internalInstance, "name");
+              props = props.querySelectorAll(
+                'input[name="' +
+                  escapeSelectorAttributeValueInsideDoubleQuotes(
+                    "" + internalInstance
+                  ) +
+                  '"][type="radio"]'
+              );
+              for (
+                internalInstance = 0;
+                internalInstance < props.length;
+                internalInstance++
+              ) {
+                var otherNode = props[internalInstance];
+                if (otherNode !== target && otherNode.form === target.form) {
+                  var otherProps = otherNode[internalPropsKey] || null;
+                  if (!otherProps)
+                    throw Error(
+                      "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
+                    );
+                  updateInput(
+                    otherNode,
+                    otherProps.value,
+                    otherProps.defaultValue,
+                    otherProps.defaultValue,
+                    otherProps.checked,
+                    otherProps.defaultChecked,
+                    otherProps.type,
+                    otherProps.name
+                  );
+                }
+              }
+              for (
+                internalInstance = 0;
+                internalInstance < props.length;
+                internalInstance++
+              )
+                (otherNode = props[internalInstance]),
+                  otherNode.form === target.form &&
+                    updateValueIfChanged(otherNode);
+            }
+            break a;
+          case "textarea":
+            updateTextarea(target, props.value, props.defaultValue);
+            break a;
+          case "select":
+            (internalInstance = props.value),
+              null != internalInstance &&
+                updateOptions(target, !!props.multiple, internalInstance, !1);
+        }
+      }
+    }
+    function batchedUpdates$1(fn, a, b) {
+      if (isInsideEventHandler) return fn(a, b);
+      isInsideEventHandler = !0;
+      try {
+        var JSCompiler_inline_result = fn(a);
+        return JSCompiler_inline_result;
+      } finally {
+        if (
+          ((isInsideEventHandler = !1),
+          null !== restoreTarget || null !== restoreQueue)
+        )
+          if (
+            (flushSyncWork$1(),
+            restoreTarget &&
+              ((a = restoreTarget),
+              (fn = restoreQueue),
+              (restoreQueue = restoreTarget = null),
+              restoreStateOfTarget(a),
+              fn))
+          )
+            for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
+      }
+    }
+    function getListener(inst, registrationName) {
+      var stateNode = inst.stateNode;
+      if (null === stateNode) return null;
+      var props = stateNode[internalPropsKey] || null;
+      if (null === props) return null;
+      stateNode = props[registrationName];
+      a: switch (registrationName) {
+        case "onClick":
+        case "onClickCapture":
+        case "onDoubleClick":
+        case "onDoubleClickCapture":
+        case "onMouseDown":
+        case "onMouseDownCapture":
+        case "onMouseMove":
+        case "onMouseMoveCapture":
+        case "onMouseUp":
+        case "onMouseUpCapture":
+        case "onMouseEnter":
+          (props = !props.disabled) ||
+            ((inst = inst.type),
+            (props = !(
+              "button" === inst ||
+              "input" === inst ||
+              "select" === inst ||
+              "textarea" === inst
+            )));
+          inst = !props;
+          break a;
+        default:
+          inst = !1;
+      }
+      if (inst) return null;
+      if (stateNode && "function" !== typeof stateNode)
+        throw Error(
+          "Expected `" +
+            registrationName +
+            "` listener to be a function, instead got a value of `" +
+            typeof stateNode +
+            "` type."
+        );
+      return stateNode;
+    }
+    function getData() {
+      if (fallbackText) return fallbackText;
+      var start,
+        startValue = startText,
+        startLength = startValue.length,
+        end,
+        endValue = "value" in root ? root.value : root.textContent,
+        endLength = endValue.length;
+      for (
+        start = 0;
+        start < startLength && startValue[start] === endValue[start];
+        start++
+      );
+      var minEnd = startLength - start;
+      for (
+        end = 1;
+        end <= minEnd &&
+        startValue[startLength - end] === endValue[endLength - end];
+        end++
+      );
+      return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
+    }
+    function getEventCharCode(nativeEvent) {
+      var keyCode = nativeEvent.keyCode;
+      "charCode" in nativeEvent
+        ? ((nativeEvent = nativeEvent.charCode),
+          0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
+        : (nativeEvent = keyCode);
+      10 === nativeEvent && (nativeEvent = 13);
+      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
+    }
+    function functionThatReturnsTrue() {
+      return !0;
+    }
+    function functionThatReturnsFalse() {
+      return !1;
+    }
+    function createSyntheticEvent(Interface) {
+      function SyntheticBaseEvent(
+        reactName,
+        reactEventType,
+        targetInst,
+        nativeEvent,
+        nativeEventTarget
+      ) {
+        this._reactName = reactName;
+        this._targetInst = targetInst;
+        this.type = reactEventType;
+        this.nativeEvent = nativeEvent;
+        this.target = nativeEventTarget;
+        this.currentTarget = null;
+        for (var propName in Interface)
+          Interface.hasOwnProperty(propName) &&
+            ((reactName = Interface[propName]),
+            (this[propName] = reactName
+              ? reactName(nativeEvent)
+              : nativeEvent[propName]));
+        this.isDefaultPrevented = (
+          null != nativeEvent.defaultPrevented
+            ? nativeEvent.defaultPrevented
+            : !1 === nativeEvent.returnValue
+        )
+          ? functionThatReturnsTrue
+          : functionThatReturnsFalse;
+        this.isPropagationStopped = functionThatReturnsFalse;
+        return this;
+      }
+      assign(SyntheticBaseEvent.prototype, {
+        preventDefault: function () {
+          this.defaultPrevented = !0;
+          var event = this.nativeEvent;
+          event &&
+            (event.preventDefault
+              ? event.preventDefault()
+              : "unknown" !== typeof event.returnValue &&
+                (event.returnValue = !1),
+            (this.isDefaultPrevented = functionThatReturnsTrue));
+        },
+        stopPropagation: function () {
+          var event = this.nativeEvent;
+          event &&
+            (event.stopPropagation
+              ? event.stopPropagation()
+              : "unknown" !== typeof event.cancelBubble &&
+                (event.cancelBubble = !0),
+            (this.isPropagationStopped = functionThatReturnsTrue));
+        },
+        persist: function () {},
+        isPersistent: functionThatReturnsTrue
+      });
+      return SyntheticBaseEvent;
+    }
+    function modifierStateGetter(keyArg) {
+      var nativeEvent = this.nativeEvent;
+      return nativeEvent.getModifierState
+        ? nativeEvent.getModifierState(keyArg)
+        : (keyArg = modifierKeyToProp[keyArg])
+          ? !!nativeEvent[keyArg]
+          : !1;
+    }
+    function getEventModifierState() {
+      return modifierStateGetter;
+    }
+    function isFallbackCompositionEnd(domEventName, nativeEvent) {
+      switch (domEventName) {
+        case "keyup":
+          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
+        case "keydown":
+          return nativeEvent.keyCode !== START_KEYCODE;
+        case "keypress":
+        case "mousedown":
+        case "focusout":
+          return !0;
+        default:
+          return !1;
+      }
+    }
+    function getDataFromCustomEvent(nativeEvent) {
+      nativeEvent = nativeEvent.detail;
+      return "object" === typeof nativeEvent && "data" in nativeEvent
+        ? nativeEvent.data
+        : null;
+    }
+    function getNativeBeforeInputChars(domEventName, nativeEvent) {
+      switch (domEventName) {
+        case "compositionend":
+          return getDataFromCustomEvent(nativeEvent);
+        case "keypress":
+          if (nativeEvent.which !== SPACEBAR_CODE) return null;
+          hasSpaceKeypress = !0;
+          return SPACEBAR_CHAR;
+        case "textInput":
+          return (
+            (domEventName = nativeEvent.data),
+            domEventName === SPACEBAR_CHAR && hasSpaceKeypress
+              ? null
+              : domEventName
+          );
+        default:
+          return null;
+      }
+    }
+    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
+      if (isComposing)
+        return "compositionend" === domEventName ||
+          (!canUseCompositionEvent &&
+            isFallbackCompositionEnd(domEventName, nativeEvent))
+          ? ((domEventName = getData()),
+            (fallbackText = startText = root = null),
+            (isComposing = !1),
+            domEventName)
+          : null;
+      switch (domEventName) {
+        case "paste":
+          return null;
+        case "keypress":
+          if (
+            !(
+              nativeEvent.ctrlKey ||
+              nativeEvent.altKey ||
+              nativeEvent.metaKey
+            ) ||
+            (nativeEvent.ctrlKey && nativeEvent.altKey)
+          ) {
+            if (nativeEvent.char && 1 < nativeEvent.char.length)
+              return nativeEvent.char;
+            if (nativeEvent.which)
+              return String.fromCharCode(nativeEvent.which);
+          }
+          return null;
+        case "compositionend":
+          return useFallbackCompositionData && "ko" !== nativeEvent.locale
+            ? null
+            : nativeEvent.data;
+        default:
+          return null;
+      }
+    }
+    function isTextInputElement(elem) {
+      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
+      return "input" === nodeName
+        ? !!supportedInputTypes[elem.type]
+        : "textarea" === nodeName
+          ? !0
+          : !1;
+    }
+    function isEventSupported(eventNameSuffix) {
+      if (!canUseDOM) return !1;
+      eventNameSuffix = "on" + eventNameSuffix;
+      var isSupported = eventNameSuffix in document;
+      isSupported ||
+        ((isSupported = document.createElement("div")),
+        isSupported.setAttribute(eventNameSuffix, "return;"),
+        (isSupported = "function" === typeof isSupported[eventNameSuffix]));
+      return isSupported;
+    }
+    function createAndAccumulateChangeEvent(
+      dispatchQueue,
+      inst,
+      nativeEvent,
+      target
+    ) {
+      restoreTarget
+        ? restoreQueue
+          ? restoreQueue.push(target)
+          : (restoreQueue = [target])
+        : (restoreTarget = target);
+      inst = accumulateTwoPhaseListeners(inst, "onChange");
+      0 < inst.length &&
+        ((nativeEvent = new SyntheticEvent(
+          "onChange",
+          "change",
+          null,
+          nativeEvent,
+          target
+        )),
+        dispatchQueue.push({ event: nativeEvent, listeners: inst }));
+    }
+    function runEventInBatch(dispatchQueue) {
+      processDispatchQueue(dispatchQueue, 0);
+    }
+    function getInstIfValueChanged(targetInst) {
+      var targetNode = getNodeFromInstance(targetInst);
+      if (updateValueIfChanged(targetNode)) return targetInst;
+    }
+    function getTargetInstForChangeEvent(domEventName, targetInst) {
+      if ("change" === domEventName) return targetInst;
+    }
+    function stopWatchingForValueChange() {
+      activeElement$1 &&
+        (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
+        (activeElementInst$1 = activeElement$1 = null));
+    }
+    function handlePropertyChange(nativeEvent) {
+      if (
+        "value" === nativeEvent.propertyName &&
+        getInstIfValueChanged(activeElementInst$1)
+      ) {
+        var dispatchQueue = [];
+        createAndAccumulateChangeEvent(
+          dispatchQueue,
+          activeElementInst$1,
+          nativeEvent,
+          getEventTarget(nativeEvent)
+        );
+        batchedUpdates$1(runEventInBatch, dispatchQueue);
+      }
+    }
+    function handleEventsForInputEventPolyfill(
+      domEventName,
+      target,
+      targetInst
+    ) {
+      "focusin" === domEventName
+        ? (stopWatchingForValueChange(),
+          (activeElement$1 = target),
+          (activeElementInst$1 = targetInst),
+          activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
+        : "focusout" === domEventName && stopWatchingForValueChange();
+    }
+    function getTargetInstForInputEventPolyfill(domEventName) {
+      if (
+        "selectionchange" === domEventName ||
+        "keyup" === domEventName ||
+        "keydown" === domEventName
+      )
+        return getInstIfValueChanged(activeElementInst$1);
+    }
+    function getTargetInstForClickEvent(domEventName, targetInst) {
+      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
+    }
+    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
+      if ("input" === domEventName || "change" === domEventName)
+        return getInstIfValueChanged(targetInst);
+    }
+    function is(x, y) {
+      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
+    }
+    function shallowEqual(objA, objB) {
+      if (objectIs(objA, objB)) return !0;
+      if (
+        "object" !== typeof objA ||
+        null === objA ||
+        "object" !== typeof objB ||
+        null === objB
+      )
+        return !1;
+      var keysA = Object.keys(objA),
+        keysB = Object.keys(objB);
+      if (keysA.length !== keysB.length) return !1;
+      for (keysB = 0; keysB < keysA.length; keysB++) {
+        var currentKey = keysA[keysB];
+        if (
+          !hasOwnProperty.call(objB, currentKey) ||
+          !objectIs(objA[currentKey], objB[currentKey])
+        )
+          return !1;
+      }
+      return !0;
+    }
+    function getLeafNode(node) {
+      for (; node && node.firstChild; ) node = node.firstChild;
+      return node;
+    }
+    function getNodeForCharacterOffset(root, offset) {
+      var node = getLeafNode(root);
+      root = 0;
+      for (var nodeEnd; node; ) {
+        if (3 === node.nodeType) {
+          nodeEnd = root + node.textContent.length;
+          if (root <= offset && nodeEnd >= offset)
+            return { node: node, offset: offset - root };
+          root = nodeEnd;
+        }
+        a: {
+          for (; node; ) {
+            if (node.nextSibling) {
+              node = node.nextSibling;
+              break a;
+            }
+            node = node.parentNode;
+          }
+          node = void 0;
+        }
+        node = getLeafNode(node);
+      }
+    }
+    function containsNode(outerNode, innerNode) {
+      return outerNode && innerNode
+        ? outerNode === innerNode
+          ? !0
+          : outerNode && 3 === outerNode.nodeType
+            ? !1
+            : innerNode && 3 === innerNode.nodeType
+              ? containsNode(outerNode, innerNode.parentNode)
+              : "contains" in outerNode
+                ? outerNode.contains(innerNode)
+                : outerNode.compareDocumentPosition
+                  ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
+                  : !1
+        : !1;
+    }
+    function getActiveElementDeep(containerInfo) {
+      containerInfo =
+        null != containerInfo &&
+        null != containerInfo.ownerDocument &&
+        null != containerInfo.ownerDocument.defaultView
+          ? containerInfo.ownerDocument.defaultView
+          : window;
+      for (
+        var element = getActiveElement(containerInfo.document);
+        element instanceof containerInfo.HTMLIFrameElement;
+
+      ) {
+        try {
+          var JSCompiler_inline_result =
+            "string" === typeof element.contentWindow.location.href;
+        } catch (err) {
+          JSCompiler_inline_result = !1;
+        }
+        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
+        else break;
+        element = getActiveElement(containerInfo.document);
+      }
+      return element;
+    }
+    function hasSelectionCapabilities(elem) {
+      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
+      return (
+        nodeName &&
+        (("input" === nodeName &&
+          ("text" === elem.type ||
+            "search" === elem.type ||
+            "tel" === elem.type ||
+            "url" === elem.type ||
+            "password" === elem.type)) ||
+          "textarea" === nodeName ||
+          "true" === elem.contentEditable)
+      );
+    }
+    function constructSelectEvent(
+      dispatchQueue,
+      nativeEvent,
+      nativeEventTarget
+    ) {
+      var doc =
+        nativeEventTarget.window === nativeEventTarget
+          ? nativeEventTarget.document
+          : 9 === nativeEventTarget.nodeType
+            ? nativeEventTarget
+            : nativeEventTarget.ownerDocument;
+      mouseDown ||
+        null == activeElement ||
+        activeElement !== getActiveElement(doc) ||
+        ((doc = activeElement),
+        "selectionStart" in doc && hasSelectionCapabilities(doc)
+          ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
+          : ((doc = (
+              (doc.ownerDocument && doc.ownerDocument.defaultView) ||
+              window
+            ).getSelection()),
+            (doc = {
+              anchorNode: doc.anchorNode,
+              anchorOffset: doc.anchorOffset,
+              focusNode: doc.focusNode,
+              focusOffset: doc.focusOffset
+            })),
+        (lastSelection && shallowEqual(lastSelection, doc)) ||
+          ((lastSelection = doc),
+          (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
+          0 < doc.length &&
+            ((nativeEvent = new SyntheticEvent(
+              "onSelect",
+              "select",
+              null,
+              nativeEvent,
+              nativeEventTarget
+            )),
+            dispatchQueue.push({ event: nativeEvent, listeners: doc }),
+            (nativeEvent.target = activeElement))));
+    }
+    function makePrefixMap(styleProp, eventName) {
+      var prefixes = {};
+      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
+      prefixes["Webkit" + styleProp] = "webkit" + eventName;
+      prefixes["Moz" + styleProp] = "moz" + eventName;
+      return prefixes;
+    }
+    function getVendorPrefixedEventName(eventName) {
+      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
+      if (!vendorPrefixes[eventName]) return eventName;
+      var prefixMap = vendorPrefixes[eventName],
+        styleProp;
+      for (styleProp in prefixMap)
+        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
+          return (prefixedEventNames[eventName] = prefixMap[styleProp]);
+      return eventName;
+    }
+    function registerSimpleEvent(domEventName, reactName) {
+      topLevelEventsToReactNames.set(domEventName, reactName);
+      registerTwoPhaseEvent(reactName, [domEventName]);
+    }
+    function createCapturedValueAtFiber(value, source) {
+      if ("object" === typeof value && null !== value) {
+        var existing = CapturedStacks.get(value);
+        if (void 0 !== existing) return existing;
+        source = {
+          value: value,
+          source: source,
+          stack: getStackByFiberInDevAndProd(source)
+        };
+        CapturedStacks.set(value, source);
+        return source;
+      }
+      return {
+        value: value,
+        source: source,
+        stack: getStackByFiberInDevAndProd(source)
+      };
+    }
+    function finishQueueingConcurrentUpdates() {
+      for (
+        var endIndex = concurrentQueuesIndex,
+          i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
+        i < endIndex;
+
+      ) {
+        var fiber = concurrentQueues[i];
+        concurrentQueues[i++] = null;
+        var queue = concurrentQueues[i];
+        concurrentQueues[i++] = null;
+        var update = concurrentQueues[i];
+        concurrentQueues[i++] = null;
+        var lane = concurrentQueues[i];
+        concurrentQueues[i++] = null;
+        if (null !== queue && null !== update) {
+          var pending = queue.pending;
+          null === pending
+            ? (update.next = update)
+            : ((update.next = pending.next), (pending.next = update));
+          queue.pending = update;
+        }
+        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
+      }
+    }
+    function enqueueUpdate$1(fiber, queue, update, lane) {
+      concurrentQueues[concurrentQueuesIndex++] = fiber;
+      concurrentQueues[concurrentQueuesIndex++] = queue;
+      concurrentQueues[concurrentQueuesIndex++] = update;
+      concurrentQueues[concurrentQueuesIndex++] = lane;
+      concurrentlyUpdatedLanes |= lane;
+      fiber.lanes |= lane;
+      fiber = fiber.alternate;
+      null !== fiber && (fiber.lanes |= lane);
+    }
+    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
+      enqueueUpdate$1(fiber, queue, update, lane);
+      return getRootForUpdatedFiber(fiber);
+    }
+    function enqueueConcurrentRenderForLane(fiber, lane) {
+      enqueueUpdate$1(fiber, null, null, lane);
+      return getRootForUpdatedFiber(fiber);
+    }
+    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
+      sourceFiber.lanes |= lane;
+      var alternate = sourceFiber.alternate;
+      null !== alternate && (alternate.lanes |= lane);
+      for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
+        (parent.childLanes |= lane),
+          (alternate = parent.alternate),
+          null !== alternate && (alternate.childLanes |= lane),
+          22 === parent.tag &&
+            ((sourceFiber = parent.stateNode),
+            null === sourceFiber ||
+              sourceFiber._visibility & OffscreenVisible ||
+              (isHidden = !0)),
+          (sourceFiber = parent),
+          (parent = parent.return);
+      isHidden &&
+        null !== update &&
+        3 === sourceFiber.tag &&
+        ((parent = sourceFiber.stateNode),
+        (isHidden = 31 - clz32(lane)),
+        (parent = parent.hiddenUpdates),
+        (sourceFiber = parent[isHidden]),
+        null === sourceFiber
+          ? (parent[isHidden] = [update])
+          : sourceFiber.push(update),
+        (update.lane = lane | 536870912));
+    }
+    function getRootForUpdatedFiber(sourceFiber) {
+      if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
+        throw (
+          ((nestedPassiveUpdateCount = nestedUpdateCount = 0),
+          (rootWithPassiveNestedUpdates = rootWithNestedUpdates = null),
+          Error(
+            "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
+          ))
+        );
+      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT &&
+        ((nestedPassiveUpdateCount = 0),
+        (rootWithPassiveNestedUpdates = null),
+        console.error(
+          "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
+        ));
+      null === sourceFiber.alternate &&
+        0 !== (sourceFiber.flags & 4098) &&
+        warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
+      for (var node = sourceFiber, parent = node.return; null !== parent; )
+        null === node.alternate &&
+          0 !== (node.flags & 4098) &&
+          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber),
+          (node = parent),
+          (parent = node.return);
+      return 3 === node.tag ? node.stateNode : null;
+    }
+    function resolveFunctionForHotReloading(type) {
+      if (null === resolveFamily) return type;
+      var family = resolveFamily(type);
+      return void 0 === family ? type : family.current;
+    }
+    function resolveForwardRefForHotReloading(type) {
+      if (null === resolveFamily) return type;
+      var family = resolveFamily(type);
+      return void 0 === family
+        ? null !== type &&
+          void 0 !== type &&
+          "function" === typeof type.render &&
+          ((family = resolveFunctionForHotReloading(type.render)),
+          type.render !== family)
+          ? ((family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }),
+            void 0 !== type.displayName &&
+              (family.displayName = type.displayName),
+            family)
+          : type
+        : family.current;
+    }
+    function isCompatibleFamilyForHotReloading(fiber, element) {
+      if (null === resolveFamily) return !1;
+      var prevType = fiber.elementType;
+      element = element.type;
+      var needsCompareFamilies = !1,
+        $$typeofNextType =
+          "object" === typeof element && null !== element
+            ? element.$$typeof
+            : null;
+      switch (fiber.tag) {
+        case 1:
+          "function" === typeof element && (needsCompareFamilies = !0);
+          break;
+        case 0:
+          "function" === typeof element
+            ? (needsCompareFamilies = !0)
+            : $$typeofNextType === REACT_LAZY_TYPE &&
+              (needsCompareFamilies = !0);
+          break;
+        case 11:
+          $$typeofNextType === REACT_FORWARD_REF_TYPE
+            ? (needsCompareFamilies = !0)
+            : $$typeofNextType === REACT_LAZY_TYPE &&
+              (needsCompareFamilies = !0);
+          break;
+        case 14:
+        case 15:
+          $$typeofNextType === REACT_MEMO_TYPE
+            ? (needsCompareFamilies = !0)
+            : $$typeofNextType === REACT_LAZY_TYPE &&
+              (needsCompareFamilies = !0);
+          break;
+        default:
+          return !1;
+      }
+      return needsCompareFamilies &&
+        ((fiber = resolveFamily(prevType)),
+        void 0 !== fiber && fiber === resolveFamily(element))
+        ? !0
+        : !1;
+    }
+    function markFailedErrorBoundaryForHotReloading(fiber) {
+      null !== resolveFamily &&
+        "function" === typeof WeakSet &&
+        (null === failedBoundaries && (failedBoundaries = new WeakSet()),
+        failedBoundaries.add(fiber));
+    }
+    function scheduleFibersWithFamiliesRecursively(
+      fiber,
+      updatedFamilies,
+      staleFamilies
+    ) {
+      var alternate = fiber.alternate,
+        child = fiber.child,
+        sibling = fiber.sibling,
+        tag = fiber.tag,
+        type = fiber.type,
+        candidateType = null;
+      switch (tag) {
+        case 0:
+        case 15:
+        case 1:
+          candidateType = type;
+          break;
+        case 11:
+          candidateType = type.render;
+      }
+      if (null === resolveFamily)
+        throw Error("Expected resolveFamily to be set during hot reload.");
+      var needsRender = !1;
+      type = !1;
+      null !== candidateType &&
+        ((candidateType = resolveFamily(candidateType)),
+        void 0 !== candidateType &&
+          (staleFamilies.has(candidateType)
+            ? (type = !0)
+            : updatedFamilies.has(candidateType) &&
+              (1 === tag ? (type = !0) : (needsRender = !0))));
+      null !== failedBoundaries &&
+        (failedBoundaries.has(fiber) ||
+          (null !== alternate && failedBoundaries.has(alternate))) &&
+        (type = !0);
+      type && (fiber._debugNeedsRemount = !0);
+      if (type || needsRender)
+        (alternate = enqueueConcurrentRenderForLane(fiber, 2)),
+          null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
+      null === child ||
+        type ||
+        scheduleFibersWithFamiliesRecursively(
+          child,
+          updatedFamilies,
+          staleFamilies
+        );
+      null !== sibling &&
+        scheduleFibersWithFamiliesRecursively(
+          sibling,
+          updatedFamilies,
+          staleFamilies
+        );
+    }
+    function startUpdateTimerByLane(lane) {
+      var JSCompiler_temp;
+      (JSCompiler_temp = 0 !== (lane & 3)) ||
+        (JSCompiler_temp = 0 !== (lane & 60));
+      if (JSCompiler_temp)
+        0 > blockingUpdateTime &&
+          ((blockingUpdateTime = now()),
+          (executionContext & (RenderContext | CommitContext)) !== NoContext &&
+            (blockingSpawnedUpdate = !0),
+          (lane = resolveEventTimeStamp()),
+          (JSCompiler_temp = resolveEventType()),
+          lane !== blockingEventTime || JSCompiler_temp !== blockingEventType
+            ? (blockingEventIsRepeat = !1)
+            : null !== JSCompiler_temp && (blockingSpawnedUpdate = !0),
+          (blockingEventTime = lane),
+          (blockingEventType = JSCompiler_temp));
+      else if (
+        0 !== (lane & 4194176) &&
+        0 > transitionUpdateTime &&
+        ((transitionUpdateTime = now()), 0 > transitionStartTime)
+      ) {
+        lane = resolveEventTimeStamp();
+        JSCompiler_temp = resolveEventType();
+        if (
+          lane !== transitionEventTime ||
+          JSCompiler_temp !== transitionEventType
+        )
+          transitionEventIsRepeat = !1;
+        transitionEventTime = lane;
+        transitionEventType = JSCompiler_temp;
+      }
+    }
+    function pushNestedEffectDurations() {
+      var prevEffectDuration = profilerEffectDuration;
+      profilerEffectDuration = 0;
+      return prevEffectDuration;
+    }
+    function popNestedEffectDurations(prevEffectDuration) {
+      var elapsedTime = profilerEffectDuration;
+      profilerEffectDuration = prevEffectDuration;
+      return elapsedTime;
+    }
+    function bubbleNestedEffectDurations(prevEffectDuration) {
+      var elapsedTime = profilerEffectDuration;
+      profilerEffectDuration += prevEffectDuration;
+      return elapsedTime;
+    }
+    function resetComponentEffectTimers() {
+      componentEffectEndTime = componentEffectStartTime = -1.1;
+    }
+    function pushComponentEffectStart() {
+      var prevEffectStart = componentEffectStartTime;
+      componentEffectStartTime = -1.1;
+      componentEffectDuration = -0;
+      return prevEffectStart;
+    }
+    function popComponentEffectStart(prevEffectStart) {
+      0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
+    }
+    function pushComponentEffectErrors() {
+      var prevErrors = componentEffectErrors;
+      componentEffectErrors = null;
+      return prevErrors;
+    }
+    function startProfilerTimer(fiber) {
+      profilerStartTime = now();
+      0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
+    }
+    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
+      if (0 <= profilerStartTime) {
+        var elapsedTime = now() - profilerStartTime;
+        fiber.actualDuration += elapsedTime;
+        fiber.selfBaseDuration = elapsedTime;
+        profilerStartTime = -1;
+      }
+    }
+    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
+      if (0 <= profilerStartTime) {
+        var elapsedTime = now() - profilerStartTime;
+        fiber.actualDuration += elapsedTime;
+        profilerStartTime = -1;
+      }
+    }
+    function recordEffectDuration() {
+      if (0 <= profilerStartTime) {
+        var endTime = now(),
+          elapsedTime = endTime - profilerStartTime;
+        profilerStartTime = -1;
+        profilerEffectDuration += elapsedTime;
+        componentEffectDuration += elapsedTime;
+        componentEffectEndTime = endTime;
+      }
+    }
+    function recordEffectError(errorInfo) {
+      null === componentEffectErrors && (componentEffectErrors = []);
+      componentEffectErrors.push(errorInfo);
+      null === commitErrors && (commitErrors = []);
+      commitErrors.push(errorInfo);
+    }
+    function startEffectTimer() {
+      profilerStartTime = now();
+      0 > componentEffectStartTime &&
+        (componentEffectStartTime = profilerStartTime);
+    }
+    function transferActualDuration(fiber) {
+      for (var child = fiber.child; child; )
+        (fiber.actualDuration += child.actualDuration), (child = child.sibling);
+    }
+    function setCurrentTrackFromLanes(lanes) {
+      reusableLaneDevToolDetails.track =
+        lanes & 63
+          ? "Blocking"
+          : lanes & 4194240
+            ? "Transition"
+            : lanes & 62914560
+              ? "Suspense"
+              : lanes & 2080374784
+                ? "Idle"
+                : "Other";
+    }
+    function logComponentRender(fiber, startTime, endTime, wasHydrated) {
+      var name = getComponentNameFromFiber(fiber);
+      if (null !== name && supportsUserTiming) {
+        var selfTime = fiber.actualDuration;
+        if (null === fiber.alternate || fiber.alternate.child !== fiber.child)
+          for (fiber = fiber.child; null !== fiber; fiber = fiber.sibling)
+            selfTime -= fiber.actualDuration;
+        reusableComponentDevToolDetails.color =
+          0.5 > selfTime
+            ? wasHydrated
+              ? "tertiary-light"
+              : "primary-light"
+            : 10 > selfTime
+              ? wasHydrated
+                ? "tertiary"
+                : "primary"
+              : 100 > selfTime
+                ? wasHydrated
+                  ? "tertiary-dark"
+                  : "primary-dark"
+                : "error";
+        reusableComponentOptions.start = startTime;
+        reusableComponentOptions.end = endTime;
+        performance.measure(name, reusableComponentOptions);
+      }
+    }
+    function logComponentErrored(fiber, startTime, endTime, errors) {
+      if (supportsUserTiming) {
+        var name = getComponentNameFromFiber(fiber);
+        if (null !== name) {
+          for (var properties = [], i = 0; i < errors.length; i++) {
+            var error = errors[i].value;
+            properties.push([
+              "Error",
+              "object" === typeof error &&
+              null !== error &&
+              "string" === typeof error.message
+                ? String(error.message)
+                : String(error)
+            ]);
+          }
+          performance.measure(name, {
+            start: startTime,
+            end: endTime,
+            detail: {
+              devtools: {
+                color: "error",
+                track: COMPONENTS_TRACK,
+                tooltipText:
+                  13 === fiber.tag
+                    ? "Hydration failed"
+                    : "Error boundary caught an error",
+                properties: properties
+              }
+            }
+          });
+        }
+      }
+    }
+    function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
+      if (null !== errors) {
+        if (
+          supportsUserTiming &&
+          ((selfTime = getComponentNameFromFiber(fiber)), null !== selfTime)
+        ) {
+          fiber = [];
+          for (var i = 0; i < errors.length; i++) {
+            var error = errors[i].value;
+            fiber.push([
+              "Error",
+              "object" === typeof error &&
+              null !== error &&
+              "string" === typeof error.message
+                ? String(error.message)
+                : String(error)
+            ]);
+          }
+          performance.measure(selfTime, {
+            start: startTime,
+            end: endTime,
+            detail: {
+              devtools: {
+                color: "error",
+                track: COMPONENTS_TRACK,
+                tooltipText: "A lifecycle or effect errored",
+                properties: fiber
+              }
+            }
+          });
+        }
+      } else
+        (errors = getComponentNameFromFiber(fiber)),
+          null !== errors &&
+            supportsUserTiming &&
+            ((reusableComponentDevToolDetails.color =
+              1 > selfTime
+                ? "secondary-light"
+                : 100 > selfTime
+                  ? "secondary"
+                  : 500 > selfTime
+                    ? "secondary-dark"
+                    : "error"),
+            (reusableComponentOptions.start = startTime),
+            (reusableComponentOptions.end = endTime),
+            performance.measure(errors, reusableComponentOptions));
+    }
+    function logRenderPhase(startTime, endTime, lanes) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color =
+          (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure(
+          (lanes & 536870912) === lanes
+            ? "Prepared"
+            : (lanes & 201326677) === lanes
+              ? "Hydrated"
+              : "Render",
+          reusableLaneOptions
+        ));
+    }
+    function logSuspendedRenderPhase(startTime, endTime, lanes) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color =
+          (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Prewarm", reusableLaneOptions));
+    }
+    function logSuspendedWithDelayPhase(startTime, endTime, lanes) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color =
+          (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Suspended", reusableLaneOptions));
+    }
+    function logRecoveredRenderPhase(
+      startTime,
+      endTime,
+      lanes,
+      recoverableErrors,
+      hydrationFailed
+    ) {
+      if (supportsUserTiming) {
+        lanes = [];
+        for (var i = 0; i < recoverableErrors.length; i++) {
+          var error = recoverableErrors[i].value;
+          lanes.push([
+            "Recoverable Error",
+            "object" === typeof error &&
+            null !== error &&
+            "string" === typeof error.message
+              ? String(error.message)
+              : String(error)
+          ]);
+        }
+        performance.measure("Recovered", {
+          start: startTime,
+          end: endTime,
+          detail: {
+            devtools: {
+              color: "primary-dark",
+              track: reusableLaneDevToolDetails.track,
+              trackGroup: LANES_TRACK_GROUP,
+              tooltipText: hydrationFailed
+                ? "Hydration Failed"
+                : "Recovered after Error",
+              properties: lanes
+            }
+          }
+        });
+      }
+    }
+    function logErroredRenderPhase(startTime, endTime) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color = "error"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Errored", reusableLaneOptions));
+    }
+    function logSuspenseThrottlePhase(startTime, endTime) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color = "secondary-light"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Throttled", reusableLaneOptions));
+    }
+    function logSuspendedCommitPhase(startTime, endTime) {
+      supportsUserTiming &&
+        ((reusableLaneDevToolDetails.color = "secondary-light"),
+        (reusableLaneOptions.start = startTime),
+        (reusableLaneOptions.end = endTime),
+        performance.measure("Suspended", reusableLaneOptions));
+    }
+    function logCommitErrored(startTime, endTime, errors, passive) {
+      if (supportsUserTiming) {
+        for (var properties = [], i = 0; i < errors.length; i++) {
+          var error = errors[i].value;
+          properties.push([
+            "Error",
+            "object" === typeof error &&
+            null !== error &&
+            "string" === typeof error.message
+              ? String(error.message)
+              : String(error)
+          ]);
+        }
+        performance.measure("Errored", {
+          start: startTime,
+          end: endTime,
+          detail: {
+            devtools: {
+              color: "error",
+              track: reusableLaneDevToolDetails.track,
+              trackGroup: LANES_TRACK_GROUP,
+              tooltipText: passive
+                ? "Remaining Effects Errored"
+                : "Commit Errored",
+              properties: properties
+            }
+          }
+        });
+      }
+    }
+    function resetContextDependencies() {
+      lastContextDependency = currentlyRenderingFiber$1 = null;
+      isDisallowedContextReadInDEV = !1;
+    }
+    function pushProvider(providerFiber, context, nextValue) {
+      push(valueCursor, context._currentValue, providerFiber);
+      context._currentValue = nextValue;
+      push(rendererCursorDEV, context._currentRenderer, providerFiber);
+      void 0 !== context._currentRenderer &&
+        null !== context._currentRenderer &&
+        context._currentRenderer !== rendererSigil &&
+        console.error(
+          "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
+        );
+      context._currentRenderer = rendererSigil;
+    }
+    function popProvider(context, providerFiber) {
+      context._currentValue = valueCursor.current;
+      var currentRenderer = rendererCursorDEV.current;
+      pop(rendererCursorDEV, providerFiber);
+      context._currentRenderer = currentRenderer;
+      pop(valueCursor, providerFiber);
+    }
+    function scheduleContextWorkOnParentPath(
+      parent,
+      renderLanes,
+      propagationRoot
+    ) {
+      for (; null !== parent; ) {
+        var alternate = parent.alternate;
+        (parent.childLanes & renderLanes) !== renderLanes
+          ? ((parent.childLanes |= renderLanes),
+            null !== alternate && (alternate.childLanes |= renderLanes))
+          : null !== alternate &&
+            (alternate.childLanes & renderLanes) !== renderLanes &&
+            (alternate.childLanes |= renderLanes);
+        if (parent === propagationRoot) break;
+        parent = parent.return;
+      }
+      parent !== propagationRoot &&
+        console.error(
+          "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
+        );
+    }
+    function propagateContextChanges(
+      workInProgress,
+      contexts,
+      renderLanes,
+      forcePropagateEntireTree
+    ) {
+      var fiber = workInProgress.child;
+      null !== fiber && (fiber.return = workInProgress);
+      for (; null !== fiber; ) {
+        var list = fiber.dependencies;
+        if (null !== list) {
+          var nextFiber = fiber.child;
+          list = list.firstContext;
+          a: for (; null !== list; ) {
+            var dependency = list;
+            list = fiber;
+            for (var i = 0; i < contexts.length; i++)
+              if (dependency.context === contexts[i]) {
+                list.lanes |= renderLanes;
+                dependency = list.alternate;
+                null !== dependency && (dependency.lanes |= renderLanes);
+                scheduleContextWorkOnParentPath(
+                  list.return,
+                  renderLanes,
+                  workInProgress
+                );
+                forcePropagateEntireTree || (nextFiber = null);
+                break a;
+              }
+            list = dependency.next;
+          }
+        } else if (18 === fiber.tag) {
+          nextFiber = fiber.return;
+          if (null === nextFiber)
+            throw Error(
+              "We just came from a parent so we must have had a parent. This is a bug in React."
+            );
+          nextFiber.lanes |= renderLanes;
+          list = nextFiber.alternate;
+          null !== list && (list.lanes |= renderLanes);
+          scheduleContextWorkOnParentPath(
+            nextFiber,
+            renderLanes,
+            workInProgress
+          );
+          nextFiber = null;
+        } else nextFiber = fiber.child;
+        if (null !== nextFiber) nextFiber.return = fiber;
+        else
+          for (nextFiber = fiber; null !== nextFiber; ) {
+            if (nextFiber === workInProgress) {
+              nextFiber = null;
+              break;
+            }
+            fiber = nextFiber.sibling;
+            if (null !== fiber) {
+              fiber.return = nextFiber.return;
+              nextFiber = fiber;
+              break;
+            }
+            nextFiber = nextFiber.return;
+          }
+        fiber = nextFiber;
+      }
+    }
+    function propagateParentContextChanges(
+      current,
+      workInProgress,
+      renderLanes,
+      forcePropagateEntireTree
+    ) {
+      current = null;
+      for (
+        var parent = workInProgress, isInsidePropagationBailout = !1;
+        null !== parent;
+
+      ) {
+        if (!isInsidePropagationBailout)
+          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
+          else if (0 !== (parent.flags & 262144)) break;
+        if (10 === parent.tag) {
+          var currentParent = parent.alternate;
+          if (null === currentParent)
+            throw Error("Should have a current fiber. This is a bug in React.");
+          currentParent = currentParent.memoizedProps;
+          if (null !== currentParent) {
+            var context = parent.type;
+            objectIs(parent.pendingProps.value, currentParent.value) ||
+              (null !== current
+                ? current.push(context)
+                : (current = [context]));
+          }
+        } else if (parent === hostTransitionProviderCursor.current) {
+          currentParent = parent.alternate;
+          if (null === currentParent)
+            throw Error("Should have a current fiber. This is a bug in React.");
+          currentParent.memoizedState.memoizedState !==
+            parent.memoizedState.memoizedState &&
+            (null !== current
+              ? current.push(HostTransitionContext)
+              : (current = [HostTransitionContext]));
+        }
+        parent = parent.return;
+      }
+      null !== current &&
+        propagateContextChanges(
+          workInProgress,
+          current,
+          renderLanes,
+          forcePropagateEntireTree
+        );
+      workInProgress.flags |= 262144;
+    }
+    function checkIfContextChanged(currentDependencies) {
+      for (
+        currentDependencies = currentDependencies.firstContext;
+        null !== currentDependencies;
+
+      ) {
+        if (
+          !objectIs(
+            currentDependencies.context._currentValue,
+            currentDependencies.memoizedValue
+          )
+        )
+          return !0;
+        currentDependencies = currentDependencies.next;
+      }
+      return !1;
+    }
+    function prepareToReadContext(workInProgress) {
+      currentlyRenderingFiber$1 = workInProgress;
+      lastContextDependency = null;
+      workInProgress = workInProgress.dependencies;
+      null !== workInProgress && (workInProgress.firstContext = null);
+    }
+    function readContext(context) {
+      isDisallowedContextReadInDEV &&
+        console.error(
+          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+        );
+      return readContextForConsumer(currentlyRenderingFiber$1, context);
+    }
+    function readContextDuringReconciliation(consumer, context) {
+      null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
+      return readContextForConsumer(consumer, context);
+    }
+    function readContextForConsumer(consumer, context) {
+      var value = context._currentValue;
+      context = { context: context, memoizedValue: value, next: null };
+      if (null === lastContextDependency) {
+        if (null === consumer)
+          throw Error(
+            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+          );
+        lastContextDependency = context;
+        consumer.dependencies = {
+          lanes: 0,
+          firstContext: context,
+          _debugThenableState: null
+        };
+        consumer.flags |= 524288;
+      } else lastContextDependency = lastContextDependency.next = context;
+      return value;
+    }
+    function entangleAsyncAction(transition, thenable) {
+      if (null === currentEntangledListeners) {
+        var entangledListeners = (currentEntangledListeners = []);
+        currentEntangledPendingCount = 0;
+        currentEntangledLane = requestTransitionLane();
+        currentEntangledActionThenable = {
+          status: "pending",
+          value: void 0,
+          then: function (resolve) {
+            entangledListeners.push(resolve);
+          }
+        };
+      }
+      currentEntangledPendingCount++;
+      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
+      return thenable;
+    }
+    function pingEngtangledActionScope() {
+      if (
+        0 === --currentEntangledPendingCount &&
+        (-1 < transitionUpdateTime || (transitionStartTime = -1.1),
+        null !== currentEntangledListeners)
+      ) {
+        null !== currentEntangledActionThenable &&
+          (currentEntangledActionThenable.status = "fulfilled");
+        var listeners = currentEntangledListeners;
+        currentEntangledListeners = null;
+        currentEntangledLane = 0;
+        currentEntangledActionThenable = null;
+        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
+      }
+    }
+    function chainThenableValue(thenable, result) {
+      var listeners = [],
+        thenableWithOverride = {
+          status: "pending",
+          value: null,
+          reason: null,
+          then: function (resolve) {
+            listeners.push(resolve);
+          }
+        };
+      thenable.then(
+        function () {
+          thenableWithOverride.status = "fulfilled";
+          thenableWithOverride.value = result;
+          for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
+        },
+        function (error) {
+          thenableWithOverride.status = "rejected";
+          thenableWithOverride.reason = error;
+          for (error = 0; error < listeners.length; error++)
+            (0, listeners[error])(void 0);
+        }
+      );
+      return thenableWithOverride;
+    }
+    function initializeUpdateQueue(fiber) {
+      fiber.updateQueue = {
+        baseState: fiber.memoizedState,
+        firstBaseUpdate: null,
+        lastBaseUpdate: null,
+        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
+        callbacks: null
+      };
+    }
+    function cloneUpdateQueue(current, workInProgress) {
+      current = current.updateQueue;
+      workInProgress.updateQueue === current &&
+        (workInProgress.updateQueue = {
+          baseState: current.baseState,
+          firstBaseUpdate: current.firstBaseUpdate,
+          lastBaseUpdate: current.lastBaseUpdate,
+          shared: current.shared,
+          callbacks: null
+        });
+    }
+    function createUpdate(lane) {
+      return {
+        lane: lane,
+        tag: UpdateState,
+        payload: null,
+        callback: null,
+        next: null
+      };
+    }
+    function enqueueUpdate(fiber, update, lane) {
+      var updateQueue = fiber.updateQueue;
+      if (null === updateQueue) return null;
+      updateQueue = updateQueue.shared;
+      if (
+        currentlyProcessingQueue === updateQueue &&
+        !didWarnUpdateInsideUpdate
+      ) {
+        var componentName = getComponentNameFromFiber(fiber);
+        console.error(
+          "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
+          componentName
+        );
+        didWarnUpdateInsideUpdate = !0;
+      }
+      if ((executionContext & RenderContext) !== NoContext)
+        return (
+          (componentName = updateQueue.pending),
+          null === componentName
+            ? (update.next = update)
+            : ((update.next = componentName.next),
+              (componentName.next = update)),
+          (updateQueue.pending = update),
+          (update = getRootForUpdatedFiber(fiber)),
+          markUpdateLaneFromFiberToRoot(fiber, null, lane),
+          update
+        );
+      enqueueUpdate$1(fiber, updateQueue, update, lane);
+      return getRootForUpdatedFiber(fiber);
+    }
+    function entangleTransitions(root, fiber, lane) {
+      fiber = fiber.updateQueue;
+      if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194176))) {
+        var queueLanes = fiber.lanes;
+        queueLanes &= root.pendingLanes;
+        lane |= queueLanes;
+        fiber.lanes = lane;
+        markRootEntangled(root, lane);
+      }
+    }
+    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
+      var queue = workInProgress.updateQueue,
+        current = workInProgress.alternate;
+      if (
+        null !== current &&
+        ((current = current.updateQueue), queue === current)
+      ) {
+        var newFirst = null,
+          newLast = null;
+        queue = queue.firstBaseUpdate;
+        if (null !== queue) {
+          do {
+            var clone = {
+              lane: queue.lane,
+              tag: queue.tag,
+              payload: queue.payload,
+              callback: null,
+              next: null
+            };
+            null === newLast
+              ? (newFirst = newLast = clone)
+              : (newLast = newLast.next = clone);
+            queue = queue.next;
+          } while (null !== queue);
+          null === newLast
+            ? (newFirst = newLast = capturedUpdate)
+            : (newLast = newLast.next = capturedUpdate);
+        } else newFirst = newLast = capturedUpdate;
+        queue = {
+          baseState: current.baseState,
+          firstBaseUpdate: newFirst,
+          lastBaseUpdate: newLast,
+          shared: current.shared,
+          callbacks: current.callbacks
+        };
+        workInProgress.updateQueue = queue;
+        return;
+      }
+      workInProgress = queue.lastBaseUpdate;
+      null === workInProgress
+        ? (queue.firstBaseUpdate = capturedUpdate)
+        : (workInProgress.next = capturedUpdate);
+      queue.lastBaseUpdate = capturedUpdate;
+    }
+    function suspendIfUpdateReadFromEntangledAsyncAction() {
+      if (didReadFromEntangledAsyncAction) {
+        var entangledActionThenable = currentEntangledActionThenable;
+        if (null !== entangledActionThenable) throw entangledActionThenable;
+      }
+    }
+    function processUpdateQueue(
+      workInProgress,
+      props,
+      instance$jscomp$0,
+      renderLanes
+    ) {
+      didReadFromEntangledAsyncAction = !1;
+      var queue = workInProgress.updateQueue;
+      hasForceUpdate = !1;
+      currentlyProcessingQueue = queue.shared;
+      var firstBaseUpdate = queue.firstBaseUpdate,
+        lastBaseUpdate = queue.lastBaseUpdate,
+        pendingQueue = queue.shared.pending;
+      if (null !== pendingQueue) {
+        queue.shared.pending = null;
+        var lastPendingUpdate = pendingQueue,
+          firstPendingUpdate = lastPendingUpdate.next;
+        lastPendingUpdate.next = null;
+        null === lastBaseUpdate
+          ? (firstBaseUpdate = firstPendingUpdate)
+          : (lastBaseUpdate.next = firstPendingUpdate);
+        lastBaseUpdate = lastPendingUpdate;
+        var current = workInProgress.alternate;
+        null !== current &&
+          ((current = current.updateQueue),
+          (pendingQueue = current.lastBaseUpdate),
+          pendingQueue !== lastBaseUpdate &&
+            (null === pendingQueue
+              ? (current.firstBaseUpdate = firstPendingUpdate)
+              : (pendingQueue.next = firstPendingUpdate),
+            (current.lastBaseUpdate = lastPendingUpdate)));
+      }
+      if (null !== firstBaseUpdate) {
+        var newState = queue.baseState;
+        lastBaseUpdate = 0;
+        current = firstPendingUpdate = lastPendingUpdate = null;
+        pendingQueue = firstBaseUpdate;
+        do {
+          var updateLane = pendingQueue.lane & -536870913,
+            isHiddenUpdate = updateLane !== pendingQueue.lane;
+          if (
+            isHiddenUpdate
+              ? (workInProgressRootRenderLanes & updateLane) === updateLane
+              : (renderLanes & updateLane) === updateLane
+          ) {
+            0 !== updateLane &&
+              updateLane === currentEntangledLane &&
+              (didReadFromEntangledAsyncAction = !0);
+            null !== current &&
+              (current = current.next =
+                {
+                  lane: 0,
+                  tag: pendingQueue.tag,
+                  payload: pendingQueue.payload,
+                  callback: null,
+                  next: null
+                });
+            a: {
+              updateLane = workInProgress;
+              var partialState = pendingQueue;
+              var nextProps = props,
+                instance = instance$jscomp$0;
+              switch (partialState.tag) {
+                case ReplaceState:
+                  partialState = partialState.payload;
+                  if ("function" === typeof partialState) {
+                    isDisallowedContextReadInDEV = !0;
+                    var nextState = partialState.call(
+                      instance,
+                      newState,
+                      nextProps
+                    );
+                    if (updateLane.mode & StrictLegacyMode) {
+                      setIsStrictModeForDevtools(!0);
+                      try {
+                        partialState.call(instance, newState, nextProps);
+                      } finally {
+                        setIsStrictModeForDevtools(!1);
+                      }
+                    }
+                    isDisallowedContextReadInDEV = !1;
+                    newState = nextState;
+                    break a;
+                  }
+                  newState = partialState;
+                  break a;
+                case CaptureUpdate:
+                  updateLane.flags = (updateLane.flags & -65537) | 128;
+                case UpdateState:
+                  nextState = partialState.payload;
+                  if ("function" === typeof nextState) {
+                    isDisallowedContextReadInDEV = !0;
+                    partialState = nextState.call(
+                      instance,
+                      newState,
+                      nextProps
+                    );
+                    if (updateLane.mode & StrictLegacyMode) {
+                      setIsStrictModeForDevtools(!0);
+                      try {
+                        nextState.call(instance, newState, nextProps);
+                      } finally {
+                        setIsStrictModeForDevtools(!1);
+                      }
+                    }
+                    isDisallowedContextReadInDEV = !1;
+                  } else partialState = nextState;
+                  if (null === partialState || void 0 === partialState) break a;
+                  newState = assign({}, newState, partialState);
+                  break a;
+                case ForceUpdate:
+                  hasForceUpdate = !0;
+              }
+            }
+            updateLane = pendingQueue.callback;
+            null !== updateLane &&
+              ((workInProgress.flags |= 64),
+              isHiddenUpdate && (workInProgress.flags |= 8192),
+              (isHiddenUpdate = queue.callbacks),
+              null === isHiddenUpdate
+                ? (queue.callbacks = [updateLane])
+                : isHiddenUpdate.push(updateLane));
+          } else
+            (isHiddenUpdate = {
+              lane: updateLane,
+              tag: pendingQueue.tag,
+              payload: pendingQueue.payload,
+              callback: pendingQueue.callback,
+              next: null
+            }),
+              null === current
+                ? ((firstPendingUpdate = current = isHiddenUpdate),
+                  (lastPendingUpdate = newState))
+                : (current = current.next = isHiddenUpdate),
+              (lastBaseUpdate |= updateLane);
+          pendingQueue = pendingQueue.next;
+          if (null === pendingQueue)
+            if (((pendingQueue = queue.shared.pending), null === pendingQueue))
+              break;
+            else
+              (isHiddenUpdate = pendingQueue),
+                (pendingQueue = isHiddenUpdate.next),
+                (isHiddenUpdate.next = null),
+                (queue.lastBaseUpdate = isHiddenUpdate),
+                (queue.shared.pending = null);
+        } while (1);
+        null === current && (lastPendingUpdate = newState);
+        queue.baseState = lastPendingUpdate;
+        queue.firstBaseUpdate = firstPendingUpdate;
+        queue.lastBaseUpdate = current;
+        null === firstBaseUpdate && (queue.shared.lanes = 0);
+        workInProgressRootSkippedLanes |= lastBaseUpdate;
+        workInProgress.lanes = lastBaseUpdate;
+        workInProgress.memoizedState = newState;
+      }
+      currentlyProcessingQueue = null;
+    }
+    function callCallback(callback, context) {
+      if ("function" !== typeof callback)
+        throw Error(
+          "Invalid argument passed as callback. Expected a function. Instead received: " +
+            callback
+        );
+      callback.call(context);
+    }
+    function commitHiddenCallbacks(updateQueue, context) {
+      var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
+      if (null !== hiddenCallbacks)
+        for (
+          updateQueue.shared.hiddenCallbacks = null, updateQueue = 0;
+          updateQueue < hiddenCallbacks.length;
+          updateQueue++
+        )
+          callCallback(hiddenCallbacks[updateQueue], context);
+    }
+    function commitCallbacks(updateQueue, context) {
+      var callbacks = updateQueue.callbacks;
+      if (null !== callbacks)
+        for (
+          updateQueue.callbacks = null, updateQueue = 0;
+          updateQueue < callbacks.length;
+          updateQueue++
+        )
+          callCallback(callbacks[updateQueue], context);
+    }
+    function createCache() {
+      return {
+        controller: new AbortControllerLocal(),
+        data: new Map(),
+        refCount: 0
+      };
+    }
+    function retainCache(cache) {
+      cache.controller.signal.aborted &&
+        console.warn(
+          "A cache instance was retained after it was already freed. This likely indicates a bug in React."
+        );
+      cache.refCount++;
+    }
+    function releaseCache(cache) {
+      cache.refCount--;
+      0 > cache.refCount &&
+        console.warn(
+          "A cache instance was released after it was already freed. This likely indicates a bug in React."
+        );
+      0 === cache.refCount &&
+        scheduleCallback$2(NormalPriority, function () {
+          cache.controller.abort();
+        });
+    }
+    function warnOnInvalidCallback(callback) {
+      if (null !== callback && "function" !== typeof callback) {
+        var key = String(callback);
+        didWarnOnInvalidCallback.has(key) ||
+          (didWarnOnInvalidCallback.add(key),
+          console.error(
+            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
+            callback
+          ));
+      }
+    }
+    function applyDerivedStateFromProps(
+      workInProgress,
+      ctor,
+      getDerivedStateFromProps,
+      nextProps
+    ) {
+      var prevState = workInProgress.memoizedState,
+        partialState = getDerivedStateFromProps(nextProps, prevState);
+      if (workInProgress.mode & StrictLegacyMode) {
+        setIsStrictModeForDevtools(!0);
+        try {
+          partialState = getDerivedStateFromProps(nextProps, prevState);
+        } finally {
+          setIsStrictModeForDevtools(!1);
+        }
+      }
+      void 0 === partialState &&
+        ((ctor = getComponentNameFromType(ctor) || "Component"),
+        didWarnAboutUndefinedDerivedState.has(ctor) ||
+          (didWarnAboutUndefinedDerivedState.add(ctor),
+          console.error(
+            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
+            ctor
+          )));
+      prevState =
+        null === partialState || void 0 === partialState
+          ? prevState
+          : assign({}, prevState, partialState);
+      workInProgress.memoizedState = prevState;
+      0 === workInProgress.lanes &&
+        (workInProgress.updateQueue.baseState = prevState);
+    }
+    function checkShouldComponentUpdate(
+      workInProgress,
+      ctor,
+      oldProps,
+      newProps,
+      oldState,
+      newState,
+      nextContext
+    ) {
+      var instance = workInProgress.stateNode;
+      if ("function" === typeof instance.shouldComponentUpdate) {
+        oldProps = instance.shouldComponentUpdate(
+          newProps,
+          newState,
+          nextContext
+        );
+        if (workInProgress.mode & StrictLegacyMode) {
+          setIsStrictModeForDevtools(!0);
+          try {
+            oldProps = instance.shouldComponentUpdate(
+              newProps,
+              newState,
+              nextContext
+            );
+          } finally {
+            setIsStrictModeForDevtools(!1);
+          }
+        }
+        void 0 === oldProps &&
+          console.error(
+            "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
+            getComponentNameFromType(ctor) || "Component"
+          );
+        return oldProps;
+      }
+      return ctor.prototype && ctor.prototype.isPureReactComponent
+        ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
+        : !0;
+    }
+    function callComponentWillReceiveProps(
+      workInProgress,
+      instance,
+      newProps,
+      nextContext
+    ) {
+      var oldState = instance.state;
+      "function" === typeof instance.componentWillReceiveProps &&
+        instance.componentWillReceiveProps(newProps, nextContext);
+      "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
+        instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
+      instance.state !== oldState &&
+        ((workInProgress =
+          getComponentNameFromFiber(workInProgress) || "Component"),
+        didWarnAboutStateAssignmentForComponent.has(workInProgress) ||
+          (didWarnAboutStateAssignmentForComponent.add(workInProgress),
+          console.error(
+            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
+            workInProgress
+          )),
+        classComponentUpdater.enqueueReplaceState(
+          instance,
+          instance.state,
+          null
+        ));
+    }
+    function resolveClassComponentProps(Component, baseProps) {
+      var newProps = baseProps;
+      if ("ref" in baseProps) {
+        newProps = {};
+        for (var propName in baseProps)
+          "ref" !== propName && (newProps[propName] = baseProps[propName]);
+      }
+      if ((Component = Component.defaultProps)) {
+        newProps === baseProps && (newProps = assign({}, newProps));
+        for (var _propName in Component)
+          void 0 === newProps[_propName] &&
+            (newProps[_propName] = Component[_propName]);
+      }
+      return newProps;
+    }
+    function getTreeId() {
+      var overflow = treeContextOverflow,
+        idWithLeadingBit = treeContextId;
+      return (
+        (
+          idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
+        ).toString(32) + overflow
+      );
+    }
+    function pushTreeFork(workInProgress, totalChildren) {
+      warnIfNotHydrating();
+      forkStack[forkStackIndex++] = treeForkCount;
+      forkStack[forkStackIndex++] = treeForkProvider;
+      treeForkProvider = workInProgress;
+      treeForkCount = totalChildren;
+    }
+    function pushTreeId(workInProgress, totalChildren, index) {
+      warnIfNotHydrating();
+      idStack[idStackIndex++] = treeContextId;
+      idStack[idStackIndex++] = treeContextOverflow;
+      idStack[idStackIndex++] = treeContextProvider;
+      treeContextProvider = workInProgress;
+      var baseIdWithLeadingBit = treeContextId;
+      workInProgress = treeContextOverflow;
+      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
+      baseIdWithLeadingBit &= ~(1 << baseLength);
+      index += 1;
+      var length = 32 - clz32(totalChildren) + baseLength;
+      if (30 < length) {
+        var numberOfOverflowBits = baseLength - (baseLength % 5);
+        length = (
+          baseIdWithLeadingBit &
+          ((1 << numberOfOverflowBits) - 1)
+        ).toString(32);
+        baseIdWithLeadingBit >>= numberOfOverflowBits;
+        baseLength -= numberOfOverflowBits;
+        treeContextId =
+          (1 << (32 - clz32(totalChildren) + baseLength)) |
+          (index << baseLength) |
+          baseIdWithLeadingBit;
+        treeContextOverflow = length + workInProgress;
+      } else
+        (treeContextId =
+          (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
+          (treeContextOverflow = workInProgress);
+    }
+    function pushMaterializedTreeId(workInProgress) {
+      warnIfNotHydrating();
+      null !== workInProgress.return &&
+        (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
+    }
+    function popTreeContext(workInProgress) {
+      for (; workInProgress === treeForkProvider; )
+        (treeForkProvider = forkStack[--forkStackIndex]),
+          (forkStack[forkStackIndex] = null),
+          (treeForkCount = forkStack[--forkStackIndex]),
+          (forkStack[forkStackIndex] = null);
+      for (; workInProgress === treeContextProvider; )
+        (treeContextProvider = idStack[--idStackIndex]),
+          (idStack[idStackIndex] = null),
+          (treeContextOverflow = idStack[--idStackIndex]),
+          (idStack[idStackIndex] = null),
+          (treeContextId = idStack[--idStackIndex]),
+          (idStack[idStackIndex] = null);
+    }
+    function warnIfNotHydrating() {
+      isHydrating ||
+        console.error(
+          "Expected to be hydrating. This is a bug in React. Please file an issue."
+        );
+    }
+    function createThenableState() {
+      return { didWarnAboutUncachedPromise: !1, thenables: [] };
+    }
+    function isThenableResolved(thenable) {
+      thenable = thenable.status;
+      return "fulfilled" === thenable || "rejected" === thenable;
+    }
+    function noop$3() {}
+    function trackUsedThenable(thenableState, thenable, index) {
+      null !== ReactSharedInternals.actQueue &&
+        (ReactSharedInternals.didUsePromise = !0);
+      var trackedThenables = thenableState.thenables;
+      index = trackedThenables[index];
+      void 0 === index
+        ? trackedThenables.push(thenable)
+        : index !== thenable &&
+          (thenableState.didWarnAboutUncachedPromise ||
+            ((thenableState.didWarnAboutUncachedPromise = !0),
+            console.error(
+              "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
+            )),
+          thenable.then(noop$3, noop$3),
+          (thenable = index));
+      switch (thenable.status) {
+        case "fulfilled":
+          return thenable.value;
+        case "rejected":
+          throw (
+            ((thenableState = thenable.reason),
+            checkIfUseWrappedInAsyncCatch(thenableState),
+            thenableState)
+          );
+        default:
+          if ("string" === typeof thenable.status)
+            thenable.then(noop$3, noop$3);
+          else {
+            thenableState = workInProgressRoot;
+            if (
+              null !== thenableState &&
+              100 < thenableState.shellSuspendCounter
+            )
+              throw Error(
+                "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
+              );
+            thenableState = thenable;
+            thenableState.status = "pending";
+            thenableState.then(
+              function (fulfilledValue) {
+                if ("pending" === thenable.status) {
+                  var fulfilledThenable = thenable;
+                  fulfilledThenable.status = "fulfilled";
+                  fulfilledThenable.value = fulfilledValue;
+                }
+              },
+              function (error) {
+                if ("pending" === thenable.status) {
+                  var rejectedThenable = thenable;
+                  rejectedThenable.status = "rejected";
+                  rejectedThenable.reason = error;
+                }
+              }
+            );
+          }
+          switch (thenable.status) {
+            case "fulfilled":
+              return thenable.value;
+            case "rejected":
+              throw (
+                ((thenableState = thenable.reason),
+                checkIfUseWrappedInAsyncCatch(thenableState),
+                thenableState)
+              );
+          }
+          suspendedThenable = thenable;
+          needsToResetSuspendedThenableDEV = !0;
+          throw SuspenseException;
+      }
+    }
+    function getSuspendedThenable() {
+      if (null === suspendedThenable)
+        throw Error(
+          "Expected a suspended thenable. This is a bug in React. Please file an issue."
+        );
+      var thenable = suspendedThenable;
+      suspendedThenable = null;
+      needsToResetSuspendedThenableDEV = !1;
+      return thenable;
+    }
+    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
+      if (
+        rejectedReason === SuspenseException ||
+        rejectedReason === SuspenseActionException
+      )
+        throw Error(
+          "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
+        );
+    }
+    function pushHiddenContext(fiber, context) {
+      var prevEntangledRenderLanes = entangledRenderLanes;
+      push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
+      push(currentTreeHiddenStackCursor, context, fiber);
+      entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
+    }
+    function reuseHiddenContextOnStack(fiber) {
+      push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
+      push(
+        currentTreeHiddenStackCursor,
+        currentTreeHiddenStackCursor.current,
+        fiber
+      );
+    }
+    function popHiddenContext(fiber) {
+      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
+      pop(currentTreeHiddenStackCursor, fiber);
+      pop(prevEntangledRenderLanesCursor, fiber);
+    }
+    function peekCacheFromPool() {
+      var cacheResumedFromPreviousRender = resumedCache.current;
+      return null !== cacheResumedFromPreviousRender
+        ? cacheResumedFromPreviousRender
+        : workInProgressRoot.pooledCache;
+    }
+    function pushTransition(offscreenWorkInProgress, prevCachePool) {
+      null === prevCachePool
+        ? push(resumedCache, resumedCache.current, offscreenWorkInProgress)
+        : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
+    }
+    function getSuspendedCache() {
+      var cacheFromPool = peekCacheFromPool();
+      return null === cacheFromPool
+        ? null
+        : { parent: CacheContext._currentValue, pool: cacheFromPool };
+    }
+    function mountHookTypesDev() {
+      var hookName = currentHookNameInDev;
+      null === hookTypesDev
+        ? (hookTypesDev = [hookName])
+        : hookTypesDev.push(hookName);
+    }
+    function updateHookTypesDev() {
+      var hookName = currentHookNameInDev;
+      if (
+        null !== hookTypesDev &&
+        (hookTypesUpdateIndexDev++,
+        hookTypesDev[hookTypesUpdateIndexDev] !== hookName)
+      ) {
+        var componentName = getComponentNameFromFiber(currentlyRenderingFiber);
+        if (
+          !didWarnAboutMismatchedHooksForComponent.has(componentName) &&
+          (didWarnAboutMismatchedHooksForComponent.add(componentName),
+          null !== hookTypesDev)
+        ) {
+          for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
+            var oldHookName = hookTypesDev[i],
+              newHookName =
+                i === hookTypesUpdateIndexDev ? hookName : oldHookName;
+            for (
+              oldHookName = i + 1 + ". " + oldHookName;
+              30 > oldHookName.length;
+
+            )
+              oldHookName += " ";
+            oldHookName += newHookName + "\n";
+            table += oldHookName;
+          }
+          console.error(
+            "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
+            componentName,
+            table
+          );
+        }
+      }
+    }
+    function checkDepsAreArrayDev(deps) {
+      void 0 === deps ||
+        null === deps ||
+        isArrayImpl(deps) ||
+        console.error(
+          "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
+          currentHookNameInDev,
+          typeof deps
+        );
+    }
+    function warnOnUseFormStateInDev() {
+      var componentName = getComponentNameFromFiber(currentlyRenderingFiber);
+      didWarnAboutUseFormState.has(componentName) ||
+        (didWarnAboutUseFormState.add(componentName),
+        console.error(
+          "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
+          componentName
+        ));
+    }
+    function throwInvalidHookError() {
+      throw Error(
+        "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
+      );
+    }
+    function areHookInputsEqual(nextDeps, prevDeps) {
+      if (ignorePreviousDependencies) return !1;
+      if (null === prevDeps)
+        return (
+          console.error(
+            "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
+            currentHookNameInDev
+          ),
+          !1
+        );
+      nextDeps.length !== prevDeps.length &&
+        console.error(
+          "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
+          currentHookNameInDev,
+          "[" + prevDeps.join(", ") + "]",
+          "[" + nextDeps.join(", ") + "]"
+        );
+      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
+        if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
+      return !0;
+    }
+    function renderWithHooks(
+      current,
+      workInProgress,
+      Component,
+      props,
+      secondArg,
+      nextRenderLanes
+    ) {
+      renderLanes = nextRenderLanes;
+      currentlyRenderingFiber = workInProgress;
+      hookTypesDev = null !== current ? current._debugHookTypes : null;
+      hookTypesUpdateIndexDev = -1;
+      ignorePreviousDependencies =
+        null !== current && current.type !== workInProgress.type;
+      if (
+        "[object AsyncFunction]" ===
+          Object.prototype.toString.call(Component) ||
+        "[object AsyncGeneratorFunction]" ===
+          Object.prototype.toString.call(Component)
+      )
+        (nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber)),
+          didWarnAboutAsyncClientComponent.has(nextRenderLanes) ||
+            (didWarnAboutAsyncClientComponent.add(nextRenderLanes),
+            console.error(
+              "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
+            ));
+      workInProgress.memoizedState = null;
+      workInProgress.updateQueue = null;
+      workInProgress.lanes = 0;
+      ReactSharedInternals.H =
+        null !== current && null !== current.memoizedState
+          ? HooksDispatcherOnUpdateInDEV
+          : null !== hookTypesDev
+            ? HooksDispatcherOnMountWithHookTypesInDEV
+            : HooksDispatcherOnMountInDEV;
+      shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes =
+        (workInProgress.mode & StrictLegacyMode) !== NoMode;
+      var children = callComponentInDEV(Component, props, secondArg);
+      shouldDoubleInvokeUserFnsInHooksDEV = !1;
+      didScheduleRenderPhaseUpdateDuringThisPass &&
+        (children = renderWithHooksAgain(
+          workInProgress,
+          Component,
+          props,
+          secondArg
+        ));
+      if (nextRenderLanes) {
+        setIsStrictModeForDevtools(!0);
+        try {
+          children = renderWithHooksAgain(
+            workInProgress,
+            Component,
+            props,
+            secondArg
+          );
+        } finally {
+          setIsStrictModeForDevtools(!1);
+        }
+      }
+      finishRenderingHooks(current, workInProgress);
+      return children;
+    }
+    function finishRenderingHooks(current, workInProgress) {
+      workInProgress._debugHookTypes = hookTypesDev;
+      null === workInProgress.dependencies
+        ? null !== thenableState$1 &&
+          (workInProgress.dependencies = {
+            lanes: 0,
+            firstContext: null,
+            _debugThenableState: thenableState$1
+          })
+        : (workInProgress.dependencies._debugThenableState = thenableState$1);
+      ReactSharedInternals.H = ContextOnlyDispatcher;
+      var didRenderTooFewHooks =
+        null !== currentHook && null !== currentHook.next;
+      renderLanes = 0;
+      hookTypesDev =
+        currentHookNameInDev =
+        workInProgressHook =
+        currentHook =
+        currentlyRenderingFiber =
+          null;
+      hookTypesUpdateIndexDev = -1;
+      null !== current &&
+        (current.flags & 65011712) !== (workInProgress.flags & 65011712) &&
+        console.error(
+          "Internal React error: Expected static flag was missing. Please notify the React team."
+        );
+      didScheduleRenderPhaseUpdate = !1;
+      thenableIndexCounter$1 = 0;
+      thenableState$1 = null;
+      if (didRenderTooFewHooks)
+        throw Error(
+          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
+        );
+      null === current ||
+        didReceiveUpdate ||
+        ((current = current.dependencies),
+        null !== current &&
+          checkIfContextChanged(current) &&
+          (didReceiveUpdate = !0));
+      needsToResetSuspendedThenableDEV
+        ? ((needsToResetSuspendedThenableDEV = !1), (current = !0))
+        : (current = !1);
+      current &&
+        ((workInProgress =
+          getComponentNameFromFiber(workInProgress) || "Unknown"),
+        didWarnAboutUseWrappedInTryCatch.has(workInProgress) ||
+          didWarnAboutAsyncClientComponent.has(workInProgress) ||
+          (didWarnAboutUseWrappedInTryCatch.add(workInProgress),
+          console.error(
+            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
+          )));
+    }
+    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
+      currentlyRenderingFiber = workInProgress;
+      var numberOfReRenders = 0;
+      do {
+        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
+        thenableIndexCounter$1 = 0;
+        didScheduleRenderPhaseUpdateDuringThisPass = !1;
+        if (numberOfReRenders >= RE_RENDER_LIMIT)
+          throw Error(
+            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
+          );
+        numberOfReRenders += 1;
+        ignorePreviousDependencies = !1;
+        workInProgressHook = currentHook = null;
+        if (null != workInProgress.updateQueue) {
+          var children = workInProgress.updateQueue;
+          children.lastEffect = null;
+          children.events = null;
+          children.stores = null;
+          null != children.memoCache && (children.memoCache.index = 0);
+        }
+        hookTypesUpdateIndexDev = -1;
+        ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
+        children = callComponentInDEV(Component, props, secondArg);
+      } while (didScheduleRenderPhaseUpdateDuringThisPass);
+      return children;
+    }
+    function TransitionAwareHostComponent() {
+      var dispatcher = ReactSharedInternals.H,
+        maybeThenable = dispatcher.useState()[0];
+      maybeThenable =
+        "function" === typeof maybeThenable.then
+          ? useThenable(maybeThenable)
+          : maybeThenable;
+      dispatcher = dispatcher.useState()[0];
+      (null !== currentHook ? currentHook.memoizedState : null) !==
+        dispatcher && (currentlyRenderingFiber.flags |= 1024);
+      return maybeThenable;
+    }
+    function checkDidRenderIdHook() {
+      var didRenderIdHook = 0 !== localIdCounter;
+      localIdCounter = 0;
+      return didRenderIdHook;
+    }
+    function bailoutHooks(current, workInProgress, lanes) {
+      workInProgress.updateQueue = current.updateQueue;
+      workInProgress.flags =
+        (workInProgress.mode & StrictEffectsMode) !== NoMode
+          ? workInProgress.flags & -402655237
+          : workInProgress.flags & -2053;
+      current.lanes &= ~lanes;
+    }
+    function resetHooksOnUnwind(workInProgress) {
+      if (didScheduleRenderPhaseUpdate) {
+        for (
+          workInProgress = workInProgress.memoizedState;
+          null !== workInProgress;
+
+        ) {
+          var queue = workInProgress.queue;
+          null !== queue && (queue.pending = null);
+          workInProgress = workInProgress.next;
+        }
+        didScheduleRenderPhaseUpdate = !1;
+      }
+      renderLanes = 0;
+      hookTypesDev =
+        workInProgressHook =
+        currentHook =
+        currentlyRenderingFiber =
+          null;
+      hookTypesUpdateIndexDev = -1;
+      currentHookNameInDev = null;
+      didScheduleRenderPhaseUpdateDuringThisPass = !1;
+      thenableIndexCounter$1 = localIdCounter = 0;
+      thenableState$1 = null;
+    }
+    function mountWorkInProgressHook() {
+      var hook = {
+        memoizedState: null,
+        baseState: null,
+        baseQueue: null,
+        queue: null,
+        next: null
+      };
+      null === workInProgressHook
+        ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
+        : (workInProgressHook = workInProgressHook.next = hook);
+      return workInProgressHook;
+    }
+    function updateWorkInProgressHook() {
+      if (null === currentHook) {
+        var nextCurrentHook = currentlyRenderingFiber.alternate;
+        nextCurrentHook =
+          null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
+      } else nextCurrentHook = currentHook.next;
+      var nextWorkInProgressHook =
+        null === workInProgressHook
+          ? currentlyRenderingFiber.memoizedState
+          : workInProgressHook.next;
+      if (null !== nextWorkInProgressHook)
+        (workInProgressHook = nextWorkInProgressHook),
+          (currentHook = nextCurrentHook);
+      else {
+        if (null === nextCurrentHook) {
+          if (null === currentlyRenderingFiber.alternate)
+            throw Error(
+              "Update hook called on initial render. This is likely a bug in React. Please file an issue."
+            );
+          throw Error("Rendered more hooks than during the previous render.");
+        }
+        currentHook = nextCurrentHook;
+        nextCurrentHook = {
+          memoizedState: currentHook.memoizedState,
+          baseState: currentHook.baseState,
+          baseQueue: currentHook.baseQueue,
+          queue: currentHook.queue,
+          next: null
+        };
+        null === workInProgressHook
+          ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
+              nextCurrentHook)
+          : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
+      }
+      return workInProgressHook;
+    }
+    function createFunctionComponentUpdateQueue() {
+      return { lastEffect: null, events: null, stores: null, memoCache: null };
+    }
+    function useThenable(thenable) {
+      var index = thenableIndexCounter$1;
+      thenableIndexCounter$1 += 1;
+      null === thenableState$1 && (thenableState$1 = createThenableState());
+      thenable = trackUsedThenable(thenableState$1, thenable, index);
+      index = currentlyRenderingFiber;
+      null ===
+        (null === workInProgressHook
+          ? index.memoizedState
+          : workInProgressHook.next) &&
+        ((index = index.alternate),
+        (ReactSharedInternals.H =
+          null !== index && null !== index.memoizedState
+            ? HooksDispatcherOnUpdateInDEV
+            : HooksDispatcherOnMountInDEV));
+      return thenable;
+    }
+    function use(usable) {
+      if (null !== usable && "object" === typeof usable) {
+        if ("function" === typeof usable.then) return useThenable(usable);
+        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
+      }
+      throw Error("An unsupported type was passed to use(): " + String(usable));
+    }
+    function useMemoCache(size) {
+      var memoCache = null,
+        updateQueue = currentlyRenderingFiber.updateQueue;
+      null !== updateQueue && (memoCache = updateQueue.memoCache);
+      if (null == memoCache) {
+        var current = currentlyRenderingFiber.alternate;
+        null !== current &&
+          ((current = current.updateQueue),
+          null !== current &&
+            ((current = current.memoCache),
+            null != current &&
+              (memoCache = {
+                data: current.data.map(function (array) {
+                  return array.slice();
+                }),
+                index: 0
+              })));
+      }
+      null == memoCache && (memoCache = { data: [], index: 0 });
+      null === updateQueue &&
+        ((updateQueue = createFunctionComponentUpdateQueue()),
+        (currentlyRenderingFiber.updateQueue = updateQueue));
+      updateQueue.memoCache = memoCache;
+      updateQueue = memoCache.data[memoCache.index];
+      if (void 0 === updateQueue || ignorePreviousDependencies)
+        for (
+          updateQueue = memoCache.data[memoCache.index] = Array(size),
+            current = 0;
+          current < size;
+          current++
+        )
+          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
+      else
+        updateQueue.length !== size &&
+          console.error(
+            "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
+            updateQueue.length,
+            size
+          );
+      memoCache.index++;
+      return updateQueue;
+    }
+    function basicStateReducer(state, action) {
+      return "function" === typeof action ? action(state) : action;
+    }
+    function mountReducer(reducer, initialArg, init) {
+      var hook = mountWorkInProgressHook();
+      if (void 0 !== init) {
+        var initialState = init(initialArg);
+        if (shouldDoubleInvokeUserFnsInHooksDEV) {
+          setIsStrictModeForDevtools(!0);
+          try {
+            init(initialArg);
+          } finally {
+            setIsStrictModeForDevtools(!1);
+          }
+        }
+      } else initialState = initialArg;
+      hook.memoizedState = hook.baseState = initialState;
+      reducer = {
+        pending: null,
+        lanes: 0,
+        dispatch: null,
+        lastRenderedReducer: reducer,
+        lastRenderedState: initialState
+      };
+      hook.queue = reducer;
+      reducer = reducer.dispatch = dispatchReducerAction.bind(
+        null,
+        currentlyRenderingFiber,
+        reducer
+      );
+      return [hook.memoizedState, reducer];
+    }
+    function updateReducer(reducer) {
+      var hook = updateWorkInProgressHook();
+      return updateReducerImpl(hook, currentHook, reducer);
+    }
+    function updateReducerImpl(hook, current, reducer) {
+      var queue = hook.queue;
+      if (null === queue)
+        throw Error(
+          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
+        );
+      queue.lastRenderedReducer = reducer;
+      var baseQueue = hook.baseQueue,
+        pendingQueue = queue.pending;
+      if (null !== pendingQueue) {
+        if (null !== baseQueue) {
+          var baseFirst = baseQueue.next;
+          baseQueue.next = pendingQueue.next;
+          pendingQueue.next = baseFirst;
+        }
+        current.baseQueue !== baseQueue &&
+          console.error(
+            "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
+          );
+        current.baseQueue = baseQueue = pendingQueue;
+        queue.pending = null;
+      }
+      pendingQueue = hook.baseState;
+      if (null === baseQueue) hook.memoizedState = pendingQueue;
+      else {
+        current = baseQueue.next;
+        var newBaseQueueFirst = (baseFirst = null),
+          newBaseQueueLast = null,
+          update = current,
+          didReadFromEntangledAsyncAction = !1;
+        do {
+          var updateLane = update.lane & -536870913;
+          if (
+            updateLane !== update.lane
+              ? (workInProgressRootRenderLanes & updateLane) === updateLane
+              : (renderLanes & updateLane) === updateLane
+          ) {
+            var revertLane = update.revertLane;
+            if (0 === revertLane)
+              null !== newBaseQueueLast &&
+                (newBaseQueueLast = newBaseQueueLast.next =
+                  {
+                    lane: 0,
+                    revertLane: 0,
+                    action: update.action,
+                    hasEagerState: update.hasEagerState,
+                    eagerState: update.eagerState,
+                    next: null
+                  }),
+                updateLane === currentEntangledLane &&
+                  (didReadFromEntangledAsyncAction = !0);
+            else if ((renderLanes & revertLane) === revertLane) {
+              update = update.next;
+              revertLane === currentEntangledLane &&
+                (didReadFromEntangledAsyncAction = !0);
+              continue;
+            } else
+              (updateLane = {
+                lane: 0,
+                revertLane: update.revertLane,
+                action: update.action,
+                hasEagerState: update.hasEagerState,
+                eagerState: update.eagerState,
+                next: null
+              }),
+                null === newBaseQueueLast
+                  ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
+                    (baseFirst = pendingQueue))
+                  : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
+                (currentlyRenderingFiber.lanes |= revertLane),
+                (workInProgressRootSkippedLanes |= revertLane);
+            updateLane = update.action;
+            shouldDoubleInvokeUserFnsInHooksDEV &&
+              reducer(pendingQueue, updateLane);
+            pendingQueue = update.hasEagerState
+              ? update.eagerState
+              : reducer(pendingQueue, updateLane);
+          } else
+            (revertLane = {
+              lane: updateLane,
+              revertLane: update.revertLane,
+              action: update.action,
+              hasEagerState: update.hasEagerState,
+              eagerState: update.eagerState,
+              next: null
+            }),
+              null === newBaseQueueLast
+                ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
+                  (baseFirst = pendingQueue))
+                : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
+              (currentlyRenderingFiber.lanes |= updateLane),
+              (workInProgressRootSkippedLanes |= updateLane);
+          update = update.next;
+        } while (null !== update && update !== current);
+        null === newBaseQueueLast
+          ? (baseFirst = pendingQueue)
+          : (newBaseQueueLast.next = newBaseQueueFirst);
+        if (
+          !objectIs(pendingQueue, hook.memoizedState) &&
+          ((didReceiveUpdate = !0),
+          didReadFromEntangledAsyncAction &&
+            ((reducer = currentEntangledActionThenable), null !== reducer))
+        )
+          throw reducer;
+        hook.memoizedState = pendingQueue;
+        hook.baseState = baseFirst;
+        hook.baseQueue = newBaseQueueLast;
+        queue.lastRenderedState = pendingQueue;
+      }
+      null === baseQueue && (queue.lanes = 0);
+      return [hook.memoizedState, queue.dispatch];
+    }
+    function rerenderReducer(reducer) {
+      var hook = updateWorkInProgressHook(),
+        queue = hook.queue;
+      if (null === queue)
+        throw Error(
+          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
+        );
+      queue.lastRenderedReducer = reducer;
+      var dispatch = queue.dispatch,
+        lastRenderPhaseUpdate = queue.pending,
+        newState = hook.memoizedState;
+      if (null !== lastRenderPhaseUpdate) {
+        queue.pending = null;
+        var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
+        do
+          (newState = reducer(newState, update.action)), (update = update.next);
+        while (update !== lastRenderPhaseUpdate);
+        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
+        hook.memoizedState = newState;
+        null === hook.baseQueue && (hook.baseState = newState);
+        queue.lastRenderedState = newState;
+      }
+      return [newState, dispatch];
+    }
+    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
+      var fiber = currentlyRenderingFiber,
+        hook = mountWorkInProgressHook();
+      if (isHydrating) {
+        if (void 0 === getServerSnapshot)
+          throw Error(
+            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
+          );
+        var nextSnapshot = getServerSnapshot();
+        didWarnUncachedGetSnapshot ||
+          nextSnapshot === getServerSnapshot() ||
+          (console.error(
+            "The result of getServerSnapshot should be cached to avoid an infinite loop"
+          ),
+          (didWarnUncachedGetSnapshot = !0));
+      } else {
+        nextSnapshot = getSnapshot();
+        didWarnUncachedGetSnapshot ||
+          ((getServerSnapshot = getSnapshot()),
+          objectIs(nextSnapshot, getServerSnapshot) ||
+            (console.error(
+              "The result of getSnapshot should be cached to avoid an infinite loop"
+            ),
+            (didWarnUncachedGetSnapshot = !0)));
+        if (null === workInProgressRoot)
+          throw Error(
+            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
+          );
+        0 !== (workInProgressRootRenderLanes & 60) ||
+          pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
+      }
+      hook.memoizedState = nextSnapshot;
+      getServerSnapshot = { value: nextSnapshot, getSnapshot: getSnapshot };
+      hook.queue = getServerSnapshot;
+      mountEffect(
+        subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
+        [subscribe]
+      );
+      fiber.flags |= 2048;
+      pushSimpleEffect(
+        HasEffect | Passive,
+        createEffectInstance(),
+        updateStoreInstance.bind(
+          null,
+          fiber,
+          getServerSnapshot,
+          nextSnapshot,
+          getSnapshot
+        ),
+        null
+      );
+      return nextSnapshot;
+    }
+    function updateSyncExternalStore(
+      subscribe,
+      getSnapshot,
+      getServerSnapshot
+    ) {
+      var fiber = currentlyRenderingFiber,
+        hook = updateWorkInProgressHook(),
+        isHydrating$jscomp$0 = isHydrating;
+      if (isHydrating$jscomp$0) {
+        if (void 0 === getServerSnapshot)
+          throw Error(
+            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
+          );
+        getServerSnapshot = getServerSnapshot();
+      } else if (
+        ((getServerSnapshot = getSnapshot()), !didWarnUncachedGetSnapshot)
+      ) {
+        var cachedSnapshot = getSnapshot();
+        objectIs(getServerSnapshot, cachedSnapshot) ||
+          (console.error(
+            "The result of getSnapshot should be cached to avoid an infinite loop"
+          ),
+          (didWarnUncachedGetSnapshot = !0));
+      }
+      if (
+        (cachedSnapshot = !objectIs(
+          (currentHook || hook).memoizedState,
+          getServerSnapshot
+        ))
+      )
+        (hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0);
+      hook = hook.queue;
+      var create = subscribeToStore.bind(null, fiber, hook, subscribe);
+      updateEffectImpl(2048, Passive, create, [subscribe]);
+      if (
+        hook.getSnapshot !== getSnapshot ||
+        cachedSnapshot ||
+        (null !== workInProgressHook &&
+          workInProgressHook.memoizedState.tag & HasEffect)
+      ) {
+        fiber.flags |= 2048;
+        pushSimpleEffect(
+          HasEffect | Passive,
+          createEffectInstance(),
+          updateStoreInstance.bind(
+            null,
+            fiber,
+            hook,
+            getServerSnapshot,
+            getSnapshot
+          ),
+          null
+        );
+        if (null === workInProgressRoot)
+          throw Error(
+            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
+          );
+        isHydrating$jscomp$0 ||
+          0 !== (renderLanes & 60) ||
+          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
+      }
+      return getServerSnapshot;
+    }
+    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
+      fiber.flags |= 16384;
+      fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
+      getSnapshot = currentlyRenderingFiber.updateQueue;
+      null === getSnapshot
+        ? ((getSnapshot = createFunctionComponentUpdateQueue()),
+          (currentlyRenderingFiber.updateQueue = getSnapshot),
+          (getSnapshot.stores = [fiber]))
+        : ((renderedSnapshot = getSnapshot.stores),
+          null === renderedSnapshot
+            ? (getSnapshot.stores = [fiber])
+            : renderedSnapshot.push(fiber));
+    }
+    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
+      inst.value = nextSnapshot;
+      inst.getSnapshot = getSnapshot;
+      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
+    }
+    function subscribeToStore(fiber, inst, subscribe) {
+      return subscribe(function () {
+        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
+      });
+    }
+    function checkIfSnapshotChanged(inst) {
+      var latestGetSnapshot = inst.getSnapshot;
+      inst = inst.value;
+      try {
+        var nextValue = latestGetSnapshot();
+        return !objectIs(inst, nextValue);
+      } catch (error) {
+        return !0;
+      }
+    }
+    function forceStoreRerender(fiber) {
+      var root = enqueueConcurrentRenderForLane(fiber, 2);
+      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
+    }
+    function mountStateImpl(initialState) {
+      var hook = mountWorkInProgressHook();
+      if ("function" === typeof initialState) {
+        var initialStateInitializer = initialState;
+        initialState = initialStateInitializer();
+        if (shouldDoubleInvokeUserFnsInHooksDEV) {
+          setIsStrictModeForDevtools(!0);
+          try {
+            initialStateInitializer();
+          } finally {
+            setIsStrictModeForDevtools(!1);
+          }
+        }
+      }
+      hook.memoizedState = hook.baseState = initialState;
+      hook.queue = {
+        pending: null,
+        lanes: 0,
+        dispatch: null,
+        lastRenderedReducer: basicStateReducer,
+        lastRenderedState: initialState
+      };
+      return hook;
+    }
+    function mountState(initialState) {
+      initialState = mountStateImpl(initialState);
+      var queue = initialState.queue,
+        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
+      queue.dispatch = dispatch;
+      return [initialState.memoizedState, dispatch];
+    }
+    function mountOptimistic(passthrough) {
+      var hook = mountWorkInProgressHook();
+      hook.memoizedState = hook.baseState = passthrough;
+      var queue = {
+        pending: null,
+        lanes: 0,
+        dispatch: null,
+        lastRenderedReducer: null,
+        lastRenderedState: null
+      };
+      hook.queue = queue;
+      hook = dispatchOptimisticSetState.bind(
+        null,
+        currentlyRenderingFiber,
+        !0,
+        queue
+      );
+      queue.dispatch = hook;
+      return [passthrough, hook];
+    }
+    function updateOptimistic(passthrough, reducer) {
+      var hook = updateWorkInProgressHook();
+      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
+    }
+    function updateOptimisticImpl(hook, current, passthrough, reducer) {
+      hook.baseState = passthrough;
+      return updateReducerImpl(
+        hook,
+        currentHook,
+        "function" === typeof reducer ? reducer : basicStateReducer
+      );
+    }
+    function rerenderOptimistic(passthrough, reducer) {
+      var hook = updateWorkInProgressHook();
+      if (null !== currentHook)
+        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
+      hook.baseState = passthrough;
+      return [passthrough, hook.queue.dispatch];
+    }
+    function dispatchActionState(
+      fiber,
+      actionQueue,
+      setPendingState,
+      setState,
+      payload
+    ) {
+      if (isRenderPhaseUpdate(fiber))
+        throw Error("Cannot update form state while rendering.");
+      fiber = actionQueue.action;
+      if (null !== fiber) {
+        var actionNode = {
+          payload: payload,
+          action: fiber,
+          next: null,
+          isTransition: !0,
+          status: "pending",
+          value: null,
+          reason: null,
+          listeners: [],
+          then: function (listener) {
+            actionNode.listeners.push(listener);
+          }
+        };
+        null !== ReactSharedInternals.T
+          ? setPendingState(!0)
+          : (actionNode.isTransition = !1);
+        setState(actionNode);
+        setPendingState = actionQueue.pending;
+        null === setPendingState
+          ? ((actionNode.next = actionQueue.pending = actionNode),
+            runActionStateAction(actionQueue, actionNode))
+          : ((actionNode.next = setPendingState.next),
+            (actionQueue.pending = setPendingState.next = actionNode));
+      }
+    }
+    function runActionStateAction(actionQueue, node) {
+      var action = node.action,
+        payload = node.payload,
+        prevState = actionQueue.state;
+      if (node.isTransition) {
+        var prevTransition = ReactSharedInternals.T,
+          currentTransition = {};
+        ReactSharedInternals.T = currentTransition;
+        ReactSharedInternals.T._updatedFibers = new Set();
+        try {
+          var returnValue = action(prevState, payload),
+            onStartTransitionFinish = ReactSharedInternals.S;
+          null !== onStartTransitionFinish &&
+            onStartTransitionFinish(currentTransition, returnValue);
+          handleActionReturnValue(actionQueue, node, returnValue);
+        } catch (error) {
+          onActionError(actionQueue, node, error);
+        } finally {
+          (ReactSharedInternals.T = prevTransition),
+            null === prevTransition &&
+              currentTransition._updatedFibers &&
+              ((actionQueue = currentTransition._updatedFibers.size),
+              currentTransition._updatedFibers.clear(),
+              10 < actionQueue &&
+                console.warn(
+                  "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
+                ));
+        }
+      } else
+        try {
+          (currentTransition = action(prevState, payload)),
+            handleActionReturnValue(actionQueue, node, currentTransition);
+        } catch (error$3) {
+          onActionError(actionQueue, node, error$3);
+        }
+    }
+    function handleActionReturnValue(actionQueue, node, returnValue) {
+      null !== returnValue &&
+      "object" === typeof returnValue &&
+      "function" === typeof returnValue.then
+        ? (returnValue.then(
+            function (nextState) {
+              onActionSuccess(actionQueue, node, nextState);
+            },
+            function (error) {
+              return onActionError(actionQueue, node, error);
+            }
+          ),
+          node.isTransition ||
+            console.error(
+              "An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`"
+            ))
+        : onActionSuccess(actionQueue, node, returnValue);
+    }
+    function onActionSuccess(actionQueue, actionNode, nextState) {
+      actionNode.status = "fulfilled";
+      actionNode.value = nextState;
+      notifyActionListeners(actionNode);
+      actionQueue.state = nextState;
+      actionNode = actionQueue.pending;
+      null !== actionNode &&
+        ((nextState = actionNode.next),
+        nextState === actionNode
+          ? (actionQueue.pending = null)
+          : ((nextState = nextState.next),
+            (actionNode.next = nextState),
+            runActionStateAction(actionQueue, nextState)));
+    }
+    function onActionError(actionQueue, actionNode, error) {
+      var last = actionQueue.pending;
+      actionQueue.pending = null;
+      if (null !== last) {
+        last = last.next;
+        do
+          (actionNode.status = "rejected"),
+            (actionNode.reason = error),
+            notifyActionListeners(actionNode),
+            (actionNode = actionNode.next);
+        while (actionNode !== last);
+      }
+      actionQueue.action = null;
+    }
+    function notifyActionListeners(actionNode) {
+      actionNode = actionNode.listeners;
+      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
+    }
+    function actionStateReducer(oldState, newState) {
+      return newState;
+    }
+    function mountActionState(action, initialStateProp) {
+      if (isHydrating) {
+        var ssrFormState = workInProgressRoot.formState;
+        if (null !== ssrFormState) {
+          a: {
+            var isMatching = currentlyRenderingFiber;
+            if (isHydrating) {
+              if (nextHydratableInstance) {
+                b: {
+                  var markerInstance = nextHydratableInstance;
+                  for (
+                    var inRootOrSingleton = rootOrSingletonContext;
+                    8 !== markerInstance.nodeType;
+
+                  ) {
+                    if (!inRootOrSingleton) {
+                      markerInstance = null;
+                      break b;
+                    }
+                    markerInstance = getNextHydratable(
+                      markerInstance.nextSibling
+                    );
+                    if (null === markerInstance) {
+                      markerInstance = null;
+                      break b;
+                    }
+                  }
+                  inRootOrSingleton = markerInstance.data;
+                  markerInstance =
+                    inRootOrSingleton === FORM_STATE_IS_MATCHING ||
+                    inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING
+                      ? markerInstance
+                      : null;
+                }
+                if (markerInstance) {
+                  nextHydratableInstance = getNextHydratable(
+                    markerInstance.nextSibling
+                  );
+                  isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
+                  break a;
+                }
+              }
+              throwOnHydrationMismatch(isMatching);
+            }
+            isMatching = !1;
+          }
+          isMatching && (initialStateProp = ssrFormState[0]);
+        }
+      }
+      ssrFormState = mountWorkInProgressHook();
+      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
+      isMatching = {
+        pending: null,
+        lanes: 0,
+        dispatch: null,
+        lastRenderedReducer: actionStateReducer,
+        lastRenderedState: initialStateProp
+      };
+      ssrFormState.queue = isMatching;
+      ssrFormState = dispatchSetState.bind(
+        null,
+        currentlyRenderingFiber,
+        isMatching
+      );
+      isMatching.dispatch = ssrFormState;
+      isMatching = mountStateImpl(!1);
+      inRootOrSingleton = dispatchOptimisticSetState.bind(
+        null,
+        currentlyRenderingFiber,
+        !1,
+        isMatching.queue
+      );
+      isMatching = mountWorkInProgressHook();
+      markerInstance = {
+        state: initialStateProp,
+        dispatch: null,
+        action: action,
+        pending: null
+      };
+      isMatching.queue = markerInstance;
+      ssrFormState = dispatchActionState.bind(
+        null,
+        currentlyRenderingFiber,
+        markerInstance,
+        inRootOrSingleton,
+        ssrFormState
+      );
+      markerInstance.dispatch = ssrFormState;
+      isMatching.memoizedState = action;
+      return [initialStateProp, ssrFormState, !1];
+    }
+    function updateActionState(action) {
+      var stateHook = updateWorkInProgressHook();
+      return updateActionStateImpl(stateHook, currentHook, action);
+    }
+    function updateActionStateImpl(stateHook, currentStateHook, action) {
+      currentStateHook = updateReducerImpl(
+        stateHook,
+        currentStateHook,
+        actionStateReducer
+      )[0];
+      stateHook = updateReducer(basicStateReducer)[0];
+      if (
+        "object" === typeof currentStateHook &&
+        null !== currentStateHook &&
+        "function" === typeof currentStateHook.then
+      )
+        try {
+          var state = useThenable(currentStateHook);
+        } catch (x) {
+          if (x === SuspenseException) throw SuspenseActionException;
+          throw x;
+        }
+      else state = currentStateHook;
+      currentStateHook = updateWorkInProgressHook();
+      var actionQueue = currentStateHook.queue,
+        dispatch = actionQueue.dispatch;
+      action !== currentStateHook.memoizedState &&
+        ((currentlyRenderingFiber.flags |= 2048),
+        pushSimpleEffect(
+          HasEffect | Passive,
+          createEffectInstance(),
+          actionStateActionEffect.bind(null, actionQueue, action),
+          null
+        ));
+      return [state, dispatch, stateHook];
+    }
+    function actionStateActionEffect(actionQueue, action) {
+      actionQueue.action = action;
+    }
+    function rerenderActionState(action) {
+      var stateHook = updateWorkInProgressHook(),
+        currentStateHook = currentHook;
+      if (null !== currentStateHook)
+        return updateActionStateImpl(stateHook, currentStateHook, action);
+      updateWorkInProgressHook();
+      stateHook = stateHook.memoizedState;
+      currentStateHook = updateWorkInProgressHook();
+      var dispatch = currentStateHook.queue.dispatch;
+      currentStateHook.memoizedState = action;
+      return [stateHook, dispatch, !1];
+    }
+    function pushSimpleEffect(tag, inst, create, deps) {
+      tag = { tag: tag, create: create, deps: deps, inst: inst, next: null };
+      inst = currentlyRenderingFiber.updateQueue;
+      null === inst &&
+        ((inst = createFunctionComponentUpdateQueue()),
+        (currentlyRenderingFiber.updateQueue = inst));
+      create = inst.lastEffect;
+      null === create
+        ? (inst.lastEffect = tag.next = tag)
+        : ((deps = create.next),
+          (create.next = tag),
+          (tag.next = deps),
+          (inst.lastEffect = tag));
+      return tag;
+    }
+    function createEffectInstance() {
+      return { destroy: void 0, resource: void 0 };
+    }
+    function mountRef(initialValue) {
+      var hook = mountWorkInProgressHook();
+      initialValue = { current: initialValue };
+      return (hook.memoizedState = initialValue);
+    }
+    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
+      var hook = mountWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      currentlyRenderingFiber.flags |= fiberFlags;
+      hook.memoizedState = pushSimpleEffect(
+        HasEffect | hookFlags,
+        createEffectInstance(),
+        create,
+        deps
+      );
+    }
+    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
+      var hook = updateWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var inst = hook.memoizedState.inst;
+      null !== currentHook &&
+      null !== deps &&
+      areHookInputsEqual(deps, currentHook.memoizedState.deps)
+        ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
+        : ((currentlyRenderingFiber.flags |= fiberFlags),
+          (hook.memoizedState = pushSimpleEffect(
+            HasEffect | hookFlags,
+            inst,
+            create,
+            deps
+          )));
+    }
+    function mountEffect(create, deps) {
+      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode &&
+      (currentlyRenderingFiber.mode & NoStrictPassiveEffectsMode) === NoMode
+        ? mountEffectImpl(276826112, Passive, create, deps)
+        : mountEffectImpl(8390656, Passive, create, deps);
+    }
+    function useEffectEventImpl(payload) {
+      currentlyRenderingFiber.flags |= 4;
+      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
+      if (null === componentUpdateQueue)
+        (componentUpdateQueue = createFunctionComponentUpdateQueue()),
+          (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
+          (componentUpdateQueue.events = [payload]);
+      else {
+        var events = componentUpdateQueue.events;
+        null === events
+          ? (componentUpdateQueue.events = [payload])
+          : events.push(payload);
+      }
+    }
+    function mountEvent(callback) {
+      var hook = mountWorkInProgressHook(),
+        ref = { impl: callback };
+      hook.memoizedState = ref;
+      return function () {
+        if ((executionContext & RenderContext) !== NoContext)
+          throw Error(
+            "A function wrapped in useEffectEvent can't be called during rendering."
+          );
+        return ref.impl.apply(void 0, arguments);
+      };
+    }
+    function updateEvent(callback) {
+      var ref = updateWorkInProgressHook().memoizedState;
+      useEffectEventImpl({ ref: ref, nextImpl: callback });
+      return function () {
+        if ((executionContext & RenderContext) !== NoContext)
+          throw Error(
+            "A function wrapped in useEffectEvent can't be called during rendering."
+          );
+        return ref.impl.apply(void 0, arguments);
+      };
+    }
+    function mountLayoutEffect(create, deps) {
+      var fiberFlags = 4194308;
+      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode &&
+        (fiberFlags |= 134217728);
+      return mountEffectImpl(fiberFlags, Layout, create, deps);
+    }
+    function imperativeHandleEffect(create, ref) {
+      if ("function" === typeof ref) {
+        create = create();
+        var refCleanup = ref(create);
+        return function () {
+          "function" === typeof refCleanup ? refCleanup() : ref(null);
+        };
+      }
+      if (null !== ref && void 0 !== ref)
+        return (
+          ref.hasOwnProperty("current") ||
+            console.error(
+              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
+              "an object with keys {" + Object.keys(ref).join(", ") + "}"
+            ),
+          (create = create()),
+          (ref.current = create),
+          function () {
+            ref.current = null;
+          }
+        );
+    }
+    function mountImperativeHandle(ref, create, deps) {
+      "function" !== typeof create &&
+        console.error(
+          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
+          null !== create ? typeof create : "null"
+        );
+      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
+      var fiberFlags = 4194308;
+      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode &&
+        (fiberFlags |= 134217728);
+      mountEffectImpl(
+        fiberFlags,
+        Layout,
+        imperativeHandleEffect.bind(null, create, ref),
+        deps
+      );
+    }
+    function updateImperativeHandle(ref, create, deps) {
+      "function" !== typeof create &&
+        console.error(
+          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
+          null !== create ? typeof create : "null"
+        );
+      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
+      updateEffectImpl(
+        4,
+        Layout,
+        imperativeHandleEffect.bind(null, create, ref),
+        deps
+      );
+    }
+    function mountCallback(callback, deps) {
+      mountWorkInProgressHook().memoizedState = [
+        callback,
+        void 0 === deps ? null : deps
+      ];
+      return callback;
+    }
+    function updateCallback(callback, deps) {
+      var hook = updateWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var prevState = hook.memoizedState;
+      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
+        return prevState[0];
+      hook.memoizedState = [callback, deps];
+      return callback;
+    }
+    function mountMemo(nextCreate, deps) {
+      var hook = mountWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var nextValue = nextCreate();
+      if (shouldDoubleInvokeUserFnsInHooksDEV) {
+        setIsStrictModeForDevtools(!0);
+        try {
+          nextCreate();
+        } finally {
+          setIsStrictModeForDevtools(!1);
+        }
+      }
+      hook.memoizedState = [nextValue, deps];
+      return nextValue;
+    }
+    function updateMemo(nextCreate, deps) {
+      var hook = updateWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var prevState = hook.memoizedState;
+      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
+        return prevState[0];
+      prevState = nextCreate();
+      if (shouldDoubleInvokeUserFnsInHooksDEV) {
+        setIsStrictModeForDevtools(!0);
+        try {
+          nextCreate();
+        } finally {
+          setIsStrictModeForDevtools(!1);
+        }
+      }
+      hook.memoizedState = [prevState, deps];
+      return prevState;
+    }
+    function mountDeferredValue(value, initialValue) {
+      var hook = mountWorkInProgressHook();
+      return mountDeferredValueImpl(hook, value, initialValue);
+    }
+    function updateDeferredValue(value, initialValue) {
+      var hook = updateWorkInProgressHook();
+      return updateDeferredValueImpl(
+        hook,
+        currentHook.memoizedState,
+        value,
+        initialValue
+      );
+    }
+    function rerenderDeferredValue(value, initialValue) {
+      var hook = updateWorkInProgressHook();
+      return null === currentHook
+        ? mountDeferredValueImpl(hook, value, initialValue)
+        : updateDeferredValueImpl(
+            hook,
+            currentHook.memoizedState,
+            value,
+            initialValue
+          );
+    }
+    function mountDeferredValueImpl(hook, value, initialValue) {
+      if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
+        return (hook.memoizedState = value);
+      hook.memoizedState = initialValue;
+      hook = requestDeferredLane();
+      currentlyRenderingFiber.lanes |= hook;
+      workInProgressRootSkippedLanes |= hook;
+      return initialValue;
+    }
+    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
+      if (objectIs(value, prevValue)) return value;
+      if (null !== currentTreeHiddenStackCursor.current)
+        return (
+          (hook = mountDeferredValueImpl(hook, value, initialValue)),
+          objectIs(hook, prevValue) || (didReceiveUpdate = !0),
+          hook
+        );
+      if (0 === (renderLanes & 42))
+        return (didReceiveUpdate = !0), (hook.memoizedState = value);
+      hook = requestDeferredLane();
+      currentlyRenderingFiber.lanes |= hook;
+      workInProgressRootSkippedLanes |= hook;
+      return prevValue;
+    }
+    function startTransition(
+      fiber,
+      queue,
+      pendingState,
+      finishedState,
+      callback
+    ) {
+      var previousPriority = ReactDOMSharedInternals.p;
+      ReactDOMSharedInternals.p =
+        0 !== previousPriority && previousPriority < ContinuousEventPriority
+          ? previousPriority
+          : ContinuousEventPriority;
+      var prevTransition = ReactSharedInternals.T,
+        currentTransition = {};
+      ReactSharedInternals.T = currentTransition;
+      dispatchOptimisticSetState(fiber, !1, queue, pendingState);
+      currentTransition._updatedFibers = new Set();
+      try {
+        var returnValue = callback(),
+          onStartTransitionFinish = ReactSharedInternals.S;
+        null !== onStartTransitionFinish &&
+          onStartTransitionFinish(currentTransition, returnValue);
+        if (
+          null !== returnValue &&
+          "object" === typeof returnValue &&
+          "function" === typeof returnValue.then
+        ) {
+          var thenableForFinishedState = chainThenableValue(
+            returnValue,
+            finishedState
+          );
+          dispatchSetStateInternal(
+            fiber,
+            queue,
+            thenableForFinishedState,
+            requestUpdateLane(fiber)
+          );
+        } else
+          dispatchSetStateInternal(
+            fiber,
+            queue,
+            finishedState,
+            requestUpdateLane(fiber)
+          );
+      } catch (error) {
+        dispatchSetStateInternal(
+          fiber,
+          queue,
+          { then: function () {}, status: "rejected", reason: error },
+          requestUpdateLane(fiber)
+        );
+      } finally {
+        (ReactDOMSharedInternals.p = previousPriority),
+          (ReactSharedInternals.T = prevTransition),
+          null === prevTransition &&
+            currentTransition._updatedFibers &&
+            ((fiber = currentTransition._updatedFibers.size),
+            currentTransition._updatedFibers.clear(),
+            10 < fiber &&
+              console.warn(
+                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
+              ));
+      }
+    }
+    function startHostTransition(formFiber, pendingState, action, formData) {
+      if (5 !== formFiber.tag)
+        throw Error(
+          "Expected the form instance to be a HostComponent. This is a bug in React."
+        );
+      var queue = ensureFormComponentIsStateful(formFiber).queue;
+      startTransition(
+        formFiber,
+        queue,
+        pendingState,
+        NotPendingTransition,
+        null === action
+          ? noop$2
+          : function () {
+              requestFormReset$1(formFiber);
+              return action(formData);
+            }
+      );
+    }
+    function ensureFormComponentIsStateful(formFiber) {
+      var existingStateHook = formFiber.memoizedState;
+      if (null !== existingStateHook) return existingStateHook;
+      existingStateHook = {
+        memoizedState: NotPendingTransition,
+        baseState: NotPendingTransition,
+        baseQueue: null,
+        queue: {
+          pending: null,
+          lanes: 0,
+          dispatch: null,
+          lastRenderedReducer: basicStateReducer,
+          lastRenderedState: NotPendingTransition
+        },
+        next: null
+      };
+      var initialResetState = {};
+      existingStateHook.next = {
+        memoizedState: initialResetState,
+        baseState: initialResetState,
+        baseQueue: null,
+        queue: {
+          pending: null,
+          lanes: 0,
+          dispatch: null,
+          lastRenderedReducer: basicStateReducer,
+          lastRenderedState: initialResetState
+        },
+        next: null
+      };
+      formFiber.memoizedState = existingStateHook;
+      formFiber = formFiber.alternate;
+      null !== formFiber && (formFiber.memoizedState = existingStateHook);
+      return existingStateHook;
+    }
+    function requestFormReset$1(formFiber) {
+      null === ReactSharedInternals.T &&
+        console.error(
+          "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
+        );
+      var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
+      dispatchSetStateInternal(
+        formFiber,
+        resetStateQueue,
+        {},
+        requestUpdateLane(formFiber)
+      );
+    }
+    function mountTransition() {
+      var stateHook = mountStateImpl(!1);
+      stateHook = startTransition.bind(
+        null,
+        currentlyRenderingFiber,
+        stateHook.queue,
+        !0,
+        !1
+      );
+      mountWorkInProgressHook().memoizedState = stateHook;
+      return [!1, stateHook];
+    }
+    function updateTransition() {
+      var booleanOrThenable = updateReducer(basicStateReducer)[0],
+        start = updateWorkInProgressHook().memoizedState;
+      return [
+        "boolean" === typeof booleanOrThenable
+          ? booleanOrThenable
+          : useThenable(booleanOrThenable),
+        start
+      ];
+    }
+    function rerenderTransition() {
+      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
+        start = updateWorkInProgressHook().memoizedState;
+      return [
+        "boolean" === typeof booleanOrThenable
+          ? booleanOrThenable
+          : useThenable(booleanOrThenable),
+        start
+      ];
+    }
+    function useHostTransitionStatus() {
+      return readContext(HostTransitionContext);
+    }
+    function mountId() {
+      var hook = mountWorkInProgressHook(),
+        identifierPrefix = workInProgressRoot.identifierPrefix;
+      if (isHydrating) {
+        var treeId = getTreeId();
+        identifierPrefix = ":" + identifierPrefix + "R" + treeId;
+        treeId = localIdCounter++;
+        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
+        identifierPrefix += ":";
+      } else
+        (treeId = globalClientIdCounter$1++),
+          (identifierPrefix =
+            ":" + identifierPrefix + "r" + treeId.toString(32) + ":");
+      return (hook.memoizedState = identifierPrefix);
+    }
+    function mountRefresh() {
+      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
+        null,
+        currentlyRenderingFiber
+      ));
+    }
+    function refreshCache(fiber, seedKey, seedValue) {
+      for (var provider = fiber.return; null !== provider; ) {
+        switch (provider.tag) {
+          case 24:
+          case 3:
+            var lane = requestUpdateLane(provider);
+            fiber = createUpdate(lane);
+            var root = enqueueUpdate(provider, fiber, lane);
+            null !== root &&
+              (startUpdateTimerByLane(lane),
+              scheduleUpdateOnFiber(root, provider, lane),
+              entangleTransitions(root, provider, lane));
+            provider = createCache();
+            null !== seedKey &&
+              void 0 !== seedKey &&
+              null !== root &&
+              provider.data.set(seedKey, seedValue);
+            fiber.payload = { cache: provider };
+            return;
+        }
+        provider = provider.return;
+      }
+    }
+    function dispatchReducerAction(fiber, queue, action) {
+      var args = arguments;
+      "function" === typeof args[3] &&
+        console.error(
+          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
+        );
+      args = requestUpdateLane(fiber);
+      var update = {
+        lane: args,
+        revertLane: 0,
+        action: action,
+        hasEagerState: !1,
+        eagerState: null,
+        next: null
+      };
+      isRenderPhaseUpdate(fiber)
+        ? enqueueRenderPhaseUpdate(queue, update)
+        : ((update = enqueueConcurrentHookUpdate(fiber, queue, update, args)),
+          null !== update &&
+            (startUpdateTimerByLane(args),
+            scheduleUpdateOnFiber(update, fiber, args),
+            entangleTransitionUpdate(update, queue, args)));
+    }
+    function dispatchSetState(fiber, queue, action) {
+      var args = arguments;
+      "function" === typeof args[3] &&
+        console.error(
+          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
+        );
+      args = requestUpdateLane(fiber);
+      dispatchSetStateInternal(fiber, queue, action, args) &&
+        startUpdateTimerByLane(args);
+    }
+    function dispatchSetStateInternal(fiber, queue, action, lane) {
+      var update = {
+        lane: lane,
+        revertLane: 0,
+        action: action,
+        hasEagerState: !1,
+        eagerState: null,
+        next: null
+      };
+      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
+      else {
+        var alternate = fiber.alternate;
+        if (
+          0 === fiber.lanes &&
+          (null === alternate || 0 === alternate.lanes) &&
+          ((alternate = queue.lastRenderedReducer), null !== alternate)
+        ) {
+          var prevDispatcher = ReactSharedInternals.H;
+          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
+          try {
+            var currentState = queue.lastRenderedState,
+              eagerState = alternate(currentState, action);
+            update.hasEagerState = !0;
+            update.eagerState = eagerState;
+            if (objectIs(eagerState, currentState))
+              return (
+                enqueueUpdate$1(fiber, queue, update, 0),
+                null === workInProgressRoot &&
+                  finishQueueingConcurrentUpdates(),
+                !1
+              );
+          } catch (error) {
+          } finally {
+            ReactSharedInternals.H = prevDispatcher;
+          }
+        }
+        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
+        if (null !== action)
+          return (
+            scheduleUpdateOnFiber(action, fiber, lane),
+            entangleTransitionUpdate(action, queue, lane),
+            !0
+          );
+      }
+      return !1;
+    }
+    function dispatchOptimisticSetState(
+      fiber,
+      throwIfDuringRender,
+      queue,
+      action
+    ) {
+      null === ReactSharedInternals.T &&
+        0 === currentEntangledLane &&
+        console.error(
+          "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
+        );
+      action = {
+        lane: 2,
+        revertLane: requestTransitionLane(),
+        action: action,
+        hasEagerState: !1,
+        eagerState: null,
+        next: null
+      };
+      if (isRenderPhaseUpdate(fiber)) {
+        if (throwIfDuringRender)
+          throw Error("Cannot update optimistic state while rendering.");
+        console.error("Cannot call startTransition while rendering.");
+      } else
+        (throwIfDuringRender = enqueueConcurrentHookUpdate(
+          fiber,
+          queue,
+          action,
+          2
+        )),
+          null !== throwIfDuringRender &&
+            (startUpdateTimerByLane(2),
+            scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
+    }
+    function isRenderPhaseUpdate(fiber) {
+      var alternate = fiber.alternate;
+      return (
+        fiber === currentlyRenderingFiber ||
+        (null !== alternate && alternate === currentlyRenderingFiber)
+      );
+    }
+    function enqueueRenderPhaseUpdate(queue, update) {
+      didScheduleRenderPhaseUpdateDuringThisPass =
+        didScheduleRenderPhaseUpdate = !0;
+      var pending = queue.pending;
+      null === pending
+        ? (update.next = update)
+        : ((update.next = pending.next), (pending.next = update));
+      queue.pending = update;
+    }
+    function entangleTransitionUpdate(root, queue, lane) {
+      if (0 !== (lane & 4194176)) {
+        var queueLanes = queue.lanes;
+        queueLanes &= root.pendingLanes;
+        lane |= queueLanes;
+        queue.lanes = lane;
+        markRootEntangled(root, lane);
+      }
+    }
+    function pushDebugInfo(debugInfo) {
+      var previousDebugInfo = currentDebugInfo;
+      null != debugInfo &&
+        (currentDebugInfo =
+          null === previousDebugInfo
+            ? debugInfo
+            : previousDebugInfo.concat(debugInfo));
+      return previousDebugInfo;
+    }
+    function validateFragmentProps(element, fiber, returnFiber) {
+      for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
+        var key = keys[i];
+        if ("children" !== key && "key" !== key) {
+          null === fiber &&
+            ((fiber = createFiberFromElement(element, returnFiber.mode, 0)),
+            (fiber._debugInfo = currentDebugInfo),
+            (fiber.return = returnFiber));
+          runWithFiberInDEV(
+            fiber,
+            function (erroredKey) {
+              console.error(
+                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
+                erroredKey
+              );
+            },
+            key
+          );
+          break;
+        }
+      }
+    }
+    function unwrapThenable(thenable) {
+      var index = thenableIndexCounter;
+      thenableIndexCounter += 1;
+      null === thenableState && (thenableState = createThenableState());
+      return trackUsedThenable(thenableState, thenable, index);
+    }
+    function coerceRef(workInProgress, element) {
+      element = element.props.ref;
+      workInProgress.ref = void 0 !== element ? element : null;
+    }
+    function throwOnInvalidObjectType(returnFiber, newChild) {
+      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
+        throw Error(
+          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
+        );
+      returnFiber = Object.prototype.toString.call(newChild);
+      throw Error(
+        "Objects are not valid as a React child (found: " +
+          ("[object Object]" === returnFiber
+            ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
+            : returnFiber) +
+          "). If you meant to render a collection of children, use an array instead."
+      );
+    }
+    function warnOnFunctionType(returnFiber, invalidChild) {
+      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
+      ownerHasFunctionTypeWarning[parentName] ||
+        ((ownerHasFunctionTypeWarning[parentName] = !0),
+        (invalidChild =
+          invalidChild.displayName || invalidChild.name || "Component"),
+        3 === returnFiber.tag
+          ? console.error(
+              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
+              invalidChild,
+              invalidChild,
+              invalidChild
+            )
+          : console.error(
+              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
+              invalidChild,
+              invalidChild,
+              parentName,
+              invalidChild,
+              parentName
+            ));
+    }
+    function warnOnSymbolType(returnFiber, invalidChild) {
+      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
+      ownerHasSymbolTypeWarning[parentName] ||
+        ((ownerHasSymbolTypeWarning[parentName] = !0),
+        (invalidChild = String(invalidChild)),
+        3 === returnFiber.tag
+          ? console.error(
+              "Symbols are not valid as a React child.\n  root.render(%s)",
+              invalidChild
+            )
+          : console.error(
+              "Symbols are not valid as a React child.\n  <%s>%s</%s>",
+              parentName,
+              invalidChild,
+              parentName
+            ));
+    }
+    function createChildReconciler(shouldTrackSideEffects) {
+      function deleteChild(returnFiber, childToDelete) {
+        if (shouldTrackSideEffects) {
+          var deletions = returnFiber.deletions;
+          null === deletions
+            ? ((returnFiber.deletions = [childToDelete]),
+              (returnFiber.flags |= 16))
+            : deletions.push(childToDelete);
+        }
+      }
+      function deleteRemainingChildren(returnFiber, currentFirstChild) {
+        if (!shouldTrackSideEffects) return null;
+        for (; null !== currentFirstChild; )
+          deleteChild(returnFiber, currentFirstChild),
+            (currentFirstChild = currentFirstChild.sibling);
+        return null;
+      }
+      function mapRemainingChildren(currentFirstChild) {
+        for (var existingChildren = new Map(); null !== currentFirstChild; )
+          null !== currentFirstChild.key
+            ? existingChildren.set(currentFirstChild.key, currentFirstChild)
+            : existingChildren.set(currentFirstChild.index, currentFirstChild),
+            (currentFirstChild = currentFirstChild.sibling);
+        return existingChildren;
+      }
+      function useFiber(fiber, pendingProps) {
+        fiber = createWorkInProgress(fiber, pendingProps);
+        fiber.index = 0;
+        fiber.sibling = null;
+        return fiber;
+      }
+      function placeChild(newFiber, lastPlacedIndex, newIndex) {
+        newFiber.index = newIndex;
+        if (!shouldTrackSideEffects)
+          return (newFiber.flags |= 1048576), lastPlacedIndex;
+        newIndex = newFiber.alternate;
+        if (null !== newIndex)
+          return (
+            (newIndex = newIndex.index),
+            newIndex < lastPlacedIndex
+              ? ((newFiber.flags |= 67108866), lastPlacedIndex)
+              : newIndex
+          );
+        newFiber.flags |= 67108866;
+        return lastPlacedIndex;
+      }
+      function placeSingleChild(newFiber) {
+        shouldTrackSideEffects &&
+          null === newFiber.alternate &&
+          (newFiber.flags |= 67108866);
+        return newFiber;
+      }
+      function updateTextNode(returnFiber, current, textContent, lanes) {
+        if (null === current || 6 !== current.tag)
+          return (
+            (current = createFiberFromText(
+              textContent,
+              returnFiber.mode,
+              lanes
+            )),
+            (current.return = returnFiber),
+            (current._debugOwner = returnFiber),
+            (current._debugTask = returnFiber._debugTask),
+            (current._debugInfo = currentDebugInfo),
+            current
+          );
+        current = useFiber(current, textContent);
+        current.return = returnFiber;
+        current._debugInfo = currentDebugInfo;
+        return current;
+      }
+      function updateElement(returnFiber, current, element, lanes) {
+        var elementType = element.type;
+        if (elementType === REACT_FRAGMENT_TYPE)
+          return (
+            (current = updateFragment(
+              returnFiber,
+              current,
+              element.props.children,
+              lanes,
+              element.key
+            )),
+            validateFragmentProps(element, current, returnFiber),
+            current
+          );
+        if (
+          null !== current &&
+          (current.elementType === elementType ||
+            isCompatibleFamilyForHotReloading(current, element) ||
+            ("object" === typeof elementType &&
+              null !== elementType &&
+              elementType.$$typeof === REACT_LAZY_TYPE &&
+              callLazyInitInDEV(elementType) === current.type))
+        )
+          return (
+            (current = useFiber(current, element.props)),
+            coerceRef(current, element),
+            (current.return = returnFiber),
+            (current._debugOwner = element._owner),
+            (current._debugInfo = currentDebugInfo),
+            current
+          );
+        current = createFiberFromElement(element, returnFiber.mode, lanes);
+        coerceRef(current, element);
+        current.return = returnFiber;
+        current._debugInfo = currentDebugInfo;
+        return current;
+      }
+      function updatePortal(returnFiber, current, portal, lanes) {
+        if (
+          null === current ||
+          4 !== current.tag ||
+          current.stateNode.containerInfo !== portal.containerInfo ||
+          current.stateNode.implementation !== portal.implementation
+        )
+          return (
+            (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
+            (current.return = returnFiber),
+            (current._debugInfo = currentDebugInfo),
+            current
+          );
+        current = useFiber(current, portal.children || []);
+        current.return = returnFiber;
+        current._debugInfo = currentDebugInfo;
+        return current;
+      }
+      function updateFragment(returnFiber, current, fragment, lanes, key) {
+        if (null === current || 7 !== current.tag)
+          return (
+            (current = createFiberFromFragment(
+              fragment,
+              returnFiber.mode,
+              lanes,
+              key
+            )),
+            (current.return = returnFiber),
+            (current._debugOwner = returnFiber),
+            (current._debugTask = returnFiber._debugTask),
+            (current._debugInfo = currentDebugInfo),
+            current
+          );
+        current = useFiber(current, fragment);
+        current.return = returnFiber;
+        current._debugInfo = currentDebugInfo;
+        return current;
+      }
+      function createChild(returnFiber, newChild, lanes) {
+        if (
+          ("string" === typeof newChild && "" !== newChild) ||
+          "number" === typeof newChild ||
+          "bigint" === typeof newChild
+        )
+          return (
+            (newChild = createFiberFromText(
+              "" + newChild,
+              returnFiber.mode,
+              lanes
+            )),
+            (newChild.return = returnFiber),
+            (newChild._debugOwner = returnFiber),
+            (newChild._debugTask = returnFiber._debugTask),
+            (newChild._debugInfo = currentDebugInfo),
+            newChild
+          );
+        if ("object" === typeof newChild && null !== newChild) {
+          switch (newChild.$$typeof) {
+            case REACT_ELEMENT_TYPE:
+              return (
+                (lanes = createFiberFromElement(
+                  newChild,
+                  returnFiber.mode,
+                  lanes
+                )),
+                coerceRef(lanes, newChild),
+                (lanes.return = returnFiber),
+                (returnFiber = pushDebugInfo(newChild._debugInfo)),
+                (lanes._debugInfo = currentDebugInfo),
+                (currentDebugInfo = returnFiber),
+                lanes
+              );
+            case REACT_PORTAL_TYPE:
+              return (
+                (newChild = createFiberFromPortal(
+                  newChild,
+                  returnFiber.mode,
+                  lanes
+                )),
+                (newChild.return = returnFiber),
+                (newChild._debugInfo = currentDebugInfo),
+                newChild
+              );
+            case REACT_LAZY_TYPE:
+              var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
+              newChild = callLazyInitInDEV(newChild);
+              returnFiber = createChild(returnFiber, newChild, lanes);
+              currentDebugInfo = _prevDebugInfo;
+              return returnFiber;
+          }
+          if (
+            isArrayImpl(newChild) ||
+            getIteratorFn(newChild) ||
+            "function" === typeof newChild[ASYNC_ITERATOR]
+          )
+            return (
+              (lanes = createFiberFromFragment(
+                newChild,
+                returnFiber.mode,
+                lanes,
+                null
+              )),
+              (lanes.return = returnFiber),
+              (lanes._debugOwner = returnFiber),
+              (lanes._debugTask = returnFiber._debugTask),
+              (returnFiber = pushDebugInfo(newChild._debugInfo)),
+              (lanes._debugInfo = currentDebugInfo),
+              (currentDebugInfo = returnFiber),
+              lanes
+            );
+          if ("function" === typeof newChild.then)
+            return (
+              (_prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
+              (returnFiber = createChild(
+                returnFiber,
+                unwrapThenable(newChild),
+                lanes
+              )),
+              (currentDebugInfo = _prevDebugInfo),
+              returnFiber
+            );
+          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
+            return createChild(
+              returnFiber,
+              readContextDuringReconciliation(returnFiber, newChild),
+              lanes
+            );
+          throwOnInvalidObjectType(returnFiber, newChild);
+        }
+        "function" === typeof newChild &&
+          warnOnFunctionType(returnFiber, newChild);
+        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
+        return null;
+      }
+      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
+        var key = null !== oldFiber ? oldFiber.key : null;
+        if (
+          ("string" === typeof newChild && "" !== newChild) ||
+          "number" === typeof newChild ||
+          "bigint" === typeof newChild
+        )
+          return null !== key
+            ? null
+            : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
+        if ("object" === typeof newChild && null !== newChild) {
+          switch (newChild.$$typeof) {
+            case REACT_ELEMENT_TYPE:
+              return newChild.key === key
+                ? ((key = pushDebugInfo(newChild._debugInfo)),
+                  (returnFiber = updateElement(
+                    returnFiber,
+                    oldFiber,
+                    newChild,
+                    lanes
+                  )),
+                  (currentDebugInfo = key),
+                  returnFiber)
+                : null;
+            case REACT_PORTAL_TYPE:
+              return newChild.key === key
+                ? updatePortal(returnFiber, oldFiber, newChild, lanes)
+                : null;
+            case REACT_LAZY_TYPE:
+              return (
+                (key = pushDebugInfo(newChild._debugInfo)),
+                (newChild = callLazyInitInDEV(newChild)),
+                (returnFiber = updateSlot(
+                  returnFiber,
+                  oldFiber,
+                  newChild,
+                  lanes
+                )),
+                (currentDebugInfo = key),
+                returnFiber
+              );
+          }
+          if (
+            isArrayImpl(newChild) ||
+            getIteratorFn(newChild) ||
+            "function" === typeof newChild[ASYNC_ITERATOR]
+          ) {
+            if (null !== key) return null;
+            key = pushDebugInfo(newChild._debugInfo);
+            returnFiber = updateFragment(
+              returnFiber,
+              oldFiber,
+              newChild,
+              lanes,
+              null
+            );
+            currentDebugInfo = key;
+            return returnFiber;
+          }
+          if ("function" === typeof newChild.then)
+            return (
+              (key = pushDebugInfo(newChild._debugInfo)),
+              (returnFiber = updateSlot(
+                returnFiber,
+                oldFiber,
+                unwrapThenable(newChild),
+                lanes
+              )),
+              (currentDebugInfo = key),
+              returnFiber
+            );
+          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
+            return updateSlot(
+              returnFiber,
+              oldFiber,
+              readContextDuringReconciliation(returnFiber, newChild),
+              lanes
+            );
+          throwOnInvalidObjectType(returnFiber, newChild);
+        }
+        "function" === typeof newChild &&
+          warnOnFunctionType(returnFiber, newChild);
+        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
+        return null;
+      }
+      function updateFromMap(
+        existingChildren,
+        returnFiber,
+        newIdx,
+        newChild,
+        lanes
+      ) {
+        if (
+          ("string" === typeof newChild && "" !== newChild) ||
+          "number" === typeof newChild ||
+          "bigint" === typeof newChild
+        )
+          return (
+            (existingChildren = existingChildren.get(newIdx) || null),
+            updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
+          );
+        if ("object" === typeof newChild && null !== newChild) {
+          switch (newChild.$$typeof) {
+            case REACT_ELEMENT_TYPE:
+              return (
+                (newIdx =
+                  existingChildren.get(
+                    null === newChild.key ? newIdx : newChild.key
+                  ) || null),
+                (existingChildren = pushDebugInfo(newChild._debugInfo)),
+                (returnFiber = updateElement(
+                  returnFiber,
+                  newIdx,
+                  newChild,
+                  lanes
+                )),
+                (currentDebugInfo = existingChildren),
+                returnFiber
+              );
+            case REACT_PORTAL_TYPE:
+              return (
+                (existingChildren =
+                  existingChildren.get(
+                    null === newChild.key ? newIdx : newChild.key
+                  ) || null),
+                updatePortal(returnFiber, existingChildren, newChild, lanes)
+              );
+            case REACT_LAZY_TYPE:
+              var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
+              newChild = callLazyInitInDEV(newChild);
+              returnFiber = updateFromMap(
+                existingChildren,
+                returnFiber,
+                newIdx,
+                newChild,
+                lanes
+              );
+              currentDebugInfo = _prevDebugInfo7;
+              return returnFiber;
+          }
+          if (
+            isArrayImpl(newChild) ||
+            getIteratorFn(newChild) ||
+            "function" === typeof newChild[ASYNC_ITERATOR]
+          )
+            return (
+              (newIdx = existingChildren.get(newIdx) || null),
+              (existingChildren = pushDebugInfo(newChild._debugInfo)),
+              (returnFiber = updateFragment(
+                returnFiber,
+                newIdx,
+                newChild,
+                lanes,
+                null
+              )),
+              (currentDebugInfo = existingChildren),
+              returnFiber
+            );
+          if ("function" === typeof newChild.then)
+            return (
+              (_prevDebugInfo7 = pushDebugInfo(newChild._debugInfo)),
+              (returnFiber = updateFromMap(
+                existingChildren,
+                returnFiber,
+                newIdx,
+                unwrapThenable(newChild),
+                lanes
+              )),
+              (currentDebugInfo = _prevDebugInfo7),
+              returnFiber
+            );
+          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
+            return updateFromMap(
+              existingChildren,
+              returnFiber,
+              newIdx,
+              readContextDuringReconciliation(returnFiber, newChild),
+              lanes
+            );
+          throwOnInvalidObjectType(returnFiber, newChild);
+        }
+        "function" === typeof newChild &&
+          warnOnFunctionType(returnFiber, newChild);
+        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
+        return null;
+      }
+      function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {
+        if ("object" !== typeof child || null === child) return knownKeys;
+        switch (child.$$typeof) {
+          case REACT_ELEMENT_TYPE:
+          case REACT_PORTAL_TYPE:
+            warnForMissingKey(returnFiber, workInProgress, child);
+            var key = child.key;
+            if ("string" !== typeof key) break;
+            if (null === knownKeys) {
+              knownKeys = new Set();
+              knownKeys.add(key);
+              break;
+            }
+            if (!knownKeys.has(key)) {
+              knownKeys.add(key);
+              break;
+            }
+            runWithFiberInDEV(workInProgress, function () {
+              console.error(
+                "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
+                key
+              );
+            });
+            break;
+          case REACT_LAZY_TYPE:
+            (child = callLazyInitInDEV(child)),
+              warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);
+        }
+        return knownKeys;
+      }
+      function reconcileChildrenArray(
+        returnFiber,
+        currentFirstChild,
+        newChildren,
+        lanes
+      ) {
+        for (
+          var knownKeys = null,
+            resultingFirstChild = null,
+            previousNewFiber = null,
+            oldFiber = currentFirstChild,
+            newIdx = (currentFirstChild = 0),
+            nextOldFiber = null;
+          null !== oldFiber && newIdx < newChildren.length;
+          newIdx++
+        ) {
+          oldFiber.index > newIdx
+            ? ((nextOldFiber = oldFiber), (oldFiber = null))
+            : (nextOldFiber = oldFiber.sibling);
+          var newFiber = updateSlot(
+            returnFiber,
+            oldFiber,
+            newChildren[newIdx],
+            lanes
+          );
+          if (null === newFiber) {
+            null === oldFiber && (oldFiber = nextOldFiber);
+            break;
+          }
+          knownKeys = warnOnInvalidKey(
+            returnFiber,
+            newFiber,
+            newChildren[newIdx],
+            knownKeys
+          );
+          shouldTrackSideEffects &&
+            oldFiber &&
+            null === newFiber.alternate &&
+            deleteChild(returnFiber, oldFiber);
+          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
+          null === previousNewFiber
+            ? (resultingFirstChild = newFiber)
+            : (previousNewFiber.sibling = newFiber);
+          previousNewFiber = newFiber;
+          oldFiber = nextOldFiber;
+        }
+        if (newIdx === newChildren.length)
+          return (
+            deleteRemainingChildren(returnFiber, oldFiber),
+            isHydrating && pushTreeFork(returnFiber, newIdx),
+            resultingFirstChild
+          );
+        if (null === oldFiber) {
+          for (; newIdx < newChildren.length; newIdx++)
+            (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
+              null !== oldFiber &&
+                ((knownKeys = warnOnInvalidKey(
+                  returnFiber,
+                  oldFiber,
+                  newChildren[newIdx],
+                  knownKeys
+                )),
+                (currentFirstChild = placeChild(
+                  oldFiber,
+                  currentFirstChild,
+                  newIdx
+                )),
+                null === previousNewFiber
+                  ? (resultingFirstChild = oldFiber)
+                  : (previousNewFiber.sibling = oldFiber),
+                (previousNewFiber = oldFiber));
+          isHydrating && pushTreeFork(returnFiber, newIdx);
+          return resultingFirstChild;
+        }
+        for (
+          oldFiber = mapRemainingChildren(oldFiber);
+          newIdx < newChildren.length;
+          newIdx++
+        )
+          (nextOldFiber = updateFromMap(
+            oldFiber,
+            returnFiber,
+            newIdx,
+            newChildren[newIdx],
+            lanes
+          )),
+            null !== nextOldFiber &&
+              ((knownKeys = warnOnInvalidKey(
+                returnFiber,
+                nextOldFiber,
+                newChildren[newIdx],
+                knownKeys
+              )),
+              shouldTrackSideEffects &&
+                null !== nextOldFiber.alternate &&
+                oldFiber.delete(
+                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
+                ),
+              (currentFirstChild = placeChild(
+                nextOldFiber,
+                currentFirstChild,
+                newIdx
+              )),
+              null === previousNewFiber
+                ? (resultingFirstChild = nextOldFiber)
+                : (previousNewFiber.sibling = nextOldFiber),
+              (previousNewFiber = nextOldFiber));
+        shouldTrackSideEffects &&
+          oldFiber.forEach(function (child) {
+            return deleteChild(returnFiber, child);
+          });
+        isHydrating && pushTreeFork(returnFiber, newIdx);
+        return resultingFirstChild;
+      }
+      function reconcileChildrenAsyncIteratable(
+        returnFiber,
+        currentFirstChild,
+        newChildrenIterable,
+        lanes
+      ) {
+        var newChildren = newChildrenIterable[ASYNC_ITERATOR]();
+        newChildren !== newChildrenIterable ||
+          (0 === returnFiber.tag &&
+            "[object AsyncGeneratorFunction]" ===
+              Object.prototype.toString.call(returnFiber.type) &&
+            "[object AsyncGenerator]" ===
+              Object.prototype.toString.call(newChildren)) ||
+          (didWarnAboutGenerators ||
+            console.error(
+              "Using AsyncIterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You can use an AsyncIterable that can iterate multiple times over the same items."
+            ),
+          (didWarnAboutGenerators = !0));
+        if (null == newChildren)
+          throw Error("An iterable object provided no iterator.");
+        return reconcileChildrenIterator(
+          returnFiber,
+          currentFirstChild,
+          {
+            next: function () {
+              return unwrapThenable(newChildren.next());
+            }
+          },
+          lanes
+        );
+      }
+      function reconcileChildrenIterator(
+        returnFiber,
+        currentFirstChild,
+        newChildren,
+        lanes
+      ) {
+        if (null == newChildren)
+          throw Error("An iterable object provided no iterator.");
+        for (
+          var resultingFirstChild = null,
+            previousNewFiber = null,
+            oldFiber = currentFirstChild,
+            newIdx = (currentFirstChild = 0),
+            nextOldFiber = null,
+            knownKeys = null,
+            step = newChildren.next();
+          null !== oldFiber && !step.done;
+          newIdx++, step = newChildren.next()
+        ) {
+          oldFiber.index > newIdx
+            ? ((nextOldFiber = oldFiber), (oldFiber = null))
+            : (nextOldFiber = oldFiber.sibling);
+          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
+          if (null === newFiber) {
+            null === oldFiber && (oldFiber = nextOldFiber);
+            break;
+          }
+          knownKeys = warnOnInvalidKey(
+            returnFiber,
+            newFiber,
+            step.value,
+            knownKeys
+          );
+          shouldTrackSideEffects &&
+            oldFiber &&
+            null === newFiber.alternate &&
+            deleteChild(returnFiber, oldFiber);
+          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
+          null === previousNewFiber
+            ? (resultingFirstChild = newFiber)
+            : (previousNewFiber.sibling = newFiber);
+          previousNewFiber = newFiber;
+          oldFiber = nextOldFiber;
+        }
+        if (step.done)
+          return (
+            deleteRemainingChildren(returnFiber, oldFiber),
+            isHydrating && pushTreeFork(returnFiber, newIdx),
+            resultingFirstChild
+          );
+        if (null === oldFiber) {
+          for (; !step.done; newIdx++, step = newChildren.next())
+            (oldFiber = createChild(returnFiber, step.value, lanes)),
+              null !== oldFiber &&
+                ((knownKeys = warnOnInvalidKey(
+                  returnFiber,
+                  oldFiber,
+                  step.value,
+                  knownKeys
+                )),
+                (currentFirstChild = placeChild(
+                  oldFiber,
+                  currentFirstChild,
+                  newIdx
+                )),
+                null === previousNewFiber
+                  ? (resultingFirstChild = oldFiber)
+                  : (previousNewFiber.sibling = oldFiber),
+                (previousNewFiber = oldFiber));
+          isHydrating && pushTreeFork(returnFiber, newIdx);
+          return resultingFirstChild;
+        }
+        for (
+          oldFiber = mapRemainingChildren(oldFiber);
+          !step.done;
+          newIdx++, step = newChildren.next()
+        )
+          (nextOldFiber = updateFromMap(
+            oldFiber,
+            returnFiber,
+            newIdx,
+            step.value,
+            lanes
+          )),
+            null !== nextOldFiber &&
+              ((knownKeys = warnOnInvalidKey(
+                returnFiber,
+                nextOldFiber,
+                step.value,
+                knownKeys
+              )),
+              shouldTrackSideEffects &&
+                null !== nextOldFiber.alternate &&
+                oldFiber.delete(
+                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
+                ),
+              (currentFirstChild = placeChild(
+                nextOldFiber,
+                currentFirstChild,
+                newIdx
+              )),
+              null === previousNewFiber
+                ? (resultingFirstChild = nextOldFiber)
+                : (previousNewFiber.sibling = nextOldFiber),
+              (previousNewFiber = nextOldFiber));
+        shouldTrackSideEffects &&
+          oldFiber.forEach(function (child) {
+            return deleteChild(returnFiber, child);
+          });
+        isHydrating && pushTreeFork(returnFiber, newIdx);
+        return resultingFirstChild;
+      }
+      function reconcileChildFibersImpl(
+        returnFiber,
+        currentFirstChild,
+        newChild,
+        lanes
+      ) {
+        "object" === typeof newChild &&
+          null !== newChild &&
+          newChild.type === REACT_FRAGMENT_TYPE &&
+          null === newChild.key &&
+          (validateFragmentProps(newChild, null, returnFiber),
+          (newChild = newChild.props.children));
+        if ("object" === typeof newChild && null !== newChild) {
+          switch (newChild.$$typeof) {
+            case REACT_ELEMENT_TYPE:
+              var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
+              a: {
+                for (var key = newChild.key; null !== currentFirstChild; ) {
+                  if (currentFirstChild.key === key) {
+                    key = newChild.type;
+                    if (key === REACT_FRAGMENT_TYPE) {
+                      if (7 === currentFirstChild.tag) {
+                        deleteRemainingChildren(
+                          returnFiber,
+                          currentFirstChild.sibling
+                        );
+                        lanes = useFiber(
+                          currentFirstChild,
+                          newChild.props.children
+                        );
+                        lanes.return = returnFiber;
+                        lanes._debugOwner = newChild._owner;
+                        lanes._debugInfo = currentDebugInfo;
+                        validateFragmentProps(newChild, lanes, returnFiber);
+                        returnFiber = lanes;
+                        break a;
+                      }
+                    } else if (
+                      currentFirstChild.elementType === key ||
+                      isCompatibleFamilyForHotReloading(
+                        currentFirstChild,
+                        newChild
+                      ) ||
+                      ("object" === typeof key &&
+                        null !== key &&
+                        key.$$typeof === REACT_LAZY_TYPE &&
+                        callLazyInitInDEV(key) === currentFirstChild.type)
+                    ) {
+                      deleteRemainingChildren(
+                        returnFiber,
+                        currentFirstChild.sibling
+                      );
+                      lanes = useFiber(currentFirstChild, newChild.props);
+                      coerceRef(lanes, newChild);
+                      lanes.return = returnFiber;
+                      lanes._debugOwner = newChild._owner;
+                      lanes._debugInfo = currentDebugInfo;
+                      returnFiber = lanes;
+                      break a;
+                    }
+                    deleteRemainingChildren(returnFiber, currentFirstChild);
+                    break;
+                  } else deleteChild(returnFiber, currentFirstChild);
+                  currentFirstChild = currentFirstChild.sibling;
+                }
+                newChild.type === REACT_FRAGMENT_TYPE
+                  ? ((lanes = createFiberFromFragment(
+                      newChild.props.children,
+                      returnFiber.mode,
+                      lanes,
+                      newChild.key
+                    )),
+                    (lanes.return = returnFiber),
+                    (lanes._debugOwner = returnFiber),
+                    (lanes._debugTask = returnFiber._debugTask),
+                    (lanes._debugInfo = currentDebugInfo),
+                    validateFragmentProps(newChild, lanes, returnFiber),
+                    (returnFiber = lanes))
+                  : ((lanes = createFiberFromElement(
+                      newChild,
+                      returnFiber.mode,
+                      lanes
+                    )),
+                    coerceRef(lanes, newChild),
+                    (lanes.return = returnFiber),
+                    (lanes._debugInfo = currentDebugInfo),
+                    (returnFiber = lanes));
+              }
+              returnFiber = placeSingleChild(returnFiber);
+              currentDebugInfo = prevDebugInfo;
+              return returnFiber;
+            case REACT_PORTAL_TYPE:
+              a: {
+                prevDebugInfo = newChild;
+                for (
+                  newChild = prevDebugInfo.key;
+                  null !== currentFirstChild;
+
+                ) {
+                  if (currentFirstChild.key === newChild)
+                    if (
+                      4 === currentFirstChild.tag &&
+                      currentFirstChild.stateNode.containerInfo ===
+                        prevDebugInfo.containerInfo &&
+                      currentFirstChild.stateNode.implementation ===
+                        prevDebugInfo.implementation
+                    ) {
+                      deleteRemainingChildren(
+                        returnFiber,
+                        currentFirstChild.sibling
+                      );
+                      lanes = useFiber(
+                        currentFirstChild,
+                        prevDebugInfo.children || []
+                      );
+                      lanes.return = returnFiber;
+                      returnFiber = lanes;
+                      break a;
+                    } else {
+                      deleteRemainingChildren(returnFiber, currentFirstChild);
+                      break;
+                    }
+                  else deleteChild(returnFiber, currentFirstChild);
+                  currentFirstChild = currentFirstChild.sibling;
+                }
+                lanes = createFiberFromPortal(
+                  prevDebugInfo,
+                  returnFiber.mode,
+                  lanes
+                );
+                lanes.return = returnFiber;
+                returnFiber = lanes;
+              }
+              return placeSingleChild(returnFiber);
+            case REACT_LAZY_TYPE:
+              return (
+                (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
+                (newChild = callLazyInitInDEV(newChild)),
+                (returnFiber = reconcileChildFibersImpl(
+                  returnFiber,
+                  currentFirstChild,
+                  newChild,
+                  lanes
+                )),
+                (currentDebugInfo = prevDebugInfo),
+                returnFiber
+              );
+          }
+          if (isArrayImpl(newChild))
+            return (
+              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
+              (returnFiber = reconcileChildrenArray(
+                returnFiber,
+                currentFirstChild,
+                newChild,
+                lanes
+              )),
+              (currentDebugInfo = prevDebugInfo),
+              returnFiber
+            );
+          if (getIteratorFn(newChild)) {
+            prevDebugInfo = pushDebugInfo(newChild._debugInfo);
+            key = getIteratorFn(newChild);
+            if ("function" !== typeof key)
+              throw Error(
+                "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
+              );
+            var newChildren = key.call(newChild);
+            if (newChildren === newChild) {
+              if (
+                0 !== returnFiber.tag ||
+                "[object GeneratorFunction]" !==
+                  Object.prototype.toString.call(returnFiber.type) ||
+                "[object Generator]" !==
+                  Object.prototype.toString.call(newChildren)
+              )
+                didWarnAboutGenerators ||
+                  console.error(
+                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
+                  ),
+                  (didWarnAboutGenerators = !0);
+            } else
+              newChild.entries !== key ||
+                didWarnAboutMaps ||
+                (console.error(
+                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
+                ),
+                (didWarnAboutMaps = !0));
+            returnFiber = reconcileChildrenIterator(
+              returnFiber,
+              currentFirstChild,
+              newChildren,
+              lanes
+            );
+            currentDebugInfo = prevDebugInfo;
+            return returnFiber;
+          }
+          if ("function" === typeof newChild[ASYNC_ITERATOR])
+            return (
+              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
+              (returnFiber = reconcileChildrenAsyncIteratable(
+                returnFiber,
+                currentFirstChild,
+                newChild,
+                lanes
+              )),
+              (currentDebugInfo = prevDebugInfo),
+              returnFiber
+            );
+          if ("function" === typeof newChild.then)
+            return (
+              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
+              (returnFiber = reconcileChildFibersImpl(
+                returnFiber,
+                currentFirstChild,
+                unwrapThenable(newChild),
+                lanes
+              )),
+              (currentDebugInfo = prevDebugInfo),
+              returnFiber
+            );
+          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
+            return reconcileChildFibersImpl(
+              returnFiber,
+              currentFirstChild,
+              readContextDuringReconciliation(returnFiber, newChild),
+              lanes
+            );
+          throwOnInvalidObjectType(returnFiber, newChild);
+        }
+        if (
+          ("string" === typeof newChild && "" !== newChild) ||
+          "number" === typeof newChild ||
+          "bigint" === typeof newChild
+        )
+          return (
+            (prevDebugInfo = "" + newChild),
+            null !== currentFirstChild && 6 === currentFirstChild.tag
+              ? (deleteRemainingChildren(
+                  returnFiber,
+                  currentFirstChild.sibling
+                ),
+                (lanes = useFiber(currentFirstChild, prevDebugInfo)),
+                (lanes.return = returnFiber),
+                (returnFiber = lanes))
+              : (deleteRemainingChildren(returnFiber, currentFirstChild),
+                (lanes = createFiberFromText(
+                  prevDebugInfo,
+                  returnFiber.mode,
+                  lanes
+                )),
+                (lanes.return = returnFiber),
+                (lanes._debugOwner = returnFiber),
+                (lanes._debugTask = returnFiber._debugTask),
+                (lanes._debugInfo = currentDebugInfo),
+                (returnFiber = lanes)),
+            placeSingleChild(returnFiber)
+          );
+        "function" === typeof newChild &&
+          warnOnFunctionType(returnFiber, newChild);
+        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
+        return deleteRemainingChildren(returnFiber, currentFirstChild);
+      }
+      return function (returnFiber, currentFirstChild, newChild, lanes) {
+        var prevDebugInfo = currentDebugInfo;
+        currentDebugInfo = null;
+        try {
+          thenableIndexCounter = 0;
+          var firstChildFiber = reconcileChildFibersImpl(
+            returnFiber,
+            currentFirstChild,
+            newChild,
+            lanes
+          );
+          thenableState = null;
+          return firstChildFiber;
+        } catch (x) {
+          if (x === SuspenseException || x === SuspenseActionException) throw x;
+          var fiber = createFiber(29, x, null, returnFiber.mode);
+          fiber.lanes = lanes;
+          fiber.return = returnFiber;
+          var debugInfo = (fiber._debugInfo = currentDebugInfo);
+          fiber._debugOwner = returnFiber._debugOwner;
+          fiber._debugTask = returnFiber._debugTask;
+          if (null != debugInfo)
+            for (var i = debugInfo.length - 1; 0 <= i; i--)
+              if ("string" === typeof debugInfo[i].stack) {
+                fiber._debugOwner = debugInfo[i];
+                fiber._debugTask = debugInfo[i].debugTask;
+                break;
+              }
+          return fiber;
+        } finally {
+          currentDebugInfo = prevDebugInfo;
+        }
+      };
+    }
+    function pushPrimaryTreeSuspenseHandler(handler) {
+      var current = handler.alternate;
+      push(
+        suspenseStackCursor,
+        suspenseStackCursor.current & SubtreeSuspenseContextMask,
+        handler
+      );
+      push(suspenseHandlerStackCursor, handler, handler);
+      null === shellBoundary &&
+        (null === current || null !== currentTreeHiddenStackCursor.current
+          ? (shellBoundary = handler)
+          : null !== current.memoizedState && (shellBoundary = handler));
+    }
+    function pushOffscreenSuspenseHandler(fiber) {
+      if (22 === fiber.tag) {
+        if (
+          (push(suspenseStackCursor, suspenseStackCursor.current, fiber),
+          push(suspenseHandlerStackCursor, fiber, fiber),
+          null === shellBoundary)
+        ) {
+          var current = fiber.alternate;
+          null !== current &&
+            null !== current.memoizedState &&
+            (shellBoundary = fiber);
+        }
+      } else reuseSuspenseHandlerOnStack(fiber);
+    }
+    function reuseSuspenseHandlerOnStack(fiber) {
+      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
+      push(
+        suspenseHandlerStackCursor,
+        suspenseHandlerStackCursor.current,
+        fiber
+      );
+    }
+    function popSuspenseHandler(fiber) {
+      pop(suspenseHandlerStackCursor, fiber);
+      shellBoundary === fiber && (shellBoundary = null);
+      pop(suspenseStackCursor, fiber);
+    }
+    function findFirstSuspended(row) {
+      for (var node = row; null !== node; ) {
+        if (13 === node.tag) {
+          var state = node.memoizedState;
+          if (
+            null !== state &&
+            ((state = state.dehydrated),
+            null === state ||
+              state.data === SUSPENSE_PENDING_START_DATA ||
+              isSuspenseInstanceFallback(state))
+          )
+            return node;
+        } else if (
+          19 === node.tag &&
+          void 0 !== node.memoizedProps.revealOrder
+        ) {
+          if (0 !== (node.flags & 128)) return node;
+        } else if (null !== node.child) {
+          node.child.return = node;
+          node = node.child;
+          continue;
+        }
+        if (node === row) break;
+        for (; null === node.sibling; ) {
+          if (null === node.return || node.return === row) return null;
+          node = node.return;
+        }
+        node.sibling.return = node.return;
+        node = node.sibling;
+      }
+      return null;
+    }
+    function defaultOnUncaughtError(error) {
+      reportGlobalError(error);
+      console.warn(
+        "%s\n\n%s\n",
+        componentName
+          ? "An error occurred in the <" + componentName + "> component."
+          : "An error occurred in one of your React components.",
+        "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
+      );
+    }
+    function defaultOnCaughtError(error) {
+      var componentNameMessage = componentName
+          ? "The above error occurred in the <" + componentName + "> component."
+          : "The above error occurred in one of your React components.",
+        recreateMessage =
+          "React will try to recreate this component tree from scratch using the error boundary you provided, " +
+          ((errorBoundaryName || "Anonymous") + ".");
+      if (
+        "object" === typeof error &&
+        null !== error &&
+        "string" === typeof error.environmentName
+      ) {
+        var JSCompiler_inline_result = error.environmentName;
+        error = [
+          "%o\n\n%s\n\n%s\n",
+          error,
+          componentNameMessage,
+          recreateMessage
+        ].slice(0);
+        "string" === typeof error[0]
+          ? error.splice(
+              0,
+              1,
+              badgeFormat + error[0],
+              badgeStyle,
+              pad + JSCompiler_inline_result + pad,
+              resetStyle
+            )
+          : error.splice(
+              0,
+              0,
+              badgeFormat,
+              badgeStyle,
+              pad + JSCompiler_inline_result + pad,
+              resetStyle
+            );
+        error.unshift(console);
+        JSCompiler_inline_result = bind.apply(console.error, error);
+        JSCompiler_inline_result();
+      } else
+        console.error(
+          "%o\n\n%s\n\n%s\n",
+          error,
+          componentNameMessage,
+          recreateMessage
+        );
+    }
+    function defaultOnRecoverableError(error) {
+      reportGlobalError(error);
+    }
+    function logUncaughtError(root, errorInfo) {
+      try {
+        componentName = errorInfo.source
+          ? getComponentNameFromFiber(errorInfo.source)
+          : null;
+        errorBoundaryName = null;
+        var error = errorInfo.value;
+        if (null !== ReactSharedInternals.actQueue)
+          ReactSharedInternals.thrownErrors.push(error);
+        else {
+          var onUncaughtError = root.onUncaughtError;
+          onUncaughtError(error, { componentStack: errorInfo.stack });
+        }
+      } catch (e$4) {
+        setTimeout(function () {
+          throw e$4;
+        });
+      }
+    }
+    function logCaughtError(root, boundary, errorInfo) {
+      try {
+        componentName = errorInfo.source
+          ? getComponentNameFromFiber(errorInfo.source)
+          : null;
+        errorBoundaryName = getComponentNameFromFiber(boundary);
+        var onCaughtError = root.onCaughtError;
+        onCaughtError(errorInfo.value, {
+          componentStack: errorInfo.stack,
+          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
+        });
+      } catch (e$5) {
+        setTimeout(function () {
+          throw e$5;
+        });
+      }
+    }
+    function createRootErrorUpdate(root, errorInfo, lane) {
+      lane = createUpdate(lane);
+      lane.tag = CaptureUpdate;
+      lane.payload = { element: null };
+      lane.callback = function () {
+        runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
+      };
+      return lane;
+    }
+    function createClassErrorUpdate(lane) {
+      lane = createUpdate(lane);
+      lane.tag = CaptureUpdate;
+      return lane;
+    }
+    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
+      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
+      if ("function" === typeof getDerivedStateFromError) {
+        var error = errorInfo.value;
+        update.payload = function () {
+          return getDerivedStateFromError(error);
+        };
+        update.callback = function () {
+          markFailedErrorBoundaryForHotReloading(fiber);
+          runWithFiberInDEV(
+            errorInfo.source,
+            logCaughtError,
+            root,
+            fiber,
+            errorInfo
+          );
+        };
+      }
+      var inst = fiber.stateNode;
+      null !== inst &&
+        "function" === typeof inst.componentDidCatch &&
+        (update.callback = function () {
+          markFailedErrorBoundaryForHotReloading(fiber);
+          runWithFiberInDEV(
+            errorInfo.source,
+            logCaughtError,
+            root,
+            fiber,
+            errorInfo
+          );
+          "function" !== typeof getDerivedStateFromError &&
+            (null === legacyErrorBoundariesThatAlreadyFailed
+              ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
+              : legacyErrorBoundariesThatAlreadyFailed.add(this));
+          callComponentDidCatchInDEV(this, errorInfo);
+          "function" === typeof getDerivedStateFromError ||
+            (0 === (fiber.lanes & 2) &&
+              console.error(
+                "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
+                getComponentNameFromFiber(fiber) || "Unknown"
+              ));
+        });
+    }
+    function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
+      var currentSourceFiber = sourceFiber.alternate;
+      null !== currentSourceFiber &&
+        propagateParentContextChanges(
+          currentSourceFiber,
+          sourceFiber,
+          rootRenderLanes,
+          !0
+        );
+    }
+    function markSuspenseBoundaryShouldCapture(
+      suspenseBoundary,
+      returnFiber,
+      sourceFiber,
+      root,
+      rootRenderLanes
+    ) {
+      suspenseBoundary.flags |= 65536;
+      suspenseBoundary.lanes = rootRenderLanes;
+      return suspenseBoundary;
+    }
+    function throwException(
+      root,
+      returnFiber,
+      sourceFiber,
+      value,
+      rootRenderLanes
+    ) {
+      sourceFiber.flags |= 32768;
+      isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
+      if (
+        null !== value &&
+        "object" === typeof value &&
+        (value.$$typeof === REACT_POSTPONE_TYPE &&
+          (value = { then: function () {} }),
+        "function" === typeof value.then)
+      ) {
+        resetSuspendedComponent(sourceFiber, rootRenderLanes);
+        isHydrating && (didSuspendOrErrorDEV = !0);
+        var suspenseBoundary = suspenseHandlerStackCursor.current;
+        if (null !== suspenseBoundary) {
+          switch (suspenseBoundary.tag) {
+            case 13:
+              return (
+                null === shellBoundary
+                  ? renderDidSuspendDelayIfPossible()
+                  : null === suspenseBoundary.alternate &&
+                    workInProgressRootExitStatus === RootInProgress &&
+                    (workInProgressRootExitStatus = RootSuspended),
+                (suspenseBoundary.flags &= -257),
+                markSuspenseBoundaryShouldCapture(
+                  suspenseBoundary,
+                  returnFiber,
+                  sourceFiber,
+                  root,
+                  rootRenderLanes
+                ),
+                value === noopSuspenseyCommitThenable
+                  ? (suspenseBoundary.flags |= 16384)
+                  : ((sourceFiber = suspenseBoundary.updateQueue),
+                    null === sourceFiber
+                      ? (suspenseBoundary.updateQueue = new Set([value]))
+                      : sourceFiber.add(value),
+                    attachPingListener(root, value, rootRenderLanes)),
+                !1
+              );
+            case 22:
+              return (
+                (suspenseBoundary.flags |= 65536),
+                value === noopSuspenseyCommitThenable
+                  ? (suspenseBoundary.flags |= 16384)
+                  : ((sourceFiber = suspenseBoundary.updateQueue),
+                    null === sourceFiber
+                      ? ((sourceFiber = {
+                          transitions: null,
+                          markerInstances: null,
+                          retryQueue: new Set([value])
+                        }),
+                        (suspenseBoundary.updateQueue = sourceFiber))
+                      : ((returnFiber = sourceFiber.retryQueue),
+                        null === returnFiber
+                          ? (sourceFiber.retryQueue = new Set([value]))
+                          : returnFiber.add(value)),
+                    attachPingListener(root, value, rootRenderLanes)),
+                !1
+              );
+          }
+          throw Error(
+            "Unexpected Suspense handler tag (" +
+              suspenseBoundary.tag +
+              "). This is a bug in React."
+          );
+        }
+        attachPingListener(root, value, rootRenderLanes);
+        renderDidSuspendDelayIfPossible();
+        return !1;
+      }
+      if (isHydrating)
+        return (
+          (didSuspendOrErrorDEV = !0),
+          (suspenseBoundary = suspenseHandlerStackCursor.current),
+          null !== suspenseBoundary
+            ? (0 === (suspenseBoundary.flags & 65536) &&
+                (suspenseBoundary.flags |= 256),
+              markSuspenseBoundaryShouldCapture(
+                suspenseBoundary,
+                returnFiber,
+                sourceFiber,
+                root,
+                rootRenderLanes
+              ),
+              value !== HydrationMismatchException &&
+                queueHydrationError(
+                  createCapturedValueAtFiber(
+                    Error(
+                      "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
+                      { cause: value }
+                    ),
+                    sourceFiber
+                  )
+                ))
+            : (value !== HydrationMismatchException &&
+                queueHydrationError(
+                  createCapturedValueAtFiber(
+                    Error(
+                      "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
+                      { cause: value }
+                    ),
+                    sourceFiber
+                  )
+                ),
+              (root = root.current.alternate),
+              (root.flags |= 65536),
+              (rootRenderLanes &= -rootRenderLanes),
+              (root.lanes |= rootRenderLanes),
+              (sourceFiber = createCapturedValueAtFiber(value, sourceFiber)),
+              (rootRenderLanes = createRootErrorUpdate(
+                root.stateNode,
+                sourceFiber,
+                rootRenderLanes
+              )),
+              enqueueCapturedUpdate(root, rootRenderLanes),
+              workInProgressRootExitStatus !== RootSuspendedWithDelay &&
+                (workInProgressRootExitStatus = RootErrored)),
+          !1
+        );
+      queueConcurrentError(
+        createCapturedValueAtFiber(
+          Error(
+            "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
+            { cause: value }
+          ),
+          sourceFiber
+        )
+      );
+      workInProgressRootExitStatus !== RootSuspendedWithDelay &&
+        (workInProgressRootExitStatus = RootErrored);
+      if (null === returnFiber) return !0;
+      sourceFiber = createCapturedValueAtFiber(value, sourceFiber);
+      value = returnFiber;
+      do {
+        switch (value.tag) {
+          case 3:
+            return (
+              (value.flags |= 65536),
+              (root = rootRenderLanes & -rootRenderLanes),
+              (value.lanes |= root),
+              (root = createRootErrorUpdate(
+                value.stateNode,
+                sourceFiber,
+                root
+              )),
+              enqueueCapturedUpdate(value, root),
+              !1
+            );
+          case 1:
+            if (
+              ((returnFiber = value.type),
+              (suspenseBoundary = value.stateNode),
+              0 === (value.flags & 128) &&
+                ("function" === typeof returnFiber.getDerivedStateFromError ||
+                  (null !== suspenseBoundary &&
+                    "function" === typeof suspenseBoundary.componentDidCatch &&
+                    (null === legacyErrorBoundariesThatAlreadyFailed ||
+                      !legacyErrorBoundariesThatAlreadyFailed.has(
+                        suspenseBoundary
+                      )))))
+            )
+              return (
+                (value.flags |= 65536),
+                (rootRenderLanes &= -rootRenderLanes),
+                (value.lanes |= rootRenderLanes),
+                (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
+                initializeClassErrorUpdate(
+                  rootRenderLanes,
+                  root,
+                  value,
+                  sourceFiber
+                ),
+                enqueueCapturedUpdate(value, rootRenderLanes),
+                !1
+              );
+        }
+        value = value.return;
+      } while (null !== value);
+      return !1;
+    }
+    function reconcileChildren(
+      current,
+      workInProgress,
+      nextChildren,
+      renderLanes
+    ) {
+      workInProgress.child =
+        null === current
+          ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
+          : reconcileChildFibers(
+              workInProgress,
+              current.child,
+              nextChildren,
+              renderLanes
+            );
+    }
+    function updateForwardRef(
+      current,
+      workInProgress,
+      Component,
+      nextProps,
+      renderLanes
+    ) {
+      Component = Component.render;
+      var ref = workInProgress.ref;
+      if ("ref" in nextProps) {
+        var propsWithoutRef = {};
+        for (var key in nextProps)
+          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
+      } else propsWithoutRef = nextProps;
+      prepareToReadContext(workInProgress);
+      nextProps = renderWithHooks(
+        current,
+        workInProgress,
+        Component,
+        propsWithoutRef,
+        ref,
+        renderLanes
+      );
+      key = checkDidRenderIdHook();
+      if (null !== current && !didReceiveUpdate)
+        return (
+          bailoutHooks(current, workInProgress, renderLanes),
+          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
+        );
+      isHydrating && key && pushMaterializedTreeId(workInProgress);
+      workInProgress.flags |= 1;
+      reconcileChildren(current, workInProgress, nextProps, renderLanes);
+      return workInProgress.child;
+    }
+    function updateMemoComponent(
+      current,
+      workInProgress,
+      Component,
+      nextProps,
+      renderLanes
+    ) {
+      if (null === current) {
+        var type = Component.type;
+        if (
+          "function" === typeof type &&
+          !shouldConstruct(type) &&
+          void 0 === type.defaultProps &&
+          null === Component.compare
+        )
+          return (
+            (Component = resolveFunctionForHotReloading(type)),
+            (workInProgress.tag = 15),
+            (workInProgress.type = Component),
+            validateFunctionComponentInDev(workInProgress, type),
+            updateSimpleMemoComponent(
+              current,
+              workInProgress,
+              Component,
+              nextProps,
+              renderLanes
+            )
+          );
+        current = createFiberFromTypeAndProps(
+          Component.type,
+          null,
+          nextProps,
+          workInProgress,
+          workInProgress.mode,
+          renderLanes
+        );
+        current.ref = workInProgress.ref;
+        current.return = workInProgress;
+        return (workInProgress.child = current);
+      }
+      type = current.child;
+      if (!checkScheduledUpdateOrContext(current, renderLanes)) {
+        var prevProps = type.memoizedProps;
+        Component = Component.compare;
+        Component = null !== Component ? Component : shallowEqual;
+        if (
+          Component(prevProps, nextProps) &&
+          current.ref === workInProgress.ref
+        )
+          return bailoutOnAlreadyFinishedWork(
+            current,
+            workInProgress,
+            renderLanes
+          );
+      }
+      workInProgress.flags |= 1;
+      current = createWorkInProgress(type, nextProps);
+      current.ref = workInProgress.ref;
+      current.return = workInProgress;
+      return (workInProgress.child = current);
+    }
+    function updateSimpleMemoComponent(
+      current,
+      workInProgress,
+      Component,
+      nextProps,
+      renderLanes
+    ) {
+      if (null !== current) {
+        var prevProps = current.memoizedProps;
+        if (
+          shallowEqual(prevProps, nextProps) &&
+          current.ref === workInProgress.ref &&
+          workInProgress.type === current.type
+        )
+          if (
+            ((didReceiveUpdate = !1),
+            (workInProgress.pendingProps = nextProps = prevProps),
+            checkScheduledUpdateOrContext(current, renderLanes))
+          )
+            0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
+          else
+            return (
+              (workInProgress.lanes = current.lanes),
+              bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
+            );
+      }
+      return updateFunctionComponent(
+        current,
+        workInProgress,
+        Component,
+        nextProps,
+        renderLanes
+      );
+    }
+    function updateOffscreenComponent(current, workInProgress, renderLanes) {
+      var nextProps = workInProgress.pendingProps,
+        nextChildren = nextProps.children,
+        nextIsDetached =
+          0 !==
+          (workInProgress.stateNode._pendingVisibility & OffscreenDetached),
+        prevState = null !== current ? current.memoizedState : null;
+      markRef(current, workInProgress);
+      if ("hidden" === nextProps.mode || nextIsDetached) {
+        if (0 !== (workInProgress.flags & 128)) {
+          nextProps =
+            null !== prevState
+              ? prevState.baseLanes | renderLanes
+              : renderLanes;
+          if (null !== current) {
+            nextChildren = workInProgress.child = current.child;
+            for (nextIsDetached = 0; null !== nextChildren; )
+              (nextIsDetached =
+                nextIsDetached | nextChildren.lanes | nextChildren.childLanes),
+                (nextChildren = nextChildren.sibling);
+            workInProgress.childLanes = nextIsDetached & ~nextProps;
+          } else (workInProgress.childLanes = 0), (workInProgress.child = null);
+          return deferHiddenOffscreenComponent(
+            current,
+            workInProgress,
+            nextProps,
+            renderLanes
+          );
+        }
+        if (0 !== (renderLanes & 536870912))
+          (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
+            null !== current &&
+              pushTransition(
+                workInProgress,
+                null !== prevState ? prevState.cachePool : null
+              ),
+            null !== prevState
+              ? pushHiddenContext(workInProgress, prevState)
+              : reuseHiddenContextOnStack(workInProgress),
+            pushOffscreenSuspenseHandler(workInProgress);
+        else
+          return (
+            (workInProgress.lanes = workInProgress.childLanes = 536870912),
+            deferHiddenOffscreenComponent(
+              current,
+              workInProgress,
+              null !== prevState
+                ? prevState.baseLanes | renderLanes
+                : renderLanes,
+              renderLanes
+            )
+          );
+      } else
+        null !== prevState
+          ? (pushTransition(workInProgress, prevState.cachePool),
+            pushHiddenContext(workInProgress, prevState),
+            reuseSuspenseHandlerOnStack(workInProgress),
+            (workInProgress.memoizedState = null))
+          : (null !== current && pushTransition(workInProgress, null),
+            reuseHiddenContextOnStack(workInProgress),
+            reuseSuspenseHandlerOnStack(workInProgress));
+      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+      return workInProgress.child;
+    }
+    function deferHiddenOffscreenComponent(
+      current,
+      workInProgress,
+      nextBaseLanes,
+      renderLanes
+    ) {
+      var JSCompiler_inline_result = peekCacheFromPool();
+      JSCompiler_inline_result =
+        null === JSCompiler_inline_result
+          ? null
+          : {
+              parent: CacheContext._currentValue,
+              pool: JSCompiler_inline_result
+            };
+      workInProgress.memoizedState = {
+        baseLanes: nextBaseLanes,
+        cachePool: JSCompiler_inline_result
+      };
+      null !== current && pushTransition(workInProgress, null);
+      reuseHiddenContextOnStack(workInProgress);
+      pushOffscreenSuspenseHandler(workInProgress);
+      null !== current &&
+        propagateParentContextChanges(current, workInProgress, renderLanes, !0);
+      return null;
+    }
+    function markRef(current, workInProgress) {
+      var ref = workInProgress.ref;
+      if (null === ref)
+        null !== current &&
+          null !== current.ref &&
+          (workInProgress.flags |= 4194816);
+      else {
+        if ("function" !== typeof ref && "object" !== typeof ref)
+          throw Error(
+            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
+          );
+        if (null === current || current.ref !== ref)
+          workInProgress.flags |= 4194816;
+      }
+    }
+    function updateFunctionComponent(
+      current,
+      workInProgress,
+      Component,
+      nextProps,
+      renderLanes
+    ) {
+      if (
+        Component.prototype &&
+        "function" === typeof Component.prototype.render
+      ) {
+        var componentName = getComponentNameFromType(Component) || "Unknown";
+        didWarnAboutBadClass[componentName] ||
+          (console.error(
+            "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
+            componentName,
+            componentName
+          ),
+          (didWarnAboutBadClass[componentName] = !0));
+      }
+      workInProgress.mode & StrictLegacyMode &&
+        ReactStrictModeWarnings.recordLegacyContextWarning(
+          workInProgress,
+          null
+        );
+      null === current &&
+        (validateFunctionComponentInDev(workInProgress, workInProgress.type),
+        Component.contextTypes &&
+          ((componentName = getComponentNameFromType(Component) || "Unknown"),
+          didWarnAboutContextTypes[componentName] ||
+            ((didWarnAboutContextTypes[componentName] = !0),
+            console.error(
+              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
+              componentName
+            ))));
+      prepareToReadContext(workInProgress);
+      Component = renderWithHooks(
+        current,
+        workInProgress,
+        Component,
+        nextProps,
+        void 0,
+        renderLanes
+      );
+      nextProps = checkDidRenderIdHook();
+      if (null !== current && !didReceiveUpdate)
+        return (
+          bailoutHooks(current, workInProgress, renderLanes),
+          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
+        );
+      isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
+      workInProgress.flags |= 1;
+      reconcileChildren(current, workInProgress, Component, renderLanes);
+      return workInProgress.child;
+    }
+    function replayFunctionComponent(
+      current,
+      workInProgress,
+      nextProps,
+      Component,
+      secondArg,
+      renderLanes
+    ) {
+      prepareToReadContext(workInProgress);
+      hookTypesUpdateIndexDev = -1;
+      ignorePreviousDependencies =
+        null !== current && current.type !== workInProgress.type;
+      workInProgress.updateQueue = null;
+      nextProps = renderWithHooksAgain(
+        workInProgress,
+        Component,
+        nextProps,
+        secondArg
+      );
+      finishRenderingHooks(current, workInProgress);
+      Component = checkDidRenderIdHook();
+      if (null !== current && !didReceiveUpdate)
+        return (
+          bailoutHooks(current, workInProgress, renderLanes),
+          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
+        );
+      isHydrating && Component && pushMaterializedTreeId(workInProgress);
+      workInProgress.flags |= 1;
+      reconcileChildren(current, workInProgress, nextProps, renderLanes);
+      return workInProgress.child;
+    }
+    function updateClassComponent(
+      current$jscomp$0,
+      workInProgress,
+      Component,
+      nextProps,
+      renderLanes
+    ) {
+      switch (shouldErrorImpl(workInProgress)) {
+        case !1:
+          var _instance = workInProgress.stateNode,
+            state = new workInProgress.type(
+              workInProgress.memoizedProps,
+              _instance.context
+            ).state;
+          _instance.updater.enqueueSetState(_instance, state, null);
+          break;
+        case !0:
+          workInProgress.flags |= 128;
+          workInProgress.flags |= 65536;
+          _instance = Error("Simulated error coming from DevTools");
+          var lane = renderLanes & -renderLanes;
+          workInProgress.lanes |= lane;
+          state = workInProgressRoot;
+          if (null === state)
+            throw Error(
+              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
+            );
+          lane = createClassErrorUpdate(lane);
+          initializeClassErrorUpdate(
+            lane,
+            state,
+            workInProgress,
+            createCapturedValueAtFiber(_instance, workInProgress)
+          );
+          enqueueCapturedUpdate(workInProgress, lane);
+      }
+      prepareToReadContext(workInProgress);
+      if (null === workInProgress.stateNode) {
+        state = emptyContextObject;
+        _instance = Component.contextType;
+        "contextType" in Component &&
+          null !== _instance &&
+          (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) &&
+          !didWarnAboutInvalidateContextType.has(Component) &&
+          (didWarnAboutInvalidateContextType.add(Component),
+          (lane =
+            void 0 === _instance
+              ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file."
+              : "object" !== typeof _instance
+                ? " However, it is set to a " + typeof _instance + "."
+                : _instance.$$typeof === REACT_CONSUMER_TYPE
+                  ? " Did you accidentally pass the Context.Consumer instead?"
+                  : " However, it is set to an object with keys {" +
+                    Object.keys(_instance).join(", ") +
+                    "}."),
+          console.error(
+            "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
+            getComponentNameFromType(Component) || "Component",
+            lane
+          ));
+        "object" === typeof _instance &&
+          null !== _instance &&
+          (state = readContext(_instance));
+        _instance = new Component(nextProps, state);
+        if (workInProgress.mode & StrictLegacyMode) {
+          setIsStrictModeForDevtools(!0);
+          try {
+            _instance = new Component(nextProps, state);
+          } finally {
+            setIsStrictModeForDevtools(!1);
+          }
+        }
+        state = workInProgress.memoizedState =
+          null !== _instance.state && void 0 !== _instance.state
+            ? _instance.state
+            : null;
+        _instance.updater = classComponentUpdater;
+        workInProgress.stateNode = _instance;
+        _instance._reactInternals = workInProgress;
+        _instance._reactInternalInstance = fakeInternalInstance;
+        "function" === typeof Component.getDerivedStateFromProps &&
+          null === state &&
+          ((state = getComponentNameFromType(Component) || "Component"),
+          didWarnAboutUninitializedState.has(state) ||
+            (didWarnAboutUninitializedState.add(state),
+            console.error(
+              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
+              state,
+              null === _instance.state ? "null" : "undefined",
+              state
+            )));
+        if (
+          "function" === typeof Component.getDerivedStateFromProps ||
+          "function" === typeof _instance.getSnapshotBeforeUpdate
+        ) {
+          var foundWillUpdateName = (lane = state = null);
+          "function" === typeof _instance.componentWillMount &&
+          !0 !== _instance.componentWillMount.__suppressDeprecationWarning
+            ? (state = "componentWillMount")
+            : "function" === typeof _instance.UNSAFE_componentWillMount &&
+              (state = "UNSAFE_componentWillMount");
+          "function" === typeof _instance.componentWillReceiveProps &&
+          !0 !==
+            _instance.componentWillReceiveProps.__suppressDeprecationWarning
+            ? (lane = "componentWillReceiveProps")
+            : "function" ===
+                typeof _instance.UNSAFE_componentWillReceiveProps &&
+              (lane = "UNSAFE_componentWillReceiveProps");
+          "function" === typeof _instance.componentWillUpdate &&
+          !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning
+            ? (foundWillUpdateName = "componentWillUpdate")
+            : "function" === typeof _instance.UNSAFE_componentWillUpdate &&
+              (foundWillUpdateName = "UNSAFE_componentWillUpdate");
+          if (null !== state || null !== lane || null !== foundWillUpdateName) {
+            _instance = getComponentNameFromType(Component) || "Component";
+            var newApiName =
+              "function" === typeof Component.getDerivedStateFromProps
+                ? "getDerivedStateFromProps()"
+                : "getSnapshotBeforeUpdate()";
+            didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) ||
+              (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance),
+              console.error(
+                "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
+                _instance,
+                newApiName,
+                null !== state ? "\n  " + state : "",
+                null !== lane ? "\n  " + lane : "",
+                null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
+              ));
+          }
+        }
+        _instance = workInProgress.stateNode;
+        state = getComponentNameFromType(Component) || "Component";
+        _instance.render ||
+          (Component.prototype &&
+          "function" === typeof Component.prototype.render
+            ? console.error(
+                "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
+                state
+              )
+            : console.error(
+                "No `render` method found on the %s instance: you may have forgotten to define `render`.",
+                state
+              ));
+        !_instance.getInitialState ||
+          _instance.getInitialState.isReactClassApproved ||
+          _instance.state ||
+          console.error(
+            "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
+            state
+          );
+        _instance.getDefaultProps &&
+          !_instance.getDefaultProps.isReactClassApproved &&
+          console.error(
+            "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
+            state
+          );
+        _instance.contextType &&
+          console.error(
+            "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
+            state
+          );
+        Component.childContextTypes &&
+          !didWarnAboutChildContextTypes.has(Component) &&
+          (didWarnAboutChildContextTypes.add(Component),
+          console.error(
+            "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
+            state
+          ));
+        Component.contextTypes &&
+          !didWarnAboutContextTypes$1.has(Component) &&
+          (didWarnAboutContextTypes$1.add(Component),
+          console.error(
+            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
+            state
+          ));
+        "function" === typeof _instance.componentShouldUpdate &&
+          console.error(
+            "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
+            state
+          );
+        Component.prototype &&
+          Component.prototype.isPureReactComponent &&
+          "undefined" !== typeof _instance.shouldComponentUpdate &&
+          console.error(
+            "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
+            getComponentNameFromType(Component) || "A pure component"
+          );
+        "function" === typeof _instance.componentDidUnmount &&
+          console.error(
+            "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
+            state
+          );
+        "function" === typeof _instance.componentDidReceiveProps &&
+          console.error(
+            "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
+            state
+          );
+        "function" === typeof _instance.componentWillRecieveProps &&
+          console.error(
+            "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
+            state
+          );
+        "function" === typeof _instance.UNSAFE_componentWillRecieveProps &&
+          console.error(
+            "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
+            state
+          );
+        lane = _instance.props !== nextProps;
+        void 0 !== _instance.props &&
+          lane &&
+          console.error(
+            "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
+            state
+          );
+        _instance.defaultProps &&
+          console.error(
+            "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
+            state,
+            state
+          );
+        "function" !== typeof _instance.getSnapshotBeforeUpdate ||
+          "function" === typeof _instance.componentDidUpdate ||
+          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) ||
+          (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component),
+          console.error(
+            "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
+            getComponentNameFromType(Component)
+          ));
+        "function" === typeof _instance.getDerivedStateFromProps &&
+          console.error(
+            "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
+            state
+          );
+        "function" === typeof _instance.getDerivedStateFromError &&
+          console.error(
+            "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
+            state
+          );
+        "function" === typeof Component.getSnapshotBeforeUpdate &&
+          console.error(
+            "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
+            state
+          );
+        (lane = _instance.state) &&
+          ("object" !== typeof lane || isArrayImpl(lane)) &&
+          console.error("%s.state: must be set to an object or null", state);
+        "function" === typeof _instance.getChildContext &&
+          "object" !== typeof Component.childContextTypes &&
+          console.error(
+            "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
+            state
+          );
+        _instance = workInProgress.stateNode;
+        _instance.props = nextProps;
+        _instance.state = workInProgress.memoizedState;
+        _instance.refs = {};
+        initializeUpdateQueue(workInProgress);
+        state = Component.contextType;
+        _instance.context =
+          "object" === typeof state && null !== state
+            ? readContext(state)
+            : emptyContextObject;
+        _instance.state === nextProps &&
+          ((state = getComponentNameFromType(Component) || "Component"),
+          didWarnAboutDirectlyAssigningPropsToState.has(state) ||
+            (didWarnAboutDirectlyAssigningPropsToState.add(state),
+            console.error(
+              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
+              state
+            )));
+        workInProgress.mode & StrictLegacyMode &&
+          ReactStrictModeWarnings.recordLegacyContextWarning(
+            workInProgress,
+            _instance
+          );
+        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
+          workInProgress,
+          _instance
+        );
+        _instance.state = workInProgress.memoizedState;
+        state = Component.getDerivedStateFromProps;
+        "function" === typeof state &&
+          (applyDerivedStateFromProps(
+            workInProgress,
+            Component,
+            state,
+            nextProps
+          ),
+          (_instance.state = workInProgress.memoizedState));
+        "function" === typeof Component.getDerivedStateFromProps ||
+          "function" === typeof _instance.getSnapshotBeforeUpdate ||
+          ("function" !== typeof _instance.UNSAFE_componentWillMount &&
+            "function" !== typeof _instance.componentWillMount) ||
+          ((state = _instance.state),
+          "function" === typeof _instance.componentWillMount &&
+            _instance.componentWillMount(),
+          "function" === typeof _instance.UNSAFE_componentWillMount &&
+            _instance.UNSAFE_componentWillMount(),
+          state !== _instance.state &&
+            (console.error(
+              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
+              getComponentNameFromFiber(workInProgress) || "Component"
+            ),
+            classComponentUpdater.enqueueReplaceState(
+              _instance,
+              _instance.state,
+              null
+            )),
+          processUpdateQueue(workInProgress, nextProps, _instance, renderLanes),
+          suspendIfUpdateReadFromEntangledAsyncAction(),
+          (_instance.state = workInProgress.memoizedState));
+        "function" === typeof _instance.componentDidMount &&
+          (workInProgress.flags |= 4194308);
+        (workInProgress.mode & StrictEffectsMode) !== NoMode &&
+          (workInProgress.flags |= 134217728);
+        _instance = !0;
+      } else if (null === current$jscomp$0) {
+        _instance = workInProgress.stateNode;
+        var unresolvedOldProps = workInProgress.memoizedProps;
+        lane = resolveClassComponentProps(Component, unresolvedOldProps);
+        _instance.props = lane;
+        var oldContext = _instance.context;
+        foundWillUpdateName = Component.contextType;
+        state = emptyContextObject;
+        "object" === typeof foundWillUpdateName &&
+          null !== foundWillUpdateName &&
+          (state = readContext(foundWillUpdateName));
+        newApiName = Component.getDerivedStateFromProps;
+        foundWillUpdateName =
+          "function" === typeof newApiName ||
+          "function" === typeof _instance.getSnapshotBeforeUpdate;
+        unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
+        foundWillUpdateName ||
+          ("function" !== typeof _instance.UNSAFE_componentWillReceiveProps &&
+            "function" !== typeof _instance.componentWillReceiveProps) ||
+          ((unresolvedOldProps || oldContext !== state) &&
+            callComponentWillReceiveProps(
+              workInProgress,
+              _instance,
+              nextProps,
+              state
+            ));
+        hasForceUpdate = !1;
+        var oldState = workInProgress.memoizedState;
+        _instance.state = oldState;
+        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
+        suspendIfUpdateReadFromEntangledAsyncAction();
+        oldContext = workInProgress.memoizedState;
+        unresolvedOldProps || oldState !== oldContext || hasForceUpdate
+          ? ("function" === typeof newApiName &&
+              (applyDerivedStateFromProps(
+                workInProgress,
+                Component,
+                newApiName,
+                nextProps
+              ),
+              (oldContext = workInProgress.memoizedState)),
+            (lane =
+              hasForceUpdate ||
+              checkShouldComponentUpdate(
+                workInProgress,
+                Component,
+                lane,
+                nextProps,
+                oldState,
+                oldContext,
+                state
+              ))
+              ? (foundWillUpdateName ||
+                  ("function" !== typeof _instance.UNSAFE_componentWillMount &&
+                    "function" !== typeof _instance.componentWillMount) ||
+                  ("function" === typeof _instance.componentWillMount &&
+                    _instance.componentWillMount(),
+                  "function" === typeof _instance.UNSAFE_componentWillMount &&
+                    _instance.UNSAFE_componentWillMount()),
+                "function" === typeof _instance.componentDidMount &&
+                  (workInProgress.flags |= 4194308),
+                (workInProgress.mode & StrictEffectsMode) !== NoMode &&
+                  (workInProgress.flags |= 134217728))
+              : ("function" === typeof _instance.componentDidMount &&
+                  (workInProgress.flags |= 4194308),
+                (workInProgress.mode & StrictEffectsMode) !== NoMode &&
+                  (workInProgress.flags |= 134217728),
+                (workInProgress.memoizedProps = nextProps),
+                (workInProgress.memoizedState = oldContext)),
+            (_instance.props = nextProps),
+            (_instance.state = oldContext),
+            (_instance.context = state),
+            (_instance = lane))
+          : ("function" === typeof _instance.componentDidMount &&
+              (workInProgress.flags |= 4194308),
+            (workInProgress.mode & StrictEffectsMode) !== NoMode &&
+              (workInProgress.flags |= 134217728),
+            (_instance = !1));
+      } else {
+        _instance = workInProgress.stateNode;
+        cloneUpdateQueue(current$jscomp$0, workInProgress);
+        state = workInProgress.memoizedProps;
+        foundWillUpdateName = resolveClassComponentProps(Component, state);
+        _instance.props = foundWillUpdateName;
+        newApiName = workInProgress.pendingProps;
+        oldState = _instance.context;
+        oldContext = Component.contextType;
+        lane = emptyContextObject;
+        "object" === typeof oldContext &&
+          null !== oldContext &&
+          (lane = readContext(oldContext));
+        unresolvedOldProps = Component.getDerivedStateFromProps;
+        (oldContext =
+          "function" === typeof unresolvedOldProps ||
+          "function" === typeof _instance.getSnapshotBeforeUpdate) ||
+          ("function" !== typeof _instance.UNSAFE_componentWillReceiveProps &&
+            "function" !== typeof _instance.componentWillReceiveProps) ||
+          ((state !== newApiName || oldState !== lane) &&
+            callComponentWillReceiveProps(
+              workInProgress,
+              _instance,
+              nextProps,
+              lane
+            ));
+        hasForceUpdate = !1;
+        oldState = workInProgress.memoizedState;
+        _instance.state = oldState;
+        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
+        suspendIfUpdateReadFromEntangledAsyncAction();
+        var newState = workInProgress.memoizedState;
+        state !== newApiName ||
+        oldState !== newState ||
+        hasForceUpdate ||
+        (null !== current$jscomp$0 &&
+          null !== current$jscomp$0.dependencies &&
+          checkIfContextChanged(current$jscomp$0.dependencies))
+          ? ("function" === typeof unresolvedOldProps &&
+              (applyDerivedStateFromProps(
+                workInProgress,
+                Component,
+                unresolvedOldProps,
+                nextProps
+              ),
+              (newState = workInProgress.memoizedState)),
+            (foundWillUpdateName =
+              hasForceUpdate ||
+              checkShouldComponentUpdate(
+                workInProgress,
+                Component,
+                foundWillUpdateName,
+                nextProps,
+                oldState,
+                newState,
+                lane
+              ) ||
+              (null !== current$jscomp$0 &&
+                null !== current$jscomp$0.dependencies &&
+                checkIfContextChanged(current$jscomp$0.dependencies)))
+              ? (oldContext ||
+                  ("function" !== typeof _instance.UNSAFE_componentWillUpdate &&
+                    "function" !== typeof _instance.componentWillUpdate) ||
+                  ("function" === typeof _instance.componentWillUpdate &&
+                    _instance.componentWillUpdate(nextProps, newState, lane),
+                  "function" === typeof _instance.UNSAFE_componentWillUpdate &&
+                    _instance.UNSAFE_componentWillUpdate(
+                      nextProps,
+                      newState,
+                      lane
+                    )),
+                "function" === typeof _instance.componentDidUpdate &&
+                  (workInProgress.flags |= 4),
+                "function" === typeof _instance.getSnapshotBeforeUpdate &&
+                  (workInProgress.flags |= 1024))
+              : ("function" !== typeof _instance.componentDidUpdate ||
+                  (state === current$jscomp$0.memoizedProps &&
+                    oldState === current$jscomp$0.memoizedState) ||
+                  (workInProgress.flags |= 4),
+                "function" !== typeof _instance.getSnapshotBeforeUpdate ||
+                  (state === current$jscomp$0.memoizedProps &&
+                    oldState === current$jscomp$0.memoizedState) ||
+                  (workInProgress.flags |= 1024),
+                (workInProgress.memoizedProps = nextProps),
+                (workInProgress.memoizedState = newState)),
+            (_instance.props = nextProps),
+            (_instance.state = newState),
+            (_instance.context = lane),
+            (_instance = foundWillUpdateName))
+          : ("function" !== typeof _instance.componentDidUpdate ||
+              (state === current$jscomp$0.memoizedProps &&
+                oldState === current$jscomp$0.memoizedState) ||
+              (workInProgress.flags |= 4),
+            "function" !== typeof _instance.getSnapshotBeforeUpdate ||
+              (state === current$jscomp$0.memoizedProps &&
+                oldState === current$jscomp$0.memoizedState) ||
+              (workInProgress.flags |= 1024),
+            (_instance = !1));
+      }
+      lane = _instance;
+      markRef(current$jscomp$0, workInProgress);
+      state = 0 !== (workInProgress.flags & 128);
+      if (lane || state) {
+        lane = workInProgress.stateNode;
+        ReactSharedInternals.getCurrentStack =
+          null === workInProgress ? null : getCurrentFiberStackInDev;
+        isRendering = !1;
+        current = workInProgress;
+        if (state && "function" !== typeof Component.getDerivedStateFromError)
+          (Component = null), (profilerStartTime = -1);
+        else if (
+          ((Component = callRenderInDEV(lane)),
+          workInProgress.mode & StrictLegacyMode)
+        ) {
+          setIsStrictModeForDevtools(!0);
+          try {
+            callRenderInDEV(lane);
+          } finally {
+            setIsStrictModeForDevtools(!1);
+          }
+        }
+        workInProgress.flags |= 1;
+        null !== current$jscomp$0 && state
+          ? ((workInProgress.child = reconcileChildFibers(
+              workInProgress,
+              current$jscomp$0.child,
+              null,
+              renderLanes
+            )),
+            (workInProgress.child = reconcileChildFibers(
+              workInProgress,
+              null,
+              Component,
+              renderLanes
+            )))
+          : reconcileChildren(
+              current$jscomp$0,
+              workInProgress,
+              Component,
+              renderLanes
+            );
+        workInProgress.memoizedState = lane.state;
+        current$jscomp$0 = workInProgress.child;
+      } else
+        current$jscomp$0 = bailoutOnAlreadyFinishedWork(
+          current$jscomp$0,
+          workInProgress,
+          renderLanes
+        );
+      renderLanes = workInProgress.stateNode;
+      _instance &&
+        renderLanes.props !== nextProps &&
+        (didWarnAboutReassigningProps ||
+          console.error(
+            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
+            getComponentNameFromFiber(workInProgress) || "a component"
+          ),
+        (didWarnAboutReassigningProps = !0));
+      return current$jscomp$0;
+    }
+    function mountHostRootWithoutHydrating(
+      current,
+      workInProgress,
+      nextChildren,
+      renderLanes
+    ) {
+      resetHydrationState();
+      workInProgress.flags |= 256;
+      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+      return workInProgress.child;
+    }
+    function validateFunctionComponentInDev(workInProgress, Component) {
+      Component &&
+        Component.childContextTypes &&
+        console.error(
+          "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
+          Component.displayName || Component.name || "Component"
+        );
+      "function" === typeof Component.getDerivedStateFromProps &&
+        ((workInProgress = getComponentNameFromType(Component) || "Unknown"),
+        didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] ||
+          (console.error(
+            "%s: Function components do not support getDerivedStateFromProps.",
+            workInProgress
+          ),
+          (didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] =
+            !0)));
+      "object" === typeof Component.contextType &&
+        null !== Component.contextType &&
+        ((Component = getComponentNameFromType(Component) || "Unknown"),
+        didWarnAboutContextTypeOnFunctionComponent[Component] ||
+          (console.error(
+            "%s: Function components do not support contextType.",
+            Component
+          ),
+          (didWarnAboutContextTypeOnFunctionComponent[Component] = !0)));
+    }
+    function mountSuspenseOffscreenState(renderLanes) {
+      return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
+    }
+    function getRemainingWorkInPrimaryTree(
+      current,
+      primaryTreeDidDefer,
+      renderLanes
+    ) {
+      current = null !== current ? current.childLanes & ~renderLanes : 0;
+      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
+      return current;
+    }
+    function updateSuspenseComponent(current, workInProgress, renderLanes) {
+      var JSCompiler_object_inline_componentStack_2586;
+      var JSCompiler_object_inline_stack_2585 = workInProgress.pendingProps;
+      shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);
+      var JSCompiler_object_inline_message_2583 = !1;
+      var didSuspend = 0 !== (workInProgress.flags & 128);
+      (JSCompiler_object_inline_componentStack_2586 = didSuspend) ||
+        (JSCompiler_object_inline_componentStack_2586 =
+          null !== current && null === current.memoizedState
+            ? !1
+            : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
+      JSCompiler_object_inline_componentStack_2586 &&
+        ((JSCompiler_object_inline_message_2583 = !0),
+        (workInProgress.flags &= -129));
+      JSCompiler_object_inline_componentStack_2586 =
+        0 !== (workInProgress.flags & 32);
+      workInProgress.flags &= -33;
+      if (null === current) {
+        if (isHydrating) {
+          JSCompiler_object_inline_message_2583
+            ? pushPrimaryTreeSuspenseHandler(workInProgress)
+            : reuseSuspenseHandlerOnStack(workInProgress);
+          if (isHydrating) {
+            var JSCompiler_object_inline_digest_2584 = nextHydratableInstance;
+            var JSCompiler_temp;
+            if (!(JSCompiler_temp = !JSCompiler_object_inline_digest_2584)) {
+              c: {
+                var instance = JSCompiler_object_inline_digest_2584;
+                for (
+                  JSCompiler_temp = rootOrSingletonContext;
+                  8 !== instance.nodeType;
+
+                ) {
+                  if (!JSCompiler_temp) {
+                    JSCompiler_temp = null;
+                    break c;
+                  }
+                  instance = getNextHydratable(instance.nextSibling);
+                  if (null === instance) {
+                    JSCompiler_temp = null;
+                    break c;
+                  }
+                }
+                JSCompiler_temp = instance;
+              }
+              null !== JSCompiler_temp
+                ? (warnIfNotHydrating(),
+                  (workInProgress.memoizedState = {
+                    dehydrated: JSCompiler_temp,
+                    treeContext:
+                      null !== treeContextProvider
+                        ? { id: treeContextId, overflow: treeContextOverflow }
+                        : null,
+                    retryLane: 536870912,
+                    hydrationErrors: null
+                  }),
+                  (instance = createFiber(18, null, null, NoMode)),
+                  (instance.stateNode = JSCompiler_temp),
+                  (instance.return = workInProgress),
+                  (workInProgress.child = instance),
+                  (hydrationParentFiber = workInProgress),
+                  (nextHydratableInstance = null),
+                  (JSCompiler_temp = !0))
+                : (JSCompiler_temp = !1);
+              JSCompiler_temp = !JSCompiler_temp;
+            }
+            JSCompiler_temp &&
+              (warnNonHydratedInstance(
+                workInProgress,
+                JSCompiler_object_inline_digest_2584
+              ),
+              throwOnHydrationMismatch(workInProgress));
+          }
+          JSCompiler_object_inline_digest_2584 = workInProgress.memoizedState;
+          if (
+            null !== JSCompiler_object_inline_digest_2584 &&
+            ((JSCompiler_object_inline_digest_2584 =
+              JSCompiler_object_inline_digest_2584.dehydrated),
+            null !== JSCompiler_object_inline_digest_2584)
+          )
+            return (
+              isSuspenseInstanceFallback(JSCompiler_object_inline_digest_2584)
+                ? (workInProgress.lanes = 32)
+                : (workInProgress.lanes = 536870912),
+              null
+            );
+          popSuspenseHandler(workInProgress);
+        }
+        JSCompiler_object_inline_digest_2584 =
+          JSCompiler_object_inline_stack_2585.children;
+        JSCompiler_temp = JSCompiler_object_inline_stack_2585.fallback;
+        if (JSCompiler_object_inline_message_2583)
+          return (
+            reuseSuspenseHandlerOnStack(workInProgress),
+            (JSCompiler_object_inline_stack_2585 =
+              mountSuspenseFallbackChildren(
+                workInProgress,
+                JSCompiler_object_inline_digest_2584,
+                JSCompiler_temp,
+                renderLanes
+              )),
+            (JSCompiler_object_inline_message_2583 = workInProgress.child),
+            (JSCompiler_object_inline_message_2583.memoizedState =
+              mountSuspenseOffscreenState(renderLanes)),
+            (JSCompiler_object_inline_message_2583.childLanes =
+              getRemainingWorkInPrimaryTree(
+                current,
+                JSCompiler_object_inline_componentStack_2586,
+                renderLanes
+              )),
+            (workInProgress.memoizedState = SUSPENDED_MARKER),
+            JSCompiler_object_inline_stack_2585
+          );
+        if (
+          "number" ===
+          typeof JSCompiler_object_inline_stack_2585.unstable_expectedLoadTime
+        )
+          return (
+            reuseSuspenseHandlerOnStack(workInProgress),
+            (JSCompiler_object_inline_stack_2585 =
+              mountSuspenseFallbackChildren(
+                workInProgress,
+                JSCompiler_object_inline_digest_2584,
+                JSCompiler_temp,
+                renderLanes
+              )),
+            (JSCompiler_object_inline_message_2583 = workInProgress.child),
+            (JSCompiler_object_inline_message_2583.memoizedState =
+              mountSuspenseOffscreenState(renderLanes)),
+            (JSCompiler_object_inline_message_2583.childLanes =
+              getRemainingWorkInPrimaryTree(
+                current,
+                JSCompiler_object_inline_componentStack_2586,
+                renderLanes
+              )),
+            (workInProgress.memoizedState = SUSPENDED_MARKER),
+            (workInProgress.lanes = 4194304),
+            JSCompiler_object_inline_stack_2585
+          );
+        pushPrimaryTreeSuspenseHandler(workInProgress);
+        return mountSuspensePrimaryChildren(
+          workInProgress,
+          JSCompiler_object_inline_digest_2584
+        );
+      }
+      var prevState = current.memoizedState;
+      if (
+        null !== prevState &&
+        ((JSCompiler_object_inline_digest_2584 = prevState.dehydrated),
+        null !== JSCompiler_object_inline_digest_2584)
+      ) {
+        if (didSuspend)
+          workInProgress.flags & 256
+            ? (pushPrimaryTreeSuspenseHandler(workInProgress),
+              (workInProgress.flags &= -257),
+              (workInProgress = retrySuspenseComponentWithoutHydrating(
+                current,
+                workInProgress,
+                renderLanes
+              )))
+            : null !== workInProgress.memoizedState
+              ? (reuseSuspenseHandlerOnStack(workInProgress),
+                (workInProgress.child = current.child),
+                (workInProgress.flags |= 128),
+                (workInProgress = null))
+              : (reuseSuspenseHandlerOnStack(workInProgress),
+                (JSCompiler_object_inline_message_2583 =
+                  JSCompiler_object_inline_stack_2585.fallback),
+                (JSCompiler_object_inline_digest_2584 = workInProgress.mode),
+                (JSCompiler_object_inline_stack_2585 =
+                  mountWorkInProgressOffscreenFiber(
+                    {
+                      mode: "visible",
+                      children: JSCompiler_object_inline_stack_2585.children
+                    },
+                    JSCompiler_object_inline_digest_2584
+                  )),
+                (JSCompiler_object_inline_message_2583 =
+                  createFiberFromFragment(
+                    JSCompiler_object_inline_message_2583,
+                    JSCompiler_object_inline_digest_2584,
+                    renderLanes,
+                    null
+                  )),
+                (JSCompiler_object_inline_message_2583.flags |= 2),
+                (JSCompiler_object_inline_stack_2585.return = workInProgress),
+                (JSCompiler_object_inline_message_2583.return = workInProgress),
+                (JSCompiler_object_inline_stack_2585.sibling =
+                  JSCompiler_object_inline_message_2583),
+                (workInProgress.child = JSCompiler_object_inline_stack_2585),
+                reconcileChildFibers(
+                  workInProgress,
+                  current.child,
+                  null,
+                  renderLanes
+                ),
+                (JSCompiler_object_inline_stack_2585 = workInProgress.child),
+                (JSCompiler_object_inline_stack_2585.memoizedState =
+                  mountSuspenseOffscreenState(renderLanes)),
+                (JSCompiler_object_inline_stack_2585.childLanes =
+                  getRemainingWorkInPrimaryTree(
+                    current,
+                    JSCompiler_object_inline_componentStack_2586,
+                    renderLanes
+                  )),
+                (workInProgress.memoizedState = SUSPENDED_MARKER),
+                (workInProgress = JSCompiler_object_inline_message_2583));
+        else if (
+          (pushPrimaryTreeSuspenseHandler(workInProgress),
+          isHydrating &&
+            console.error(
+              "We should not be hydrating here. This is a bug in React. Please file a bug."
+            ),
+          isSuspenseInstanceFallback(JSCompiler_object_inline_digest_2584))
+        ) {
+          JSCompiler_object_inline_componentStack_2586 =
+            JSCompiler_object_inline_digest_2584.nextSibling &&
+            JSCompiler_object_inline_digest_2584.nextSibling.dataset;
+          if (JSCompiler_object_inline_componentStack_2586) {
+            JSCompiler_temp = JSCompiler_object_inline_componentStack_2586.dgst;
+            var message = JSCompiler_object_inline_componentStack_2586.msg;
+            instance = JSCompiler_object_inline_componentStack_2586.stck;
+            var componentStack =
+              JSCompiler_object_inline_componentStack_2586.cstck;
+          }
+          JSCompiler_object_inline_message_2583 = message;
+          JSCompiler_object_inline_digest_2584 = JSCompiler_temp;
+          JSCompiler_object_inline_stack_2585 = instance;
+          JSCompiler_temp = JSCompiler_object_inline_componentStack_2586 =
+            componentStack;
+          "POSTPONE" !== JSCompiler_object_inline_digest_2584 &&
+            ((JSCompiler_object_inline_componentStack_2586 =
+              JSCompiler_object_inline_message_2583
+                ? Error(JSCompiler_object_inline_message_2583)
+                : Error(
+                    "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
+                  )),
+            (JSCompiler_object_inline_componentStack_2586.stack =
+              JSCompiler_object_inline_stack_2585 || ""),
+            (JSCompiler_object_inline_componentStack_2586.digest =
+              JSCompiler_object_inline_digest_2584),
+            (JSCompiler_object_inline_stack_2585 =
+              void 0 === JSCompiler_temp ? null : JSCompiler_temp),
+            (JSCompiler_object_inline_message_2583 = {
+              value: JSCompiler_object_inline_componentStack_2586,
+              source: null,
+              stack: JSCompiler_object_inline_stack_2585
+            }),
+            "string" === typeof JSCompiler_object_inline_stack_2585 &&
+              CapturedStacks.set(
+                JSCompiler_object_inline_componentStack_2586,
+                JSCompiler_object_inline_message_2583
+              ),
+            queueHydrationError(JSCompiler_object_inline_message_2583));
+          workInProgress = retrySuspenseComponentWithoutHydrating(
+            current,
+            workInProgress,
+            renderLanes
+          );
+        } else if (
+          (didReceiveUpdate ||
+            propagateParentContextChanges(
+              current,
+              workInProgress,
+              renderLanes,
+              !1
+            ),
+          (JSCompiler_object_inline_componentStack_2586 =
+            0 !== (renderLanes & current.childLanes)),
+          didReceiveUpdate || JSCompiler_object_inline_componentStack_2586)
+        ) {
+          JSCompiler_object_inline_componentStack_2586 = workInProgressRoot;
+          if (
+            null !== JSCompiler_object_inline_componentStack_2586 &&
+            ((JSCompiler_object_inline_stack_2585 = renderLanes & -renderLanes),
+            (JSCompiler_object_inline_stack_2585 =
+              0 !== (JSCompiler_object_inline_stack_2585 & 42)
+                ? 1
+                : getBumpedLaneForHydrationByLane(
+                    JSCompiler_object_inline_stack_2585
+                  )),
+            (JSCompiler_object_inline_stack_2585 =
+              0 !==
+              (JSCompiler_object_inline_stack_2585 &
+                (JSCompiler_object_inline_componentStack_2586.suspendedLanes |
+                  renderLanes))
+                ? 0
+                : JSCompiler_object_inline_stack_2585),
+            0 !== JSCompiler_object_inline_stack_2585 &&
+              JSCompiler_object_inline_stack_2585 !== prevState.retryLane)
+          )
+            throw (
+              ((prevState.retryLane = JSCompiler_object_inline_stack_2585),
+              enqueueConcurrentRenderForLane(
+                current,
+                JSCompiler_object_inline_stack_2585
+              ),
+              scheduleUpdateOnFiber(
+                JSCompiler_object_inline_componentStack_2586,
+                current,
+                JSCompiler_object_inline_stack_2585
+              ),
+              SelectiveHydrationException)
+            );
+          JSCompiler_object_inline_digest_2584.data ===
+            SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
+          workInProgress = retrySuspenseComponentWithoutHydrating(
+            current,
+            workInProgress,
+            renderLanes
+          );
+        } else
+          JSCompiler_object_inline_digest_2584.data ===
+          SUSPENSE_PENDING_START_DATA
+            ? ((workInProgress.flags |= 192),
+              (workInProgress.child = current.child),
+              (workInProgress = null))
+            : ((current = prevState.treeContext),
+              (nextHydratableInstance = getNextHydratable(
+                JSCompiler_object_inline_digest_2584.nextSibling
+              )),
+              (hydrationParentFiber = workInProgress),
+              (isHydrating = !0),
+              (hydrationErrors = null),
+              (didSuspendOrErrorDEV = !1),
+              (hydrationDiffRootDEV = null),
+              (rootOrSingletonContext = !1),
+              null !== current &&
+                (warnIfNotHydrating(),
+                (idStack[idStackIndex++] = treeContextId),
+                (idStack[idStackIndex++] = treeContextOverflow),
+                (idStack[idStackIndex++] = treeContextProvider),
+                (treeContextId = current.id),
+                (treeContextOverflow = current.overflow),
+                (treeContextProvider = workInProgress)),
+              (workInProgress = mountSuspensePrimaryChildren(
+                workInProgress,
+                JSCompiler_object_inline_stack_2585.children
+              )),
+              (workInProgress.flags |= 4096));
+        return workInProgress;
+      }
+      if (JSCompiler_object_inline_message_2583)
+        return (
+          reuseSuspenseHandlerOnStack(workInProgress),
+          (JSCompiler_object_inline_message_2583 =
+            JSCompiler_object_inline_stack_2585.fallback),
+          (JSCompiler_object_inline_digest_2584 = workInProgress.mode),
+          (JSCompiler_temp = current.child),
+          (instance = JSCompiler_temp.sibling),
+          (JSCompiler_object_inline_stack_2585 = createWorkInProgress(
+            JSCompiler_temp,
+            {
+              mode: "hidden",
+              children: JSCompiler_object_inline_stack_2585.children
+            }
+          )),
+          (JSCompiler_object_inline_stack_2585.subtreeFlags =
+            JSCompiler_temp.subtreeFlags & 65011712),
+          null !== instance
+            ? (JSCompiler_object_inline_message_2583 = createWorkInProgress(
+                instance,
+                JSCompiler_object_inline_message_2583
+              ))
+            : ((JSCompiler_object_inline_message_2583 = createFiberFromFragment(
+                JSCompiler_object_inline_message_2583,
+                JSCompiler_object_inline_digest_2584,
+                renderLanes,
+                null
+              )),
+              (JSCompiler_object_inline_message_2583.flags |= 2)),
+          (JSCompiler_object_inline_message_2583.return = workInProgress),
+          (JSCompiler_object_inline_stack_2585.return = workInProgress),
+          (JSCompiler_object_inline_stack_2585.sibling =
+            JSCompiler_object_inline_message_2583),
+          (workInProgress.child = JSCompiler_object_inline_stack_2585),
+          (JSCompiler_object_inline_stack_2585 =
+            JSCompiler_object_inline_message_2583),
+          (JSCompiler_object_inline_message_2583 = workInProgress.child),
+          (JSCompiler_object_inline_digest_2584 = current.child.memoizedState),
+          null === JSCompiler_object_inline_digest_2584
+            ? (JSCompiler_object_inline_digest_2584 =
+                mountSuspenseOffscreenState(renderLanes))
+            : ((JSCompiler_temp =
+                JSCompiler_object_inline_digest_2584.cachePool),
+              null !== JSCompiler_temp
+                ? ((instance = CacheContext._currentValue),
+                  (JSCompiler_temp =
+                    JSCompiler_temp.parent !== instance
+                      ? { parent: instance, pool: instance }
+                      : JSCompiler_temp))
+                : (JSCompiler_temp = getSuspendedCache()),
+              (JSCompiler_object_inline_digest_2584 = {
+                baseLanes:
+                  JSCompiler_object_inline_digest_2584.baseLanes | renderLanes,
+                cachePool: JSCompiler_temp
+              })),
+          (JSCompiler_object_inline_message_2583.memoizedState =
+            JSCompiler_object_inline_digest_2584),
+          (JSCompiler_object_inline_message_2583.childLanes =
+            getRemainingWorkInPrimaryTree(
+              current,
+              JSCompiler_object_inline_componentStack_2586,
+              renderLanes
+            )),
+          (workInProgress.memoizedState = SUSPENDED_MARKER),
+          JSCompiler_object_inline_stack_2585
+        );
+      pushPrimaryTreeSuspenseHandler(workInProgress);
+      renderLanes = current.child;
+      current = renderLanes.sibling;
+      renderLanes = createWorkInProgress(renderLanes, {
+        mode: "visible",
+        children: JSCompiler_object_inline_stack_2585.children
+      });
+      renderLanes.return = workInProgress;
+      renderLanes.sibling = null;
+      null !== current &&
+        ((JSCompiler_object_inline_componentStack_2586 =
+          workInProgress.deletions),
+        null === JSCompiler_object_inline_componentStack_2586
+          ? ((workInProgress.deletions = [current]),
+            (workInProgress.flags |= 16))
+          : JSCompiler_object_inline_componentStack_2586.push(current));
+      workInProgress.child = renderLanes;
+      workInProgress.memoizedState = null;
+      return renderLanes;
+    }
+    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
+      primaryChildren = mountWorkInProgressOffscreenFiber(
+        { mode: "visible", children: primaryChildren },
+        workInProgress.mode
+      );
+      primaryChildren.return = workInProgress;
+      return (workInProgress.child = primaryChildren);
+    }
+    function mountSuspenseFallbackChildren(
+      workInProgress,
+      primaryChildren,
+      fallbackChildren,
+      renderLanes
+    ) {
+      var mode = workInProgress.mode;
+      primaryChildren = mountWorkInProgressOffscreenFiber(
+        { mode: "hidden", children: primaryChildren },
+        mode
+      );
+      fallbackChildren = createFiberFromFragment(
+        fallbackChildren,
+        mode,
+        renderLanes,
+        null
+      );
+      primaryChildren.return = workInProgress;
+      fallbackChildren.return = workInProgress;
+      primaryChildren.sibling = fallbackChildren;
+      workInProgress.child = primaryChildren;
+      return fallbackChildren;
+    }
+    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
+      return createFiberFromOffscreen(offscreenProps, mode, 0, null);
+    }
+    function retrySuspenseComponentWithoutHydrating(
+      current,
+      workInProgress,
+      renderLanes
+    ) {
+      reconcileChildFibers(workInProgress, current.child, null, renderLanes);
+      current = mountSuspensePrimaryChildren(
+        workInProgress,
+        workInProgress.pendingProps.children
+      );
+      current.flags |= 2;
+      workInProgress.memoizedState = null;
+      return current;
+    }
+    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
+      fiber.lanes |= renderLanes;
+      var alternate = fiber.alternate;
+      null !== alternate && (alternate.lanes |= renderLanes);
+      scheduleContextWorkOnParentPath(
+        fiber.return,
+        renderLanes,
+        propagationRoot
+      );
+    }
+    function validateSuspenseListNestedChild(childSlot, index) {
+      var isAnArray = isArrayImpl(childSlot);
+      childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
+      return isAnArray || childSlot
+        ? ((isAnArray = isAnArray ? "array" : "iterable"),
+          console.error(
+            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
+            isAnArray,
+            index,
+            isAnArray
+          ),
+          !1)
+        : !0;
+    }
+    function initSuspenseListRenderState(
+      workInProgress,
+      isBackwards,
+      tail,
+      lastContentRow,
+      tailMode
+    ) {
+      var renderState = workInProgress.memoizedState;
+      null === renderState
+        ? (workInProgress.memoizedState = {
+            isBackwards: isBackwards,
+            rendering: null,
+            renderingStartTime: 0,
+            last: lastContentRow,
+            tail: tail,
+            tailMode: tailMode
+          })
+        : ((renderState.isBackwards = isBackwards),
+          (renderState.rendering = null),
+          (renderState.renderingStartTime = 0),
+          (renderState.last = lastContentRow),
+          (renderState.tail = tail),
+          (renderState.tailMode = tailMode));
+    }
+    function updateSuspenseListComponent(current, workInProgress, renderLanes) {
+      var nextProps = workInProgress.pendingProps,
+        revealOrder = nextProps.revealOrder,
+        tailMode = nextProps.tail;
+      nextProps = nextProps.children;
+      if (
+        void 0 !== revealOrder &&
+        "forwards" !== revealOrder &&
+        "backwards" !== revealOrder &&
+        "together" !== revealOrder &&
+        !didWarnAboutRevealOrder[revealOrder]
+      )
+        if (
+          ((didWarnAboutRevealOrder[revealOrder] = !0),
+          "string" === typeof revealOrder)
+        )
+          switch (revealOrder.toLowerCase()) {
+            case "together":
+            case "forwards":
+            case "backwards":
+              console.error(
+                '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
+                revealOrder,
+                revealOrder.toLowerCase()
+              );
+              break;
+            case "forward":
+            case "backward":
+              console.error(
+                '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
+                revealOrder,
+                revealOrder.toLowerCase()
+              );
+              break;
+            default:
+              console.error(
+                '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
+                revealOrder
+              );
+          }
+        else
+          console.error(
+            '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
+            revealOrder
+          );
+      void 0 === tailMode ||
+        didWarnAboutTailOptions[tailMode] ||
+        ("collapsed" !== tailMode && "hidden" !== tailMode
+          ? ((didWarnAboutTailOptions[tailMode] = !0),
+            console.error(
+              '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
+              tailMode
+            ))
+          : "forwards" !== revealOrder &&
+            "backwards" !== revealOrder &&
+            ((didWarnAboutTailOptions[tailMode] = !0),
+            console.error(
+              '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
+              tailMode
+            )));
+      a: if (
+        ("forwards" === revealOrder || "backwards" === revealOrder) &&
+        void 0 !== nextProps &&
+        null !== nextProps &&
+        !1 !== nextProps
+      )
+        if (isArrayImpl(nextProps))
+          for (var i = 0; i < nextProps.length; i++) {
+            if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
+          }
+        else if (((i = getIteratorFn(nextProps)), "function" === typeof i)) {
+          if ((i = i.call(nextProps)))
+            for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
+              if (!validateSuspenseListNestedChild(step.value, _i)) break a;
+              _i++;
+            }
+        } else
+          console.error(
+            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
+            revealOrder
+          );
+      reconcileChildren(current, workInProgress, nextProps, renderLanes);
+      nextProps = suspenseStackCursor.current;
+      if (0 !== (nextProps & ForceSuspenseFallback))
+        (nextProps =
+          (nextProps & SubtreeSuspenseContextMask) | ForceSuspenseFallback),
+          (workInProgress.flags |= 128);
+      else {
+        if (null !== current && 0 !== (current.flags & 128))
+          a: for (current = workInProgress.child; null !== current; ) {
+            if (13 === current.tag)
+              null !== current.memoizedState &&
+                scheduleSuspenseWorkOnFiber(
+                  current,
+                  renderLanes,
+                  workInProgress
+                );
+            else if (19 === current.tag)
+              scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
+            else if (null !== current.child) {
+              current.child.return = current;
+              current = current.child;
+              continue;
+            }
+            if (current === workInProgress) break a;
+            for (; null === current.sibling; ) {
+              if (null === current.return || current.return === workInProgress)
+                break a;
+              current = current.return;
+            }
+            current.sibling.return = current.return;
+            current = current.sibling;
+          }
+        nextProps &= SubtreeSuspenseContextMask;
+      }
+      push(suspenseStackCursor, nextProps, workInProgress);
+      switch (revealOrder) {
+        case "forwards":
+          renderLanes = workInProgress.child;
+          for (revealOrder = null; null !== renderLanes; )
+            (current = renderLanes.alternate),
+              null !== current &&
+                null === findFirstSuspended(current) &&
+                (revealOrder = renderLanes),
+              (renderLanes = renderLanes.sibling);
+          renderLanes = revealOrder;
+          null === renderLanes
+            ? ((revealOrder = workInProgress.child),
+              (workInProgress.child = null))
+            : ((revealOrder = renderLanes.sibling),
+              (renderLanes.sibling = null));
+          initSuspenseListRenderState(
+            workInProgress,
+            !1,
+            revealOrder,
+            renderLanes,
+            tailMode
+          );
+          break;
+        case "backwards":
+          renderLanes = null;
+          revealOrder = workInProgress.child;
+          for (workInProgress.child = null; null !== revealOrder; ) {
+            current = revealOrder.alternate;
+            if (null !== current && null === findFirstSuspended(current)) {
+              workInProgress.child = revealOrder;
+              break;
+            }
+            current = revealOrder.sibling;
+            revealOrder.sibling = renderLanes;
+            renderLanes = revealOrder;
+            revealOrder = current;
+          }
+          initSuspenseListRenderState(
+            workInProgress,
+            !0,
+            renderLanes,
+            null,
+            tailMode
+          );
+          break;
+        case "together":
+          initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
+          break;
+        default:
+          workInProgress.memoizedState = null;
+      }
+      return workInProgress.child;
+    }
+    function bailoutOnAlreadyFinishedWork(
+      current,
+      workInProgress,
+      renderLanes
+    ) {
+      null !== current && (workInProgress.dependencies = current.dependencies);
+      profilerStartTime = -1;
+      workInProgressRootSkippedLanes |= workInProgress.lanes;
+      if (0 === (renderLanes & workInProgress.childLanes))
+        if (null !== current) {
+          if (
+            (propagateParentContextChanges(
+              current,
+              workInProgress,
+              renderLanes,
+              !1
+            ),
+            0 === (renderLanes & workInProgress.childLanes))
+          )
+            return null;
+        } else return null;
+      if (null !== current && workInProgress.child !== current.child)
+        throw Error("Resuming work not yet implemented.");
+      if (null !== workInProgress.child) {
+        current = workInProgress.child;
+        renderLanes = createWorkInProgress(current, current.pendingProps);
+        workInProgress.child = renderLanes;
+        for (renderLanes.return = workInProgress; null !== current.sibling; )
+          (current = current.sibling),
+            (renderLanes = renderLanes.sibling =
+              createWorkInProgress(current, current.pendingProps)),
+            (renderLanes.return = workInProgress);
+        renderLanes.sibling = null;
+      }
+      return workInProgress.child;
+    }
+    function checkScheduledUpdateOrContext(current, renderLanes) {
+      if (0 !== (current.lanes & renderLanes)) return !0;
+      current = current.dependencies;
+      return null !== current && checkIfContextChanged(current) ? !0 : !1;
+    }
+    function attemptEarlyBailoutIfNoScheduledUpdate(
+      current,
+      workInProgress,
+      renderLanes
+    ) {
+      switch (workInProgress.tag) {
+        case 3:
+          pushHostContainer(
+            workInProgress,
+            workInProgress.stateNode.containerInfo
+          );
+          pushProvider(
+            workInProgress,
+            CacheContext,
+            current.memoizedState.cache
+          );
+          resetHydrationState();
+          break;
+        case 27:
+        case 5:
+          pushHostContext(workInProgress);
+          break;
+        case 4:
+          pushHostContainer(
+            workInProgress,
+            workInProgress.stateNode.containerInfo
+          );
+          break;
+        case 10:
+          pushProvider(
+            workInProgress,
+            workInProgress.type,
+            workInProgress.memoizedProps.value
+          );
+          break;
+        case 12:
+          0 !== (renderLanes & workInProgress.childLanes) &&
+            (workInProgress.flags |= 4);
+          workInProgress.flags |= 2048;
+          var stateNode = workInProgress.stateNode;
+          stateNode.effectDuration = -0;
+          stateNode.passiveEffectDuration = -0;
+          break;
+        case 13:
+          stateNode = workInProgress.memoizedState;
+          if (null !== stateNode) {
+            if (null !== stateNode.dehydrated)
+              return (
+                pushPrimaryTreeSuspenseHandler(workInProgress),
+                (workInProgress.flags |= 128),
+                null
+              );
+            if (0 !== (renderLanes & workInProgress.child.childLanes))
+              return updateSuspenseComponent(
+                current,
+                workInProgress,
+                renderLanes
+              );
+            pushPrimaryTreeSuspenseHandler(workInProgress);
+            current = bailoutOnAlreadyFinishedWork(
+              current,
+              workInProgress,
+              renderLanes
+            );
+            return null !== current ? current.sibling : null;
+          }
+          pushPrimaryTreeSuspenseHandler(workInProgress);
+          break;
+        case 19:
+          var didSuspendBefore = 0 !== (current.flags & 128);
+          stateNode = 0 !== (renderLanes & workInProgress.childLanes);
+          stateNode ||
+            (propagateParentContextChanges(
+              current,
+              workInProgress,
+              renderLanes,
+              !1
+            ),
+            (stateNode = 0 !== (renderLanes & workInProgress.childLanes)));
+          if (didSuspendBefore) {
+            if (stateNode)
+              return updateSuspenseListComponent(
+                current,
+                workInProgress,
+                renderLanes
+              );
+            workInProgress.flags |= 128;
+          }
+          didSuspendBefore = workInProgress.memoizedState;
+          null !== didSuspendBefore &&
+            ((didSuspendBefore.rendering = null),
+            (didSuspendBefore.tail = null),
+            (didSuspendBefore.lastEffect = null));
+          push(
+            suspenseStackCursor,
+            suspenseStackCursor.current,
+            workInProgress
+          );
+          if (stateNode) break;
+          else return null;
+        case 22:
+        case 23:
+          return (
+            (workInProgress.lanes = 0),
+            updateOffscreenComponent(current, workInProgress, renderLanes)
+          );
+        case 24:
+          pushProvider(
+            workInProgress,
+            CacheContext,
+            current.memoizedState.cache
+          );
+      }
+      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
+    }
+    function beginWork(current, workInProgress, renderLanes) {
+      if (workInProgress._debugNeedsRemount && null !== current) {
+        renderLanes = createFiberFromTypeAndProps(
+          workInProgress.type,
+          workInProgress.key,
+          workInProgress.pendingProps,
+          workInProgress._debugOwner || null,
+          workInProgress.mode,
+          workInProgress.lanes
+        );
+        renderLanes._debugStack = workInProgress._debugStack;
+        renderLanes._debugTask = workInProgress._debugTask;
+        var returnFiber = workInProgress.return;
+        if (null === returnFiber) throw Error("Cannot swap the root fiber.");
+        current.alternate = null;
+        workInProgress.alternate = null;
+        renderLanes.index = workInProgress.index;
+        renderLanes.sibling = workInProgress.sibling;
+        renderLanes.return = workInProgress.return;
+        renderLanes.ref = workInProgress.ref;
+        renderLanes._debugInfo = workInProgress._debugInfo;
+        if (workInProgress === returnFiber.child)
+          returnFiber.child = renderLanes;
+        else {
+          var prevSibling = returnFiber.child;
+          if (null === prevSibling)
+            throw Error("Expected parent to have a child.");
+          for (; prevSibling.sibling !== workInProgress; )
+            if (((prevSibling = prevSibling.sibling), null === prevSibling))
+              throw Error("Expected to find the previous sibling.");
+          prevSibling.sibling = renderLanes;
+        }
+        workInProgress = returnFiber.deletions;
+        null === workInProgress
+          ? ((returnFiber.deletions = [current]), (returnFiber.flags |= 16))
+          : workInProgress.push(current);
+        renderLanes.flags |= 2;
+        return renderLanes;
+      }
+      if (null !== current)
+        if (
+          current.memoizedProps !== workInProgress.pendingProps ||
+          workInProgress.type !== current.type
+        )
+          didReceiveUpdate = !0;
+        else {
+          if (
+            !checkScheduledUpdateOrContext(current, renderLanes) &&
+            0 === (workInProgress.flags & 128)
+          )
+            return (
+              (didReceiveUpdate = !1),
+              attemptEarlyBailoutIfNoScheduledUpdate(
+                current,
+                workInProgress,
+                renderLanes
+              )
+            );
+          didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
+        }
+      else {
+        didReceiveUpdate = !1;
+        if ((returnFiber = isHydrating))
+          warnIfNotHydrating(),
+            (returnFiber = 0 !== (workInProgress.flags & 1048576));
+        returnFiber &&
+          ((returnFiber = workInProgress.index),
+          warnIfNotHydrating(),
+          pushTreeId(workInProgress, treeForkCount, returnFiber));
+      }
+      workInProgress.lanes = 0;
+      switch (workInProgress.tag) {
+        case 16:
+          a: if (
+            ((returnFiber = workInProgress.pendingProps),
+            (current = callLazyInitInDEV(workInProgress.elementType)),
+            (workInProgress.type = current),
+            "function" === typeof current)
+          )
+            shouldConstruct(current)
+              ? ((returnFiber = resolveClassComponentProps(
+                  current,
+                  returnFiber
+                )),
+                (workInProgress.tag = 1),
+                (workInProgress.type = current =
+                  resolveFunctionForHotReloading(current)),
+                (workInProgress = updateClassComponent(
+                  null,
+                  workInProgress,
+                  current,
+                  returnFiber,
+                  renderLanes
+                )))
+              : ((workInProgress.tag = 0),
+                validateFunctionComponentInDev(workInProgress, current),
+                (workInProgress.type = current =
+                  resolveFunctionForHotReloading(current)),
+                (workInProgress = updateFunctionComponent(
+                  null,
+                  workInProgress,
+                  current,
+                  returnFiber,
+                  renderLanes
+                )));
+          else {
+            if (void 0 !== current && null !== current)
+              if (
+                ((prevSibling = current.$$typeof),
+                prevSibling === REACT_FORWARD_REF_TYPE)
+              ) {
+                workInProgress.tag = 11;
+                workInProgress.type = current =
+                  resolveForwardRefForHotReloading(current);
+                workInProgress = updateForwardRef(
+                  null,
+                  workInProgress,
+                  current,
+                  returnFiber,
+                  renderLanes
+                );
+                break a;
+              } else if (prevSibling === REACT_MEMO_TYPE) {
+                workInProgress.tag = 14;
+                workInProgress = updateMemoComponent(
+                  null,
+                  workInProgress,
+                  current,
+                  returnFiber,
+                  renderLanes
+                );
+                break a;
+              }
+            workInProgress = "";
+            null !== current &&
+              "object" === typeof current &&
+              current.$$typeof === REACT_LAZY_TYPE &&
+              (workInProgress =
+                " Did you wrap a component in React.lazy() more than once?");
+            current = getComponentNameFromType(current) || current;
+            throw Error(
+              "Element type is invalid. Received a promise that resolves to: " +
+                current +
+                ". Lazy element type must resolve to a class or function." +
+                workInProgress
+            );
+          }
+          return workInProgress;
+        case 0:
+          return updateFunctionComponent(
+            current,
+            workInProgress,
+            workInProgress.type,
+            workInProgress.pendingProps,
+            renderLanes
+          );
+        case 1:
+          return (
+            (returnFiber = workInProgress.type),
+            (prevSibling = resolveClassComponentProps(
+              returnFiber,
+              workInProgress.pendingProps
+            )),
+            updateClassComponent(
+              current,
+              workInProgress,
+              returnFiber,
+              prevSibling,
+              renderLanes
+            )
+          );
+        case 3:
+          a: {
+            pushHostContainer(
+              workInProgress,
+              workInProgress.stateNode.containerInfo
+            );
+            if (null === current)
+              throw Error(
+                "Should have a current fiber. This is a bug in React."
+              );
+            var nextProps = workInProgress.pendingProps;
+            prevSibling = workInProgress.memoizedState;
+            returnFiber = prevSibling.element;
+            cloneUpdateQueue(current, workInProgress);
+            processUpdateQueue(workInProgress, nextProps, null, renderLanes);
+            var nextState = workInProgress.memoizedState;
+            nextProps = nextState.cache;
+            pushProvider(workInProgress, CacheContext, nextProps);
+            nextProps !== prevSibling.cache &&
+              propagateContextChanges(
+                workInProgress,
+                [CacheContext],
+                renderLanes,
+                !0
+              );
+            suspendIfUpdateReadFromEntangledAsyncAction();
+            nextProps = nextState.element;
+            if (prevSibling.isDehydrated)
+              if (
+                ((prevSibling = {
+                  element: nextProps,
+                  isDehydrated: !1,
+                  cache: nextState.cache
+                }),
+                (workInProgress.updateQueue.baseState = prevSibling),
+                (workInProgress.memoizedState = prevSibling),
+                workInProgress.flags & 256)
+              ) {
+                workInProgress = mountHostRootWithoutHydrating(
+                  current,
+                  workInProgress,
+                  nextProps,
+                  renderLanes
+                );
+                break a;
+              } else if (nextProps !== returnFiber) {
+                returnFiber = createCapturedValueAtFiber(
+                  Error(
+                    "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
+                  ),
+                  workInProgress
+                );
+                queueHydrationError(returnFiber);
+                workInProgress = mountHostRootWithoutHydrating(
+                  current,
+                  workInProgress,
+                  nextProps,
+                  renderLanes
+                );
+                break a;
+              } else
+                for (
+                  nextHydratableInstance = getNextHydratable(
+                    workInProgress.stateNode.containerInfo.firstChild
+                  ),
+                    hydrationParentFiber = workInProgress,
+                    isHydrating = !0,
+                    hydrationErrors = null,
+                    didSuspendOrErrorDEV = !1,
+                    hydrationDiffRootDEV = null,
+                    rootOrSingletonContext = !0,
+                    current = mountChildFibers(
+                      workInProgress,
+                      null,
+                      nextProps,
+                      renderLanes
+                    ),
+                    workInProgress.child = current;
+                  current;
+
+                )
+                  (current.flags = (current.flags & -3) | 4096),
+                    (current = current.sibling);
+            else {
+              resetHydrationState();
+              if (nextProps === returnFiber) {
+                workInProgress = bailoutOnAlreadyFinishedWork(
+                  current,
+                  workInProgress,
+                  renderLanes
+                );
+                break a;
+              }
+              reconcileChildren(
+                current,
+                workInProgress,
+                nextProps,
+                renderLanes
+              );
+            }
+            workInProgress = workInProgress.child;
+          }
+          return workInProgress;
+        case 26:
+          return (
+            markRef(current, workInProgress),
+            null === current
+              ? (current = getResource(
+                  workInProgress.type,
+                  null,
+                  workInProgress.pendingProps,
+                  null
+                ))
+                ? (workInProgress.memoizedState = current)
+                : isHydrating ||
+                  ((current = workInProgress.type),
+                  (renderLanes = workInProgress.pendingProps),
+                  (returnFiber = requiredContext(
+                    rootInstanceStackCursor.current
+                  )),
+                  (returnFiber =
+                    getOwnerDocumentFromRootContainer(
+                      returnFiber
+                    ).createElement(current)),
+                  (returnFiber[internalInstanceKey] = workInProgress),
+                  (returnFiber[internalPropsKey] = renderLanes),
+                  setInitialProperties(returnFiber, current, renderLanes),
+                  markNodeAsHoistable(returnFiber),
+                  (workInProgress.stateNode = returnFiber))
+              : (workInProgress.memoizedState = getResource(
+                  workInProgress.type,
+                  current.memoizedProps,
+                  workInProgress.pendingProps,
+                  current.memoizedState
+                )),
+            null
+          );
+        case 27:
+          return (
+            pushHostContext(workInProgress),
+            null === current &&
+              isHydrating &&
+              ((prevSibling = requiredContext(rootInstanceStackCursor.current)),
+              (returnFiber = getHostContext()),
+              (prevSibling = workInProgress.stateNode =
+                resolveSingletonInstance(
+                  workInProgress.type,
+                  workInProgress.pendingProps,
+                  prevSibling,
+                  returnFiber,
+                  !1
+                )),
+              didSuspendOrErrorDEV ||
+                ((returnFiber = diffHydratedProperties(
+                  prevSibling,
+                  workInProgress.type,
+                  workInProgress.pendingProps,
+                  returnFiber
+                )),
+                null !== returnFiber &&
+                  (buildHydrationDiffNode(workInProgress, 0).serverProps =
+                    returnFiber)),
+              (hydrationParentFiber = workInProgress),
+              (rootOrSingletonContext = !0),
+              (nextHydratableInstance = getNextHydratable(
+                prevSibling.firstChild
+              ))),
+            (returnFiber = workInProgress.pendingProps.children),
+            null !== current || isHydrating
+              ? reconcileChildren(
+                  current,
+                  workInProgress,
+                  returnFiber,
+                  renderLanes
+                )
+              : (workInProgress.child = reconcileChildFibers(
+                  workInProgress,
+                  null,
+                  returnFiber,
+                  renderLanes
+                )),
+            markRef(current, workInProgress),
+            workInProgress.child
+          );
+        case 5:
+          return (
+            null === current &&
+              isHydrating &&
+              ((nextProps = getHostContext()),
+              (returnFiber = validateDOMNesting(
+                workInProgress.type,
+                nextProps.ancestorInfo
+              )),
+              (prevSibling = nextHydratableInstance),
+              (nextState = !prevSibling) ||
+                ((nextState = canHydrateInstance(
+                  prevSibling,
+                  workInProgress.type,
+                  workInProgress.pendingProps,
+                  rootOrSingletonContext
+                )),
+                null !== nextState
+                  ? ((workInProgress.stateNode = nextState),
+                    didSuspendOrErrorDEV ||
+                      ((nextProps = diffHydratedProperties(
+                        nextState,
+                        workInProgress.type,
+                        workInProgress.pendingProps,
+                        nextProps
+                      )),
+                      null !== nextProps &&
+                        (buildHydrationDiffNode(workInProgress, 0).serverProps =
+                          nextProps)),
+                    (hydrationParentFiber = workInProgress),
+                    (nextHydratableInstance = getNextHydratable(
+                      nextState.firstChild
+                    )),
+                    (rootOrSingletonContext = !1),
+                    (nextProps = !0))
+                  : (nextProps = !1),
+                (nextState = !nextProps)),
+              nextState &&
+                (returnFiber &&
+                  warnNonHydratedInstance(workInProgress, prevSibling),
+                throwOnHydrationMismatch(workInProgress))),
+            pushHostContext(workInProgress),
+            (prevSibling = workInProgress.type),
+            (nextProps = workInProgress.pendingProps),
+            (nextState = null !== current ? current.memoizedProps : null),
+            (returnFiber = nextProps.children),
+            shouldSetTextContent(prevSibling, nextProps)
+              ? (returnFiber = null)
+              : null !== nextState &&
+                shouldSetTextContent(prevSibling, nextState) &&
+                (workInProgress.flags |= 32),
+            null !== workInProgress.memoizedState &&
+              ((prevSibling = renderWithHooks(
+                current,
+                workInProgress,
+                TransitionAwareHostComponent,
+                null,
+                null,
+                renderLanes
+              )),
+              (HostTransitionContext._currentValue = prevSibling)),
+            markRef(current, workInProgress),
+            reconcileChildren(
+              current,
+              workInProgress,
+              returnFiber,
+              renderLanes
+            ),
+            workInProgress.child
+          );
+        case 6:
+          return (
+            null === current &&
+              isHydrating &&
+              ((current = workInProgress.pendingProps),
+              (renderLanes = getHostContext().ancestorInfo.current),
+              (current =
+                null != renderLanes
+                  ? validateTextNesting(current, renderLanes.tag)
+                  : !0),
+              (renderLanes = nextHydratableInstance),
+              (returnFiber = !renderLanes) ||
+                ((returnFiber = canHydrateTextInstance(
+                  renderLanes,
+                  workInProgress.pendingProps,
+                  rootOrSingletonContext
+                )),
+                null !== returnFiber
+                  ? ((workInProgress.stateNode = returnFiber),
+                    (hydrationParentFiber = workInProgress),
+                    (nextHydratableInstance = null),
+                    (returnFiber = !0))
+                  : (returnFiber = !1),
+                (returnFiber = !returnFiber)),
+              returnFiber &&
+                (current &&
+                  warnNonHydratedInstance(workInProgress, renderLanes),
+                throwOnHydrationMismatch(workInProgress))),
+            null
+          );
+        case 13:
+          return updateSuspenseComponent(current, workInProgress, renderLanes);
+        case 4:
+          return (
+            pushHostContainer(
+              workInProgress,
+              workInProgress.stateNode.containerInfo
+            ),
+            (returnFiber = workInProgress.pendingProps),
+            null === current
+              ? (workInProgress.child = reconcileChildFibers(
+                  workInProgress,
+                  null,
+                  returnFiber,
+                  renderLanes
+                ))
+              : reconcileChildren(
+                  current,
+                  workInProgress,
+                  returnFiber,
+                  renderLanes
+                ),
+            workInProgress.child
+          );
+        case 11:
+          return updateForwardRef(
+            current,
+            workInProgress,
+            workInProgress.type,
+            workInProgress.pendingProps,
+            renderLanes
+          );
+        case 7:
+          return (
+            reconcileChildren(
+              current,
+              workInProgress,
+              workInProgress.pendingProps,
+              renderLanes
+            ),
+            workInProgress.child
+          );
+        case 8:
+          return (
+            reconcileChildren(
+              current,
+              workInProgress,
+              workInProgress.pendingProps.children,
+              renderLanes
+            ),
+            workInProgress.child
+          );
+        case 12:
+          return (
+            (workInProgress.flags |= 4),
+            (workInProgress.flags |= 2048),
+            (returnFiber = workInProgress.stateNode),
+            (returnFiber.effectDuration = -0),
+            (returnFiber.passiveEffectDuration = -0),
+            reconcileChildren(
+              current,
+              workInProgress,
+              workInProgress.pendingProps.children,
+              renderLanes
+            ),
+            workInProgress.child
+          );
+        case 10:
+          return (
+            (returnFiber = workInProgress.type),
+            (prevSibling = workInProgress.pendingProps),
+            (nextProps = prevSibling.value),
+            "value" in prevSibling ||
+              hasWarnedAboutUsingNoValuePropOnContextProvider ||
+              ((hasWarnedAboutUsingNoValuePropOnContextProvider = !0),
+              console.error(
+                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
+              )),
+            pushProvider(workInProgress, returnFiber, nextProps),
+            reconcileChildren(
+              current,
+              workInProgress,
+              prevSibling.children,
+              renderLanes
+            ),
+            workInProgress.child
+          );
+        case 9:
+          return (
+            (prevSibling = workInProgress.type._context),
+            (returnFiber = workInProgress.pendingProps.children),
+            "function" !== typeof returnFiber &&
+              console.error(
+                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
+              ),
+            prepareToReadContext(workInProgress),
+            (prevSibling = readContext(prevSibling)),
+            (returnFiber = callComponentInDEV(
+              returnFiber,
+              prevSibling,
+              void 0
+            )),
+            (workInProgress.flags |= 1),
+            reconcileChildren(
+              current,
+              workInProgress,
+              returnFiber,
+              renderLanes
+            ),
+            workInProgress.child
+          );
+        case 14:
+          return updateMemoComponent(
+            current,
+            workInProgress,
+            workInProgress.type,
+            workInProgress.pendingProps,
+            renderLanes
+          );
+        case 15:
+          return updateSimpleMemoComponent(
+            current,
+            workInProgress,
+            workInProgress.type,
+            workInProgress.pendingProps,
+            renderLanes
+          );
+        case 19:
+          return updateSuspenseListComponent(
+            current,
+            workInProgress,
+            renderLanes
+          );
+        case 22:
+          return updateOffscreenComponent(current, workInProgress, renderLanes);
+        case 24:
+          return (
+            prepareToReadContext(workInProgress),
+            (returnFiber = readContext(CacheContext)),
+            null === current
+              ? ((prevSibling = peekCacheFromPool()),
+                null === prevSibling &&
+                  ((prevSibling = workInProgressRoot),
+                  (nextProps = createCache()),
+                  (prevSibling.pooledCache = nextProps),
+                  retainCache(nextProps),
+                  null !== nextProps &&
+                    (prevSibling.pooledCacheLanes |= renderLanes),
+                  (prevSibling = nextProps)),
+                (workInProgress.memoizedState = {
+                  parent: returnFiber,
+                  cache: prevSibling
+                }),
+                initializeUpdateQueue(workInProgress),
+                pushProvider(workInProgress, CacheContext, prevSibling))
+              : (0 !== (current.lanes & renderLanes) &&
+                  (cloneUpdateQueue(current, workInProgress),
+                  processUpdateQueue(workInProgress, null, null, renderLanes),
+                  suspendIfUpdateReadFromEntangledAsyncAction()),
+                (prevSibling = current.memoizedState),
+                (nextProps = workInProgress.memoizedState),
+                prevSibling.parent !== returnFiber
+                  ? ((prevSibling = {
+                      parent: returnFiber,
+                      cache: returnFiber
+                    }),
+                    (workInProgress.memoizedState = prevSibling),
+                    0 === workInProgress.lanes &&
+                      (workInProgress.memoizedState =
+                        workInProgress.updateQueue.baseState =
+                          prevSibling),
+                    pushProvider(workInProgress, CacheContext, returnFiber))
+                  : ((returnFiber = nextProps.cache),
+                    pushProvider(workInProgress, CacheContext, returnFiber),
+                    returnFiber !== prevSibling.cache &&
+                      propagateContextChanges(
+                        workInProgress,
+                        [CacheContext],
+                        renderLanes,
+                        !0
+                      ))),
+            reconcileChildren(
+              current,
+              workInProgress,
+              workInProgress.pendingProps.children,
+              renderLanes
+            ),
+            workInProgress.child
+          );
+        case 30:
+          return (
+            (returnFiber = workInProgress.pendingProps),
+            (prevSibling = workInProgress.stateNode),
+            null != returnFiber.name && "auto" !== returnFiber.name
+              ? ((workInProgress.flags |= 2097152),
+                null === current &&
+                  trackAppearingViewTransition(prevSibling, returnFiber.name))
+              : null === prevSibling.autoName &&
+                ((nextProps = workInProgressRoot.identifierPrefix),
+                isHydrating
+                  ? ((nextState = getTreeId()),
+                    (nextProps =
+                      "\u00ab" + nextProps + "T" + nextState + "\u00bb"))
+                  : ((nextState = globalClientIdCounter++),
+                    (nextProps =
+                      "\u00ab" +
+                      nextProps +
+                      "t" +
+                      nextState.toString(32) +
+                      "\u00bb")),
+                (prevSibling.autoName = nextProps)),
+            null !== current && current.memoizedProps.name !== returnFiber.name
+              ? (workInProgress.flags |= 4194816)
+              : markRef(current, workInProgress),
+            reconcileChildren(
+              current,
+              workInProgress,
+              returnFiber.children,
+              renderLanes
+            ),
+            workInProgress.child
+          );
+        case 29:
+          throw workInProgress.pendingProps;
+      }
+      throw Error(
+        "Unknown unit of work tag (" +
+          workInProgress.tag +
+          "). This error is likely caused by a bug in React. Please file an issue."
+      );
+    }
+    function shouldProfile(current) {
+      return (current.mode & ProfileMode) !== NoMode;
+    }
+    function commitHookLayoutEffects(finishedWork, hookFlags) {
+      shouldProfile(finishedWork)
+        ? (startEffectTimer(),
+          commitHookEffectListMount(hookFlags, finishedWork),
+          recordEffectDuration())
+        : commitHookEffectListMount(hookFlags, finishedWork);
+    }
+    function commitHookLayoutUnmountEffects(
+      finishedWork,
+      nearestMountedAncestor,
+      hookFlags
+    ) {
+      shouldProfile(finishedWork)
+        ? (startEffectTimer(),
+          commitHookEffectListUnmount(
+            hookFlags,
+            finishedWork,
+            nearestMountedAncestor
+          ),
+          recordEffectDuration())
+        : commitHookEffectListUnmount(
+            hookFlags,
+            finishedWork,
+            nearestMountedAncestor
+          );
+    }
+    function commitHookEffectListMount(flags, finishedWork) {
+      try {
+        var updateQueue = finishedWork.updateQueue,
+          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
+        if (null !== lastEffect) {
+          var firstEffect = lastEffect.next;
+          updateQueue = firstEffect;
+          do {
+            if (
+              (updateQueue.tag & flags) === flags &&
+              ((lastEffect = void 0),
+              (flags & Insertion) !== NoFlags &&
+                (isRunningInsertionEffect = !0),
+              (lastEffect = runWithFiberInDEV(
+                finishedWork,
+                callCreateInDEV,
+                updateQueue
+              )),
+              (flags & Insertion) !== NoFlags &&
+                (isRunningInsertionEffect = !1),
+              void 0 !== lastEffect && "function" !== typeof lastEffect)
+            ) {
+              var hookName = void 0;
+              hookName =
+                0 !== (updateQueue.tag & Layout)
+                  ? "useLayoutEffect"
+                  : 0 !== (updateQueue.tag & Insertion)
+                    ? "useInsertionEffect"
+                    : "useEffect";
+              var addendum = void 0;
+              addendum =
+                null === lastEffect
+                  ? " You returned null. If your effect does not require clean up, return undefined (or nothing)."
+                  : "function" === typeof lastEffect.then
+                    ? "\n\nIt looks like you wrote " +
+                      hookName +
+                      "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" +
+                      hookName +
+                      "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching"
+                    : " You returned: " + lastEffect;
+              runWithFiberInDEV(
+                finishedWork,
+                function (n, a) {
+                  console.error(
+                    "%s must not return anything besides a function, which is used for clean-up.%s",
+                    n,
+                    a
+                  );
+                },
+                hookName,
+                addendum
+              );
+            }
+            updateQueue = updateQueue.next;
+          } while (updateQueue !== firstEffect);
+        }
+      } catch (error) {
+        captureCommitPhaseError(finishedWork, finishedWork.return, error);
+      }
+    }
+    function commitHookEffectListUnmount(
+      flags,
+      finishedWork,
+      nearestMountedAncestor
+    ) {
+      try {
+        var updateQueue = finishedWork.updateQueue,
+          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
+        if (null !== lastEffect) {
+          var firstEffect = lastEffect.next;
+          updateQueue = firstEffect;
+          do {
+            if ((updateQueue.tag & flags) === flags) {
+              var inst = updateQueue.inst,
+                destroy = inst.destroy;
+              void 0 !== destroy &&
+                ((inst.destroy = void 0),
+                (flags & Insertion) !== NoFlags &&
+                  (isRunningInsertionEffect = !0),
+                runWithFiberInDEV(
+                  finishedWork,
+                  callDestroyInDEV,
+                  finishedWork,
+                  nearestMountedAncestor,
+                  destroy
+                ),
+                (flags & Insertion) !== NoFlags &&
+                  (isRunningInsertionEffect = !1));
+            }
+            updateQueue = updateQueue.next;
+          } while (updateQueue !== firstEffect);
+        }
+      } catch (error) {
+        captureCommitPhaseError(finishedWork, finishedWork.return, error);
+      }
+    }
+    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
+      shouldProfile(finishedWork)
+        ? (startEffectTimer(),
+          commitHookEffectListMount(hookFlags, finishedWork),
+          recordEffectDuration())
+        : commitHookEffectListMount(hookFlags, finishedWork);
+    }
+    function commitHookPassiveUnmountEffects(
+      finishedWork,
+      nearestMountedAncestor,
+      hookFlags
+    ) {
+      shouldProfile(finishedWork)
+        ? (startEffectTimer(),
+          commitHookEffectListUnmount(
+            hookFlags,
+            finishedWork,
+            nearestMountedAncestor
+          ),
+          recordEffectDuration())
+        : commitHookEffectListUnmount(
+            hookFlags,
+            finishedWork,
+            nearestMountedAncestor
+          );
+    }
+    function commitClassCallbacks(finishedWork) {
+      var updateQueue = finishedWork.updateQueue;
+      if (null !== updateQueue) {
+        var instance = finishedWork.stateNode;
+        finishedWork.type.defaultProps ||
+          "ref" in finishedWork.memoizedProps ||
+          didWarnAboutReassigningProps ||
+          (instance.props !== finishedWork.memoizedProps &&
+            console.error(
+              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
+              getComponentNameFromFiber(finishedWork) || "instance"
+            ),
+          instance.state !== finishedWork.memoizedState &&
+            console.error(
+              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
+              getComponentNameFromFiber(finishedWork) || "instance"
+            ));
+        try {
+          runWithFiberInDEV(
+            finishedWork,
+            commitCallbacks,
+            updateQueue,
+            instance
+          );
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      }
+    }
+    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
+      return instance.getSnapshotBeforeUpdate(prevProps, prevState);
+    }
+    function commitClassSnapshot(finishedWork, current) {
+      var prevProps = current.memoizedProps,
+        prevState = current.memoizedState;
+      current = finishedWork.stateNode;
+      finishedWork.type.defaultProps ||
+        "ref" in finishedWork.memoizedProps ||
+        didWarnAboutReassigningProps ||
+        (current.props !== finishedWork.memoizedProps &&
+          console.error(
+            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
+            getComponentNameFromFiber(finishedWork) || "instance"
+          ),
+        current.state !== finishedWork.memoizedState &&
+          console.error(
+            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
+            getComponentNameFromFiber(finishedWork) || "instance"
+          ));
+      try {
+        var resolvedPrevProps = resolveClassComponentProps(
+          finishedWork.type,
+          prevProps,
+          finishedWork.elementType === finishedWork.type
+        );
+        var snapshot = runWithFiberInDEV(
+          finishedWork,
+          callGetSnapshotBeforeUpdates,
+          current,
+          resolvedPrevProps,
+          prevState
+        );
+        prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
+        void 0 !== snapshot ||
+          prevProps.has(finishedWork.type) ||
+          (prevProps.add(finishedWork.type),
+          runWithFiberInDEV(finishedWork, function () {
+            console.error(
+              "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
+              getComponentNameFromFiber(finishedWork)
+            );
+          }));
+        current.__reactInternalSnapshotBeforeUpdate = snapshot;
+      } catch (error) {
+        captureCommitPhaseError(finishedWork, finishedWork.return, error);
+      }
+    }
+    function safelyCallComponentWillUnmount(
+      current,
+      nearestMountedAncestor,
+      instance
+    ) {
+      instance.props = resolveClassComponentProps(
+        current.type,
+        current.memoizedProps
+      );
+      instance.state = current.memoizedState;
+      shouldProfile(current)
+        ? (startEffectTimer(),
+          runWithFiberInDEV(
+            current,
+            callComponentWillUnmountInDEV,
+            current,
+            nearestMountedAncestor,
+            instance
+          ),
+          recordEffectDuration())
+        : runWithFiberInDEV(
+            current,
+            callComponentWillUnmountInDEV,
+            current,
+            nearestMountedAncestor,
+            instance
+          );
+    }
+    function commitAttachRef(finishedWork) {
+      var ref = finishedWork.ref;
+      if (null !== ref) {
+        switch (finishedWork.tag) {
+          case 26:
+          case 27:
+          case 5:
+            var instanceToUse = finishedWork.stateNode;
+            break;
+          case 30:
+            instanceToUse = finishedWork.stateNode;
+            var name = getViewTransitionName(
+              finishedWork.memoizedProps,
+              instanceToUse
+            );
+            if (null === instanceToUse.ref || instanceToUse.ref.name !== name)
+              instanceToUse.ref = createViewTransitionInstance(name);
+            instanceToUse = instanceToUse.ref;
+            break;
+          default:
+            instanceToUse = finishedWork.stateNode;
+        }
+        if ("function" === typeof ref)
+          if (shouldProfile(finishedWork))
+            try {
+              startEffectTimer(),
+                (finishedWork.refCleanup = ref(instanceToUse));
+            } finally {
+              recordEffectDuration();
+            }
+          else finishedWork.refCleanup = ref(instanceToUse);
+        else
+          "string" === typeof ref
+            ? console.error("String refs are no longer supported.")
+            : ref.hasOwnProperty("current") ||
+              console.error(
+                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
+                getComponentNameFromFiber(finishedWork)
+              ),
+            (ref.current = instanceToUse);
+      }
+    }
+    function safelyAttachRef(current, nearestMountedAncestor) {
+      try {
+        runWithFiberInDEV(current, commitAttachRef, current);
+      } catch (error) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error);
+      }
+    }
+    function safelyDetachRef(current, nearestMountedAncestor) {
+      var ref = current.ref,
+        refCleanup = current.refCleanup;
+      if (null !== ref)
+        if ("function" === typeof refCleanup)
+          try {
+            if (shouldProfile(current))
+              try {
+                startEffectTimer(), runWithFiberInDEV(current, refCleanup);
+              } finally {
+                recordEffectDuration(current);
+              }
+            else runWithFiberInDEV(current, refCleanup);
+          } catch (error) {
+            captureCommitPhaseError(current, nearestMountedAncestor, error);
+          } finally {
+            (current.refCleanup = null),
+              (current = current.alternate),
+              null != current && (current.refCleanup = null);
+          }
+        else if ("function" === typeof ref)
+          try {
+            if (shouldProfile(current))
+              try {
+                startEffectTimer(), runWithFiberInDEV(current, ref, null);
+              } finally {
+                recordEffectDuration(current);
+              }
+            else runWithFiberInDEV(current, ref, null);
+          } catch (error$6) {
+            captureCommitPhaseError(current, nearestMountedAncestor, error$6);
+          }
+        else ref.current = null;
+    }
+    function commitProfiler(
+      finishedWork,
+      current,
+      commitStartTime,
+      effectDuration
+    ) {
+      var _finishedWork$memoize = finishedWork.memoizedProps,
+        id = _finishedWork$memoize.id,
+        onCommit = _finishedWork$memoize.onCommit;
+      _finishedWork$memoize = _finishedWork$memoize.onRender;
+      current = null === current ? "mount" : "update";
+      currentUpdateIsNested && (current = "nested-update");
+      "function" === typeof _finishedWork$memoize &&
+        _finishedWork$memoize(
+          id,
+          current,
+          finishedWork.actualDuration,
+          finishedWork.treeBaseDuration,
+          finishedWork.actualStartTime,
+          commitStartTime
+        );
+      "function" === typeof onCommit &&
+        onCommit(
+          finishedWork.memoizedProps.id,
+          current,
+          effectDuration,
+          commitStartTime
+        );
+    }
+    function commitProfilerPostCommitImpl(
+      finishedWork,
+      current,
+      commitStartTime,
+      passiveEffectDuration
+    ) {
+      var _finishedWork$memoize2 = finishedWork.memoizedProps;
+      finishedWork = _finishedWork$memoize2.id;
+      _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
+      current = null === current ? "mount" : "update";
+      currentUpdateIsNested && (current = "nested-update");
+      "function" === typeof _finishedWork$memoize2 &&
+        _finishedWork$memoize2(
+          finishedWork,
+          current,
+          passiveEffectDuration,
+          commitStartTime
+        );
+    }
+    function commitHostMount(finishedWork) {
+      var type = finishedWork.type,
+        props = finishedWork.memoizedProps,
+        instance = finishedWork.stateNode;
+      try {
+        runWithFiberInDEV(
+          finishedWork,
+          commitMount,
+          instance,
+          type,
+          props,
+          finishedWork
+        );
+      } catch (error) {
+        captureCommitPhaseError(finishedWork, finishedWork.return, error);
+      }
+    }
+    function commitHostUpdate(finishedWork, newProps, oldProps) {
+      try {
+        runWithFiberInDEV(
+          finishedWork,
+          commitUpdate,
+          finishedWork.stateNode,
+          finishedWork.type,
+          oldProps,
+          newProps,
+          finishedWork
+        );
+      } catch (error) {
+        captureCommitPhaseError(finishedWork, finishedWork.return, error);
+      }
+    }
+    function isHostParent(fiber) {
+      return (
+        5 === fiber.tag ||
+        3 === fiber.tag ||
+        26 === fiber.tag ||
+        27 === fiber.tag ||
+        4 === fiber.tag
+      );
+    }
+    function getHostSibling(fiber) {
+      a: for (;;) {
+        for (; null === fiber.sibling; ) {
+          if (null === fiber.return || isHostParent(fiber.return)) return null;
+          fiber = fiber.return;
+        }
+        fiber.sibling.return = fiber.return;
+        for (
+          fiber = fiber.sibling;
+          5 !== fiber.tag &&
+          6 !== fiber.tag &&
+          27 !== fiber.tag &&
+          18 !== fiber.tag;
+
+        ) {
+          if (fiber.flags & 2) continue a;
+          if (null === fiber.child || 4 === fiber.tag) continue a;
+          else (fiber.child.return = fiber), (fiber = fiber.child);
+        }
+        if (!(fiber.flags & 2)) return fiber.stateNode;
+      }
+    }
+    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
+      var tag = node.tag;
+      if (5 === tag || 6 === tag)
+        (node = node.stateNode),
+          before
+            ? 8 === parent.nodeType
+              ? parent.parentNode.insertBefore(node, before)
+              : parent.insertBefore(node, before)
+            : (8 === parent.nodeType
+                ? ((before = parent.parentNode),
+                  before.insertBefore(node, parent))
+                : ((before = parent), before.appendChild(node)),
+              (parent = parent._reactRootContainer),
+              (null !== parent && void 0 !== parent) ||
+                null !== before.onclick ||
+                (before.onclick = noop$1)),
+          (viewTransitionMutationContext = !0);
+      else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
+        for (
+          insertOrAppendPlacementNodeIntoContainer(node, before, parent),
+            node = node.sibling;
+          null !== node;
+
+        )
+          insertOrAppendPlacementNodeIntoContainer(node, before, parent),
+            (node = node.sibling);
+    }
+    function insertOrAppendPlacementNode(node, before, parent) {
+      var tag = node.tag;
+      if (5 === tag || 6 === tag)
+        (node = node.stateNode),
+          before ? parent.insertBefore(node, before) : parent.appendChild(node),
+          (viewTransitionMutationContext = !0);
+      else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
+        for (
+          insertOrAppendPlacementNode(node, before, parent),
+            node = node.sibling;
+          null !== node;
+
+        )
+          insertOrAppendPlacementNode(node, before, parent),
+            (node = node.sibling);
+    }
+    function commitPlacement(finishedWork) {
+      if (27 !== finishedWork.tag) {
+        a: {
+          for (var parent = finishedWork.return; null !== parent; ) {
+            if (isHostParent(parent)) {
+              var parentFiber = parent;
+              break a;
+            }
+            parent = parent.return;
+          }
+          throw Error(
+            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
+          );
+        }
+        switch (parentFiber.tag) {
+          case 27:
+            parent = parentFiber.stateNode;
+            parentFiber = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
+            break;
+          case 5:
+            parent = parentFiber.stateNode;
+            parentFiber.flags & 32 &&
+              (resetTextContent(parent), (parentFiber.flags &= -33));
+            parentFiber = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
+            break;
+          case 3:
+          case 4:
+            parent = parentFiber.stateNode.containerInfo;
+            parentFiber = getHostSibling(finishedWork);
+            insertOrAppendPlacementNodeIntoContainer(
+              finishedWork,
+              parentFiber,
+              parent
+            );
+            break;
+          default:
+            throw Error(
+              "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
+            );
+        }
+      }
+    }
+    function commitBeforeMutationEffects(
+      root,
+      firstChild,
+      committedLanes,
+      appearingViewTransitions
+    ) {
+      root = root.containerInfo;
+      eventsEnabled = _enabled;
+      root = getActiveElementDeep(root);
+      if (hasSelectionCapabilities(root)) {
+        if ("selectionStart" in root)
+          var JSCompiler_temp = {
+            start: root.selectionStart,
+            end: root.selectionEnd
+          };
+        else
+          a: {
+            JSCompiler_temp =
+              ((JSCompiler_temp = root.ownerDocument) &&
+                JSCompiler_temp.defaultView) ||
+              window;
+            var selection =
+              JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
+            if (selection && 0 !== selection.rangeCount) {
+              JSCompiler_temp = selection.anchorNode;
+              var anchorOffset = selection.anchorOffset,
+                focusNode = selection.focusNode;
+              selection = selection.focusOffset;
+              try {
+                JSCompiler_temp.nodeType, focusNode.nodeType;
+              } catch (e$2) {
+                JSCompiler_temp = null;
+                break a;
+              }
+              var length = 0,
+                start = -1,
+                end = -1,
+                indexWithinAnchor = 0,
+                indexWithinFocus = 0,
+                node = root,
+                parentNode = null;
+              b: for (;;) {
+                for (var next; ; ) {
+                  node !== JSCompiler_temp ||
+                    (0 !== anchorOffset && 3 !== node.nodeType) ||
+                    (start = length + anchorOffset);
+                  node !== focusNode ||
+                    (0 !== selection && 3 !== node.nodeType) ||
+                    (end = length + selection);
+                  3 === node.nodeType && (length += node.nodeValue.length);
+                  if (null === (next = node.firstChild)) break;
+                  parentNode = node;
+                  node = next;
+                }
+                for (;;) {
+                  if (node === root) break b;
+                  parentNode === JSCompiler_temp &&
+                    ++indexWithinAnchor === anchorOffset &&
+                    (start = length);
+                  parentNode === focusNode &&
+                    ++indexWithinFocus === selection &&
+                    (end = length);
+                  if (null !== (next = node.nextSibling)) break;
+                  node = parentNode;
+                  parentNode = node.parentNode;
+                }
+                node = next;
+              }
+              JSCompiler_temp =
+                -1 === start || -1 === end ? null : { start: start, end: end };
+            } else JSCompiler_temp = null;
+          }
+        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
+      } else JSCompiler_temp = null;
+      selectionInformation = {
+        focusedElem: root,
+        selectionRange: JSCompiler_temp
+      };
+      shouldStartViewTransition = _enabled = !1;
+      committedLanes = (committedLanes & 335544192) === committedLanes;
+      nextEffect = firstChild;
+      for (firstChild = committedLanes ? 9238 : 1028; null !== nextEffect; ) {
+        root = nextEffect;
+        if (
+          committedLanes &&
+          ((JSCompiler_temp = root.deletions), null !== JSCompiler_temp)
+        )
+          for (
+            anchorOffset = 0;
+            anchorOffset < JSCompiler_temp.length;
+            anchorOffset++
+          )
+            committedLanes &&
+              commitExitViewTransitions(
+                JSCompiler_temp[anchorOffset],
+                appearingViewTransitions
+              );
+        if (null === root.alternate && 0 !== (root.flags & 2))
+          commitBeforeMutationEffects_complete(committedLanes);
+        else {
+          if (22 === root.tag)
+            if (
+              ((JSCompiler_temp = root.alternate), null !== root.memoizedState)
+            ) {
+              null !== JSCompiler_temp &&
+                null === JSCompiler_temp.memoizedState &&
+                committedLanes &&
+                commitExitViewTransitions(
+                  JSCompiler_temp,
+                  appearingViewTransitions
+                );
+              commitBeforeMutationEffects_complete(committedLanes);
+              continue;
+            } else if (
+              null !== JSCompiler_temp &&
+              null !== JSCompiler_temp.memoizedState
+            ) {
+              commitBeforeMutationEffects_complete(committedLanes);
+              continue;
+            }
+          JSCompiler_temp = root.child;
+          0 !== (root.subtreeFlags & firstChild) && null !== JSCompiler_temp
+            ? ((JSCompiler_temp.return = root), (nextEffect = JSCompiler_temp))
+            : (committedLanes && commitNestedViewTransitions(root),
+              commitBeforeMutationEffects_complete(committedLanes));
+        }
+      }
+    }
+    function commitBeforeMutationEffects_complete(
+      isViewTransitionEligible$jscomp$0
+    ) {
+      for (; null !== nextEffect; ) {
+        var fiber = nextEffect,
+          finishedWork = fiber,
+          isViewTransitionEligible = isViewTransitionEligible$jscomp$0,
+          current = finishedWork.alternate,
+          flags = finishedWork.flags;
+        switch (finishedWork.tag) {
+          case 0:
+            if (
+              0 !== (flags & 4) &&
+              ((isViewTransitionEligible = finishedWork.updateQueue),
+              (isViewTransitionEligible =
+                null !== isViewTransitionEligible
+                  ? isViewTransitionEligible.events
+                  : null),
+              null !== isViewTransitionEligible)
+            )
+              for (
+                finishedWork = 0;
+                finishedWork < isViewTransitionEligible.length;
+                finishedWork++
+              )
+                (current = isViewTransitionEligible[finishedWork]),
+                  (current.ref.impl = current.nextImpl);
+            break;
+          case 11:
+          case 15:
+            break;
+          case 1:
+            0 !== (flags & 1024) &&
+              null !== current &&
+              commitClassSnapshot(finishedWork, current);
+            break;
+          case 3:
+            if (0 !== (flags & 1024))
+              if (
+                ((isViewTransitionEligible =
+                  finishedWork.stateNode.containerInfo),
+                (finishedWork = isViewTransitionEligible.nodeType),
+                9 === finishedWork)
+              )
+                clearContainerSparingly(isViewTransitionEligible);
+              else if (1 === finishedWork)
+                switch (isViewTransitionEligible.nodeName) {
+                  case "HEAD":
+                  case "HTML":
+                  case "BODY":
+                    clearContainerSparingly(isViewTransitionEligible);
+                    break;
+                  default:
+                    isViewTransitionEligible.textContent = "";
+                }
+            break;
+          case 5:
+          case 26:
+          case 27:
+          case 6:
+          case 4:
+          case 17:
+            break;
+          case 30:
+            if (
+              isViewTransitionEligible &&
+              null !== current &&
+              0 !== (finishedWork.subtreeFlags & 8246)
+            )
+              a: {
+                isViewTransitionEligible = current;
+                current = finishedWork;
+                finishedWork = getViewTransitionName(
+                  isViewTransitionEligible.memoizedProps,
+                  isViewTransitionEligible.stateNode
+                );
+                current = current.memoizedProps;
+                flags = getViewTransitionClassName(
+                  current.className,
+                  current.update
+                );
+                if (
+                  "none" === flags &&
+                  ((flags = getViewTransitionClassName(
+                    current.className,
+                    current.layout
+                  )),
+                  "none" === flags)
+                )
+                  break a;
+                viewTransitionHostInstanceIdx = 0;
+                applyViewTransitionToHostInstances(
+                  isViewTransitionEligible.child,
+                  finishedWork,
+                  flags,
+                  (isViewTransitionEligible.memoizedState = []),
+                  !0
+                );
+              }
+            break;
+          default:
+            if (0 !== (flags & 1024))
+              throw Error(
+                "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
+              );
+        }
+        isViewTransitionEligible = fiber.sibling;
+        if (null !== isViewTransitionEligible) {
+          isViewTransitionEligible.return = fiber.return;
+          nextEffect = isViewTransitionEligible;
+          break;
+        }
+        nextEffect = fiber.return;
+      }
+    }
+    function applyViewTransitionToHostInstances(
+      child,
+      name,
+      className,
+      collectMeasurements,
+      stopAtNestedViewTransitions
+    ) {
+      for (var inViewport = !1; null !== child; ) {
+        if (5 === child.tag) {
+          shouldStartViewTransition = !0;
+          var instance = child.stateNode;
+          if (null !== collectMeasurements) {
+            var measurement = measureInstance(instance);
+            collectMeasurements.push(measurement);
+            measurement.view && (inViewport = !0);
+          } else
+            inViewport || (measureInstance(instance).view && (inViewport = !0));
+          measurement = className;
+          instance.style.viewTransitionName =
+            0 === viewTransitionHostInstanceIdx
+              ? name
+              : name + "_" + viewTransitionHostInstanceIdx;
+          null != measurement &&
+            (instance.style.viewTransitionClass = measurement);
+          viewTransitionHostInstanceIdx++;
+        } else if (22 !== child.tag || null === child.memoizedState)
+          (30 === child.tag && stopAtNestedViewTransitions) ||
+            (applyViewTransitionToHostInstances(
+              child.child,
+              name,
+              className,
+              collectMeasurements,
+              stopAtNestedViewTransitions
+            ) &&
+              (inViewport = !0));
+        child = child.sibling;
+      }
+      return inViewport;
+    }
+    function restoreViewTransitionOnHostInstances(
+      child,
+      stopAtNestedViewTransitions
+    ) {
+      for (; null !== child; ) {
+        if (5 === child.tag)
+          restoreViewTransitionName(child.stateNode, child.memoizedProps);
+        else if (22 !== child.tag || null === child.memoizedState)
+          (30 === child.tag && stopAtNestedViewTransitions) ||
+            restoreViewTransitionOnHostInstances(
+              child.child,
+              stopAtNestedViewTransitions
+            );
+        child = child.sibling;
+      }
+    }
+    function commitAppearingPairViewTransitions(placement) {
+      if (0 !== (placement.subtreeFlags & 2097152))
+        for (placement = placement.child; null !== placement; ) {
+          if (22 !== placement.tag || null !== placement.memoizedState)
+            if (
+              (commitAppearingPairViewTransitions(placement),
+              30 === placement.tag &&
+                0 !== (placement.flags & 2097152) &&
+                placement.stateNode.paired)
+            ) {
+              var props = placement.memoizedProps;
+              if (null == props.name || "auto" === props.name)
+                throw Error(
+                  "Found a pair with an auto name. This is a bug in React."
+                );
+              var name = props.name;
+              props = getViewTransitionClassName(props.className, props.share);
+              "none" !== props &&
+                ((viewTransitionHostInstanceIdx = 0),
+                applyViewTransitionToHostInstances(
+                  placement.child,
+                  name,
+                  props,
+                  null,
+                  !1
+                ) || restoreViewTransitionOnHostInstances(placement.child, !1));
+            }
+          placement = placement.sibling;
+        }
+    }
+    function commitEnterViewTransitions(placement) {
+      if (30 === placement.tag) {
+        var state = placement.stateNode,
+          props = placement.memoizedProps,
+          name = getViewTransitionName(props, state),
+          className = getViewTransitionClassName(
+            props.className,
+            state.paired ? props.share : props.enter
+          );
+        "none" !== className
+          ? ((viewTransitionHostInstanceIdx = 0),
+            applyViewTransitionToHostInstances(
+              placement.child,
+              name,
+              className,
+              null,
+              !1
+            )
+              ? (commitAppearingPairViewTransitions(placement),
+                state.paired ||
+                  scheduleViewTransitionEvent(placement, props.onEnter))
+              : restoreViewTransitionOnHostInstances(placement.child, !1))
+          : commitAppearingPairViewTransitions(placement);
+      } else if (0 !== (placement.subtreeFlags & 33554432))
+        for (placement = placement.child; null !== placement; )
+          commitEnterViewTransitions(placement),
+            (placement = placement.sibling);
+      else commitAppearingPairViewTransitions(placement);
+    }
+    function commitDeletedPairViewTransitions(
+      deletion,
+      appearingViewTransitions
+    ) {
+      if (
+        0 !== appearingViewTransitions.size &&
+        0 !== (deletion.subtreeFlags & 2097152)
+      )
+        for (deletion = deletion.child; null !== deletion; ) {
+          if (22 !== deletion.tag || null !== deletion.memoizedState) {
+            if (30 === deletion.tag && 0 !== (deletion.flags & 2097152)) {
+              var props = deletion.memoizedProps,
+                name = props.name;
+              if (null != name && "auto" !== name) {
+                var pair = appearingViewTransitions.get(name);
+                if (void 0 !== pair) {
+                  var className = getViewTransitionClassName(
+                    props.className,
+                    props.share
+                  );
+                  "none" !== className &&
+                    ((viewTransitionHostInstanceIdx = 0),
+                    applyViewTransitionToHostInstances(
+                      deletion.child,
+                      name,
+                      className,
+                      null,
+                      !1
+                    )
+                      ? ((pair.paired = deletion.stateNode),
+                        scheduleViewTransitionEvent(deletion, props.onShare))
+                      : restoreViewTransitionOnHostInstances(
+                          deletion.child,
+                          !1
+                        ));
+                  appearingViewTransitions.delete(name);
+                  if (0 === appearingViewTransitions.size) break;
+                }
+              }
+            }
+            commitDeletedPairViewTransitions(
+              deletion,
+              appearingViewTransitions
+            );
+          }
+          deletion = deletion.sibling;
+        }
+    }
+    function commitExitViewTransitions(deletion, appearingViewTransitions) {
+      if (30 === deletion.tag) {
+        var props = deletion.memoizedProps,
+          name = getViewTransitionName(props, deletion.stateNode),
+          pair =
+            null !== appearingViewTransitions
+              ? appearingViewTransitions.get(name)
+              : void 0,
+          className = getViewTransitionClassName(
+            props.className,
+            void 0 !== pair ? props.share : props.exit
+          );
+        "none" !== className &&
+          ((viewTransitionHostInstanceIdx = 0),
+          applyViewTransitionToHostInstances(
+            deletion.child,
+            name,
+            className,
+            null,
+            !1
+          )
+            ? void 0 !== pair
+              ? ((pair.paired = deletion.stateNode),
+                appearingViewTransitions.delete(name),
+                scheduleViewTransitionEvent(deletion, props.onShare))
+              : scheduleViewTransitionEvent(deletion, props.onExit)
+            : restoreViewTransitionOnHostInstances(deletion.child, !1));
+        null !== appearingViewTransitions &&
+          commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+      } else if (0 !== (deletion.subtreeFlags & 33554432))
+        for (deletion = deletion.child; null !== deletion; )
+          commitExitViewTransitions(deletion, appearingViewTransitions),
+            (deletion = deletion.sibling);
+      else
+        null !== appearingViewTransitions &&
+          commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+    }
+    function commitNestedViewTransitions(changedParent) {
+      for (changedParent = changedParent.child; null !== changedParent; ) {
+        if (30 === changedParent.tag) {
+          var props = changedParent.memoizedProps,
+            name = getViewTransitionName(props, changedParent.stateNode);
+          props = getViewTransitionClassName(props.className, props.layout);
+          "none" !== props &&
+            ((viewTransitionHostInstanceIdx = 0),
+            applyViewTransitionToHostInstances(
+              changedParent.child,
+              name,
+              props,
+              (changedParent.memoizedState = []),
+              !1
+            ));
+        } else
+          0 !== (changedParent.subtreeFlags & 33554432) &&
+            commitNestedViewTransitions(changedParent);
+        changedParent = changedParent.sibling;
+      }
+    }
+    function restorePairedViewTransitions(parent) {
+      if (0 !== (parent.subtreeFlags & 2097152))
+        for (parent = parent.child; null !== parent; ) {
+          if (22 !== parent.tag || null !== parent.memoizedState) {
+            if (30 === parent.tag && 0 !== (parent.flags & 2097152)) {
+              var instance = parent.stateNode;
+              null !== instance.paired &&
+                ((instance.paired = null),
+                restoreViewTransitionOnHostInstances(parent.child, !1));
+            }
+            restorePairedViewTransitions(parent);
+          }
+          parent = parent.sibling;
+        }
+    }
+    function restoreEnterViewTransitions(placement) {
+      if (30 === placement.tag)
+        (placement.stateNode.paired = null),
+          restoreViewTransitionOnHostInstances(placement.child, !1),
+          restorePairedViewTransitions(placement);
+      else if (0 !== (placement.subtreeFlags & 33554432))
+        for (placement = placement.child; null !== placement; )
+          restoreEnterViewTransitions(placement),
+            (placement = placement.sibling);
+      else restorePairedViewTransitions(placement);
+    }
+    function restoreExitViewTransitions(deletion) {
+      if (30 === deletion.tag)
+        (deletion.stateNode.paired = null),
+          restoreViewTransitionOnHostInstances(deletion.child, !1),
+          restorePairedViewTransitions(deletion);
+      else if (0 !== (deletion.subtreeFlags & 33554432))
+        for (deletion = deletion.child; null !== deletion; )
+          restoreExitViewTransitions(deletion), (deletion = deletion.sibling);
+      else restorePairedViewTransitions(deletion);
+    }
+    function restoreNestedViewTransitions(changedParent) {
+      for (changedParent = changedParent.child; null !== changedParent; )
+        30 === changedParent.tag
+          ? ((changedParent.memoizedState = null),
+            restoreViewTransitionOnHostInstances(changedParent.child, !1))
+          : 0 !== (changedParent.subtreeFlags & 33554432) &&
+            restoreNestedViewTransitions(changedParent),
+          (changedParent = changedParent.sibling);
+    }
+    function cancelViewTransitionHostInstances(
+      currentViewTransition,
+      child,
+      stopAtNestedViewTransitions
+    ) {
+      for (; null !== child; ) {
+        if (5 === child.tag) {
+          var instance = child.stateNode,
+            oldName = getViewTransitionName(
+              currentViewTransition.memoizedProps,
+              currentViewTransition.stateNode
+            );
+          null === viewTransitionCancelableChildren &&
+            (viewTransitionCancelableChildren = []);
+          viewTransitionCancelableChildren.push(
+            instance,
+            oldName,
+            child.memoizedProps
+          );
+          viewTransitionHostInstanceIdx++;
+        } else if (22 !== child.tag || null === child.memoizedState)
+          (30 === child.tag && stopAtNestedViewTransitions) ||
+            cancelViewTransitionHostInstances(
+              currentViewTransition,
+              child.child,
+              stopAtNestedViewTransitions
+            );
+        child = child.sibling;
+      }
+    }
+    function measureViewTransitionHostInstances(
+      currentViewTransition,
+      parentViewTransition,
+      child,
+      name,
+      className,
+      previousMeasurements,
+      stopAtNestedViewTransitions
+    ) {
+      for (var inViewport = !1; null !== child; ) {
+        if (5 === child.tag) {
+          var instance = child.stateNode;
+          if (
+            null !== previousMeasurements &&
+            viewTransitionHostInstanceIdx < previousMeasurements.length
+          ) {
+            var previousMeasurement =
+                previousMeasurements[viewTransitionHostInstanceIdx],
+              nextMeasurement = measureInstance(instance);
+            if (previousMeasurement.view || nextMeasurement.view)
+              inViewport = !0;
+            var JSCompiler_temp;
+            if ((JSCompiler_temp = 0 === (parentViewTransition.flags & 4)))
+              if (nextMeasurement.clip) JSCompiler_temp = !0;
+              else {
+                JSCompiler_temp = previousMeasurement.rect;
+                var newRect = nextMeasurement.rect;
+                JSCompiler_temp =
+                  JSCompiler_temp.y !== newRect.y ||
+                  JSCompiler_temp.x !== newRect.x ||
+                  JSCompiler_temp.height !== newRect.height ||
+                  JSCompiler_temp.width !== newRect.width;
+              }
+            JSCompiler_temp && (parentViewTransition.flags |= 4);
+            nextMeasurement.abs
+              ? (nextMeasurement = !previousMeasurement.abs)
+              : ((previousMeasurement = previousMeasurement.rect),
+                (nextMeasurement = nextMeasurement.rect),
+                (nextMeasurement =
+                  previousMeasurement.height !== nextMeasurement.height ||
+                  previousMeasurement.width !== nextMeasurement.width));
+            nextMeasurement && (parentViewTransition.flags |= 32);
+          } else parentViewTransition.flags |= 32;
+          0 !== (parentViewTransition.flags & 4) &&
+            ((nextMeasurement = instance),
+            (previousMeasurement = className),
+            (nextMeasurement.style.viewTransitionName =
+              0 === viewTransitionHostInstanceIdx
+                ? name
+                : name + "_" + viewTransitionHostInstanceIdx),
+            null != previousMeasurement &&
+              (nextMeasurement.style.viewTransitionClass =
+                previousMeasurement));
+          (inViewport && 0 !== (parentViewTransition.flags & 4)) ||
+            ((nextMeasurement = getViewTransitionName(
+              currentViewTransition.memoizedProps,
+              currentViewTransition.stateNode
+            )),
+            null === viewTransitionCancelableChildren &&
+              (viewTransitionCancelableChildren = []),
+            viewTransitionCancelableChildren.push(
+              instance,
+              nextMeasurement,
+              child.memoizedProps
+            ));
+          viewTransitionHostInstanceIdx++;
+        } else if (22 !== child.tag || null === child.memoizedState)
+          30 === child.tag && stopAtNestedViewTransitions
+            ? (parentViewTransition.flags |= child.flags & 32)
+            : measureViewTransitionHostInstances(
+                currentViewTransition,
+                parentViewTransition,
+                child.child,
+                name,
+                className,
+                previousMeasurements,
+                stopAtNestedViewTransitions
+              ) && (inViewport = !0);
+        child = child.sibling;
+      }
+      return inViewport;
+    }
+    function measureNestedViewTransitions(changedParent) {
+      for (changedParent = changedParent.child; null !== changedParent; ) {
+        if (30 === changedParent.tag) {
+          var current = changedParent.alternate;
+          if (null !== current) {
+            var props = changedParent.memoizedProps,
+              name = getViewTransitionName(props, changedParent.stateNode),
+              className = getViewTransitionClassName(
+                props.className,
+                props.layout
+              );
+            viewTransitionHostInstanceIdx = 0;
+            current = measureViewTransitionHostInstances(
+              current,
+              changedParent,
+              changedParent.child,
+              name,
+              className,
+              changedParent.memoizedState,
+              !1
+            );
+            0 !== (changedParent.flags & 4) &&
+              current &&
+              scheduleViewTransitionEvent(changedParent, props.onLayout);
+          }
+        } else
+          0 !== (changedParent.subtreeFlags & 33554432) &&
+            measureNestedViewTransitions(changedParent);
+        changedParent = changedParent.sibling;
+      }
+    }
+    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors(),
+        flags = finishedWork.flags;
+      switch (finishedWork.tag) {
+        case 0:
+        case 11:
+        case 15:
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          flags & 4 &&
+            commitHookLayoutEffects(finishedWork, Layout | HasEffect);
+          break;
+        case 1:
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          if (flags & 4)
+            if (((finishedRoot = finishedWork.stateNode), null === current))
+              finishedWork.type.defaultProps ||
+                "ref" in finishedWork.memoizedProps ||
+                didWarnAboutReassigningProps ||
+                (finishedRoot.props !== finishedWork.memoizedProps &&
+                  console.error(
+                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
+                    getComponentNameFromFiber(finishedWork) || "instance"
+                  ),
+                finishedRoot.state !== finishedWork.memoizedState &&
+                  console.error(
+                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
+                    getComponentNameFromFiber(finishedWork) || "instance"
+                  )),
+                shouldProfile(finishedWork)
+                  ? (startEffectTimer(),
+                    runWithFiberInDEV(
+                      finishedWork,
+                      callComponentDidMountInDEV,
+                      finishedWork,
+                      finishedRoot
+                    ),
+                    recordEffectDuration())
+                  : runWithFiberInDEV(
+                      finishedWork,
+                      callComponentDidMountInDEV,
+                      finishedWork,
+                      finishedRoot
+                    );
+            else {
+              var prevProps = resolveClassComponentProps(
+                finishedWork.type,
+                current.memoizedProps
+              );
+              current = current.memoizedState;
+              finishedWork.type.defaultProps ||
+                "ref" in finishedWork.memoizedProps ||
+                didWarnAboutReassigningProps ||
+                (finishedRoot.props !== finishedWork.memoizedProps &&
+                  console.error(
+                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
+                    getComponentNameFromFiber(finishedWork) || "instance"
+                  ),
+                finishedRoot.state !== finishedWork.memoizedState &&
+                  console.error(
+                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
+                    getComponentNameFromFiber(finishedWork) || "instance"
+                  ));
+              shouldProfile(finishedWork)
+                ? (startEffectTimer(),
+                  runWithFiberInDEV(
+                    finishedWork,
+                    callComponentDidUpdateInDEV,
+                    finishedWork,
+                    finishedRoot,
+                    prevProps,
+                    current,
+                    finishedRoot.__reactInternalSnapshotBeforeUpdate
+                  ),
+                  recordEffectDuration())
+                : runWithFiberInDEV(
+                    finishedWork,
+                    callComponentDidUpdateInDEV,
+                    finishedWork,
+                    finishedRoot,
+                    prevProps,
+                    current,
+                    finishedRoot.__reactInternalSnapshotBeforeUpdate
+                  );
+            }
+          flags & 64 && commitClassCallbacks(finishedWork);
+          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+          break;
+        case 3:
+          current = pushNestedEffectDurations();
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          if (
+            flags & 64 &&
+            ((flags = finishedWork.updateQueue), null !== flags)
+          ) {
+            prevProps = null;
+            if (null !== finishedWork.child)
+              switch (finishedWork.child.tag) {
+                case 27:
+                case 5:
+                  prevProps = finishedWork.child.stateNode;
+                  break;
+                case 1:
+                  prevProps = finishedWork.child.stateNode;
+              }
+            try {
+              runWithFiberInDEV(
+                finishedWork,
+                commitCallbacks,
+                flags,
+                prevProps
+              );
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+          }
+          finishedRoot.effectDuration += popNestedEffectDurations(current);
+          break;
+        case 26:
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+          break;
+        case 27:
+        case 5:
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          null === current && flags & 4 && commitHostMount(finishedWork);
+          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+          break;
+        case 12:
+          if (flags & 4) {
+            flags = pushNestedEffectDurations();
+            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+            finishedRoot = finishedWork.stateNode;
+            finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
+            try {
+              runWithFiberInDEV(
+                finishedWork,
+                commitProfiler,
+                finishedWork,
+                current,
+                commitStartTime,
+                finishedRoot.effectDuration
+              );
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+          } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          break;
+        case 13:
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          flags & 4 &&
+            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
+          flags & 64 &&
+            ((finishedRoot = finishedWork.memoizedState),
+            null !== finishedRoot &&
+              ((finishedRoot = finishedRoot.dehydrated),
+              null !== finishedRoot &&
+                ((flags = retryDehydratedSuspenseBoundary.bind(
+                  null,
+                  finishedWork
+                )),
+                registerSuspenseInstanceRetry(finishedRoot, flags))));
+          break;
+        case 22:
+          prevProps =
+            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
+          if (!prevProps) {
+            current =
+              (null !== current && null !== current.memoizedState) ||
+              offscreenSubtreeWasHidden;
+            var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
+              prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+            offscreenSubtreeIsHidden = prevProps;
+            (offscreenSubtreeWasHidden = current) &&
+            !prevOffscreenSubtreeWasHidden
+              ? recursivelyTraverseReappearLayoutEffects(
+                  finishedRoot,
+                  finishedWork,
+                  0 !== (finishedWork.subtreeFlags & 8772)
+                )
+              : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+          }
+          flags & 512 &&
+            ("manual" === finishedWork.memoizedProps.mode
+              ? safelyAttachRef(finishedWork, finishedWork.return)
+              : safelyDetachRef(finishedWork, finishedWork.return));
+          break;
+        case 30:
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+          break;
+        default:
+          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
+    }
+    function detachFiberAfterEffects(fiber) {
+      var alternate = fiber.alternate;
+      null !== alternate &&
+        ((fiber.alternate = null), detachFiberAfterEffects(alternate));
+      fiber.child = null;
+      fiber.deletions = null;
+      fiber.sibling = null;
+      5 === fiber.tag &&
+        ((alternate = fiber.stateNode),
+        null !== alternate && detachDeletedInstance(alternate));
+      fiber.stateNode = null;
+      fiber._debugOwner = null;
+      fiber.return = null;
+      fiber.dependencies = null;
+      fiber.memoizedProps = null;
+      fiber.memoizedState = null;
+      fiber.pendingProps = null;
+      fiber.stateNode = null;
+      fiber.updateQueue = null;
+    }
+    function recursivelyTraverseDeletionEffects(
+      finishedRoot,
+      nearestMountedAncestor,
+      parent
+    ) {
+      for (parent = parent.child; null !== parent; )
+        commitDeletionEffectsOnFiber(
+          finishedRoot,
+          nearestMountedAncestor,
+          parent
+        ),
+          (parent = parent.sibling);
+    }
+    function commitDeletionEffectsOnFiber(
+      finishedRoot,
+      nearestMountedAncestor,
+      deletedFiber
+    ) {
+      if (
+        injectedHook &&
+        "function" === typeof injectedHook.onCommitFiberUnmount
+      )
+        try {
+          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
+        } catch (err) {
+          hasLoggedError ||
+            ((hasLoggedError = !0),
+            console.error(
+              "React instrumentation encountered an error: %s",
+              err
+            ));
+        }
+      switch (deletedFiber.tag) {
+        case 26:
+          offscreenSubtreeWasHidden ||
+            safelyDetachRef(deletedFiber, nearestMountedAncestor);
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
+          deletedFiber.memoizedState
+            ? deletedFiber.memoizedState.count--
+            : deletedFiber.stateNode &&
+              ((deletedFiber = deletedFiber.stateNode),
+              deletedFiber.parentNode.removeChild(deletedFiber));
+          break;
+        case 27:
+          offscreenSubtreeWasHidden ||
+            safelyDetachRef(deletedFiber, nearestMountedAncestor);
+          var prevHostParent = hostParent,
+            prevHostParentIsContainer = hostParentIsContainer;
+          hostParent = deletedFiber.stateNode;
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
+          deletedFiber = deletedFiber.stateNode;
+          for (finishedRoot = deletedFiber.attributes; finishedRoot.length; )
+            deletedFiber.removeAttributeNode(finishedRoot[0]);
+          detachDeletedInstance(deletedFiber);
+          hostParent = prevHostParent;
+          hostParentIsContainer = prevHostParentIsContainer;
+          break;
+        case 5:
+          offscreenSubtreeWasHidden ||
+            safelyDetachRef(deletedFiber, nearestMountedAncestor);
+        case 6:
+          prevHostParent = hostParent;
+          prevHostParentIsContainer = hostParentIsContainer;
+          hostParent = null;
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
+          hostParent = prevHostParent;
+          hostParentIsContainer = prevHostParentIsContainer;
+          if (null !== hostParent)
+            if (hostParentIsContainer)
+              try {
+                runWithFiberInDEV(
+                  deletedFiber,
+                  removeChildFromContainer,
+                  hostParent,
+                  deletedFiber.stateNode
+                ),
+                  (viewTransitionMutationContext = !0);
+              } catch (error) {
+                captureCommitPhaseError(
+                  deletedFiber,
+                  nearestMountedAncestor,
+                  error
+                );
+              }
+            else
+              try {
+                runWithFiberInDEV(
+                  deletedFiber,
+                  removeChild,
+                  hostParent,
+                  deletedFiber.stateNode
+                ),
+                  (viewTransitionMutationContext = !0);
+              } catch (error) {
+                captureCommitPhaseError(
+                  deletedFiber,
+                  nearestMountedAncestor,
+                  error
+                );
+              }
+          break;
+        case 18:
+          null !== hostParent &&
+            (hostParentIsContainer
+              ? ((finishedRoot = hostParent),
+                (deletedFiber = deletedFiber.stateNode),
+                8 === finishedRoot.nodeType
+                  ? clearSuspenseBoundary(finishedRoot.parentNode, deletedFiber)
+                  : 1 === finishedRoot.nodeType &&
+                    clearSuspenseBoundary(finishedRoot, deletedFiber),
+                retryIfBlockedOn(finishedRoot))
+              : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
+          break;
+        case 4:
+          prevHostParent = hostParent;
+          prevHostParentIsContainer = hostParentIsContainer;
+          hostParent = deletedFiber.stateNode.containerInfo;
+          hostParentIsContainer = !0;
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
+          hostParent = prevHostParent;
+          hostParentIsContainer = prevHostParentIsContainer;
+          break;
+        case 0:
+        case 11:
+        case 14:
+        case 15:
+          offscreenSubtreeWasHidden ||
+            commitHookEffectListUnmount(
+              Insertion,
+              deletedFiber,
+              nearestMountedAncestor
+            );
+          offscreenSubtreeWasHidden ||
+            commitHookLayoutUnmountEffects(
+              deletedFiber,
+              nearestMountedAncestor,
+              Layout
+            );
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
+          break;
+        case 1:
+          offscreenSubtreeWasHidden ||
+            (safelyDetachRef(deletedFiber, nearestMountedAncestor),
+            (prevHostParent = deletedFiber.stateNode),
+            "function" === typeof prevHostParent.componentWillUnmount &&
+              safelyCallComponentWillUnmount(
+                deletedFiber,
+                nearestMountedAncestor,
+                prevHostParent
+              ));
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
+          break;
+        case 21:
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
+          break;
+        case 22:
+          offscreenSubtreeWasHidden ||
+            safelyDetachRef(deletedFiber, nearestMountedAncestor);
+          offscreenSubtreeWasHidden =
+            (prevHostParent = offscreenSubtreeWasHidden) ||
+            null !== deletedFiber.memoizedState;
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
+          offscreenSubtreeWasHidden = prevHostParent;
+          break;
+        default:
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
+      }
+    }
+    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
+      if (
+        null === finishedWork.memoizedState &&
+        ((finishedRoot = finishedWork.alternate),
+        null !== finishedRoot &&
+          ((finishedRoot = finishedRoot.memoizedState),
+          null !== finishedRoot &&
+            ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
+      )
+        try {
+          runWithFiberInDEV(
+            finishedWork,
+            commitHydratedSuspenseInstance,
+            finishedRoot
+          );
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+    }
+    function getRetryCache(finishedWork) {
+      switch (finishedWork.tag) {
+        case 13:
+        case 19:
+          var retryCache = finishedWork.stateNode;
+          null === retryCache &&
+            (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
+          return retryCache;
+        case 22:
+          return (
+            (finishedWork = finishedWork.stateNode),
+            (retryCache = finishedWork._retryCache),
+            null === retryCache &&
+              (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
+            retryCache
+          );
+        default:
+          throw Error(
+            "Unexpected Suspense handler tag (" +
+              finishedWork.tag +
+              "). This is a bug in React."
+          );
+      }
+    }
+    function attachSuspenseRetryListeners(finishedWork, wakeables) {
+      var retryCache = getRetryCache(finishedWork);
+      wakeables.forEach(function (wakeable) {
+        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
+        if (!retryCache.has(wakeable)) {
+          retryCache.add(wakeable);
+          if (isDevToolsPresent)
+            if (null !== inProgressLanes && null !== inProgressRoot)
+              restorePendingUpdaters(inProgressRoot, inProgressLanes);
+            else
+              throw Error(
+                "Expected finished root and lanes to be set. This is a bug in React."
+              );
+          wakeable.then(retry, retry);
+        }
+      });
+    }
+    function recursivelyTraverseMutationEffects(
+      root$jscomp$0,
+      parentFiber,
+      lanes
+    ) {
+      var deletions = parentFiber.deletions;
+      if (null !== deletions)
+        for (var i = 0; i < deletions.length; i++) {
+          var root = root$jscomp$0,
+            returnFiber = parentFiber,
+            deletedFiber = deletions[i],
+            parent = returnFiber;
+          a: for (; null !== parent; ) {
+            switch (parent.tag) {
+              case 27:
+              case 5:
+                hostParent = parent.stateNode;
+                hostParentIsContainer = !1;
+                break a;
+              case 3:
+                hostParent = parent.stateNode.containerInfo;
+                hostParentIsContainer = !0;
+                break a;
+              case 4:
+                hostParent = parent.stateNode.containerInfo;
+                hostParentIsContainer = !0;
+                break a;
+            }
+            parent = parent.return;
+          }
+          if (null === hostParent)
+            throw Error(
+              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
+            );
+          commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
+          hostParent = null;
+          hostParentIsContainer = !1;
+          root = deletedFiber;
+          returnFiber = root.alternate;
+          null !== returnFiber && (returnFiber.return = null);
+          root.return = null;
+        }
+      if (parentFiber.subtreeFlags & 13878)
+        for (parentFiber = parentFiber.child; null !== parentFiber; )
+          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0, lanes),
+            (parentFiber = parentFiber.sibling);
+    }
+    function commitMutationEffectsOnFiber(finishedWork, root, lanes) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors(),
+        current = finishedWork.alternate,
+        flags = finishedWork.flags;
+      switch (finishedWork.tag) {
+        case 0:
+        case 11:
+        case 14:
+        case 15:
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          flags & 4 &&
+            (commitHookEffectListUnmount(
+              Insertion | HasEffect,
+              finishedWork,
+              finishedWork.return
+            ),
+            commitHookEffectListMount(Insertion | HasEffect, finishedWork),
+            commitHookLayoutUnmountEffects(
+              finishedWork,
+              finishedWork.return,
+              Layout | HasEffect
+            ));
+          break;
+        case 1:
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          flags & 512 &&
+            (offscreenSubtreeWasHidden ||
+              null === current ||
+              safelyDetachRef(current, current.return));
+          flags & 64 &&
+            offscreenSubtreeIsHidden &&
+            ((current = finishedWork.updateQueue),
+            null !== current &&
+              ((flags = current.callbacks),
+              null !== flags &&
+                ((root = current.shared.hiddenCallbacks),
+                (current.shared.hiddenCallbacks =
+                  null === root ? flags : root.concat(flags)))));
+          break;
+        case 26:
+          var hoistableRoot = currentHoistableRoot;
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          flags & 512 &&
+            (offscreenSubtreeWasHidden ||
+              null === current ||
+              safelyDetachRef(current, current.return));
+          if (flags & 4)
+            if (
+              ((root = null !== current ? current.memoizedState : null),
+              (flags = finishedWork.memoizedState),
+              null === current)
+            )
+              if (null === flags)
+                if (null === finishedWork.stateNode) {
+                  a: {
+                    current = finishedWork.type;
+                    flags = finishedWork.memoizedProps;
+                    root = hoistableRoot.ownerDocument || hoistableRoot;
+                    b: switch (current) {
+                      case "title":
+                        lanes = root.getElementsByTagName("title")[0];
+                        if (
+                          !lanes ||
+                          lanes[internalHoistableMarker] ||
+                          lanes[internalInstanceKey] ||
+                          lanes.namespaceURI === SVG_NAMESPACE ||
+                          lanes.hasAttribute("itemprop")
+                        )
+                          (lanes = root.createElement(current)),
+                            root.head.insertBefore(
+                              lanes,
+                              root.querySelector("head > title")
+                            );
+                        setInitialProperties(lanes, current, flags);
+                        lanes[internalInstanceKey] = finishedWork;
+                        markNodeAsHoistable(lanes);
+                        current = lanes;
+                        break a;
+                      case "link":
+                        if (
+                          (hoistableRoot = getHydratableHoistableCache(
+                            "link",
+                            "href",
+                            root
+                          ).get(current + (flags.href || "")))
+                        )
+                          for (var i = 0; i < hoistableRoot.length; i++)
+                            if (
+                              ((lanes = hoistableRoot[i]),
+                              lanes.getAttribute("href") ===
+                                (null == flags.href || "" === flags.href
+                                  ? null
+                                  : flags.href) &&
+                                lanes.getAttribute("rel") ===
+                                  (null == flags.rel ? null : flags.rel) &&
+                                lanes.getAttribute("title") ===
+                                  (null == flags.title ? null : flags.title) &&
+                                lanes.getAttribute("crossorigin") ===
+                                  (null == flags.crossOrigin
+                                    ? null
+                                    : flags.crossOrigin))
+                            ) {
+                              hoistableRoot.splice(i, 1);
+                              break b;
+                            }
+                        lanes = root.createElement(current);
+                        setInitialProperties(lanes, current, flags);
+                        root.head.appendChild(lanes);
+                        break;
+                      case "meta":
+                        if (
+                          (hoistableRoot = getHydratableHoistableCache(
+                            "meta",
+                            "content",
+                            root
+                          ).get(current + (flags.content || "")))
+                        )
+                          for (i = 0; i < hoistableRoot.length; i++)
+                            if (
+                              ((lanes = hoistableRoot[i]),
+                              checkAttributeStringCoercion(
+                                flags.content,
+                                "content"
+                              ),
+                              lanes.getAttribute("content") ===
+                                (null == flags.content
+                                  ? null
+                                  : "" + flags.content) &&
+                                lanes.getAttribute("name") ===
+                                  (null == flags.name ? null : flags.name) &&
+                                lanes.getAttribute("property") ===
+                                  (null == flags.property
+                                    ? null
+                                    : flags.property) &&
+                                lanes.getAttribute("http-equiv") ===
+                                  (null == flags.httpEquiv
+                                    ? null
+                                    : flags.httpEquiv) &&
+                                lanes.getAttribute("charset") ===
+                                  (null == flags.charSet
+                                    ? null
+                                    : flags.charSet))
+                            ) {
+                              hoistableRoot.splice(i, 1);
+                              break b;
+                            }
+                        lanes = root.createElement(current);
+                        setInitialProperties(lanes, current, flags);
+                        root.head.appendChild(lanes);
+                        break;
+                      default:
+                        throw Error(
+                          'getNodesForType encountered a type it did not expect: "' +
+                            current +
+                            '". This is a bug in React.'
+                        );
+                    }
+                    lanes[internalInstanceKey] = finishedWork;
+                    markNodeAsHoistable(lanes);
+                    current = lanes;
+                  }
+                  finishedWork.stateNode = current;
+                } else
+                  mountHoistable(
+                    hoistableRoot,
+                    finishedWork.type,
+                    finishedWork.stateNode
+                  );
+              else
+                finishedWork.stateNode = acquireResource(
+                  hoistableRoot,
+                  flags,
+                  finishedWork.memoizedProps
+                );
+            else
+              root !== flags
+                ? (null === root
+                    ? null !== current.stateNode &&
+                      ((current = current.stateNode),
+                      current.parentNode.removeChild(current))
+                    : root.count--,
+                  null === flags
+                    ? mountHoistable(
+                        hoistableRoot,
+                        finishedWork.type,
+                        finishedWork.stateNode
+                      )
+                    : acquireResource(
+                        hoistableRoot,
+                        flags,
+                        finishedWork.memoizedProps
+                      ))
+                : null === flags &&
+                  null !== finishedWork.stateNode &&
+                  commitHostUpdate(
+                    finishedWork,
+                    finishedWork.memoizedProps,
+                    current.memoizedProps
+                  );
+          break;
+        case 27:
+          if (flags & 4 && null === finishedWork.alternate) {
+            hoistableRoot = finishedWork.stateNode;
+            i = finishedWork.memoizedProps;
+            try {
+              for (var node = hoistableRoot.firstChild; node; ) {
+                var nextNode = node.nextSibling,
+                  nodeName = node.nodeName;
+                node[internalHoistableMarker] ||
+                  "HEAD" === nodeName ||
+                  "BODY" === nodeName ||
+                  "SCRIPT" === nodeName ||
+                  "STYLE" === nodeName ||
+                  ("LINK" === nodeName &&
+                    "stylesheet" === node.rel.toLowerCase()) ||
+                  hoistableRoot.removeChild(node);
+                node = nextNode;
+              }
+              runWithFiberInDEV(
+                finishedWork,
+                acquireSingletonInstance,
+                finishedWork.type,
+                i,
+                hoistableRoot,
+                finishedWork
+              );
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+          }
+        case 5:
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          flags & 512 &&
+            (offscreenSubtreeWasHidden ||
+              null === current ||
+              safelyDetachRef(current, current.return));
+          if (finishedWork.flags & 32) {
+            root = finishedWork.stateNode;
+            try {
+              runWithFiberInDEV(finishedWork, resetTextContent, root),
+                (viewTransitionMutationContext = !0);
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+          }
+          flags & 4 &&
+            null != finishedWork.stateNode &&
+            ((root = finishedWork.memoizedProps),
+            commitHostUpdate(
+              finishedWork,
+              root,
+              null !== current ? current.memoizedProps : root
+            ));
+          flags & 1024 &&
+            ((needsFormReset = !0),
+            "form" !== finishedWork.type &&
+              console.error(
+                "Unexpected host component type. Expected a form. This is a bug in React."
+              ));
+          break;
+        case 6:
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          if (flags & 4) {
+            if (null === finishedWork.stateNode)
+              throw Error(
+                "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
+              );
+            flags = finishedWork.memoizedProps;
+            current = null !== current ? current.memoizedProps : flags;
+            root = finishedWork.stateNode;
+            try {
+              runWithFiberInDEV(
+                finishedWork,
+                commitTextUpdate,
+                root,
+                current,
+                flags
+              ),
+                (viewTransitionMutationContext = !0);
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+          }
+          break;
+        case 3:
+          hoistableRoot = pushNestedEffectDurations();
+          tagCaches = null;
+          i = currentHoistableRoot;
+          currentHoistableRoot = getHoistableRoot(root.containerInfo);
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          currentHoistableRoot = i;
+          commitReconciliationEffects(finishedWork);
+          if (
+            flags & 4 &&
+            null !== current &&
+            current.memoizedState.isDehydrated
+          )
+            try {
+              runWithFiberInDEV(
+                finishedWork,
+                commitHydratedContainer,
+                root.containerInfo
+              );
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+          needsFormReset &&
+            ((needsFormReset = !1), recursivelyResetForms(finishedWork));
+          root.effectDuration += popNestedEffectDurations(hoistableRoot);
+          break;
+        case 4:
+          current = currentHoistableRoot;
+          currentHoistableRoot = getHoistableRoot(
+            finishedWork.stateNode.containerInfo
+          );
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          currentHoistableRoot = current;
+          break;
+        case 12:
+          current = pushNestedEffectDurations();
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          finishedWork.stateNode.effectDuration +=
+            bubbleNestedEffectDurations(current);
+          break;
+        case 13:
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          finishedWork.child.flags & 8192 &&
+            (null !== finishedWork.memoizedState) !==
+              (null !== current && null !== current.memoizedState) &&
+            (globalMostRecentFallbackTime = now$1());
+          flags & 4 &&
+            ((current = finishedWork.updateQueue),
+            null !== current &&
+              ((finishedWork.updateQueue = null),
+              attachSuspenseRetryListeners(finishedWork, current)));
+          break;
+        case 22:
+          flags & 512 &&
+            (offscreenSubtreeWasHidden ||
+              null === current ||
+              safelyDetachRef(current, current.return));
+          node = null !== finishedWork.memoizedState;
+          nextNode = null !== current && null !== current.memoizedState;
+          nodeName = offscreenSubtreeIsHidden;
+          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+          offscreenSubtreeIsHidden = nodeName || node;
+          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || nextNode;
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+          offscreenSubtreeIsHidden = nodeName;
+          commitReconciliationEffects(finishedWork);
+          root = finishedWork.stateNode;
+          root._current = finishedWork;
+          root._visibility &= ~OffscreenDetached;
+          root._visibility |= root._pendingVisibility & OffscreenDetached;
+          if (
+            flags & 8192 &&
+            ((root._visibility = node
+              ? root._visibility & ~OffscreenVisible
+              : root._visibility | OffscreenVisible),
+            node &&
+              ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
+              null === current ||
+                nextNode ||
+                root ||
+                recursivelyTraverseDisappearLayoutEffects(finishedWork)),
+            null === finishedWork.memoizedProps ||
+              "manual" !== finishedWork.memoizedProps.mode)
+          )
+            a: for (current = null, root = finishedWork; ; ) {
+              if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
+                if (null === current) {
+                  lanes = current = root;
+                  try {
+                    (hoistableRoot = lanes.stateNode),
+                      node
+                        ? runWithFiberInDEV(lanes, hideInstance, hoistableRoot)
+                        : runWithFiberInDEV(
+                            lanes,
+                            unhideInstance,
+                            lanes.stateNode,
+                            lanes.memoizedProps
+                          );
+                  } catch (error) {
+                    captureCommitPhaseError(lanes, lanes.return, error);
+                  }
+                }
+              } else if (6 === root.tag) {
+                if (null === current) {
+                  lanes = root;
+                  try {
+                    (i = lanes.stateNode),
+                      node
+                        ? runWithFiberInDEV(lanes, hideTextInstance, i)
+                        : runWithFiberInDEV(
+                            lanes,
+                            unhideTextInstance,
+                            i,
+                            lanes.memoizedProps
+                          );
+                  } catch (error) {
+                    captureCommitPhaseError(lanes, lanes.return, error);
+                  }
+                }
+              } else if (
+                ((22 !== root.tag && 23 !== root.tag) ||
+                  null === root.memoizedState ||
+                  root === finishedWork) &&
+                null !== root.child
+              ) {
+                root.child.return = root;
+                root = root.child;
+                continue;
+              }
+              if (root === finishedWork) break a;
+              for (; null === root.sibling; ) {
+                if (null === root.return || root.return === finishedWork)
+                  break a;
+                current === root && (current = null);
+                root = root.return;
+              }
+              current === root && (current = null);
+              root.sibling.return = root.return;
+              root = root.sibling;
+            }
+          flags & 4 &&
+            ((current = finishedWork.updateQueue),
+            null !== current &&
+              ((flags = current.retryQueue),
+              null !== flags &&
+                ((current.retryQueue = null),
+                attachSuspenseRetryListeners(finishedWork, flags))));
+          break;
+        case 19:
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          flags & 4 &&
+            ((current = finishedWork.updateQueue),
+            null !== current &&
+              ((finishedWork.updateQueue = null),
+              attachSuspenseRetryListeners(finishedWork, current)));
+          break;
+        case 30:
+          flags & 512 &&
+            (offscreenSubtreeWasHidden ||
+              null === current ||
+              safelyDetachRef(current, current.return));
+          flags = viewTransitionMutationContext;
+          viewTransitionMutationContext = !1;
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+          commitReconciliationEffects(finishedWork);
+          (lanes & 335544192) === lanes &&
+            null !== current &&
+            viewTransitionMutationContext &&
+            (finishedWork.flags |= 4);
+          viewTransitionMutationContext = flags;
+          break;
+        case 21:
+          break;
+        default:
+          recursivelyTraverseMutationEffects(root, finishedWork, lanes),
+            commitReconciliationEffects(finishedWork);
+      }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
+    }
+    function commitReconciliationEffects(finishedWork) {
+      var flags = finishedWork.flags;
+      if (flags & 2) {
+        try {
+          runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+        finishedWork.flags &= -3;
+      }
+      flags & 4096 && (finishedWork.flags &= -4097);
+    }
+    function recursivelyResetForms(parentFiber) {
+      if (parentFiber.subtreeFlags & 1024)
+        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+          var fiber = parentFiber;
+          recursivelyResetForms(fiber);
+          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
+          parentFiber = parentFiber.sibling;
+        }
+    }
+    function recursivelyTraverseAfterMutationEffects(root, parentFiber) {
+      if (parentFiber.subtreeFlags & 9238)
+        for (parentFiber = parentFiber.child; null !== parentFiber; )
+          commitAfterMutationEffectsOnFiber(parentFiber, root),
+            (parentFiber = parentFiber.sibling);
+      else measureNestedViewTransitions(parentFiber);
+    }
+    function commitAfterMutationEffectsOnFiber(finishedWork, root) {
+      var current = finishedWork.alternate;
+      if (null === current) commitEnterViewTransitions(finishedWork);
+      else
+        switch (finishedWork.tag) {
+          case 3:
+            viewTransitionContextChanged = !1;
+            viewTransitionCancelableChildren = null;
+            recursivelyTraverseAfterMutationEffects(root, finishedWork);
+            if (!viewTransitionContextChanged) {
+              finishedWork = viewTransitionCancelableChildren;
+              viewTransitionCancelableChildren = null;
+              if (null !== finishedWork)
+                for (var i = 0; i < finishedWork.length; i += 3) {
+                  var instance = finishedWork[i],
+                    oldName = finishedWork[i + 1];
+                  restoreViewTransitionName(instance, finishedWork[i + 2]);
+                  instance = instance.ownerDocument.documentElement;
+                  null !== instance &&
+                    instance.animate(
+                      { opacity: [0, 0], pointerEvents: ["none", "none"] },
+                      {
+                        duration: 0,
+                        fill: "forwards",
+                        pseudoElement:
+                          "::view-transition-group(" + oldName + ")"
+                      }
+                    );
+                }
+              finishedWork = root.containerInfo;
+              finishedWork =
+                9 === finishedWork.nodeType
+                  ? finishedWork.documentElement
+                  : finishedWork.ownerDocument.documentElement;
+              null !== finishedWork &&
+                "" === finishedWork.style.viewTransitionName &&
+                ((finishedWork.style.viewTransitionName = "none"),
+                finishedWork.animate(
+                  { opacity: [0, 0], pointerEvents: ["none", "none"] },
+                  {
+                    duration: 0,
+                    fill: "forwards",
+                    pseudoElement: "::view-transition-group(root)"
+                  }
+                ),
+                finishedWork.animate(
+                  { width: [0, 0], height: [0, 0] },
+                  {
+                    duration: 0,
+                    fill: "forwards",
+                    pseudoElement: "::view-transition"
+                  }
+                ));
+            }
+            break;
+          case 5:
+            recursivelyTraverseAfterMutationEffects(root, finishedWork);
+            break;
+          case 22:
+            null === finishedWork.memoizedState &&
+              (null !== current.memoizedState
+                ? commitEnterViewTransitions(finishedWork)
+                : recursivelyTraverseAfterMutationEffects(root, finishedWork));
+            break;
+          case 30:
+            if (0 !== (finishedWork.subtreeFlags & 8246)) {
+              i = 0 !== (finishedWork.flags & 4);
+              oldName = viewTransitionContextChanged;
+              instance = viewTransitionCancelableChildren;
+              viewTransitionContextChanged = !1;
+              viewTransitionCancelableChildren = null;
+              recursivelyTraverseAfterMutationEffects(root, finishedWork);
+              viewTransitionContextChanged && (finishedWork.flags |= 4);
+              a: {
+                root = finishedWork.memoizedProps;
+                var updateClassName = getViewTransitionClassName(
+                    root.className,
+                    root.update
+                  ),
+                  layoutClassName = getViewTransitionClassName(
+                    root.className,
+                    root.update
+                  );
+                if ("none" === updateClassName) {
+                  if ("none" === layoutClassName) {
+                    current = !1;
+                    break a;
+                  }
+                  finishedWork.flags &= -5;
+                  updateClassName = layoutClassName;
+                } else if (0 === (finishedWork.flags & 4)) {
+                  if ("none" === layoutClassName) {
+                    viewTransitionHostInstanceIdx = 0;
+                    cancelViewTransitionHostInstances(
+                      current,
+                      finishedWork.child,
+                      !0
+                    );
+                    current = !1;
+                    break a;
+                  }
+                  updateClassName = layoutClassName;
+                }
+                layoutClassName = getViewTransitionName(
+                  root,
+                  finishedWork.stateNode
+                );
+                viewTransitionHostInstanceIdx = 0;
+                root = current.memoizedState;
+                current = measureViewTransitionHostInstances(
+                  current,
+                  finishedWork,
+                  finishedWork.child,
+                  layoutClassName,
+                  updateClassName,
+                  root,
+                  !0
+                );
+                viewTransitionHostInstanceIdx !==
+                  (null === root ? 0 : root.length) &&
+                  (finishedWork.flags |= 32);
+              }
+              0 !== (finishedWork.flags & 4) && current
+                ? ((current = finishedWork.memoizedProps),
+                  scheduleViewTransitionEvent(
+                    finishedWork,
+                    i || viewTransitionContextChanged
+                      ? current.onUpdate
+                      : current.onLayout
+                  ),
+                  (viewTransitionCancelableChildren = instance))
+                : null !== instance &&
+                  (instance.push.apply(
+                    instance,
+                    viewTransitionCancelableChildren
+                  ),
+                  (viewTransitionCancelableChildren = instance));
+              viewTransitionContextChanged =
+                0 !== (finishedWork.flags & 32) ? !0 : oldName;
+            }
+            break;
+          default:
+            recursivelyTraverseAfterMutationEffects(root, finishedWork);
+        }
+    }
+    function recursivelyTraverseLayoutEffects(root, parentFiber) {
+      if (parentFiber.subtreeFlags & 8772)
+        for (parentFiber = parentFiber.child; null !== parentFiber; )
+          commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
+            (parentFiber = parentFiber.sibling);
+    }
+    function disappearLayoutEffects(finishedWork) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
+      switch (finishedWork.tag) {
+        case 0:
+        case 11:
+        case 14:
+        case 15:
+          commitHookLayoutUnmountEffects(
+            finishedWork,
+            finishedWork.return,
+            Layout
+          );
+          recursivelyTraverseDisappearLayoutEffects(finishedWork);
+          break;
+        case 1:
+          safelyDetachRef(finishedWork, finishedWork.return);
+          var instance = finishedWork.stateNode;
+          "function" === typeof instance.componentWillUnmount &&
+            safelyCallComponentWillUnmount(
+              finishedWork,
+              finishedWork.return,
+              instance
+            );
+          recursivelyTraverseDisappearLayoutEffects(finishedWork);
+          break;
+        case 26:
+        case 27:
+        case 5:
+          safelyDetachRef(finishedWork, finishedWork.return);
+          recursivelyTraverseDisappearLayoutEffects(finishedWork);
+          break;
+        case 22:
+          safelyDetachRef(finishedWork, finishedWork.return);
+          null === finishedWork.memoizedState &&
+            recursivelyTraverseDisappearLayoutEffects(finishedWork);
+          break;
+        case 30:
+          safelyDetachRef(finishedWork, finishedWork.return);
+        default:
+          recursivelyTraverseDisappearLayoutEffects(finishedWork);
+      }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
+    }
+    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
+      for (parentFiber = parentFiber.child; null !== parentFiber; )
+        disappearLayoutEffects(parentFiber),
+          (parentFiber = parentFiber.sibling);
+    }
+    function reappearLayoutEffects(
+      finishedRoot,
+      current,
+      finishedWork,
+      includeWorkInProgressEffects
+    ) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors(),
+        flags = finishedWork.flags;
+      switch (finishedWork.tag) {
+        case 0:
+        case 11:
+        case 15:
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+          commitHookLayoutEffects(finishedWork, Layout);
+          break;
+        case 1:
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+          current = finishedWork.stateNode;
+          "function" === typeof current.componentDidMount &&
+            runWithFiberInDEV(
+              finishedWork,
+              callComponentDidMountInDEV,
+              finishedWork,
+              current
+            );
+          current = finishedWork.updateQueue;
+          if (null !== current) {
+            finishedRoot = finishedWork.stateNode;
+            try {
+              runWithFiberInDEV(
+                finishedWork,
+                commitHiddenCallbacks,
+                current,
+                finishedRoot
+              );
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+          }
+          includeWorkInProgressEffects &&
+            flags & 64 &&
+            commitClassCallbacks(finishedWork);
+          safelyAttachRef(finishedWork, finishedWork.return);
+          break;
+        case 26:
+        case 27:
+        case 5:
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+          includeWorkInProgressEffects &&
+            null === current &&
+            flags & 4 &&
+            commitHostMount(finishedWork);
+          safelyAttachRef(finishedWork, finishedWork.return);
+          break;
+        case 12:
+          if (includeWorkInProgressEffects && flags & 4) {
+            flags = pushNestedEffectDurations();
+            recursivelyTraverseReappearLayoutEffects(
+              finishedRoot,
+              finishedWork,
+              includeWorkInProgressEffects
+            );
+            includeWorkInProgressEffects = finishedWork.stateNode;
+            includeWorkInProgressEffects.effectDuration +=
+              bubbleNestedEffectDurations(flags);
+            try {
+              runWithFiberInDEV(
+                finishedWork,
+                commitProfiler,
+                finishedWork,
+                current,
+                commitStartTime,
+                includeWorkInProgressEffects.effectDuration
+              );
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+          } else
+            recursivelyTraverseReappearLayoutEffects(
+              finishedRoot,
+              finishedWork,
+              includeWorkInProgressEffects
+            );
+          break;
+        case 13:
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+          includeWorkInProgressEffects &&
+            flags & 4 &&
+            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
+          break;
+        case 22:
+          null === finishedWork.memoizedState &&
+            recursivelyTraverseReappearLayoutEffects(
+              finishedRoot,
+              finishedWork,
+              includeWorkInProgressEffects
+            );
+          safelyAttachRef(finishedWork, finishedWork.return);
+          break;
+        case 30:
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+          safelyAttachRef(finishedWork, finishedWork.return);
+          break;
+        default:
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+      }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
+    }
+    function recursivelyTraverseReappearLayoutEffects(
+      finishedRoot,
+      parentFiber,
+      includeWorkInProgressEffects
+    ) {
+      includeWorkInProgressEffects =
+        includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
+      for (parentFiber = parentFiber.child; null !== parentFiber; )
+        reappearLayoutEffects(
+          finishedRoot,
+          parentFiber.alternate,
+          parentFiber,
+          includeWorkInProgressEffects
+        ),
+          (parentFiber = parentFiber.sibling);
+    }
+    function commitOffscreenPassiveMountEffects(current, finishedWork) {
+      var previousCache = null;
+      null !== current &&
+        null !== current.memoizedState &&
+        null !== current.memoizedState.cachePool &&
+        (previousCache = current.memoizedState.cachePool.pool);
+      current = null;
+      null !== finishedWork.memoizedState &&
+        null !== finishedWork.memoizedState.cachePool &&
+        (current = finishedWork.memoizedState.cachePool.pool);
+      current !== previousCache &&
+        (null != current && retainCache(current),
+        null != previousCache && releaseCache(previousCache));
+    }
+    function commitCachePassiveMountEffect(current, finishedWork) {
+      current = null;
+      null !== finishedWork.alternate &&
+        (current = finishedWork.alternate.memoizedState.cache);
+      finishedWork = finishedWork.memoizedState.cache;
+      finishedWork !== current &&
+        (retainCache(finishedWork), null != current && releaseCache(current));
+    }
+    function recursivelyTraversePassiveMountEffects(
+      root,
+      parentFiber,
+      committedLanes,
+      committedTransitions,
+      endTime
+    ) {
+      var isViewTransitionEligible =
+        (committedLanes & 335544192) === committedLanes;
+      if (
+        parentFiber.subtreeFlags & (isViewTransitionEligible ? 10262 : 10256) ||
+        (0 !== parentFiber.actualDuration &&
+          (null === parentFiber.alternate ||
+            parentFiber.alternate.child !== parentFiber.child))
+      )
+        for (parentFiber = parentFiber.child; null !== parentFiber; )
+          (isViewTransitionEligible = parentFiber.sibling),
+            commitPassiveMountOnFiber(
+              root,
+              parentFiber,
+              committedLanes,
+              committedTransitions,
+              null !== isViewTransitionEligible
+                ? isViewTransitionEligible.actualStartTime
+                : endTime
+            ),
+            (parentFiber = isViewTransitionEligible);
+      else
+        isViewTransitionEligible && restoreNestedViewTransitions(parentFiber);
+    }
+    function commitPassiveMountOnFiber(
+      finishedRoot,
+      finishedWork,
+      committedLanes,
+      committedTransitions,
+      endTime
+    ) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 < finishedWork.actualStartTime &&
+        0 !== (finishedWork.flags & 1) &&
+        logComponentRender(
+          finishedWork,
+          finishedWork.actualStartTime,
+          endTime,
+          inHydratedSubtree
+        );
+      var isViewTransitionEligible =
+        (committedLanes & 335544192) === committedLanes;
+      isViewTransitionEligible &&
+        null === finishedWork.alternate &&
+        null !== finishedWork.return &&
+        null !== finishedWork.return.alternate &&
+        restoreEnterViewTransitions(finishedWork);
+      var flags = finishedWork.flags;
+      switch (finishedWork.tag) {
+        case 0:
+        case 11:
+        case 15:
+          (finishedWork.mode & ProfileMode) !== NoMode &&
+            0 < finishedWork.actualStartTime &&
+            0 !== (finishedWork.flags & 1) &&
+            logComponentRender(
+              finishedWork,
+              finishedWork.actualStartTime,
+              endTime,
+              inHydratedSubtree
+            );
+          recursivelyTraversePassiveMountEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
+          flags & 2048 &&
+            commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
+          break;
+        case 1:
+          (finishedWork.mode & ProfileMode) !== NoMode &&
+            0 < finishedWork.actualStartTime &&
+            (0 !== (finishedWork.flags & 128)
+              ? logComponentErrored(
+                  finishedWork,
+                  finishedWork.actualStartTime,
+                  endTime,
+                  []
+                )
+              : 0 !== (finishedWork.flags & 1) &&
+                logComponentRender(
+                  finishedWork,
+                  finishedWork.actualStartTime,
+                  endTime,
+                  inHydratedSubtree
+                ));
+          recursivelyTraversePassiveMountEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
+          break;
+        case 3:
+          var prevEffectDuration = pushNestedEffectDurations(),
+            wasInHydratedSubtree = inHydratedSubtree;
+          inHydratedSubtree =
+            null !== finishedWork.alternate &&
+            finishedWork.alternate.memoizedState.isDehydrated &&
+            0 === (finishedWork.flags & 256);
+          recursivelyTraversePassiveMountEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
+          inHydratedSubtree = wasInHydratedSubtree;
+          isViewTransitionEligible &&
+            ((committedLanes = finishedRoot.containerInfo),
+            (committedLanes =
+              9 === committedLanes.nodeType
+                ? committedLanes.documentElement
+                : committedLanes.ownerDocument.documentElement),
+            null !== committedLanes &&
+              "none" === committedLanes.style.viewTransitionName &&
+              (committedLanes.style.viewTransitionName = ""));
+          flags & 2048 &&
+            ((committedLanes = null),
+            null !== finishedWork.alternate &&
+              (committedLanes = finishedWork.alternate.memoizedState.cache),
+            (committedTransitions = finishedWork.memoizedState.cache),
+            committedTransitions !== committedLanes &&
+              (retainCache(committedTransitions),
+              null != committedLanes && releaseCache(committedLanes)));
+          finishedRoot.passiveEffectDuration +=
+            popNestedEffectDurations(prevEffectDuration);
+          break;
+        case 12:
+          if (flags & 2048) {
+            flags = pushNestedEffectDurations();
+            recursivelyTraversePassiveMountEffects(
+              finishedRoot,
+              finishedWork,
+              committedLanes,
+              committedTransitions,
+              endTime
+            );
+            finishedRoot = finishedWork.stateNode;
+            finishedRoot.passiveEffectDuration +=
+              bubbleNestedEffectDurations(flags);
+            try {
+              runWithFiberInDEV(
+                finishedWork,
+                commitProfilerPostCommitImpl,
+                finishedWork,
+                finishedWork.alternate,
+                commitStartTime,
+                finishedRoot.passiveEffectDuration
+              );
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+          } else
+            recursivelyTraversePassiveMountEffects(
+              finishedRoot,
+              finishedWork,
+              committedLanes,
+              committedTransitions,
+              endTime
+            );
+          break;
+        case 13:
+          flags = inHydratedSubtree;
+          prevEffectDuration =
+            null !== finishedWork.alternate
+              ? finishedWork.alternate.memoizedState
+              : null;
+          isViewTransitionEligible = finishedWork.memoizedState;
+          null === prevEffectDuration ||
+          null === prevEffectDuration.dehydrated ||
+          (null !== isViewTransitionEligible &&
+            null !== isViewTransitionEligible.dehydrated)
+            ? (inHydratedSubtree = !1)
+            : ((isViewTransitionEligible = finishedWork.deletions),
+              null !== isViewTransitionEligible &&
+              0 < isViewTransitionEligible.length &&
+              18 === isViewTransitionEligible[0].tag
+                ? ((inHydratedSubtree = !1),
+                  (prevEffectDuration = prevEffectDuration.hydrationErrors),
+                  null !== prevEffectDuration &&
+                    logComponentErrored(
+                      finishedWork,
+                      finishedWork.actualStartTime,
+                      endTime,
+                      prevEffectDuration
+                    ))
+                : (inHydratedSubtree = !0));
+          recursivelyTraversePassiveMountEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
+          inHydratedSubtree = flags;
+          break;
+        case 23:
+          break;
+        case 22:
+          prevEffectDuration = finishedWork.stateNode;
+          wasInHydratedSubtree = finishedWork.alternate;
+          null !== finishedWork.memoizedState
+            ? (isViewTransitionEligible &&
+                null !== wasInHydratedSubtree &&
+                null === wasInHydratedSubtree.memoizedState &&
+                restoreExitViewTransitions(wasInHydratedSubtree),
+              prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
+                ? recursivelyTraversePassiveMountEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    endTime
+                  )
+                : recursivelyTraverseAtomicPassiveEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    endTime
+                  ))
+            : (isViewTransitionEligible &&
+                null !== wasInHydratedSubtree &&
+                null !== wasInHydratedSubtree.memoizedState &&
+                restoreEnterViewTransitions(finishedWork),
+              prevEffectDuration._visibility & OffscreenPassiveEffectsConnected
+                ? recursivelyTraversePassiveMountEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    endTime
+                  )
+                : ((prevEffectDuration._visibility |=
+                    OffscreenPassiveEffectsConnected),
+                  recursivelyTraverseReconnectPassiveEffects(
+                    finishedRoot,
+                    finishedWork,
+                    committedLanes,
+                    committedTransitions,
+                    0 !== (finishedWork.subtreeFlags & 10256),
+                    endTime
+                  )));
+          flags & 2048 &&
+            commitOffscreenPassiveMountEffects(
+              wasInHydratedSubtree,
+              finishedWork
+            );
+          break;
+        case 24:
+          recursivelyTraversePassiveMountEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
+          flags & 2048 &&
+            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
+          break;
+        case 30:
+          isViewTransitionEligible &&
+            ((flags = finishedWork.alternate),
+            null !== flags &&
+              0 !== (finishedWork.subtreeFlags & 8246) &&
+              ((finishedWork.memoizedState = null),
+              restoreViewTransitionOnHostInstances(flags.child, !0),
+              restoreViewTransitionOnHostInstances(finishedWork.child, !0)));
+          recursivelyTraversePassiveMountEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
+          break;
+        default:
+          recursivelyTraversePassiveMountEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            endTime
+          );
+      }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
+    }
+    function recursivelyTraverseReconnectPassiveEffects(
+      finishedRoot,
+      parentFiber,
+      committedLanes,
+      committedTransitions,
+      includeWorkInProgressEffects,
+      endTime
+    ) {
+      includeWorkInProgressEffects =
+        includeWorkInProgressEffects &&
+        0 !== (parentFiber.subtreeFlags & 10256);
+      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+        var nextSibling = parentFiber.sibling;
+        reconnectPassiveEffects(
+          finishedRoot,
+          parentFiber,
+          committedLanes,
+          committedTransitions,
+          includeWorkInProgressEffects,
+          null !== nextSibling ? nextSibling.actualStartTime : endTime
+        );
+        parentFiber = nextSibling;
+      }
+    }
+    function reconnectPassiveEffects(
+      finishedRoot,
+      finishedWork,
+      committedLanes,
+      committedTransitions,
+      includeWorkInProgressEffects,
+      endTime
+    ) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 < finishedWork.actualStartTime &&
+        0 !== (finishedWork.flags & 1) &&
+        logComponentRender(
+          finishedWork,
+          finishedWork.actualStartTime,
+          endTime,
+          inHydratedSubtree
+        );
+      var flags = finishedWork.flags;
+      switch (finishedWork.tag) {
+        case 0:
+        case 11:
+        case 15:
+          recursivelyTraverseReconnectPassiveEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            includeWorkInProgressEffects,
+            endTime
+          );
+          commitHookPassiveMountEffects(finishedWork, Passive);
+          break;
+        case 23:
+          break;
+        case 22:
+          var _instance2 = finishedWork.stateNode;
+          null !== finishedWork.memoizedState
+            ? _instance2._visibility & OffscreenPassiveEffectsConnected
+              ? recursivelyTraverseReconnectPassiveEffects(
+                  finishedRoot,
+                  finishedWork,
+                  committedLanes,
+                  committedTransitions,
+                  includeWorkInProgressEffects,
+                  endTime
+                )
+              : recursivelyTraverseAtomicPassiveEffects(
+                  finishedRoot,
+                  finishedWork,
+                  committedLanes,
+                  committedTransitions,
+                  endTime
+                )
+            : ((_instance2._visibility |= OffscreenPassiveEffectsConnected),
+              recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions,
+                includeWorkInProgressEffects,
+                endTime
+              ));
+          includeWorkInProgressEffects &&
+            flags & 2048 &&
+            commitOffscreenPassiveMountEffects(
+              finishedWork.alternate,
+              finishedWork
+            );
+          break;
+        case 24:
+          recursivelyTraverseReconnectPassiveEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            includeWorkInProgressEffects,
+            endTime
+          );
+          includeWorkInProgressEffects &&
+            flags & 2048 &&
+            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
+          break;
+        default:
+          recursivelyTraverseReconnectPassiveEffects(
+            finishedRoot,
+            finishedWork,
+            committedLanes,
+            committedTransitions,
+            includeWorkInProgressEffects,
+            endTime
+          );
+      }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
+    }
+    function recursivelyTraverseAtomicPassiveEffects(
+      finishedRoot$jscomp$0,
+      parentFiber,
+      committedLanes$jscomp$0,
+      committedTransitions$jscomp$0,
+      endTime$jscomp$0
+    ) {
+      if (parentFiber.subtreeFlags & 10256)
+        for (var child = parentFiber.child; null !== child; ) {
+          parentFiber = child.sibling;
+          var finishedRoot = finishedRoot$jscomp$0,
+            committedLanes = committedLanes$jscomp$0,
+            committedTransitions = committedTransitions$jscomp$0,
+            endTime =
+              null !== parentFiber
+                ? parentFiber.actualStartTime
+                : endTime$jscomp$0;
+          (child.mode & ProfileMode) !== NoMode &&
+            0 < child.actualStartTime &&
+            0 !== (child.flags & 1) &&
+            logComponentRender(
+              child,
+              child.actualStartTime,
+              endTime,
+              inHydratedSubtree
+            );
+          var flags = child.flags;
+          switch (child.tag) {
+            case 22:
+              recursivelyTraverseAtomicPassiveEffects(
+                finishedRoot,
+                child,
+                committedLanes,
+                committedTransitions,
+                endTime
+              );
+              flags & 2048 &&
+                commitOffscreenPassiveMountEffects(child.alternate, child);
+              break;
+            case 24:
+              recursivelyTraverseAtomicPassiveEffects(
+                finishedRoot,
+                child,
+                committedLanes,
+                committedTransitions,
+                endTime
+              );
+              flags & 2048 &&
+                commitCachePassiveMountEffect(child.alternate, child);
+              break;
+            default:
+              recursivelyTraverseAtomicPassiveEffects(
+                finishedRoot,
+                child,
+                committedLanes,
+                committedTransitions,
+                endTime
+              );
+          }
+          child = parentFiber;
+        }
+    }
+    function recursivelyAccumulateSuspenseyCommit(parentFiber) {
+      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
+        for (parentFiber = parentFiber.child; null !== parentFiber; )
+          accumulateSuspenseyCommitOnFiber(parentFiber),
+            (parentFiber = parentFiber.sibling);
+    }
+    function accumulateSuspenseyCommitOnFiber(fiber) {
+      switch (fiber.tag) {
+        case 26:
+          recursivelyAccumulateSuspenseyCommit(fiber);
+          fiber.flags & suspenseyCommitFlag &&
+            null !== fiber.memoizedState &&
+            suspendResource(
+              currentHoistableRoot,
+              fiber.memoizedState,
+              fiber.memoizedProps
+            );
+          break;
+        case 5:
+          recursivelyAccumulateSuspenseyCommit(fiber);
+          break;
+        case 3:
+        case 4:
+          var previousHoistableRoot = currentHoistableRoot;
+          currentHoistableRoot = getHoistableRoot(
+            fiber.stateNode.containerInfo
+          );
+          recursivelyAccumulateSuspenseyCommit(fiber);
+          currentHoistableRoot = previousHoistableRoot;
+          break;
+        case 22:
+          null === fiber.memoizedState &&
+            ((previousHoistableRoot = fiber.alternate),
+            null !== previousHoistableRoot &&
+            null !== previousHoistableRoot.memoizedState
+              ? ((previousHoistableRoot = suspenseyCommitFlag),
+                (suspenseyCommitFlag = 16777216),
+                recursivelyAccumulateSuspenseyCommit(fiber),
+                (suspenseyCommitFlag = previousHoistableRoot))
+              : recursivelyAccumulateSuspenseyCommit(fiber));
+          break;
+        default:
+          recursivelyAccumulateSuspenseyCommit(fiber);
+      }
+    }
+    function detachAlternateSiblings(parentFiber) {
+      var previousFiber = parentFiber.alternate;
+      if (
+        null !== previousFiber &&
+        ((parentFiber = previousFiber.child), null !== parentFiber)
+      ) {
+        previousFiber.child = null;
+        do
+          (previousFiber = parentFiber.sibling),
+            (parentFiber.sibling = null),
+            (parentFiber = previousFiber);
+        while (null !== parentFiber);
+      }
+    }
+    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
+      var deletions = parentFiber.deletions;
+      if (0 !== (parentFiber.flags & 16)) {
+        if (null !== deletions)
+          for (var i = 0; i < deletions.length; i++) {
+            var childToDelete = deletions[i];
+            nextEffect = childToDelete;
+            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+              childToDelete,
+              parentFiber
+            );
+          }
+        detachAlternateSiblings(parentFiber);
+      }
+      if (parentFiber.subtreeFlags & 10256)
+        for (parentFiber = parentFiber.child; null !== parentFiber; )
+          commitPassiveUnmountOnFiber(parentFiber),
+            (parentFiber = parentFiber.sibling);
+    }
+    function commitPassiveUnmountOnFiber(finishedWork) {
+      var prevEffectStart = pushComponentEffectStart(),
+        prevEffectErrors = pushComponentEffectErrors();
+      switch (finishedWork.tag) {
+        case 0:
+        case 11:
+        case 15:
+          recursivelyTraversePassiveUnmountEffects(finishedWork);
+          finishedWork.flags & 2048 &&
+            commitHookPassiveUnmountEffects(
+              finishedWork,
+              finishedWork.return,
+              Passive | HasEffect
+            );
+          break;
+        case 3:
+          var prevEffectDuration = pushNestedEffectDurations();
+          recursivelyTraversePassiveUnmountEffects(finishedWork);
+          finishedWork.stateNode.passiveEffectDuration +=
+            popNestedEffectDurations(prevEffectDuration);
+          break;
+        case 12:
+          prevEffectDuration = pushNestedEffectDurations();
+          recursivelyTraversePassiveUnmountEffects(finishedWork);
+          finishedWork.stateNode.passiveEffectDuration +=
+            bubbleNestedEffectDurations(prevEffectDuration);
+          break;
+        case 22:
+          prevEffectDuration = finishedWork.stateNode;
+          null !== finishedWork.memoizedState &&
+          prevEffectDuration._visibility & OffscreenPassiveEffectsConnected &&
+          (null === finishedWork.return || 13 !== finishedWork.return.tag)
+            ? ((prevEffectDuration._visibility &=
+                ~OffscreenPassiveEffectsConnected),
+              recursivelyTraverseDisconnectPassiveEffects(finishedWork))
+            : recursivelyTraversePassiveUnmountEffects(finishedWork);
+          break;
+        default:
+          recursivelyTraversePassiveUnmountEffects(finishedWork);
+      }
+      (finishedWork.mode & ProfileMode) !== NoMode &&
+        0 <= componentEffectStartTime &&
+        0 <= componentEffectEndTime &&
+        0.05 < componentEffectDuration &&
+        logComponentEffect(
+          finishedWork,
+          componentEffectStartTime,
+          componentEffectEndTime,
+          componentEffectDuration,
+          componentEffectErrors
+        );
+      popComponentEffectStart(prevEffectStart);
+      componentEffectErrors = prevEffectErrors;
+    }
+    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
+      var deletions = parentFiber.deletions;
+      if (0 !== (parentFiber.flags & 16)) {
+        if (null !== deletions)
+          for (var i = 0; i < deletions.length; i++) {
+            var childToDelete = deletions[i];
+            nextEffect = childToDelete;
+            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+              childToDelete,
+              parentFiber
+            );
+          }
+        detachAlternateSiblings(parentFiber);
+      }
+      for (parentFiber = parentFiber.child; null !== parentFiber; )
+        disconnectPassiveEffect(parentFiber),
+          (parentFiber = parentFiber.sibling);
+    }
+    function disconnectPassiveEffect(finishedWork) {
+      switch (finishedWork.tag) {
+        case 0:
+        case 11:
+        case 15:
+          commitHookPassiveUnmountEffects(
+            finishedWork,
+            finishedWork.return,
+            Passive
+          );
+          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
+          break;
+        case 22:
+          var instance = finishedWork.stateNode;
+          instance._visibility & OffscreenPassiveEffectsConnected &&
+            ((instance._visibility &= ~OffscreenPassiveEffectsConnected),
+            recursivelyTraverseDisconnectPassiveEffects(finishedWork));
+          break;
+        default:
+          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
+      }
+    }
+    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+      deletedSubtreeRoot,
+      nearestMountedAncestor$jscomp$0
+    ) {
+      for (; null !== nextEffect; ) {
+        var fiber = nextEffect,
+          current = fiber,
+          nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
+          prevEffectStart = pushComponentEffectStart(),
+          prevEffectErrors = pushComponentEffectErrors();
+        switch (current.tag) {
+          case 0:
+          case 11:
+          case 15:
+            commitHookPassiveUnmountEffects(
+              current,
+              nearestMountedAncestor,
+              Passive
+            );
+            break;
+          case 23:
+          case 22:
+            null !== current.memoizedState &&
+              null !== current.memoizedState.cachePool &&
+              ((nearestMountedAncestor = current.memoizedState.cachePool.pool),
+              null != nearestMountedAncestor &&
+                retainCache(nearestMountedAncestor));
+            break;
+          case 24:
+            releaseCache(current.memoizedState.cache);
+        }
+        (current.mode & ProfileMode) !== NoMode &&
+          0 <= componentEffectStartTime &&
+          0 <= componentEffectEndTime &&
+          0.05 < componentEffectDuration &&
+          logComponentEffect(
+            current,
+            componentEffectStartTime,
+            componentEffectEndTime,
+            componentEffectDuration,
+            componentEffectErrors
+          );
+        popComponentEffectStart(prevEffectStart);
+        componentEffectErrors = prevEffectErrors;
+        current = fiber.child;
+        if (null !== current) (current.return = fiber), (nextEffect = current);
+        else
+          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
+            current = nextEffect;
+            prevEffectStart = current.sibling;
+            prevEffectErrors = current.return;
+            detachFiberAfterEffects(current);
+            if (current === fiber) {
+              nextEffect = null;
+              break a;
+            }
+            if (null !== prevEffectStart) {
+              prevEffectStart.return = prevEffectErrors;
+              nextEffect = prevEffectStart;
+              break a;
+            }
+            nextEffect = prevEffectErrors;
+          }
+      }
+    }
+    function FiberNode(tag, pendingProps, key, mode) {
+      this.tag = tag;
+      this.key = key;
+      this.sibling =
+        this.child =
+        this.return =
+        this.stateNode =
+        this.type =
+        this.elementType =
+          null;
+      this.index = 0;
+      this.refCleanup = this.ref = null;
+      this.pendingProps = pendingProps;
+      this.dependencies =
+        this.memoizedState =
+        this.updateQueue =
+        this.memoizedProps =
+          null;
+      this.mode = mode;
+      this.subtreeFlags = this.flags = 0;
+      this.deletions = null;
+      this.childLanes = this.lanes = 0;
+      this.alternate = null;
+      this.actualDuration = -0;
+      this.actualStartTime = -1.1;
+      this.treeBaseDuration = this.selfBaseDuration = -0;
+      this._debugTask =
+        this._debugStack =
+        this._debugOwner =
+        this._debugInfo =
+          null;
+      this._debugNeedsRemount = !1;
+      this._debugHookTypes = null;
+      hasBadMapPolyfill ||
+        "function" !== typeof Object.preventExtensions ||
+        Object.preventExtensions(this);
+    }
+    function shouldConstruct(Component) {
+      Component = Component.prototype;
+      return !(!Component || !Component.isReactComponent);
+    }
+    function createWorkInProgress(current, pendingProps) {
+      var workInProgress = current.alternate;
+      null === workInProgress
+        ? ((workInProgress = createFiber(
+            current.tag,
+            pendingProps,
+            current.key,
+            current.mode
+          )),
+          (workInProgress.elementType = current.elementType),
+          (workInProgress.type = current.type),
+          (workInProgress.stateNode = current.stateNode),
+          (workInProgress._debugOwner = current._debugOwner),
+          (workInProgress._debugStack = current._debugStack),
+          (workInProgress._debugTask = current._debugTask),
+          (workInProgress._debugHookTypes = current._debugHookTypes),
+          (workInProgress.alternate = current),
+          (current.alternate = workInProgress))
+        : ((workInProgress.pendingProps = pendingProps),
+          (workInProgress.type = current.type),
+          (workInProgress.flags = 0),
+          (workInProgress.subtreeFlags = 0),
+          (workInProgress.deletions = null),
+          (workInProgress.actualDuration = -0),
+          (workInProgress.actualStartTime = -1.1));
+      workInProgress.flags = current.flags & 65011712;
+      workInProgress.childLanes = current.childLanes;
+      workInProgress.lanes = current.lanes;
+      workInProgress.child = current.child;
+      workInProgress.memoizedProps = current.memoizedProps;
+      workInProgress.memoizedState = current.memoizedState;
+      workInProgress.updateQueue = current.updateQueue;
+      pendingProps = current.dependencies;
+      workInProgress.dependencies =
+        null === pendingProps
+          ? null
+          : {
+              lanes: pendingProps.lanes,
+              firstContext: pendingProps.firstContext,
+              _debugThenableState: pendingProps._debugThenableState
+            };
+      workInProgress.sibling = current.sibling;
+      workInProgress.index = current.index;
+      workInProgress.ref = current.ref;
+      workInProgress.refCleanup = current.refCleanup;
+      workInProgress.selfBaseDuration = current.selfBaseDuration;
+      workInProgress.treeBaseDuration = current.treeBaseDuration;
+      workInProgress._debugInfo = current._debugInfo;
+      workInProgress._debugNeedsRemount = current._debugNeedsRemount;
+      switch (workInProgress.tag) {
+        case 0:
+        case 15:
+          workInProgress.type = resolveFunctionForHotReloading(current.type);
+          break;
+        case 1:
+          workInProgress.type = resolveFunctionForHotReloading(current.type);
+          break;
+        case 11:
+          workInProgress.type = resolveForwardRefForHotReloading(current.type);
+      }
+      return workInProgress;
+    }
+    function resetWorkInProgress(workInProgress, renderLanes) {
+      workInProgress.flags &= 65011714;
+      var current = workInProgress.alternate;
+      null === current
+        ? ((workInProgress.childLanes = 0),
+          (workInProgress.lanes = renderLanes),
+          (workInProgress.child = null),
+          (workInProgress.subtreeFlags = 0),
+          (workInProgress.memoizedProps = null),
+          (workInProgress.memoizedState = null),
+          (workInProgress.updateQueue = null),
+          (workInProgress.dependencies = null),
+          (workInProgress.stateNode = null),
+          (workInProgress.selfBaseDuration = 0),
+          (workInProgress.treeBaseDuration = 0))
+        : ((workInProgress.childLanes = current.childLanes),
+          (workInProgress.lanes = current.lanes),
+          (workInProgress.child = current.child),
+          (workInProgress.subtreeFlags = 0),
+          (workInProgress.deletions = null),
+          (workInProgress.memoizedProps = current.memoizedProps),
+          (workInProgress.memoizedState = current.memoizedState),
+          (workInProgress.updateQueue = current.updateQueue),
+          (workInProgress.type = current.type),
+          (renderLanes = current.dependencies),
+          (workInProgress.dependencies =
+            null === renderLanes
+              ? null
+              : {
+                  lanes: renderLanes.lanes,
+                  firstContext: renderLanes.firstContext,
+                  _debugThenableState: renderLanes._debugThenableState
+                }),
+          (workInProgress.selfBaseDuration = current.selfBaseDuration),
+          (workInProgress.treeBaseDuration = current.treeBaseDuration));
+      return workInProgress;
+    }
+    function createFiberFromTypeAndProps(
+      type,
+      key,
+      pendingProps,
+      owner,
+      mode,
+      lanes
+    ) {
+      var fiberTag = 0,
+        resolvedType = type;
+      if ("function" === typeof type)
+        shouldConstruct(type) && (fiberTag = 1),
+          (resolvedType = resolveFunctionForHotReloading(resolvedType));
+      else if ("string" === typeof type)
+        (fiberTag = getHostContext()),
+          (fiberTag = isHostHoistableType(type, pendingProps, fiberTag)
+            ? 26
+            : "html" === type || "head" === type || "body" === type
+              ? 27
+              : 5);
+      else
+        a: switch (type) {
+          case REACT_FRAGMENT_TYPE:
+            return createFiberFromFragment(
+              pendingProps.children,
+              mode,
+              lanes,
+              key
+            );
+          case REACT_STRICT_MODE_TYPE:
+            fiberTag = 8;
+            mode |= StrictLegacyMode;
+            mode |= StrictEffectsMode;
+            break;
+          case REACT_PROFILER_TYPE:
+            return (
+              (type = pendingProps),
+              (owner = mode),
+              "string" !== typeof type.id &&
+                console.error(
+                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
+                  typeof type.id
+                ),
+              (key = createFiber(12, type, key, owner | ProfileMode)),
+              (key.elementType = REACT_PROFILER_TYPE),
+              (key.lanes = lanes),
+              (key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }),
+              key
+            );
+          case REACT_SUSPENSE_TYPE:
+            return (
+              (key = createFiber(13, pendingProps, key, mode)),
+              (key.elementType = REACT_SUSPENSE_TYPE),
+              (key.lanes = lanes),
+              key
+            );
+          case REACT_SUSPENSE_LIST_TYPE:
+            return (
+              (key = createFiber(19, pendingProps, key, mode)),
+              (key.elementType = REACT_SUSPENSE_LIST_TYPE),
+              (key.lanes = lanes),
+              key
+            );
+          case REACT_OFFSCREEN_TYPE:
+            return createFiberFromOffscreen(pendingProps, mode, lanes, key);
+          case REACT_LEGACY_HIDDEN_TYPE:
+          case REACT_VIEW_TRANSITION_TYPE:
+            return (
+              (key = createFiber(30, pendingProps, key, mode)),
+              (key.elementType = REACT_VIEW_TRANSITION_TYPE),
+              (key.lanes = lanes),
+              (key.stateNode = { autoName: null, paired: null, ref: null }),
+              key
+            );
+          default:
+            if ("object" === typeof type && null !== type)
+              switch (type.$$typeof) {
+                case REACT_PROVIDER_TYPE:
+                case REACT_CONTEXT_TYPE:
+                  fiberTag = 10;
+                  break a;
+                case REACT_CONSUMER_TYPE:
+                  fiberTag = 9;
+                  break a;
+                case REACT_FORWARD_REF_TYPE:
+                  fiberTag = 11;
+                  resolvedType = resolveForwardRefForHotReloading(resolvedType);
+                  break a;
+                case REACT_MEMO_TYPE:
+                  fiberTag = 14;
+                  break a;
+                case REACT_LAZY_TYPE:
+                  fiberTag = 16;
+                  resolvedType = null;
+                  break a;
+              }
+            resolvedType = "";
+            if (
+              void 0 === type ||
+              ("object" === typeof type &&
+                null !== type &&
+                0 === Object.keys(type).length)
+            )
+              resolvedType +=
+                " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
+            null === type
+              ? (pendingProps = "null")
+              : isArrayImpl(type)
+                ? (pendingProps = "array")
+                : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE
+                  ? ((pendingProps =
+                      "<" +
+                      (getComponentNameFromType(type.type) || "Unknown") +
+                      " />"),
+                    (resolvedType =
+                      " Did you accidentally export a JSX literal instead of a component?"))
+                  : (pendingProps = typeof type);
+            (fiberTag = owner ? getComponentNameFromOwner(owner) : null) &&
+              (resolvedType +=
+                "\n\nCheck the render method of `" + fiberTag + "`.");
+            fiberTag = 29;
+            pendingProps = Error(
+              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " +
+                (pendingProps + "." + resolvedType)
+            );
+            resolvedType = null;
+        }
+      key = createFiber(fiberTag, pendingProps, key, mode);
+      key.elementType = type;
+      key.type = resolvedType;
+      key.lanes = lanes;
+      key._debugOwner = owner;
+      return key;
+    }
+    function createFiberFromElement(element, mode, lanes) {
+      mode = createFiberFromTypeAndProps(
+        element.type,
+        element.key,
+        element.props,
+        element._owner,
+        mode,
+        lanes
+      );
+      mode._debugOwner = element._owner;
+      mode._debugStack = element._debugStack;
+      mode._debugTask = element._debugTask;
+      return mode;
+    }
+    function createFiberFromFragment(elements, mode, lanes, key) {
+      elements = createFiber(7, elements, key, mode);
+      elements.lanes = lanes;
+      return elements;
+    }
+    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
+      pendingProps = createFiber(22, pendingProps, key, mode);
+      pendingProps.elementType = REACT_OFFSCREEN_TYPE;
+      pendingProps.lanes = lanes;
+      var primaryChildInstance = {
+        _visibility: OffscreenVisible,
+        _pendingVisibility: OffscreenVisible,
+        _pendingMarkers: null,
+        _retryCache: null,
+        _transitions: null,
+        _current: null,
+        detach: function () {
+          var instance = primaryChildInstance,
+            fiber = instance._current;
+          if (null === fiber)
+            throw Error(
+              "Calling Offscreen.detach before instance handle has been set."
+            );
+          if (0 === (instance._pendingVisibility & OffscreenDetached)) {
+            var root = enqueueConcurrentRenderForLane(fiber, 2);
+            null !== root &&
+              ((instance._pendingVisibility |= OffscreenDetached),
+              scheduleUpdateOnFiber(root, fiber, 2));
+          }
+        },
+        attach: function () {
+          var instance = primaryChildInstance,
+            fiber = instance._current;
+          if (null === fiber)
+            throw Error(
+              "Calling Offscreen.detach before instance handle has been set."
+            );
+          if (0 !== (instance._pendingVisibility & OffscreenDetached)) {
+            var root = enqueueConcurrentRenderForLane(fiber, 2);
+            null !== root &&
+              ((instance._pendingVisibility &= ~OffscreenDetached),
+              scheduleUpdateOnFiber(root, fiber, 2));
+          }
+        }
+      };
+      pendingProps.stateNode = primaryChildInstance;
+      return pendingProps;
+    }
+    function createFiberFromText(content, mode, lanes) {
+      content = createFiber(6, content, null, mode);
+      content.lanes = lanes;
+      return content;
+    }
+    function createFiberFromPortal(portal, mode, lanes) {
+      mode = createFiber(
+        4,
+        null !== portal.children ? portal.children : [],
+        portal.key,
+        mode
+      );
+      mode.lanes = lanes;
+      mode.stateNode = {
+        containerInfo: portal.containerInfo,
+        pendingChildren: null,
+        implementation: portal.implementation
+      };
+      return mode;
+    }
+    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
+      if (null === fiber.return) {
+        if (null === hydrationDiffRootDEV)
+          hydrationDiffRootDEV = {
+            fiber: fiber,
+            children: [],
+            serverProps: void 0,
+            serverTail: [],
+            distanceFromLeaf: distanceFromLeaf
+          };
+        else {
+          if (hydrationDiffRootDEV.fiber !== fiber)
+            throw Error(
+              "Saw multiple hydration diff roots in a pass. This is a bug in React."
+            );
+          hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf &&
+            (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
+        }
+        return hydrationDiffRootDEV;
+      }
+      var siblings = buildHydrationDiffNode(
+        fiber.return,
+        distanceFromLeaf + 1
+      ).children;
+      if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
+        return (
+          (siblings = siblings[siblings.length - 1]),
+          siblings.distanceFromLeaf > distanceFromLeaf &&
+            (siblings.distanceFromLeaf = distanceFromLeaf),
+          siblings
+        );
+      distanceFromLeaf = {
+        fiber: fiber,
+        children: [],
+        serverProps: void 0,
+        serverTail: [],
+        distanceFromLeaf: distanceFromLeaf
+      };
+      siblings.push(distanceFromLeaf);
+      return distanceFromLeaf;
+    }
+    function warnNonHydratedInstance(fiber, rejectedCandidate) {
+      didSuspendOrErrorDEV ||
+        ((fiber = buildHydrationDiffNode(fiber, 0)),
+        (fiber.serverProps = null),
+        null !== rejectedCandidate &&
+          ((rejectedCandidate =
+            describeHydratableInstanceForDevWarnings(rejectedCandidate)),
+          fiber.serverTail.push(rejectedCandidate)));
+    }
+    function throwOnHydrationMismatch(fiber) {
+      var diff = "",
+        diffRoot = hydrationDiffRootDEV;
+      null !== diffRoot &&
+        ((hydrationDiffRootDEV = null), (diff = describeDiff(diffRoot)));
+      queueHydrationError(
+        createCapturedValueAtFiber(
+          Error(
+            "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" +
+              diff
+          ),
+          fiber
+        )
+      );
+      throw HydrationMismatchException;
+    }
+    function prepareToHydrateHostInstance(fiber) {
+      var didHydrate = fiber.stateNode;
+      var type = fiber.type,
+        props = fiber.memoizedProps;
+      didHydrate[internalInstanceKey] = fiber;
+      didHydrate[internalPropsKey] = props;
+      validatePropertiesInDevelopment(type, props);
+      switch (type) {
+        case "dialog":
+          listenToNonDelegatedEvent("cancel", didHydrate);
+          listenToNonDelegatedEvent("close", didHydrate);
+          break;
+        case "iframe":
+        case "object":
+        case "embed":
+          listenToNonDelegatedEvent("load", didHydrate);
+          break;
+        case "video":
+        case "audio":
+          for (type = 0; type < mediaEventTypes.length; type++)
+            listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
+          break;
+        case "source":
+          listenToNonDelegatedEvent("error", didHydrate);
+          break;
+        case "img":
+        case "image":
+        case "link":
+          listenToNonDelegatedEvent("error", didHydrate);
+          listenToNonDelegatedEvent("load", didHydrate);
+          break;
+        case "details":
+          listenToNonDelegatedEvent("toggle", didHydrate);
+          break;
+        case "input":
+          checkControlledValueProps("input", props);
+          listenToNonDelegatedEvent("invalid", didHydrate);
+          validateInputProps(didHydrate, props);
+          initInput(
+            didHydrate,
+            props.value,
+            props.defaultValue,
+            props.checked,
+            props.defaultChecked,
+            props.type,
+            props.name,
+            !0
+          );
+          track(didHydrate);
+          break;
+        case "option":
+          validateOptionProps(didHydrate, props);
+          break;
+        case "select":
+          checkControlledValueProps("select", props);
+          listenToNonDelegatedEvent("invalid", didHydrate);
+          validateSelectProps(didHydrate, props);
+          break;
+        case "textarea":
+          checkControlledValueProps("textarea", props),
+            listenToNonDelegatedEvent("invalid", didHydrate),
+            validateTextareaProps(didHydrate, props),
+            initTextarea(
+              didHydrate,
+              props.value,
+              props.defaultValue,
+              props.children
+            ),
+            track(didHydrate);
+      }
+      type = props.children;
+      ("string" !== typeof type &&
+        "number" !== typeof type &&
+        "bigint" !== typeof type) ||
+      didHydrate.textContent === "" + type ||
+      !0 === props.suppressHydrationWarning ||
+      checkForUnmatchedText(didHydrate.textContent, type)
+        ? (null != props.popover &&
+            (listenToNonDelegatedEvent("beforetoggle", didHydrate),
+            listenToNonDelegatedEvent("toggle", didHydrate)),
+          null != props.onScroll &&
+            listenToNonDelegatedEvent("scroll", didHydrate),
+          null != props.onScrollEnd &&
+            listenToNonDelegatedEvent("scrollend", didHydrate),
+          null != props.onClick && (didHydrate.onclick = noop$1),
+          (didHydrate = !0))
+        : (didHydrate = !1);
+      didHydrate || throwOnHydrationMismatch(fiber);
+    }
+    function popToNextHostParent(fiber) {
+      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
+        switch (hydrationParentFiber.tag) {
+          case 3:
+          case 27:
+            rootOrSingletonContext = !0;
+            return;
+          case 5:
+          case 13:
+            rootOrSingletonContext = !1;
+            return;
+          default:
+            hydrationParentFiber = hydrationParentFiber.return;
+        }
+    }
+    function popHydrationState(fiber) {
+      if (fiber !== hydrationParentFiber) return !1;
+      if (!isHydrating)
+        return popToNextHostParent(fiber), (isHydrating = !0), !1;
+      var shouldClear = !1,
+        JSCompiler_temp;
+      if ((JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag)) {
+        if ((JSCompiler_temp = 5 === fiber.tag))
+          (JSCompiler_temp = fiber.type),
+            (JSCompiler_temp =
+              !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
+              shouldSetTextContent(fiber.type, fiber.memoizedProps));
+        JSCompiler_temp = !JSCompiler_temp;
+      }
+      JSCompiler_temp && (shouldClear = !0);
+      if (shouldClear && nextHydratableInstance) {
+        for (shouldClear = nextHydratableInstance; shouldClear; ) {
+          JSCompiler_temp = buildHydrationDiffNode(fiber, 0);
+          var description =
+            describeHydratableInstanceForDevWarnings(shouldClear);
+          JSCompiler_temp.serverTail.push(description);
+          shouldClear =
+            "Suspense" === description.type
+              ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear)
+              : getNextHydratable(shouldClear.nextSibling);
+        }
+        throwOnHydrationMismatch(fiber);
+      }
+      popToNextHostParent(fiber);
+      if (13 === fiber.tag) {
+        fiber = fiber.memoizedState;
+        fiber = null !== fiber ? fiber.dehydrated : null;
+        if (!fiber)
+          throw Error(
+            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
+          );
+        nextHydratableInstance =
+          getNextHydratableInstanceAfterSuspenseInstance(fiber);
+      } else
+        nextHydratableInstance = hydrationParentFiber
+          ? getNextHydratable(fiber.stateNode.nextSibling)
+          : null;
+      return !0;
+    }
+    function resetHydrationState() {
+      nextHydratableInstance = hydrationParentFiber = null;
+      didSuspendOrErrorDEV = isHydrating = !1;
+    }
+    function upgradeHydrationErrorsToRecoverable() {
+      var queuedErrors = hydrationErrors;
+      null !== queuedErrors &&
+        (null === workInProgressRootRecoverableErrors
+          ? (workInProgressRootRecoverableErrors = queuedErrors)
+          : workInProgressRootRecoverableErrors.push.apply(
+              workInProgressRootRecoverableErrors,
+              queuedErrors
+            ),
+        (hydrationErrors = null));
+      return queuedErrors;
+    }
+    function queueHydrationError(error) {
+      null === hydrationErrors
+        ? (hydrationErrors = [error])
+        : hydrationErrors.push(error);
+    }
+    function emitPendingHydrationWarnings() {
+      var diffRoot = hydrationDiffRootDEV;
+      null !== diffRoot &&
+        ((hydrationDiffRootDEV = null),
+        (diffRoot = describeDiff(diffRoot)),
+        console.error(
+          "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
+          "https://react.dev/link/hydration-mismatch",
+          diffRoot
+        ));
+    }
+    function getViewTransitionName(props, instance) {
+      return null != props.name && "auto" !== props.name
+        ? props.name
+        : instance.autoName;
+    }
+    function getViewTransitionClassName(className, eventClassName) {
+      return null == eventClassName
+        ? className
+        : "none" === eventClassName
+          ? eventClassName
+          : null != className
+            ? className + " " + eventClassName
+            : eventClassName;
+    }
+    function markUpdate(workInProgress) {
+      workInProgress.flags |= 4;
+    }
+    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
+      if (
+        "stylesheet" !== resource.type ||
+        (resource.state.loading & Inserted) !== NotLoaded
+      )
+        workInProgress.flags &= -16777217;
+      else if (
+        ((workInProgress.flags |= 16777216), !preloadResource(resource))
+      ) {
+        resource = suspenseHandlerStackCursor.current;
+        if (
+          null !== resource &&
+          ((workInProgressRootRenderLanes & 4194176) ===
+          workInProgressRootRenderLanes
+            ? null !== shellBoundary
+            : ((workInProgressRootRenderLanes & 62914560) !==
+                workInProgressRootRenderLanes &&
+                0 === (workInProgressRootRenderLanes & 536870912)) ||
+              resource !== shellBoundary)
+        )
+          throw (
+            ((suspendedThenable = noopSuspenseyCommitThenable),
+            SuspenseyCommitException)
+          );
+        workInProgress.flags |= 8192;
+      }
+    }
+    function scheduleRetryEffect(workInProgress, retryQueue) {
+      null !== retryQueue && (workInProgress.flags |= 4);
+      workInProgress.flags & 16384 &&
+        ((retryQueue =
+          22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
+        (workInProgress.lanes |= retryQueue),
+        (workInProgressSuspendedRetryLanes |= retryQueue));
+    }
+    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
+      if (!isHydrating)
+        switch (renderState.tailMode) {
+          case "hidden":
+            hasRenderedATailFallback = renderState.tail;
+            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
+              null !== hasRenderedATailFallback.alternate &&
+                (lastTailNode = hasRenderedATailFallback),
+                (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
+            null === lastTailNode
+              ? (renderState.tail = null)
+              : (lastTailNode.sibling = null);
+            break;
+          case "collapsed":
+            lastTailNode = renderState.tail;
+            for (var _lastTailNode = null; null !== lastTailNode; )
+              null !== lastTailNode.alternate && (_lastTailNode = lastTailNode),
+                (lastTailNode = lastTailNode.sibling);
+            null === _lastTailNode
+              ? hasRenderedATailFallback || null === renderState.tail
+                ? (renderState.tail = null)
+                : (renderState.tail.sibling = null)
+              : (_lastTailNode.sibling = null);
+        }
+    }
+    function bubbleProperties(completedWork) {
+      var didBailout =
+          null !== completedWork.alternate &&
+          completedWork.alternate.child === completedWork.child,
+        newChildLanes = 0,
+        subtreeFlags = 0;
+      if (didBailout)
+        if ((completedWork.mode & ProfileMode) !== NoMode) {
+          for (
+            var _treeBaseDuration = completedWork.selfBaseDuration,
+              _child2 = completedWork.child;
+            null !== _child2;
+
+          )
+            (newChildLanes |= _child2.lanes | _child2.childLanes),
+              (subtreeFlags |= _child2.subtreeFlags & 65011712),
+              (subtreeFlags |= _child2.flags & 65011712),
+              (_treeBaseDuration += _child2.treeBaseDuration),
+              (_child2 = _child2.sibling);
+          completedWork.treeBaseDuration = _treeBaseDuration;
+        } else
+          for (
+            _treeBaseDuration = completedWork.child;
+            null !== _treeBaseDuration;
+
+          )
+            (newChildLanes |=
+              _treeBaseDuration.lanes | _treeBaseDuration.childLanes),
+              (subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712),
+              (subtreeFlags |= _treeBaseDuration.flags & 65011712),
+              (_treeBaseDuration.return = completedWork),
+              (_treeBaseDuration = _treeBaseDuration.sibling);
+      else if ((completedWork.mode & ProfileMode) !== NoMode) {
+        _treeBaseDuration = completedWork.actualDuration;
+        _child2 = completedWork.selfBaseDuration;
+        for (var child = completedWork.child; null !== child; )
+          (newChildLanes |= child.lanes | child.childLanes),
+            (subtreeFlags |= child.subtreeFlags),
+            (subtreeFlags |= child.flags),
+            (_treeBaseDuration += child.actualDuration),
+            (_child2 += child.treeBaseDuration),
+            (child = child.sibling);
+        completedWork.actualDuration = _treeBaseDuration;
+        completedWork.treeBaseDuration = _child2;
+      } else
+        for (
+          _treeBaseDuration = completedWork.child;
+          null !== _treeBaseDuration;
+
+        )
+          (newChildLanes |=
+            _treeBaseDuration.lanes | _treeBaseDuration.childLanes),
+            (subtreeFlags |= _treeBaseDuration.subtreeFlags),
+            (subtreeFlags |= _treeBaseDuration.flags),
+            (_treeBaseDuration.return = completedWork),
+            (_treeBaseDuration = _treeBaseDuration.sibling);
+      completedWork.subtreeFlags |= subtreeFlags;
+      completedWork.childLanes = newChildLanes;
+      return didBailout;
+    }
+    function trackReappearingViewTransitions(workInProgress) {
+      if (0 !== (workInProgress.subtreeFlags & 2097152))
+        for (workInProgress = workInProgress.child; null !== workInProgress; ) {
+          if (
+            22 !== workInProgress.tag ||
+            null !== workInProgress.memoizedState
+          ) {
+            if (
+              30 === workInProgress.tag &&
+              0 !== (workInProgress.flags & 2097152)
+            ) {
+              var props = workInProgress.memoizedProps;
+              null != props.name &&
+                "auto" !== props.name &&
+                trackAppearingViewTransition(
+                  workInProgress.stateNode,
+                  props.name
+                );
+            }
+            trackReappearingViewTransitions(workInProgress);
+          }
+          workInProgress = workInProgress.sibling;
+        }
+    }
+    function completeWork(current, workInProgress, renderLanes) {
+      var newProps = workInProgress.pendingProps;
+      popTreeContext(workInProgress);
+      switch (workInProgress.tag) {
+        case 16:
+        case 15:
+        case 0:
+        case 11:
+        case 7:
+        case 8:
+        case 12:
+        case 9:
+        case 14:
+          return bubbleProperties(workInProgress), null;
+        case 1:
+          return bubbleProperties(workInProgress), null;
+        case 3:
+          renderLanes = workInProgress.stateNode;
+          newProps = null;
+          null !== current && (newProps = current.memoizedState.cache);
+          workInProgress.memoizedState.cache !== newProps &&
+            (workInProgress.flags |= 2048);
+          popProvider(CacheContext, workInProgress);
+          popHostContainer(workInProgress);
+          renderLanes.pendingContext &&
+            ((renderLanes.context = renderLanes.pendingContext),
+            (renderLanes.pendingContext = null));
+          if (null === current || null === current.child)
+            popHydrationState(workInProgress)
+              ? (emitPendingHydrationWarnings(), markUpdate(workInProgress))
+              : null === current ||
+                (current.memoizedState.isDehydrated &&
+                  0 === (workInProgress.flags & 256)) ||
+                ((workInProgress.flags |= 1024),
+                upgradeHydrationErrorsToRecoverable());
+          bubbleProperties(workInProgress);
+          return null;
+        case 26:
+          return (
+            (renderLanes = workInProgress.memoizedState),
+            null === current
+              ? (markUpdate(workInProgress),
+                null !== renderLanes
+                  ? (bubbleProperties(workInProgress),
+                    preloadResourceAndSuspendIfNeeded(
+                      workInProgress,
+                      renderLanes
+                    ))
+                  : (bubbleProperties(workInProgress),
+                    (workInProgress.flags &= -16777217)))
+              : renderLanes
+                ? renderLanes !== current.memoizedState
+                  ? (markUpdate(workInProgress),
+                    bubbleProperties(workInProgress),
+                    preloadResourceAndSuspendIfNeeded(
+                      workInProgress,
+                      renderLanes
+                    ))
+                  : (bubbleProperties(workInProgress),
+                    (workInProgress.flags &= -16777217))
+                : (current.memoizedProps !== newProps &&
+                    markUpdate(workInProgress),
+                  bubbleProperties(workInProgress),
+                  (workInProgress.flags &= -16777217)),
+            null
+          );
+        case 27:
+          popHostContext(workInProgress);
+          renderLanes = requiredContext(rootInstanceStackCursor.current);
+          var _type = workInProgress.type;
+          if (null !== current && null != workInProgress.stateNode)
+            current.memoizedProps !== newProps && markUpdate(workInProgress);
+          else {
+            if (!newProps) {
+              if (null === workInProgress.stateNode)
+                throw Error(
+                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+                );
+              bubbleProperties(workInProgress);
+              workInProgress.subtreeFlags &= -33554433;
+              return null;
+            }
+            current = getHostContext();
+            popHydrationState(workInProgress)
+              ? prepareToHydrateHostInstance(workInProgress, current)
+              : ((current = resolveSingletonInstance(
+                  _type,
+                  newProps,
+                  renderLanes,
+                  current,
+                  !0
+                )),
+                (workInProgress.stateNode = current),
+                markUpdate(workInProgress));
+          }
+          bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
+          return null;
+        case 5:
+          popHostContext(workInProgress);
+          renderLanes = workInProgress.type;
+          if (null !== current && null != workInProgress.stateNode)
+            current.memoizedProps !== newProps && markUpdate(workInProgress);
+          else {
+            if (!newProps) {
+              if (null === workInProgress.stateNode)
+                throw Error(
+                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+                );
+              bubbleProperties(workInProgress);
+              workInProgress.subtreeFlags &= -33554433;
+              return null;
+            }
+            _type = getHostContext();
+            if (popHydrationState(workInProgress))
+              prepareToHydrateHostInstance(workInProgress, _type);
+            else {
+              current = requiredContext(rootInstanceStackCursor.current);
+              validateDOMNesting(renderLanes, _type.ancestorInfo);
+              _type = _type.context;
+              current = getOwnerDocumentFromRootContainer(current);
+              switch (_type) {
+                case HostContextNamespaceSvg:
+                  current = current.createElementNS(SVG_NAMESPACE, renderLanes);
+                  break;
+                case HostContextNamespaceMath:
+                  current = current.createElementNS(
+                    MATH_NAMESPACE,
+                    renderLanes
+                  );
+                  break;
+                default:
+                  switch (renderLanes) {
+                    case "svg":
+                      current = current.createElementNS(
+                        SVG_NAMESPACE,
+                        renderLanes
+                      );
+                      break;
+                    case "math":
+                      current = current.createElementNS(
+                        MATH_NAMESPACE,
+                        renderLanes
+                      );
+                      break;
+                    case "script":
+                      current = current.createElement("div");
+                      current.innerHTML = "<script>\x3c/script>";
+                      current = current.removeChild(current.firstChild);
+                      break;
+                    case "select":
+                      current =
+                        "string" === typeof newProps.is
+                          ? current.createElement("select", { is: newProps.is })
+                          : current.createElement("select");
+                      newProps.multiple
+                        ? (current.multiple = !0)
+                        : newProps.size && (current.size = newProps.size);
+                      break;
+                    default:
+                      (current =
+                        "string" === typeof newProps.is
+                          ? current.createElement(renderLanes, {
+                              is: newProps.is
+                            })
+                          : current.createElement(renderLanes)),
+                        -1 === renderLanes.indexOf("-") &&
+                          (renderLanes !== renderLanes.toLowerCase() &&
+                            console.error(
+                              "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
+                              renderLanes
+                            ),
+                          "[object HTMLUnknownElement]" !==
+                            Object.prototype.toString.call(current) ||
+                            hasOwnProperty.call(
+                              warnedUnknownTags,
+                              renderLanes
+                            ) ||
+                            ((warnedUnknownTags[renderLanes] = !0),
+                            console.error(
+                              "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
+                              renderLanes
+                            )));
+                  }
+              }
+              current[internalInstanceKey] = workInProgress;
+              current[internalPropsKey] = newProps;
+              a: for (_type = workInProgress.child; null !== _type; ) {
+                if (5 === _type.tag || 6 === _type.tag)
+                  current.appendChild(_type.stateNode);
+                else if (
+                  4 !== _type.tag &&
+                  27 !== _type.tag &&
+                  null !== _type.child
+                ) {
+                  _type.child.return = _type;
+                  _type = _type.child;
+                  continue;
+                }
+                if (_type === workInProgress) break a;
+                for (; null === _type.sibling; ) {
+                  if (null === _type.return || _type.return === workInProgress)
+                    break a;
+                  _type = _type.return;
+                }
+                _type.sibling.return = _type.return;
+                _type = _type.sibling;
+              }
+              workInProgress.stateNode = current;
+              a: switch (
+                (setInitialProperties(current, renderLanes, newProps),
+                renderLanes)
+              ) {
+                case "button":
+                case "input":
+                case "select":
+                case "textarea":
+                  current = !!newProps.autoFocus;
+                  break a;
+                case "img":
+                  current = !0;
+                  break a;
+                default:
+                  current = !1;
+              }
+              current && markUpdate(workInProgress);
+            }
+          }
+          bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
+          workInProgress.flags &= -16777217;
+          return null;
+        case 6:
+          if (current && null != workInProgress.stateNode)
+            current.memoizedProps !== newProps && markUpdate(workInProgress);
+          else {
+            if (
+              "string" !== typeof newProps &&
+              null === workInProgress.stateNode
+            )
+              throw Error(
+                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+              );
+            current = requiredContext(rootInstanceStackCursor.current);
+            renderLanes = getHostContext();
+            if (popHydrationState(workInProgress)) {
+              current = workInProgress.stateNode;
+              renderLanes = workInProgress.memoizedProps;
+              _type = !didSuspendOrErrorDEV;
+              newProps = null;
+              var returnFiber = hydrationParentFiber;
+              if (null !== returnFiber)
+                switch (returnFiber.tag) {
+                  case 3:
+                    _type &&
+                      ((_type = diffHydratedTextForDevWarnings(
+                        current,
+                        renderLanes,
+                        newProps
+                      )),
+                      null !== _type &&
+                        (buildHydrationDiffNode(workInProgress, 0).serverProps =
+                          _type));
+                    break;
+                  case 27:
+                  case 5:
+                    (newProps = returnFiber.memoizedProps),
+                      _type &&
+                        ((_type = diffHydratedTextForDevWarnings(
+                          current,
+                          renderLanes,
+                          newProps
+                        )),
+                        null !== _type &&
+                          (buildHydrationDiffNode(
+                            workInProgress,
+                            0
+                          ).serverProps = _type));
+                }
+              current[internalInstanceKey] = workInProgress;
+              current =
+                current.nodeValue === renderLanes ||
+                (null !== newProps &&
+                  !0 === newProps.suppressHydrationWarning) ||
+                checkForUnmatchedText(current.nodeValue, renderLanes)
+                  ? !0
+                  : !1;
+              current || throwOnHydrationMismatch(workInProgress);
+            } else
+              (renderLanes = renderLanes.ancestorInfo.current),
+                null != renderLanes &&
+                  validateTextNesting(newProps, renderLanes.tag),
+                (current =
+                  getOwnerDocumentFromRootContainer(current).createTextNode(
+                    newProps
+                  )),
+                (current[internalInstanceKey] = workInProgress),
+                (workInProgress.stateNode = current);
+          }
+          bubbleProperties(workInProgress);
+          return null;
+        case 13:
+          newProps = workInProgress.memoizedState;
+          if (
+            null === current ||
+            (null !== current.memoizedState &&
+              null !== current.memoizedState.dehydrated)
+          ) {
+            _type = popHydrationState(workInProgress);
+            if (null !== newProps && null !== newProps.dehydrated) {
+              if (null === current) {
+                if (!_type)
+                  throw Error(
+                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
+                  );
+                _type = workInProgress.memoizedState;
+                _type = null !== _type ? _type.dehydrated : null;
+                if (!_type)
+                  throw Error(
+                    "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
+                  );
+                _type[internalInstanceKey] = workInProgress;
+                bubbleProperties(workInProgress);
+                (workInProgress.mode & ProfileMode) !== NoMode &&
+                  null !== newProps &&
+                  ((_type = workInProgress.child),
+                  null !== _type &&
+                    (workInProgress.treeBaseDuration -=
+                      _type.treeBaseDuration));
+              } else
+                emitPendingHydrationWarnings(),
+                  resetHydrationState(),
+                  0 === (workInProgress.flags & 128) &&
+                    (workInProgress.memoizedState = null),
+                  (workInProgress.flags |= 4),
+                  bubbleProperties(workInProgress),
+                  (workInProgress.mode & ProfileMode) !== NoMode &&
+                    null !== newProps &&
+                    ((_type = workInProgress.child),
+                    null !== _type &&
+                      (workInProgress.treeBaseDuration -=
+                        _type.treeBaseDuration));
+              _type = !1;
+            } else
+              (_type = upgradeHydrationErrorsToRecoverable()),
+                null !== current &&
+                  null !== current.memoizedState &&
+                  (current.memoizedState.hydrationErrors = _type),
+                (_type = !0);
+            if (!_type) {
+              if (workInProgress.flags & 256)
+                return popSuspenseHandler(workInProgress), workInProgress;
+              popSuspenseHandler(workInProgress);
+              return null;
+            }
+          }
+          popSuspenseHandler(workInProgress);
+          if (0 !== (workInProgress.flags & 128))
+            return (
+              (workInProgress.lanes = renderLanes),
+              (workInProgress.mode & ProfileMode) !== NoMode &&
+                transferActualDuration(workInProgress),
+              workInProgress
+            );
+          renderLanes = null !== newProps;
+          current = null !== current && null !== current.memoizedState;
+          renderLanes &&
+            ((newProps = workInProgress.child),
+            (_type = null),
+            null !== newProps.alternate &&
+              null !== newProps.alternate.memoizedState &&
+              null !== newProps.alternate.memoizedState.cachePool &&
+              (_type = newProps.alternate.memoizedState.cachePool.pool),
+            (returnFiber = null),
+            null !== newProps.memoizedState &&
+              null !== newProps.memoizedState.cachePool &&
+              (returnFiber = newProps.memoizedState.cachePool.pool),
+            returnFiber !== _type && (newProps.flags |= 2048));
+          renderLanes !== current &&
+            renderLanes &&
+            (workInProgress.child.flags |= 8192);
+          scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
+          bubbleProperties(workInProgress);
+          (workInProgress.mode & ProfileMode) !== NoMode &&
+            renderLanes &&
+            ((current = workInProgress.child),
+            null !== current &&
+              (workInProgress.treeBaseDuration -= current.treeBaseDuration));
+          return null;
+        case 4:
+          return (
+            popHostContainer(workInProgress),
+            null === current &&
+              listenToAllSupportedEvents(
+                workInProgress.stateNode.containerInfo
+              ),
+            bubbleProperties(workInProgress),
+            null
+          );
+        case 10:
+          return (
+            popProvider(workInProgress.type, workInProgress),
+            bubbleProperties(workInProgress),
+            null
+          );
+        case 19:
+          pop(suspenseStackCursor, workInProgress);
+          _type = workInProgress.memoizedState;
+          if (null === _type) return bubbleProperties(workInProgress), null;
+          newProps = 0 !== (workInProgress.flags & 128);
+          returnFiber = _type.rendering;
+          if (null === returnFiber)
+            if (newProps) cutOffTailIfNeeded(_type, !1);
+            else {
+              if (
+                workInProgressRootExitStatus !== RootInProgress ||
+                (null !== current && 0 !== (current.flags & 128))
+              )
+                for (current = workInProgress.child; null !== current; ) {
+                  returnFiber = findFirstSuspended(current);
+                  if (null !== returnFiber) {
+                    workInProgress.flags |= 128;
+                    cutOffTailIfNeeded(_type, !1);
+                    current = returnFiber.updateQueue;
+                    workInProgress.updateQueue = current;
+                    scheduleRetryEffect(workInProgress, current);
+                    workInProgress.subtreeFlags = 0;
+                    current = renderLanes;
+                    for (
+                      renderLanes = workInProgress.child;
+                      null !== renderLanes;
+
+                    )
+                      resetWorkInProgress(renderLanes, current),
+                        (renderLanes = renderLanes.sibling);
+                    push(
+                      suspenseStackCursor,
+                      (suspenseStackCursor.current &
+                        SubtreeSuspenseContextMask) |
+                        ForceSuspenseFallback,
+                      workInProgress
+                    );
+                    return workInProgress.child;
+                  }
+                  current = current.sibling;
+                }
+              null !== _type.tail &&
+                now$1() > workInProgressRootRenderTargetTime &&
+                ((workInProgress.flags |= 128),
+                (newProps = !0),
+                cutOffTailIfNeeded(_type, !1),
+                (workInProgress.lanes = 4194304));
+            }
+          else {
+            if (!newProps)
+              if (
+                ((current = findFirstSuspended(returnFiber)), null !== current)
+              ) {
+                if (
+                  ((workInProgress.flags |= 128),
+                  (newProps = !0),
+                  (current = current.updateQueue),
+                  (workInProgress.updateQueue = current),
+                  scheduleRetryEffect(workInProgress, current),
+                  cutOffTailIfNeeded(_type, !0),
+                  null === _type.tail &&
+                    "hidden" === _type.tailMode &&
+                    !returnFiber.alternate &&
+                    !isHydrating)
+                )
+                  return bubbleProperties(workInProgress), null;
+              } else
+                2 * now$1() - _type.renderingStartTime >
+                  workInProgressRootRenderTargetTime &&
+                  536870912 !== renderLanes &&
+                  ((workInProgress.flags |= 128),
+                  (newProps = !0),
+                  cutOffTailIfNeeded(_type, !1),
+                  (workInProgress.lanes = 4194304));
+            _type.isBackwards
+              ? ((returnFiber.sibling = workInProgress.child),
+                (workInProgress.child = returnFiber))
+              : ((current = _type.last),
+                null !== current
+                  ? (current.sibling = returnFiber)
+                  : (workInProgress.child = returnFiber),
+                (_type.last = returnFiber));
+          }
+          if (null !== _type.tail)
+            return (
+              (current = _type.tail),
+              (_type.rendering = current),
+              (_type.tail = current.sibling),
+              (_type.renderingStartTime = now$1()),
+              (current.sibling = null),
+              (renderLanes = suspenseStackCursor.current),
+              (renderLanes = newProps
+                ? (renderLanes & SubtreeSuspenseContextMask) |
+                  ForceSuspenseFallback
+                : renderLanes & SubtreeSuspenseContextMask),
+              push(suspenseStackCursor, renderLanes, workInProgress),
+              current
+            );
+          bubbleProperties(workInProgress);
+          return null;
+        case 22:
+        case 23:
+          return (
+            popSuspenseHandler(workInProgress),
+            popHiddenContext(workInProgress),
+            (newProps = null !== workInProgress.memoizedState),
+            null !== current
+              ? (null !== current.memoizedState) !== newProps &&
+                ((workInProgress.flags |= 8192),
+                newProps || trackReappearingViewTransitions(workInProgress))
+              : newProps && (workInProgress.flags |= 8192),
+            newProps
+              ? 0 !== (renderLanes & 536870912) &&
+                0 === (workInProgress.flags & 128) &&
+                (bubbleProperties(workInProgress),
+                workInProgress.subtreeFlags & 6 &&
+                  (workInProgress.flags |= 8192))
+              : bubbleProperties(workInProgress),
+            (renderLanes = workInProgress.updateQueue),
+            null !== renderLanes &&
+              scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
+            (renderLanes = null),
+            null !== current &&
+              null !== current.memoizedState &&
+              null !== current.memoizedState.cachePool &&
+              (renderLanes = current.memoizedState.cachePool.pool),
+            (newProps = null),
+            null !== workInProgress.memoizedState &&
+              null !== workInProgress.memoizedState.cachePool &&
+              (newProps = workInProgress.memoizedState.cachePool.pool),
+            newProps !== renderLanes && (workInProgress.flags |= 2048),
+            null !== current && pop(resumedCache, workInProgress),
+            null
+          );
+        case 24:
+          return (
+            (renderLanes = null),
+            null !== current && (renderLanes = current.memoizedState.cache),
+            workInProgress.memoizedState.cache !== renderLanes &&
+              (workInProgress.flags |= 2048),
+            popProvider(CacheContext, workInProgress),
+            bubbleProperties(workInProgress),
+            null
+          );
+        case 25:
+          return null;
+        case 30:
+          return (
+            (workInProgress.flags |= 33554432),
+            bubbleProperties(workInProgress),
+            null
+          );
+      }
+      throw Error(
+        "Unknown unit of work tag (" +
+          workInProgress.tag +
+          "). This error is likely caused by a bug in React. Please file an issue."
+      );
+    }
+    function unwindWork(current, workInProgress) {
+      popTreeContext(workInProgress);
+      switch (workInProgress.tag) {
+        case 1:
+          return (
+            (current = workInProgress.flags),
+            current & 65536
+              ? ((workInProgress.flags = (current & -65537) | 128),
+                (workInProgress.mode & ProfileMode) !== NoMode &&
+                  transferActualDuration(workInProgress),
+                workInProgress)
+              : null
+          );
+        case 3:
+          return (
+            popProvider(CacheContext, workInProgress),
+            popHostContainer(workInProgress),
+            (current = workInProgress.flags),
+            0 !== (current & 65536) && 0 === (current & 128)
+              ? ((workInProgress.flags = (current & -65537) | 128),
+                workInProgress)
+              : null
+          );
+        case 26:
+        case 27:
+        case 5:
+          return popHostContext(workInProgress), null;
+        case 13:
+          popSuspenseHandler(workInProgress);
+          current = workInProgress.memoizedState;
+          if (null !== current && null !== current.dehydrated) {
+            if (null === workInProgress.alternate)
+              throw Error(
+                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
+              );
+            resetHydrationState();
+          }
+          current = workInProgress.flags;
+          return current & 65536
+            ? ((workInProgress.flags = (current & -65537) | 128),
+              (workInProgress.mode & ProfileMode) !== NoMode &&
+                transferActualDuration(workInProgress),
+              workInProgress)
+            : null;
+        case 19:
+          return pop(suspenseStackCursor, workInProgress), null;
+        case 4:
+          return popHostContainer(workInProgress), null;
+        case 10:
+          return popProvider(workInProgress.type, workInProgress), null;
+        case 22:
+        case 23:
+          return (
+            popSuspenseHandler(workInProgress),
+            popHiddenContext(workInProgress),
+            null !== current && pop(resumedCache, workInProgress),
+            (current = workInProgress.flags),
+            current & 65536
+              ? ((workInProgress.flags = (current & -65537) | 128),
+                (workInProgress.mode & ProfileMode) !== NoMode &&
+                  transferActualDuration(workInProgress),
+                workInProgress)
+              : null
+          );
+        case 24:
+          return popProvider(CacheContext, workInProgress), null;
+        case 25:
+          return null;
+        default:
+          return null;
+      }
+    }
+    function unwindInterruptedWork(current, interruptedWork) {
+      popTreeContext(interruptedWork);
+      switch (interruptedWork.tag) {
+        case 3:
+          popProvider(CacheContext, interruptedWork);
+          popHostContainer(interruptedWork);
+          break;
+        case 26:
+        case 27:
+        case 5:
+          popHostContext(interruptedWork);
+          break;
+        case 4:
+          popHostContainer(interruptedWork);
+          break;
+        case 13:
+          popSuspenseHandler(interruptedWork);
+          break;
+        case 19:
+          pop(suspenseStackCursor, interruptedWork);
+          break;
+        case 10:
+          popProvider(interruptedWork.type, interruptedWork);
+          break;
+        case 22:
+        case 23:
+          popSuspenseHandler(interruptedWork);
+          popHiddenContext(interruptedWork);
+          null !== current && pop(resumedCache, interruptedWork);
+          break;
+        case 24:
+          popProvider(CacheContext, interruptedWork);
+      }
+    }
+    function findFiberRootForHostRoot(hostRoot) {
+      var maybeFiber = getClosestInstanceFromNode(hostRoot);
+      if (null != maybeFiber) {
+        if ("string" !== typeof maybeFiber.memoizedProps["data-testname"])
+          throw Error(
+            "Invalid host root specified. Should be either a React container or a node with a testname attribute."
+          );
+        return maybeFiber;
+      }
+      a: {
+        hostRoot = [hostRoot];
+        for (maybeFiber = 0; maybeFiber < hostRoot.length; ) {
+          var current = hostRoot[maybeFiber++];
+          if (current[internalContainerInstanceKey]) {
+            hostRoot = getInstanceFromNode(current);
+            break a;
+          }
+          hostRoot.push.apply(hostRoot, current.children);
+        }
+        hostRoot = null;
+      }
+      if (null === hostRoot)
+        throw Error(
+          "Could not find React container within specified host subtree."
+        );
+      return hostRoot.stateNode.current;
+    }
+    function matchSelector(fiber$jscomp$0, selector) {
+      var tag = fiber$jscomp$0.tag;
+      switch (selector.$$typeof) {
+        case COMPONENT_TYPE:
+          if (fiber$jscomp$0.type === selector.value) return !0;
+          break;
+        case HAS_PSEUDO_CLASS_TYPE:
+          a: {
+            selector = selector.value;
+            tag = [fiber$jscomp$0, 0];
+            for (fiber$jscomp$0 = 0; fiber$jscomp$0 < tag.length; ) {
+              var fiber = tag[fiber$jscomp$0++],
+                tag$jscomp$0 = fiber.tag,
+                selectorIndex = tag[fiber$jscomp$0++],
+                selector$jscomp$0 = selector[selectorIndex];
+              if (
+                (5 !== tag$jscomp$0 &&
+                  26 !== tag$jscomp$0 &&
+                  27 !== tag$jscomp$0) ||
+                !isHiddenSubtree(fiber)
+              ) {
+                for (
+                  ;
+                  null != selector$jscomp$0 &&
+                  matchSelector(fiber, selector$jscomp$0);
+
+                )
+                  selectorIndex++,
+                    (selector$jscomp$0 = selector[selectorIndex]);
+                if (selectorIndex === selector.length) {
+                  selector = !0;
+                  break a;
+                } else
+                  for (fiber = fiber.child; null !== fiber; )
+                    tag.push(fiber, selectorIndex), (fiber = fiber.sibling);
+              }
+            }
+            selector = !1;
+          }
+          return selector;
+        case ROLE_TYPE:
+          if (5 === tag || 26 === tag || 27 === tag)
+            if (
+              ((tag = fiber$jscomp$0.stateNode),
+              (selector = selector.value),
+              (fiber$jscomp$0 = (fiber$jscomp$0 = tag.getAttribute("role"))
+                ? fiber$jscomp$0.trim().split(" ")
+                : null),
+              (selector =
+                (null !== fiber$jscomp$0 &&
+                  0 <= fiber$jscomp$0.indexOf(selector)) ||
+                selector === getImplicitRole(tag)
+                  ? !0
+                  : !1),
+              selector)
+            )
+              return !0;
+          break;
+        case TEXT_TYPE:
+          if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {
+            a: {
+              switch (fiber$jscomp$0.tag) {
+                case 26:
+                case 27:
+                case 5:
+                  tag = "";
+                  fiber$jscomp$0 = fiber$jscomp$0.stateNode.childNodes;
+                  for (
+                    selectorIndex = 0;
+                    selectorIndex < fiber$jscomp$0.length;
+                    selectorIndex++
+                  )
+                    (fiber = fiber$jscomp$0[selectorIndex]),
+                      fiber.nodeType === Node.TEXT_NODE &&
+                        (tag += fiber.textContent);
+                  break a;
+                case 6:
+                  tag = fiber$jscomp$0.stateNode.textContent;
+                  break a;
+              }
+              tag = null;
+            }
+            if (null !== tag && 0 <= tag.indexOf(selector.value)) return !0;
+          }
+          break;
+        case TEST_NAME_TYPE:
+          if (5 === tag || 26 === tag || 27 === tag)
+            if (
+              ((tag = fiber$jscomp$0.memoizedProps["data-testname"]),
+              "string" === typeof tag &&
+                tag.toLowerCase() === selector.value.toLowerCase())
+            )
+              return !0;
+          break;
+        default:
+          throw Error("Invalid selector type specified.");
+      }
+      return !1;
+    }
+    function selectorToString(selector) {
+      switch (selector.$$typeof) {
+        case COMPONENT_TYPE:
+          return (
+            "<" + (getComponentNameFromType(selector.value) || "Unknown") + ">"
+          );
+        case HAS_PSEUDO_CLASS_TYPE:
+          return ":has(" + (selectorToString(selector) || "") + ")";
+        case ROLE_TYPE:
+          return '[role="' + selector.value + '"]';
+        case TEXT_TYPE:
+          return '"' + selector.value + '"';
+        case TEST_NAME_TYPE:
+          return '[data-testname="' + selector.value + '"]';
+        default:
+          throw Error("Invalid selector type specified.");
+      }
+    }
+    function findPaths(root, selectors) {
+      var matchingFibers = [];
+      root = [root, 0];
+      for (var index = 0; index < root.length; ) {
+        var fiber = root[index++],
+          tag = fiber.tag,
+          selectorIndex = root[index++],
+          selector = selectors[selectorIndex];
+        if (
+          (5 !== tag && 26 !== tag && 27 !== tag) ||
+          !isHiddenSubtree(fiber)
+        ) {
+          for (; null != selector && matchSelector(fiber, selector); )
+            selectorIndex++, (selector = selectors[selectorIndex]);
+          if (selectorIndex === selectors.length) matchingFibers.push(fiber);
+          else
+            for (fiber = fiber.child; null !== fiber; )
+              root.push(fiber, selectorIndex), (fiber = fiber.sibling);
+        }
+      }
+      return matchingFibers;
+    }
+    function findAllNodes(hostRoot, selectors) {
+      hostRoot = findFiberRootForHostRoot(hostRoot);
+      hostRoot = findPaths(hostRoot, selectors);
+      selectors = [];
+      hostRoot = Array.from(hostRoot);
+      for (var index = 0; index < hostRoot.length; ) {
+        var node = hostRoot[index++],
+          tag = node.tag;
+        if (5 === tag || 26 === tag || 27 === tag)
+          isHiddenSubtree(node) || selectors.push(node.stateNode);
+        else
+          for (node = node.child; null !== node; )
+            hostRoot.push(node), (node = node.sibling);
+      }
+      return selectors;
+    }
+    function onCommitRoot() {
+      commitHooks.forEach(function (commitHook) {
+        return commitHook();
+      });
+    }
+    function isConcurrentActEnvironment() {
+      var isReactActEnvironmentGlobal =
+        "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT
+          ? IS_REACT_ACT_ENVIRONMENT
+          : void 0;
+      isReactActEnvironmentGlobal ||
+        null === ReactSharedInternals.actQueue ||
+        console.error(
+          "The current testing environment is not configured to support act(...)"
+        );
+      return isReactActEnvironmentGlobal;
+    }
+    function requestUpdateLane(fiber) {
+      if (
+        (executionContext & RenderContext) !== NoContext &&
+        0 !== workInProgressRootRenderLanes
+      )
+        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
+      var transition = ReactSharedInternals.T;
+      return null !== transition
+        ? (transition._updatedFibers || (transition._updatedFibers = new Set()),
+          transition._updatedFibers.add(fiber),
+          (fiber = currentEntangledLane),
+          0 !== fiber ? fiber : requestTransitionLane())
+        : resolveUpdatePriority();
+    }
+    function requestDeferredLane() {
+      0 === workInProgressDeferredLane &&
+        (workInProgressDeferredLane =
+          0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
+            ? claimNextTransitionLane()
+            : 536870912);
+      var suspenseHandler = suspenseHandlerStackCursor.current;
+      null !== suspenseHandler && (suspenseHandler.flags |= 32);
+      return workInProgressDeferredLane;
+    }
+    function scheduleViewTransitionEvent(fiber, callback) {
+      if (null != callback) {
+        var state = fiber.stateNode,
+          instance = state.ref;
+        null === instance &&
+          (instance = state.ref =
+            createViewTransitionInstance(
+              getViewTransitionName(fiber.memoizedProps, state)
+            ));
+        null === pendingViewTransitionEvents &&
+          (pendingViewTransitionEvents = []);
+        pendingViewTransitionEvents.push(callback.bind(null, instance));
+      }
+    }
+    function scheduleUpdateOnFiber(root, fiber, lane) {
+      isRunningInsertionEffect &&
+        console.error("useInsertionEffect must not schedule updates.");
+      isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);
+      if (
+        (root === workInProgressRoot &&
+          (workInProgressSuspendedReason === SuspendedOnData ||
+            workInProgressSuspendedReason === SuspendedOnAction)) ||
+        null !== root.cancelPendingCommit
+      )
+        prepareFreshStack(root, 0),
+          markRootSuspended(
+            root,
+            workInProgressRootRenderLanes,
+            workInProgressDeferredLane,
+            !1
+          );
+      markRootUpdated$1(root, lane);
+      if (
+        0 !== (executionContext & RenderContext) &&
+        root === workInProgressRoot
+      ) {
+        if (isRendering)
+          switch (fiber.tag) {
+            case 0:
+            case 11:
+            case 15:
+              root =
+                (workInProgress && getComponentNameFromFiber(workInProgress)) ||
+                "Unknown";
+              didWarnAboutUpdateInRenderForAnotherComponent.has(root) ||
+                (didWarnAboutUpdateInRenderForAnotherComponent.add(root),
+                (fiber = getComponentNameFromFiber(fiber) || "Unknown"),
+                console.error(
+                  "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
+                  fiber,
+                  root,
+                  root
+                ));
+              break;
+            case 1:
+              didWarnAboutUpdateInRender ||
+                (console.error(
+                  "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
+                ),
+                (didWarnAboutUpdateInRender = !0));
+          }
+      } else
+        isDevToolsPresent && addFiberToLanesMap(root, fiber, lane),
+          warnIfUpdatesNotWrappedWithActDEV(fiber),
+          root === workInProgressRoot &&
+            ((executionContext & RenderContext) === NoContext &&
+              (workInProgressRootInterleavedUpdatedLanes |= lane),
+            workInProgressRootExitStatus === RootSuspendedWithDelay &&
+              markRootSuspended(
+                root,
+                workInProgressRootRenderLanes,
+                workInProgressDeferredLane,
+                !1
+              )),
+          ensureRootIsScheduled(root);
+    }
+    function performWorkOnRoot(root, lanes, forceSync) {
+      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
+        throw Error("Should not already be working.");
+      if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {
+        var yieldEndTime = now$1();
+        switch (yieldReason) {
+          case SuspendedOnImmediate:
+          case SuspendedOnData:
+            var startTime = yieldStartTime;
+            supportsUserTiming &&
+              ((reusableComponentDevToolDetails.color = "primary-light"),
+              (reusableComponentOptions.start = startTime),
+              (reusableComponentOptions.end = yieldEndTime),
+              performance.measure("Suspended", reusableComponentOptions));
+            break;
+          case SuspendedOnAction:
+            startTime = yieldStartTime;
+            supportsUserTiming &&
+              ((reusableComponentDevToolDetails.color = "primary-light"),
+              (reusableComponentOptions.start = startTime),
+              (reusableComponentOptions.end = yieldEndTime),
+              performance.measure("Action", reusableComponentOptions));
+            break;
+          default:
+            if (((startTime = yieldStartTime), supportsUserTiming)) {
+              var yieldDuration = yieldEndTime - startTime;
+              1 > yieldDuration ||
+                ((reusableComponentDevToolDetails.color =
+                  5 > yieldDuration
+                    ? "primary-light"
+                    : 10 > yieldDuration
+                      ? "primary"
+                      : 100 > yieldDuration
+                        ? "primary-dark"
+                        : "error"),
+                (reusableComponentOptions.start = startTime),
+                (reusableComponentOptions.end = yieldEndTime),
+                performance.measure("Blocked", reusableComponentOptions));
+            }
+        }
+      }
+      yieldDuration = (forceSync =
+        (!forceSync &&
+          0 === (lanes & 60) &&
+          0 === (lanes & root.expiredLanes)) ||
+        checkIfRootIsPrerendering(root, lanes))
+        ? renderRootConcurrent(root, lanes)
+        : renderRootSync(root, lanes, !0);
+      var renderWasConcurrent = forceSync;
+      do {
+        if (yieldDuration === RootInProgress) {
+          workInProgressRootIsPrerendering &&
+            !forceSync &&
+            markRootSuspended(root, lanes, 0, !1);
+          lanes = workInProgressSuspendedReason;
+          yieldStartTime = now();
+          yieldReason = lanes;
+          break;
+        } else {
+          startTime = now$1();
+          yieldEndTime = root.current.alternate;
+          if (
+            renderWasConcurrent &&
+            !isRenderConsistentWithExternalStores(yieldEndTime)
+          ) {
+            setCurrentTrackFromLanes(lanes);
+            yieldEndTime = renderStartTime;
+            yieldDuration = startTime;
+            supportsUserTiming &&
+              ((reusableLaneDevToolDetails.color = "error"),
+              (reusableLaneOptions.start = yieldEndTime),
+              (reusableLaneOptions.end = yieldDuration),
+              performance.measure("Teared Render", reusableLaneOptions));
+            finalizeRender(lanes, startTime);
+            yieldDuration = renderRootSync(root, lanes, !1);
+            renderWasConcurrent = !1;
+            continue;
+          }
+          if (yieldDuration === RootErrored) {
+            renderWasConcurrent = lanes;
+            if (root.errorRecoveryDisabledLanes & renderWasConcurrent)
+              var errorRetryLanes = 0;
+            else
+              (errorRetryLanes = root.pendingLanes & -536870913),
+                (errorRetryLanes =
+                  0 !== errorRetryLanes
+                    ? errorRetryLanes
+                    : errorRetryLanes & 536870912
+                      ? 536870912
+                      : 0);
+            if (0 !== errorRetryLanes) {
+              setCurrentTrackFromLanes(lanes);
+              logErroredRenderPhase(renderStartTime, startTime);
+              finalizeRender(lanes, startTime);
+              lanes = errorRetryLanes;
+              a: {
+                startTime = root;
+                yieldDuration = renderWasConcurrent;
+                renderWasConcurrent = workInProgressRootConcurrentErrors;
+                var wasRootDehydrated =
+                  startTime.current.memoizedState.isDehydrated;
+                wasRootDehydrated &&
+                  (prepareFreshStack(startTime, errorRetryLanes).flags |= 256);
+                errorRetryLanes = renderRootSync(
+                  startTime,
+                  errorRetryLanes,
+                  !1
+                );
+                if (errorRetryLanes !== RootErrored) {
+                  if (
+                    workInProgressRootDidAttachPingListener &&
+                    !wasRootDehydrated
+                  ) {
+                    startTime.errorRecoveryDisabledLanes |= yieldDuration;
+                    workInProgressRootInterleavedUpdatedLanes |= yieldDuration;
+                    yieldDuration = RootSuspendedWithDelay;
+                    break a;
+                  }
+                  startTime = workInProgressRootRecoverableErrors;
+                  workInProgressRootRecoverableErrors = renderWasConcurrent;
+                  null !== startTime &&
+                    (null === workInProgressRootRecoverableErrors
+                      ? (workInProgressRootRecoverableErrors = startTime)
+                      : workInProgressRootRecoverableErrors.push.apply(
+                          workInProgressRootRecoverableErrors,
+                          startTime
+                        ));
+                }
+                yieldDuration = errorRetryLanes;
+              }
+              renderWasConcurrent = !1;
+              if (yieldDuration !== RootErrored) continue;
+              else startTime = now$1();
+            }
+          }
+          if (yieldDuration === RootFatalErrored) {
+            setCurrentTrackFromLanes(lanes);
+            logErroredRenderPhase(renderStartTime, startTime);
+            finalizeRender(lanes, startTime);
+            prepareFreshStack(root, 0);
+            markRootSuspended(root, lanes, 0, !0);
+            break;
+          }
+          a: {
+            forceSync = root;
+            switch (yieldDuration) {
+              case RootInProgress:
+              case RootFatalErrored:
+                throw Error("Root did not complete. This is a bug in React.");
+              case RootSuspendedWithDelay:
+                if ((lanes & 4194176) !== lanes) break;
+              case RootSuspendedAtTheShell:
+                setCurrentTrackFromLanes(lanes);
+                logSuspendedRenderPhase(renderStartTime, startTime, lanes);
+                finalizeRender(lanes, startTime);
+                yieldEndTime = lanes;
+                0 !== (yieldEndTime & 3) || 0 !== (yieldEndTime & 60)
+                  ? (blockingSuspendedTime = startTime)
+                  : 0 !== (yieldEndTime & 4194176) &&
+                    (transitionSuspendedTime = startTime);
+                markRootSuspended(
+                  forceSync,
+                  lanes,
+                  workInProgressDeferredLane,
+                  !workInProgressRootDidSkipSuspendedSiblings
+                );
+                break a;
+              case RootErrored:
+                workInProgressRootRecoverableErrors = null;
+                break;
+              case RootSuspended:
+              case RootCompleted:
+                break;
+              default:
+                throw Error("Unknown root exit status.");
+            }
+            if (null !== ReactSharedInternals.actQueue)
+              commitRoot(
+                forceSync,
+                yieldEndTime,
+                lanes,
+                workInProgressRootRecoverableErrors,
+                workInProgressTransitions,
+                workInProgressAppearingViewTransitions,
+                workInProgressRootDidIncludeRecursiveRenderUpdate,
+                workInProgressDeferredLane,
+                workInProgressRootInterleavedUpdatedLanes,
+                workInProgressSuspendedRetryLanes,
+                yieldDuration,
+                IMMEDIATE_COMMIT,
+                renderStartTime,
+                startTime
+              );
+            else {
+              if (
+                (lanes & 62914560) === lanes &&
+                ((renderWasConcurrent =
+                  globalMostRecentFallbackTime +
+                  FALLBACK_THROTTLE_MS -
+                  now$1()),
+                10 < renderWasConcurrent)
+              ) {
+                markRootSuspended(
+                  forceSync,
+                  lanes,
+                  workInProgressDeferredLane,
+                  !workInProgressRootDidSkipSuspendedSiblings
+                );
+                if (0 !== getNextLanes(forceSync, 0, !0)) break a;
+                forceSync.timeoutHandle = scheduleTimeout(
+                  commitRootWhenReady.bind(
+                    null,
+                    forceSync,
+                    yieldEndTime,
+                    workInProgressRootRecoverableErrors,
+                    workInProgressTransitions,
+                    workInProgressAppearingViewTransitions,
+                    workInProgressRootDidIncludeRecursiveRenderUpdate,
+                    lanes,
+                    workInProgressDeferredLane,
+                    workInProgressRootInterleavedUpdatedLanes,
+                    workInProgressSuspendedRetryLanes,
+                    workInProgressRootDidSkipSuspendedSiblings,
+                    yieldDuration,
+                    THROTTLED_COMMIT,
+                    renderStartTime,
+                    startTime
+                  ),
+                  renderWasConcurrent
+                );
+                break a;
+              }
+              commitRootWhenReady(
+                forceSync,
+                yieldEndTime,
+                workInProgressRootRecoverableErrors,
+                workInProgressTransitions,
+                workInProgressAppearingViewTransitions,
+                workInProgressRootDidIncludeRecursiveRenderUpdate,
+                lanes,
+                workInProgressDeferredLane,
+                workInProgressRootInterleavedUpdatedLanes,
+                workInProgressSuspendedRetryLanes,
+                workInProgressRootDidSkipSuspendedSiblings,
+                yieldDuration,
+                IMMEDIATE_COMMIT,
+                renderStartTime,
+                startTime
+              );
+            }
+          }
+        }
+        break;
+      } while (1);
+      ensureRootIsScheduled(root);
+    }
+    function commitRootWhenReady(
+      root,
+      finishedWork,
+      recoverableErrors,
+      transitions,
+      appearingViewTransitions,
+      didIncludeRenderPhaseUpdate,
+      lanes,
+      spawnedLane,
+      updatedLanes,
+      suspendedRetryLanes,
+      didSkipSuspendedSiblings,
+      exitStatus,
+      suspendedCommitReason,
+      completedRenderStartTime,
+      completedRenderEndTime
+    ) {
+      root.timeoutHandle = noTimeout;
+      var subtreeFlags = finishedWork.subtreeFlags,
+        isViewTransitionEligible = (lanes & 335544192) === lanes;
+      subtreeFlags =
+        subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408);
+      if (isViewTransitionEligible || subtreeFlags) {
+        suspendedState = { stylesheets: null, count: 0, unsuspend: noop };
+        subtreeFlags && accumulateSuspenseyCommitOnFiber(finishedWork);
+        if (isViewTransitionEligible) {
+          subtreeFlags = root.containerInfo;
+          if (null === suspendedState)
+            throw Error(
+              "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
+            );
+          isViewTransitionEligible = suspendedState;
+          subtreeFlags = (
+            9 === subtreeFlags.nodeType
+              ? subtreeFlags
+              : subtreeFlags.ownerDocument
+          ).__reactViewTransition;
+          null != subtreeFlags &&
+            (isViewTransitionEligible.count++,
+            (isViewTransitionEligible = onUnsuspend.bind(
+              isViewTransitionEligible
+            )),
+            subtreeFlags.finished.then(
+              isViewTransitionEligible,
+              isViewTransitionEligible
+            ));
+        }
+        isViewTransitionEligible = waitForCommitToBeReady();
+        if (null !== isViewTransitionEligible) {
+          root.cancelPendingCommit = isViewTransitionEligible(
+            commitRoot.bind(
+              null,
+              root,
+              finishedWork,
+              lanes,
+              recoverableErrors,
+              transitions,
+              appearingViewTransitions,
+              didIncludeRenderPhaseUpdate,
+              spawnedLane,
+              updatedLanes,
+              suspendedRetryLanes,
+              exitStatus,
+              SUSPENDED_COMMIT,
+              completedRenderStartTime,
+              completedRenderEndTime
+            )
+          );
+          markRootSuspended(
+            root,
+            lanes,
+            spawnedLane,
+            !didSkipSuspendedSiblings
+          );
+          return;
+        }
+      }
+      commitRoot(
+        root,
+        finishedWork,
+        lanes,
+        recoverableErrors,
+        transitions,
+        appearingViewTransitions,
+        didIncludeRenderPhaseUpdate,
+        spawnedLane,
+        updatedLanes,
+        suspendedRetryLanes,
+        exitStatus,
+        suspendedCommitReason,
+        completedRenderStartTime,
+        completedRenderEndTime
+      );
+    }
+    function isRenderConsistentWithExternalStores(finishedWork) {
+      for (var node = finishedWork; ; ) {
+        var tag = node.tag;
+        if (
+          (0 === tag || 11 === tag || 15 === tag) &&
+          node.flags & 16384 &&
+          ((tag = node.updateQueue),
+          null !== tag && ((tag = tag.stores), null !== tag))
+        )
+          for (var i = 0; i < tag.length; i++) {
+            var check = tag[i],
+              getSnapshot = check.getSnapshot;
+            check = check.value;
+            try {
+              if (!objectIs(getSnapshot(), check)) return !1;
+            } catch (error) {
+              return !1;
+            }
+          }
+        tag = node.child;
+        if (node.subtreeFlags & 16384 && null !== tag)
+          (tag.return = node), (node = tag);
+        else {
+          if (node === finishedWork) break;
+          for (; null === node.sibling; ) {
+            if (null === node.return || node.return === finishedWork) return !0;
+            node = node.return;
+          }
+          node.sibling.return = node.return;
+          node = node.sibling;
+        }
+      }
+      return !0;
+    }
+    function markRootSuspended(
+      root,
+      suspendedLanes,
+      spawnedLane,
+      didAttemptEntireTree
+    ) {
+      suspendedLanes &= ~workInProgressRootPingedLanes;
+      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
+      root.suspendedLanes |= suspendedLanes;
+      root.pingedLanes &= ~suspendedLanes;
+      didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
+      didAttemptEntireTree = root.expirationTimes;
+      for (var lanes = suspendedLanes; 0 < lanes; ) {
+        var index = 31 - clz32(lanes),
+          lane = 1 << index;
+        didAttemptEntireTree[index] = -1;
+        lanes &= ~lane;
+      }
+      0 !== spawnedLane &&
+        markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
+    }
+    function flushSyncWork$1() {
+      return (executionContext & (RenderContext | CommitContext)) === NoContext
+        ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)
+        : !0;
+    }
+    function resetWorkInProgressStack() {
+      if (null !== workInProgress) {
+        if (workInProgressSuspendedReason === NotSuspended)
+          var interruptedWork = workInProgress.return;
+        else
+          (interruptedWork = workInProgress),
+            resetContextDependencies(),
+            resetHooksOnUnwind(interruptedWork),
+            (thenableState = null),
+            (thenableIndexCounter = 0),
+            (interruptedWork = workInProgress);
+        for (; null !== interruptedWork; )
+          unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
+            (interruptedWork = interruptedWork.return);
+        workInProgress = null;
+      }
+    }
+    function finalizeRender(lanes, finalizationTime) {
+      if (0 !== (lanes & 3) || 0 !== (lanes & 60))
+        blockingClampTime = finalizationTime;
+      0 !== (lanes & 4194176) && (transitionClampTime = finalizationTime);
+    }
+    function prepareFreshStack(root, lanes) {
+      supportsUserTiming &&
+        (performance.mark("Blocking Track", blockingLaneMarker),
+        performance.mark("Transition Track", transitionLaneMarker),
+        performance.mark("Suspense Track", suspenseLaneMarker),
+        performance.mark("Idle Track", idleLaneMarker));
+      var previousRenderStartTime = renderStartTime;
+      renderStartTime = now();
+      if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {
+        setCurrentTrackFromLanes(workInProgressRootRenderLanes);
+        if (
+          workInProgressRootExitStatus === RootSuspended ||
+          workInProgressRootExitStatus === RootSuspendedWithDelay
+        )
+          logSuspendedRenderPhase(
+            previousRenderStartTime,
+            renderStartTime,
+            lanes
+          );
+        else {
+          var endTime = renderStartTime;
+          supportsUserTiming &&
+            ((reusableLaneDevToolDetails.color =
+              (lanes & 738197589) === lanes ? "tertiary-dark" : "primary-dark"),
+            (reusableLaneOptions.start = previousRenderStartTime),
+            (reusableLaneOptions.end = endTime),
+            performance.measure(
+              (lanes & 536870912) === lanes
+                ? "Prewarm"
+                : (lanes & 201326677) === lanes
+                  ? "Interrupted Hydration"
+                  : "Interrupted Render",
+              reusableLaneOptions
+            ));
+        }
+        finalizeRender(workInProgressRootRenderLanes, renderStartTime);
+      }
+      if (0 !== (lanes & 3) || 0 !== (lanes & 60)) {
+        previousRenderStartTime =
+          0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime
+            ? blockingClampTime
+            : blockingUpdateTime;
+        endTime =
+          0 <= blockingEventTime && blockingEventTime < blockingClampTime
+            ? blockingClampTime
+            : blockingEventTime;
+        0 <= blockingSuspendedTime &&
+          (setCurrentTrackFromLanes(lanes),
+          logSuspendedWithDelayPhase(
+            blockingSuspendedTime,
+            0 <= endTime
+              ? endTime
+              : 0 <= previousRenderStartTime
+                ? previousRenderStartTime
+                : renderStartTime,
+            lanes
+          ));
+        var eventType = blockingEventType,
+          eventIsRepeat = blockingEventIsRepeat,
+          isSpawnedUpdate = blockingSpawnedUpdate,
+          renderStartTime$jscomp$0 = renderStartTime;
+        supportsUserTiming &&
+          ((reusableLaneDevToolDetails.track = "Blocking"),
+          0 < endTime &&
+            null !== eventType &&
+            ((reusableLaneDevToolDetails.color = eventIsRepeat
+              ? "secondary-light"
+              : "warning"),
+            (reusableLaneOptions.start = endTime),
+            (reusableLaneOptions.end =
+              0 < previousRenderStartTime
+                ? previousRenderStartTime
+                : renderStartTime$jscomp$0),
+            performance.measure(
+              eventIsRepeat ? "" : "Event: " + eventType,
+              reusableLaneOptions
+            )),
+          0 < previousRenderStartTime &&
+            ((reusableLaneDevToolDetails.color = isSpawnedUpdate
+              ? "error"
+              : (lanes & 738197589) === lanes
+                ? "tertiary-light"
+                : "primary-light"),
+            (reusableLaneOptions.start = previousRenderStartTime),
+            (reusableLaneOptions.end = renderStartTime$jscomp$0),
+            performance.measure(
+              isSpawnedUpdate ? "Cascade" : "Blocked",
+              reusableLaneOptions
+            )));
+        blockingSuspendedTime = blockingUpdateTime = -1.1;
+        blockingEventIsRepeat = !0;
+        blockingSpawnedUpdate = !1;
+      }
+      0 !== (lanes & 4194176) &&
+        ((previousRenderStartTime =
+          0 <= transitionStartTime && transitionStartTime < transitionClampTime
+            ? transitionClampTime
+            : transitionStartTime),
+        (endTime =
+          0 <= transitionUpdateTime &&
+          transitionUpdateTime < transitionClampTime
+            ? transitionClampTime
+            : transitionUpdateTime),
+        (eventType =
+          0 <= transitionEventTime && transitionEventTime < transitionClampTime
+            ? transitionClampTime
+            : transitionEventTime),
+        0 <= transitionSuspendedTime &&
+          (setCurrentTrackFromLanes(lanes),
+          logSuspendedWithDelayPhase(
+            transitionSuspendedTime,
+            0 <= eventType
+              ? eventType
+              : 0 <= endTime
+                ? endTime
+                : renderStartTime,
+            lanes
+          )),
+        (eventIsRepeat = transitionEventType),
+        (isSpawnedUpdate = transitionEventIsRepeat),
+        (renderStartTime$jscomp$0 = renderStartTime),
+        supportsUserTiming &&
+          ((reusableLaneDevToolDetails.track = "Transition"),
+          0 < eventType &&
+            null !== eventIsRepeat &&
+            ((reusableLaneDevToolDetails.color = isSpawnedUpdate
+              ? "secondary-light"
+              : "warning"),
+            (reusableLaneOptions.start = eventType),
+            (reusableLaneOptions.end =
+              0 < previousRenderStartTime
+                ? previousRenderStartTime
+                : 0 < endTime
+                  ? endTime
+                  : renderStartTime$jscomp$0),
+            performance.measure(
+              isSpawnedUpdate ? "" : "Event: " + eventIsRepeat,
+              reusableLaneOptions
+            )),
+          0 < previousRenderStartTime &&
+            ((reusableLaneDevToolDetails.color = "primary-dark"),
+            (reusableLaneOptions.start = previousRenderStartTime),
+            (reusableLaneOptions.end =
+              0 < endTime ? endTime : renderStartTime$jscomp$0),
+            performance.measure("Action", reusableLaneOptions)),
+          0 < endTime &&
+            ((reusableLaneDevToolDetails.color = "primary-light"),
+            (reusableLaneOptions.start = endTime),
+            (reusableLaneOptions.end = renderStartTime$jscomp$0),
+            performance.measure("Blocked", reusableLaneOptions))),
+        (transitionSuspendedTime =
+          transitionUpdateTime =
+          transitionStartTime =
+            -1.1),
+        (transitionEventIsRepeat = !0));
+      previousRenderStartTime = root.timeoutHandle;
+      previousRenderStartTime !== noTimeout &&
+        ((root.timeoutHandle = noTimeout),
+        cancelTimeout(previousRenderStartTime));
+      previousRenderStartTime = root.cancelPendingCommit;
+      null !== previousRenderStartTime &&
+        ((root.cancelPendingCommit = null), previousRenderStartTime());
+      resetWorkInProgressStack();
+      workInProgressRoot = root;
+      workInProgress = previousRenderStartTime = createWorkInProgress(
+        root.current,
+        null
+      );
+      workInProgressRootRenderLanes = lanes;
+      workInProgressSuspendedReason = NotSuspended;
+      workInProgressThrownValue = null;
+      workInProgressRootDidSkipSuspendedSiblings = !1;
+      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
+      workInProgressRootDidAttachPingListener = !1;
+      workInProgressRootExitStatus = RootInProgress;
+      workInProgressSuspendedRetryLanes =
+        workInProgressDeferredLane =
+        workInProgressRootPingedLanes =
+        workInProgressRootInterleavedUpdatedLanes =
+        workInProgressRootSkippedLanes =
+          0;
+      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
+        null;
+      workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
+      workInProgressAppearingViewTransitions = null;
+      0 !== (lanes & 8) && (lanes |= lanes & 32);
+      endTime = root.entangledLanes;
+      if (0 !== endTime)
+        for (root = root.entanglements, endTime &= lanes; 0 < endTime; )
+          (eventType = 31 - clz32(endTime)),
+            (eventIsRepeat = 1 << eventType),
+            (lanes |= root[eventType]),
+            (endTime &= ~eventIsRepeat);
+      entangledRenderLanes = lanes;
+      finishQueueingConcurrentUpdates();
+      ReactStrictModeWarnings.discardPendingWarnings();
+      return previousRenderStartTime;
+    }
+    function handleThrow(root, thrownValue) {
+      currentlyRenderingFiber = null;
+      ReactSharedInternals.H = ContextOnlyDispatcher;
+      ReactSharedInternals.getCurrentStack = null;
+      isRendering = !1;
+      current = null;
+      thrownValue === SuspenseException ||
+      thrownValue === SuspenseActionException
+        ? ((thrownValue = getSuspendedThenable()),
+          (workInProgressSuspendedReason = SuspendedOnImmediate))
+        : thrownValue === SuspenseyCommitException
+          ? ((thrownValue = getSuspendedThenable()),
+            (workInProgressSuspendedReason = SuspendedOnInstance))
+          : (workInProgressSuspendedReason =
+              thrownValue === SelectiveHydrationException
+                ? SuspendedOnHydration
+                : null !== thrownValue &&
+                    "object" === typeof thrownValue &&
+                    "function" === typeof thrownValue.then
+                  ? SuspendedOnDeprecatedThrowPromise
+                  : SuspendedOnError);
+      workInProgressThrownValue = thrownValue;
+      var erroredWork = workInProgress;
+      null === erroredWork
+        ? ((workInProgressRootExitStatus = RootFatalErrored),
+          logUncaughtError(
+            root,
+            createCapturedValueAtFiber(thrownValue, root.current)
+          ))
+        : erroredWork.mode & ProfileMode &&
+          stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
+    }
+    function pushDispatcher() {
+      var prevDispatcher = ReactSharedInternals.H;
+      ReactSharedInternals.H = ContextOnlyDispatcher;
+      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
+    }
+    function pushAsyncDispatcher() {
+      var prevAsyncDispatcher = ReactSharedInternals.A;
+      ReactSharedInternals.A = DefaultAsyncDispatcher;
+      return prevAsyncDispatcher;
+    }
+    function renderDidSuspendDelayIfPossible() {
+      workInProgressRootExitStatus = RootSuspendedWithDelay;
+      workInProgressRootDidSkipSuspendedSiblings ||
+        ((workInProgressRootRenderLanes & 4194176) !==
+          workInProgressRootRenderLanes &&
+          null !== suspenseHandlerStackCursor.current) ||
+        (workInProgressRootIsPrerendering = !0);
+      (0 === (workInProgressRootSkippedLanes & 134217727) &&
+        0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
+        null === workInProgressRoot ||
+        markRootSuspended(
+          workInProgressRoot,
+          workInProgressRootRenderLanes,
+          workInProgressDeferredLane,
+          !1
+        );
+    }
+    function queueConcurrentError(error) {
+      null === workInProgressRootConcurrentErrors
+        ? (workInProgressRootConcurrentErrors = [error])
+        : workInProgressRootConcurrentErrors.push(error);
+    }
+    function trackAppearingViewTransition(instance, name) {
+      if (null === workInProgressAppearingViewTransitions) {
+        if (
+          (workInProgressRootRenderLanes & 335544192) !==
+          workInProgressRootRenderLanes
+        )
+          return;
+        workInProgressAppearingViewTransitions = new Map();
+      }
+      instance.paired = null;
+      workInProgressAppearingViewTransitions.set(name, instance);
+    }
+    function renderRootSync(root, lanes, shouldYieldForPrerendering) {
+      var prevExecutionContext = executionContext;
+      executionContext |= RenderContext;
+      var prevDispatcher = pushDispatcher(),
+        prevAsyncDispatcher = pushAsyncDispatcher();
+      if (
+        workInProgressRoot !== root ||
+        workInProgressRootRenderLanes !== lanes
+      ) {
+        if (isDevToolsPresent) {
+          var memoizedUpdaters = root.memoizedUpdaters;
+          0 < memoizedUpdaters.size &&
+            (restorePendingUpdaters(root, workInProgressRootRenderLanes),
+            memoizedUpdaters.clear());
+          movePendingFibersToMemoized(root, lanes);
+        }
+        workInProgressTransitions = null;
+        prepareFreshStack(root, lanes);
+      }
+      lanes = !1;
+      memoizedUpdaters = workInProgressRootExitStatus;
+      a: do
+        try {
+          if (
+            workInProgressSuspendedReason !== NotSuspended &&
+            null !== workInProgress
+          ) {
+            var unitOfWork = workInProgress,
+              thrownValue = workInProgressThrownValue;
+            switch (workInProgressSuspendedReason) {
+              case SuspendedOnHydration:
+                resetWorkInProgressStack();
+                memoizedUpdaters = RootSuspendedAtTheShell;
+                break a;
+              case SuspendedOnImmediate:
+              case SuspendedOnData:
+              case SuspendedOnAction:
+              case SuspendedOnDeprecatedThrowPromise:
+                null === suspenseHandlerStackCursor.current && (lanes = !0);
+                var reason = workInProgressSuspendedReason;
+                workInProgressSuspendedReason = NotSuspended;
+                workInProgressThrownValue = null;
+                throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
+                if (
+                  shouldYieldForPrerendering &&
+                  workInProgressRootIsPrerendering
+                ) {
+                  memoizedUpdaters = RootInProgress;
+                  break a;
+                }
+                break;
+              default:
+                (reason = workInProgressSuspendedReason),
+                  (workInProgressSuspendedReason = NotSuspended),
+                  (workInProgressThrownValue = null),
+                  throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
+            }
+          }
+          workLoopSync();
+          memoizedUpdaters = workInProgressRootExitStatus;
+          break;
+        } catch (thrownValue$8) {
+          handleThrow(root, thrownValue$8);
+        }
+      while (1);
+      lanes && root.shellSuspendCounter++;
+      resetContextDependencies();
+      executionContext = prevExecutionContext;
+      ReactSharedInternals.H = prevDispatcher;
+      ReactSharedInternals.A = prevAsyncDispatcher;
+      null === workInProgress &&
+        ((workInProgressRoot = null),
+        (workInProgressRootRenderLanes = 0),
+        finishQueueingConcurrentUpdates());
+      return memoizedUpdaters;
+    }
+    function workLoopSync() {
+      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
+    }
+    function renderRootConcurrent(root, lanes) {
+      var prevExecutionContext = executionContext;
+      executionContext |= RenderContext;
+      var prevDispatcher = pushDispatcher(),
+        prevAsyncDispatcher = pushAsyncDispatcher();
+      if (
+        workInProgressRoot !== root ||
+        workInProgressRootRenderLanes !== lanes
+      ) {
+        if (isDevToolsPresent) {
+          var memoizedUpdaters = root.memoizedUpdaters;
+          0 < memoizedUpdaters.size &&
+            (restorePendingUpdaters(root, workInProgressRootRenderLanes),
+            memoizedUpdaters.clear());
+          movePendingFibersToMemoized(root, lanes);
+        }
+        workInProgressTransitions = null;
+        workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
+        prepareFreshStack(root, lanes);
+      } else
+        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
+          root,
+          lanes
+        );
+      a: do
+        try {
+          if (
+            workInProgressSuspendedReason !== NotSuspended &&
+            null !== workInProgress
+          )
+            b: switch (
+              ((lanes = workInProgress),
+              (memoizedUpdaters = workInProgressThrownValue),
+              workInProgressSuspendedReason)
+            ) {
+              case SuspendedOnError:
+                workInProgressSuspendedReason = NotSuspended;
+                workInProgressThrownValue = null;
+                throwAndUnwindWorkLoop(
+                  root,
+                  lanes,
+                  memoizedUpdaters,
+                  SuspendedOnError
+                );
+                break;
+              case SuspendedOnData:
+              case SuspendedOnAction:
+                if (isThenableResolved(memoizedUpdaters)) {
+                  workInProgressSuspendedReason = NotSuspended;
+                  workInProgressThrownValue = null;
+                  replaySuspendedUnitOfWork(lanes);
+                  break;
+                }
+                lanes = function () {
+                  (workInProgressSuspendedReason !== SuspendedOnData &&
+                    workInProgressSuspendedReason !== SuspendedOnAction) ||
+                    workInProgressRoot !== root ||
+                    (workInProgressSuspendedReason =
+                      SuspendedAndReadyToContinue);
+                  ensureRootIsScheduled(root);
+                };
+                memoizedUpdaters.then(lanes, lanes);
+                break a;
+              case SuspendedOnImmediate:
+                workInProgressSuspendedReason = SuspendedAndReadyToContinue;
+                break a;
+              case SuspendedOnInstance:
+                workInProgressSuspendedReason =
+                  SuspendedOnInstanceAndReadyToContinue;
+                break a;
+              case SuspendedAndReadyToContinue:
+                isThenableResolved(memoizedUpdaters)
+                  ? ((workInProgressSuspendedReason = NotSuspended),
+                    (workInProgressThrownValue = null),
+                    replaySuspendedUnitOfWork(lanes))
+                  : ((workInProgressSuspendedReason = NotSuspended),
+                    (workInProgressThrownValue = null),
+                    throwAndUnwindWorkLoop(
+                      root,
+                      lanes,
+                      memoizedUpdaters,
+                      SuspendedAndReadyToContinue
+                    ));
+                break;
+              case SuspendedOnInstanceAndReadyToContinue:
+                var resource = null;
+                switch (workInProgress.tag) {
+                  case 26:
+                    resource = workInProgress.memoizedState;
+                  case 5:
+                  case 27:
+                    var hostFiber = workInProgress;
+                    if (resource ? preloadResource(resource) : 1) {
+                      workInProgressSuspendedReason = NotSuspended;
+                      workInProgressThrownValue = null;
+                      var sibling = hostFiber.sibling;
+                      if (null !== sibling) workInProgress = sibling;
+                      else {
+                        var returnFiber = hostFiber.return;
+                        null !== returnFiber
+                          ? ((workInProgress = returnFiber),
+                            completeUnitOfWork(returnFiber))
+                          : (workInProgress = null);
+                      }
+                      break b;
+                    }
+                    break;
+                  default:
+                    console.error(
+                      "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
+                    );
+                }
+                workInProgressSuspendedReason = NotSuspended;
+                workInProgressThrownValue = null;
+                throwAndUnwindWorkLoop(
+                  root,
+                  lanes,
+                  memoizedUpdaters,
+                  SuspendedOnInstanceAndReadyToContinue
+                );
+                break;
+              case SuspendedOnDeprecatedThrowPromise:
+                workInProgressSuspendedReason = NotSuspended;
+                workInProgressThrownValue = null;
+                throwAndUnwindWorkLoop(
+                  root,
+                  lanes,
+                  memoizedUpdaters,
+                  SuspendedOnDeprecatedThrowPromise
+                );
+                break;
+              case SuspendedOnHydration:
+                resetWorkInProgressStack();
+                workInProgressRootExitStatus = RootSuspendedAtTheShell;
+                break a;
+              default:
+                throw Error(
+                  "Unexpected SuspendedReason. This is a bug in React."
+                );
+            }
+          null !== ReactSharedInternals.actQueue
+            ? workLoopSync()
+            : workLoopConcurrentByScheduler();
+          break;
+        } catch (thrownValue$9) {
+          handleThrow(root, thrownValue$9);
+        }
+      while (1);
+      resetContextDependencies();
+      ReactSharedInternals.H = prevDispatcher;
+      ReactSharedInternals.A = prevAsyncDispatcher;
+      executionContext = prevExecutionContext;
+      if (null !== workInProgress) return RootInProgress;
+      workInProgressRoot = null;
+      workInProgressRootRenderLanes = 0;
+      finishQueueingConcurrentUpdates();
+      return workInProgressRootExitStatus;
+    }
+    function workLoopConcurrentByScheduler() {
+      for (; null !== workInProgress && !shouldYield(); )
+        performUnitOfWork(workInProgress);
+    }
+    function performUnitOfWork(unitOfWork) {
+      var current = unitOfWork.alternate;
+      (unitOfWork.mode & ProfileMode) !== NoMode
+        ? (startProfilerTimer(unitOfWork),
+          (current = runWithFiberInDEV(
+            unitOfWork,
+            beginWork,
+            current,
+            unitOfWork,
+            entangledRenderLanes
+          )),
+          stopProfilerTimerIfRunningAndRecordDuration(unitOfWork))
+        : (current = runWithFiberInDEV(
+            unitOfWork,
+            beginWork,
+            current,
+            unitOfWork,
+            entangledRenderLanes
+          ));
+      unitOfWork.memoizedProps = unitOfWork.pendingProps;
+      null === current
+        ? completeUnitOfWork(unitOfWork)
+        : (workInProgress = current);
+    }
+    function replaySuspendedUnitOfWork(unitOfWork) {
+      var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
+      unitOfWork.memoizedProps = unitOfWork.pendingProps;
+      null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
+    }
+    function replayBeginWork(unitOfWork) {
+      var current = unitOfWork.alternate,
+        isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
+      isProfilingMode && startProfilerTimer(unitOfWork);
+      switch (unitOfWork.tag) {
+        case 15:
+        case 0:
+          current = replayFunctionComponent(
+            current,
+            unitOfWork,
+            unitOfWork.pendingProps,
+            unitOfWork.type,
+            void 0,
+            workInProgressRootRenderLanes
+          );
+          break;
+        case 11:
+          current = replayFunctionComponent(
+            current,
+            unitOfWork,
+            unitOfWork.pendingProps,
+            unitOfWork.type.render,
+            unitOfWork.ref,
+            workInProgressRootRenderLanes
+          );
+          break;
+        case 5:
+          resetHooksOnUnwind(unitOfWork);
+        default:
+          unwindInterruptedWork(current, unitOfWork),
+            (unitOfWork = workInProgress =
+              resetWorkInProgress(unitOfWork, entangledRenderLanes)),
+            (current = beginWork(current, unitOfWork, entangledRenderLanes));
+      }
+      isProfilingMode &&
+        stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
+      return current;
+    }
+    function throwAndUnwindWorkLoop(
+      root,
+      unitOfWork,
+      thrownValue,
+      suspendedReason
+    ) {
+      resetContextDependencies();
+      resetHooksOnUnwind(unitOfWork);
+      thenableState = null;
+      thenableIndexCounter = 0;
+      var returnFiber = unitOfWork.return;
+      try {
+        if (
+          throwException(
+            root,
+            returnFiber,
+            unitOfWork,
+            thrownValue,
+            workInProgressRootRenderLanes
+          )
+        ) {
+          workInProgressRootExitStatus = RootFatalErrored;
+          logUncaughtError(
+            root,
+            createCapturedValueAtFiber(thrownValue, root.current)
+          );
+          workInProgress = null;
+          return;
+        }
+      } catch (error) {
+        if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
+        workInProgressRootExitStatus = RootFatalErrored;
+        logUncaughtError(
+          root,
+          createCapturedValueAtFiber(thrownValue, root.current)
+        );
+        workInProgress = null;
+        return;
+      }
+      if (unitOfWork.flags & 32768) {
+        if (isHydrating || suspendedReason === SuspendedOnError) root = !0;
+        else if (
+          workInProgressRootIsPrerendering ||
+          0 !== (workInProgressRootRenderLanes & 536870912)
+        )
+          root = !1;
+        else if (
+          ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
+          suspendedReason === SuspendedOnData ||
+            suspendedReason === SuspendedOnAction ||
+            suspendedReason === SuspendedOnImmediate ||
+            suspendedReason === SuspendedOnDeprecatedThrowPromise)
+        )
+          (suspendedReason = suspenseHandlerStackCursor.current),
+            null !== suspendedReason &&
+              13 === suspendedReason.tag &&
+              (suspendedReason.flags |= 16384);
+        unwindUnitOfWork(unitOfWork, root);
+      } else completeUnitOfWork(unitOfWork);
+    }
+    function completeUnitOfWork(unitOfWork) {
+      var completedWork = unitOfWork;
+      do {
+        if (0 !== (completedWork.flags & 32768)) {
+          unwindUnitOfWork(
+            completedWork,
+            workInProgressRootDidSkipSuspendedSiblings
+          );
+          return;
+        }
+        var current = completedWork.alternate;
+        unitOfWork = completedWork.return;
+        startProfilerTimer(completedWork);
+        current = runWithFiberInDEV(
+          completedWork,
+          completeWork,
+          current,
+          completedWork,
+          entangledRenderLanes
+        );
+        (completedWork.mode & ProfileMode) !== NoMode &&
+          stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
+        if (null !== current) {
+          workInProgress = current;
+          return;
+        }
+        completedWork = completedWork.sibling;
+        if (null !== completedWork) {
+          workInProgress = completedWork;
+          return;
+        }
+        workInProgress = completedWork = unitOfWork;
+      } while (null !== completedWork);
+      workInProgressRootExitStatus === RootInProgress &&
+        (workInProgressRootExitStatus = RootCompleted);
+    }
+    function unwindUnitOfWork(unitOfWork, skipSiblings) {
+      do {
+        var next = unwindWork(unitOfWork.alternate, unitOfWork);
+        if (null !== next) {
+          next.flags &= 32767;
+          workInProgress = next;
+          return;
+        }
+        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
+          stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
+          next = unitOfWork.actualDuration;
+          for (var child = unitOfWork.child; null !== child; )
+            (next += child.actualDuration), (child = child.sibling);
+          unitOfWork.actualDuration = next;
+        }
+        next = unitOfWork.return;
+        null !== next &&
+          ((next.flags |= 32768),
+          (next.subtreeFlags = 0),
+          (next.deletions = null));
+        if (
+          !skipSiblings &&
+          ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
+        ) {
+          workInProgress = unitOfWork;
+          return;
+        }
+        workInProgress = unitOfWork = next;
+      } while (null !== unitOfWork);
+      workInProgressRootExitStatus = RootSuspendedAtTheShell;
+      workInProgress = null;
+    }
+    function commitRoot(
+      root,
+      finishedWork,
+      lanes,
+      recoverableErrors,
+      transitions,
+      appearingViewTransitions,
+      didIncludeRenderPhaseUpdate,
+      spawnedLane,
+      updatedLanes,
+      suspendedRetryLanes,
+      exitStatus,
+      suspendedCommitReason,
+      completedRenderStartTime,
+      completedRenderEndTime
+    ) {
+      root.cancelPendingCommit = null;
+      do flushPendingEffects();
+      while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
+      ReactStrictModeWarnings.flushLegacyContextWarning();
+      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
+      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
+        throw Error("Should not already be working.");
+      setCurrentTrackFromLanes(lanes);
+      exitStatus === RootErrored
+        ? logErroredRenderPhase(
+            completedRenderStartTime,
+            completedRenderEndTime
+          )
+        : null !== recoverableErrors
+          ? logRecoveredRenderPhase(
+              completedRenderStartTime,
+              completedRenderEndTime,
+              lanes,
+              recoverableErrors,
+              null !== finishedWork &&
+                null !== finishedWork.alternate &&
+                finishedWork.alternate.memoizedState.isDehydrated &&
+                0 !== (finishedWork.flags & 256)
+            )
+          : logRenderPhase(
+              completedRenderStartTime,
+              completedRenderEndTime,
+              lanes
+            );
+      if (null !== finishedWork) {
+        0 === lanes &&
+          console.error(
+            "finishedLanes should not be empty during a commit. This is a bug in React."
+          );
+        if (finishedWork === root.current)
+          throw Error(
+            "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
+          );
+        didIncludeRenderPhaseUpdate =
+          finishedWork.lanes | finishedWork.childLanes;
+        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
+        markRootFinished(
+          root,
+          lanes,
+          didIncludeRenderPhaseUpdate,
+          spawnedLane,
+          updatedLanes,
+          suspendedRetryLanes
+        );
+        root === workInProgressRoot &&
+          ((workInProgress = workInProgressRoot = null),
+          (workInProgressRootRenderLanes = 0));
+        pendingFinishedWork = finishedWork;
+        pendingEffectsRoot = root;
+        pendingEffectsLanes = lanes;
+        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
+        pendingPassiveTransitions = transitions;
+        pendingRecoverableErrors = recoverableErrors;
+        pendingViewTransitionEvents = null;
+        pendingEffectsRenderEndTime = completedRenderEndTime;
+        pendingSuspendedCommitReason = suspendedCommitReason;
+        recoverableErrors = (lanes & 335544192) === lanes ? 10262 : 10256;
+        0 !== finishedWork.actualDuration ||
+        0 !== (finishedWork.subtreeFlags & recoverableErrors) ||
+        0 !== (finishedWork.flags & recoverableErrors)
+          ? ((root.callbackNode = null),
+            (root.callbackPriority = 0),
+            scheduleCallback$1(NormalPriority$1, function () {
+              schedulerEvent = window.event;
+              flushPassiveEffects(!0);
+              return null;
+            }))
+          : ((root.callbackNode = null), (root.callbackPriority = 0));
+        commitErrors = null;
+        commitStartTime = now();
+        suspendedCommitReason === SUSPENDED_COMMIT
+          ? logSuspendedCommitPhase(completedRenderEndTime, commitStartTime)
+          : suspendedCommitReason === THROTTLED_COMMIT &&
+            logSuspenseThrottlePhase(completedRenderEndTime, commitStartTime);
+        suspendedCommitReason = 0 !== (finishedWork.flags & 13878);
+        if (
+          0 !== (finishedWork.subtreeFlags & 13878) ||
+          suspendedCommitReason
+        ) {
+          suspendedCommitReason = ReactSharedInternals.T;
+          ReactSharedInternals.T = null;
+          completedRenderEndTime = ReactDOMSharedInternals.p;
+          ReactDOMSharedInternals.p = DiscreteEventPriority;
+          recoverableErrors = executionContext;
+          executionContext |= CommitContext;
+          try {
+            commitBeforeMutationEffects(
+              root,
+              finishedWork,
+              lanes,
+              appearingViewTransitions
+            );
+          } finally {
+            (executionContext = recoverableErrors),
+              (ReactDOMSharedInternals.p = completedRenderEndTime),
+              (ReactSharedInternals.T = suspendedCommitReason);
+          }
+        }
+        pendingEffectsStatus = PENDING_MUTATION_PHASE;
+        (shouldStartViewTransition &&
+          startViewTransition(
+            root.containerInfo,
+            flushMutationEffects,
+            flushLayoutEffects,
+            flushAfterMutationEffects,
+            flushSpawnedWork,
+            flushPassiveEffects
+          )) ||
+          (flushMutationEffects(), flushLayoutEffects(), flushSpawnedWork());
+      }
+    }
+    function flushAfterMutationEffects() {
+      pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE &&
+        ((pendingEffectsStatus = NO_PENDING_EFFECTS),
+        commitAfterMutationEffectsOnFiber(
+          pendingFinishedWork,
+          pendingEffectsRoot
+        ),
+        (pendingEffectsStatus = PENDING_SPAWNED_WORK));
+    }
+    function flushMutationEffects() {
+      if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
+        pendingEffectsStatus = NO_PENDING_EFFECTS;
+        var root = pendingEffectsRoot,
+          finishedWork = pendingFinishedWork,
+          lanes = pendingEffectsLanes,
+          rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
+        if (
+          0 !== (finishedWork.subtreeFlags & 13878) ||
+          rootMutationHasEffect
+        ) {
+          rootMutationHasEffect = ReactSharedInternals.T;
+          ReactSharedInternals.T = null;
+          var previousPriority = ReactDOMSharedInternals.p;
+          ReactDOMSharedInternals.p = DiscreteEventPriority;
+          var prevExecutionContext = executionContext;
+          executionContext |= CommitContext;
+          try {
+            inProgressLanes = lanes;
+            inProgressRoot = root;
+            resetComponentEffectTimers();
+            commitMutationEffectsOnFiber(finishedWork, root, lanes);
+            inProgressRoot = inProgressLanes = null;
+            lanes = selectionInformation;
+            var curFocusedElem = getActiveElementDeep(root.containerInfo),
+              priorFocusedElem = lanes.focusedElem,
+              priorSelectionRange = lanes.selectionRange;
+            if (
+              curFocusedElem !== priorFocusedElem &&
+              priorFocusedElem &&
+              priorFocusedElem.ownerDocument &&
+              containsNode(
+                priorFocusedElem.ownerDocument.documentElement,
+                priorFocusedElem
+              )
+            ) {
+              if (
+                null !== priorSelectionRange &&
+                hasSelectionCapabilities(priorFocusedElem)
+              ) {
+                var start = priorSelectionRange.start,
+                  end = priorSelectionRange.end;
+                void 0 === end && (end = start);
+                if ("selectionStart" in priorFocusedElem)
+                  (priorFocusedElem.selectionStart = start),
+                    (priorFocusedElem.selectionEnd = Math.min(
+                      end,
+                      priorFocusedElem.value.length
+                    ));
+                else {
+                  var doc = priorFocusedElem.ownerDocument || document,
+                    win = (doc && doc.defaultView) || window;
+                  if (win.getSelection) {
+                    var selection = win.getSelection(),
+                      length = priorFocusedElem.textContent.length,
+                      start$jscomp$0 = Math.min(
+                        priorSelectionRange.start,
+                        length
+                      ),
+                      end$jscomp$0 =
+                        void 0 === priorSelectionRange.end
+                          ? start$jscomp$0
+                          : Math.min(priorSelectionRange.end, length);
+                    !selection.extend &&
+                      start$jscomp$0 > end$jscomp$0 &&
+                      ((curFocusedElem = end$jscomp$0),
+                      (end$jscomp$0 = start$jscomp$0),
+                      (start$jscomp$0 = curFocusedElem));
+                    var startMarker = getNodeForCharacterOffset(
+                        priorFocusedElem,
+                        start$jscomp$0
+                      ),
+                      endMarker = getNodeForCharacterOffset(
+                        priorFocusedElem,
+                        end$jscomp$0
+                      );
+                    if (
+                      startMarker &&
+                      endMarker &&
+                      (1 !== selection.rangeCount ||
+                        selection.anchorNode !== startMarker.node ||
+                        selection.anchorOffset !== startMarker.offset ||
+                        selection.focusNode !== endMarker.node ||
+                        selection.focusOffset !== endMarker.offset)
+                    ) {
+                      var range = doc.createRange();
+                      range.setStart(startMarker.node, startMarker.offset);
+                      selection.removeAllRanges();
+                      start$jscomp$0 > end$jscomp$0
+                        ? (selection.addRange(range),
+                          selection.extend(endMarker.node, endMarker.offset))
+                        : (range.setEnd(endMarker.node, endMarker.offset),
+                          selection.addRange(range));
+                    }
+                  }
+                }
+              }
+              doc = [];
+              for (
+                selection = priorFocusedElem;
+                (selection = selection.parentNode);
+
+              )
+                1 === selection.nodeType &&
+                  doc.push({
+                    element: selection,
+                    left: selection.scrollLeft,
+                    top: selection.scrollTop
+                  });
+              "function" === typeof priorFocusedElem.focus &&
+                priorFocusedElem.focus();
+              for (
+                priorFocusedElem = 0;
+                priorFocusedElem < doc.length;
+                priorFocusedElem++
+              ) {
+                var info = doc[priorFocusedElem];
+                info.element.scrollLeft = info.left;
+                info.element.scrollTop = info.top;
+              }
+            }
+            _enabled = !!eventsEnabled;
+            selectionInformation = eventsEnabled = null;
+          } finally {
+            (executionContext = prevExecutionContext),
+              (ReactDOMSharedInternals.p = previousPriority),
+              (ReactSharedInternals.T = rootMutationHasEffect);
+          }
+        }
+        root.current = finishedWork;
+        pendingEffectsStatus = PENDING_LAYOUT_PHASE;
+      }
+    }
+    function flushLayoutEffects() {
+      if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
+        pendingEffectsStatus = NO_PENDING_EFFECTS;
+        var root = pendingEffectsRoot,
+          finishedWork = pendingFinishedWork,
+          lanes = pendingEffectsLanes,
+          rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
+        if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
+          rootHasLayoutEffect = ReactSharedInternals.T;
+          ReactSharedInternals.T = null;
+          var previousPriority = ReactDOMSharedInternals.p;
+          ReactDOMSharedInternals.p = DiscreteEventPriority;
+          var prevExecutionContext = executionContext;
+          executionContext |= CommitContext;
+          try {
+            (inProgressLanes = lanes),
+              (inProgressRoot = root),
+              resetComponentEffectTimers(),
+              commitLayoutEffectOnFiber(
+                root,
+                finishedWork.alternate,
+                finishedWork
+              ),
+              (inProgressRoot = inProgressLanes = null);
+          } finally {
+            (executionContext = prevExecutionContext),
+              (ReactDOMSharedInternals.p = previousPriority),
+              (ReactSharedInternals.T = rootHasLayoutEffect);
+          }
+        }
+        pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
+      }
+    }
+    function flushSpawnedWork() {
+      if (
+        pendingEffectsStatus === PENDING_SPAWNED_WORK ||
+        pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE
+      ) {
+        pendingEffectsStatus = NO_PENDING_EFFECTS;
+        requestPaint();
+        var root = pendingEffectsRoot,
+          finishedWork = pendingFinishedWork,
+          lanes = pendingEffectsLanes,
+          completedRenderEndTime = pendingEffectsRenderEndTime,
+          recoverableErrors = pendingRecoverableErrors,
+          suspendedCommitReason = pendingSuspendedCommitReason;
+        commitEndTime = now();
+        completedRenderEndTime =
+          suspendedCommitReason === IMMEDIATE_COMMIT
+            ? completedRenderEndTime
+            : commitStartTime;
+        suspendedCommitReason = commitEndTime;
+        null !== commitErrors
+          ? logCommitErrored(
+              completedRenderEndTime,
+              suspendedCommitReason,
+              commitErrors,
+              !1
+            )
+          : supportsUserTiming &&
+            ((reusableLaneDevToolDetails.color = "secondary-dark"),
+            (reusableLaneOptions.start = completedRenderEndTime),
+            (reusableLaneOptions.end = suspendedCommitReason),
+            performance.measure("Commit", reusableLaneOptions));
+        completedRenderEndTime = (lanes & 335544192) === lanes ? 10262 : 10256;
+        (completedRenderEndTime =
+          0 !== finishedWork.actualDuration ||
+          0 !== (finishedWork.subtreeFlags & completedRenderEndTime) ||
+          0 !== (finishedWork.flags & completedRenderEndTime))
+          ? (pendingEffectsStatus = PENDING_PASSIVE_PHASE)
+          : ((pendingEffectsStatus = NO_PENDING_EFFECTS),
+            (pendingEffectsRoot = null),
+            releaseRootPooledCache(root, root.pendingLanes),
+            (nestedPassiveUpdateCount = 0),
+            (rootWithPassiveNestedUpdates = null));
+        suspendedCommitReason = root.pendingLanes;
+        0 === suspendedCommitReason &&
+          (legacyErrorBoundariesThatAlreadyFailed = null);
+        completedRenderEndTime || commitDoubleInvokeEffectsInDEV(root);
+        suspendedCommitReason = lanesToEventPriority(lanes);
+        finishedWork = finishedWork.stateNode;
+        if (
+          injectedHook &&
+          "function" === typeof injectedHook.onCommitFiberRoot
+        )
+          try {
+            var didError = 128 === (finishedWork.current.flags & 128);
+            switch (suspendedCommitReason) {
+              case DiscreteEventPriority:
+                var schedulerPriority = ImmediatePriority;
+                break;
+              case ContinuousEventPriority:
+                schedulerPriority = UserBlockingPriority;
+                break;
+              case DefaultEventPriority:
+                schedulerPriority = NormalPriority$1;
+                break;
+              case IdleEventPriority:
+                schedulerPriority = IdlePriority;
+                break;
+              default:
+                schedulerPriority = NormalPriority$1;
+            }
+            injectedHook.onCommitFiberRoot(
+              rendererID,
+              finishedWork,
+              schedulerPriority,
+              didError
+            );
+          } catch (err) {
+            hasLoggedError ||
+              ((hasLoggedError = !0),
+              console.error(
+                "React instrumentation encountered an error: %s",
+                err
+              ));
+          }
+        isDevToolsPresent && root.memoizedUpdaters.clear();
+        onCommitRoot();
+        if (null !== recoverableErrors) {
+          didError = ReactSharedInternals.T;
+          schedulerPriority = ReactDOMSharedInternals.p;
+          ReactDOMSharedInternals.p = DiscreteEventPriority;
+          ReactSharedInternals.T = null;
+          try {
+            var onRecoverableError = root.onRecoverableError;
+            for (
+              finishedWork = 0;
+              finishedWork < recoverableErrors.length;
+              finishedWork++
+            ) {
+              var recoverableError = recoverableErrors[finishedWork],
+                errorInfo = makeErrorInfo(recoverableError.stack);
+              runWithFiberInDEV(
+                recoverableError.source,
+                onRecoverableError,
+                recoverableError.value,
+                errorInfo
+              );
+            }
+          } finally {
+            (ReactSharedInternals.T = didError),
+              (ReactDOMSharedInternals.p = schedulerPriority);
+          }
+        }
+        recoverableErrors = pendingViewTransitionEvents;
+        if (null !== recoverableErrors)
+          for (
+            pendingViewTransitionEvents = null, onRecoverableError = 0;
+            onRecoverableError < recoverableErrors.length;
+            onRecoverableError++
+          )
+            (0, recoverableErrors[onRecoverableError])();
+        0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
+        ensureRootIsScheduled(root);
+        suspendedCommitReason = root.pendingLanes;
+        0 !== (lanes & 4194218) && 0 !== (suspendedCommitReason & 42)
+          ? ((nestedUpdateScheduled = !0),
+            root === rootWithNestedUpdates
+              ? nestedUpdateCount++
+              : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)))
+          : (nestedUpdateCount = 0);
+        completedRenderEndTime || finalizeRender(lanes, commitEndTime);
+        flushSyncWorkAcrossRoots_impl(0, !1);
+      }
+    }
+    function makeErrorInfo(componentStack) {
+      componentStack = { componentStack: componentStack };
+      Object.defineProperty(componentStack, "digest", {
+        get: function () {
+          console.error(
+            'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
+          );
+        }
+      });
+      return componentStack;
+    }
+    function releaseRootPooledCache(root, remainingLanes) {
+      0 === (root.pooledCacheLanes &= remainingLanes) &&
+        ((remainingLanes = root.pooledCache),
+        null != remainingLanes &&
+          ((root.pooledCache = null), releaseCache(remainingLanes)));
+    }
+    function flushPendingEffects(wasDelayedCommit) {
+      flushMutationEffects();
+      flushLayoutEffects();
+      flushSpawnedWork();
+      return flushPassiveEffects(wasDelayedCommit);
+    }
+    function flushPassiveEffects(wasDelayedCommit) {
+      if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return !1;
+      var root = pendingEffectsRoot,
+        remainingLanes = pendingEffectsRemainingLanes;
+      pendingEffectsRemainingLanes = 0;
+      var renderPriority = lanesToEventPriority(pendingEffectsLanes),
+        priority =
+          0 === DefaultEventPriority || DefaultEventPriority > renderPriority
+            ? DefaultEventPriority
+            : renderPriority;
+      renderPriority = ReactSharedInternals.T;
+      var previousPriority = ReactDOMSharedInternals.p;
+      try {
+        ReactDOMSharedInternals.p = priority;
+        ReactSharedInternals.T = null;
+        var transitions = pendingPassiveTransitions;
+        pendingPassiveTransitions = null;
+        priority = pendingEffectsRoot;
+        var lanes = pendingEffectsLanes;
+        pendingEffectsStatus = NO_PENDING_EFFECTS;
+        pendingEffectsRoot = null;
+        pendingEffectsLanes = 0;
+        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
+          throw Error("Cannot flush passive effects while already rendering.");
+        setCurrentTrackFromLanes(lanes);
+        isFlushingPassiveEffects = !0;
+        didScheduleUpdateDuringPassiveEffects = !1;
+        var passiveEffectStartTime = 0;
+        commitErrors = null;
+        passiveEffectStartTime = now$1();
+        var startTime = commitEndTime,
+          endTime = passiveEffectStartTime;
+        wasDelayedCommit = !!wasDelayedCommit;
+        supportsUserTiming &&
+          ((reusableLaneDevToolDetails.color = "secondary-light"),
+          (reusableLaneOptions.start = startTime),
+          (reusableLaneOptions.end = endTime),
+          performance.measure(
+            wasDelayedCommit ? "Waiting for Paint" : "",
+            reusableLaneOptions
+          ));
+        wasDelayedCommit = executionContext;
+        executionContext |= CommitContext;
+        var finishedWork = priority.current;
+        resetComponentEffectTimers();
+        commitPassiveUnmountOnFiber(finishedWork);
+        var finishedWork$jscomp$0 = priority.current;
+        finishedWork = pendingEffectsRenderEndTime;
+        resetComponentEffectTimers();
+        commitPassiveMountOnFiber(
+          priority,
+          finishedWork$jscomp$0,
+          lanes,
+          transitions,
+          finishedWork
+        );
+        commitDoubleInvokeEffectsInDEV(priority);
+        executionContext = wasDelayedCommit;
+        var passiveEffectsEndTime = now$1();
+        finishedWork$jscomp$0 = passiveEffectStartTime;
+        null !== commitErrors
+          ? logCommitErrored(
+              finishedWork$jscomp$0,
+              passiveEffectsEndTime,
+              commitErrors,
+              !0
+            )
+          : supportsUserTiming &&
+            ((reusableLaneDevToolDetails.color = "secondary-dark"),
+            (reusableLaneOptions.start = finishedWork$jscomp$0),
+            (reusableLaneOptions.end = passiveEffectsEndTime),
+            performance.measure("Remaining Effects", reusableLaneOptions));
+        finalizeRender(lanes, passiveEffectsEndTime);
+        flushSyncWorkAcrossRoots_impl(0, !1);
+        didScheduleUpdateDuringPassiveEffects
+          ? priority === rootWithPassiveNestedUpdates
+            ? nestedPassiveUpdateCount++
+            : ((nestedPassiveUpdateCount = 0),
+              (rootWithPassiveNestedUpdates = priority))
+          : (nestedPassiveUpdateCount = 0);
+        didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;
+        if (
+          injectedHook &&
+          "function" === typeof injectedHook.onPostCommitFiberRoot
+        )
+          try {
+            injectedHook.onPostCommitFiberRoot(rendererID, priority);
+          } catch (err) {
+            hasLoggedError ||
+              ((hasLoggedError = !0),
+              console.error(
+                "React instrumentation encountered an error: %s",
+                err
+              ));
+          }
+        var stateNode = priority.current.stateNode;
+        stateNode.effectDuration = 0;
+        stateNode.passiveEffectDuration = 0;
+        return !0;
+      } finally {
+        (ReactDOMSharedInternals.p = previousPriority),
+          (ReactSharedInternals.T = renderPriority),
+          releaseRootPooledCache(root, remainingLanes);
+      }
+    }
+    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
+      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+      recordEffectError(sourceFiber);
+      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
+      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
+      null !== rootFiber &&
+        (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
+    }
+    function captureCommitPhaseError(
+      sourceFiber,
+      nearestMountedAncestor,
+      error
+    ) {
+      isRunningInsertionEffect = !1;
+      if (3 === sourceFiber.tag)
+        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
+      else {
+        for (; null !== nearestMountedAncestor; ) {
+          if (3 === nearestMountedAncestor.tag) {
+            captureCommitPhaseErrorOnRoot(
+              nearestMountedAncestor,
+              sourceFiber,
+              error
+            );
+            return;
+          }
+          if (1 === nearestMountedAncestor.tag) {
+            var instance = nearestMountedAncestor.stateNode;
+            if (
+              "function" ===
+                typeof nearestMountedAncestor.type.getDerivedStateFromError ||
+              ("function" === typeof instance.componentDidCatch &&
+                (null === legacyErrorBoundariesThatAlreadyFailed ||
+                  !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+            ) {
+              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+              recordEffectError(sourceFiber);
+              error = createClassErrorUpdate(2);
+              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
+              null !== instance &&
+                (initializeClassErrorUpdate(
+                  error,
+                  instance,
+                  nearestMountedAncestor,
+                  sourceFiber
+                ),
+                markRootUpdated$1(instance, 2),
+                ensureRootIsScheduled(instance));
+              return;
+            }
+          }
+          nearestMountedAncestor = nearestMountedAncestor.return;
+        }
+        console.error(
+          "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
+          error
+        );
+      }
+    }
+    function attachPingListener(root, wakeable, lanes) {
+      var pingCache = root.pingCache;
+      if (null === pingCache) {
+        pingCache = root.pingCache = new PossiblyWeakMap();
+        var threadIDs = new Set();
+        pingCache.set(wakeable, threadIDs);
+      } else
+        (threadIDs = pingCache.get(wakeable)),
+          void 0 === threadIDs &&
+            ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
+      threadIDs.has(lanes) ||
+        ((workInProgressRootDidAttachPingListener = !0),
+        threadIDs.add(lanes),
+        (pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
+        isDevToolsPresent && restorePendingUpdaters(root, lanes),
+        wakeable.then(pingCache, pingCache));
+    }
+    function pingSuspendedRoot(root, wakeable, pingedLanes) {
+      var pingCache = root.pingCache;
+      null !== pingCache && pingCache.delete(wakeable);
+      root.pingedLanes |= root.suspendedLanes & pingedLanes;
+      root.warmLanes &= ~pingedLanes;
+      0 !== (pingedLanes & 3) || 0 !== (pingedLanes & 60)
+        ? 0 > blockingUpdateTime &&
+          (blockingClampTime = blockingUpdateTime = now())
+        : 0 !== (pingedLanes & 4194176) &&
+          0 > transitionUpdateTime &&
+          (transitionClampTime = transitionUpdateTime = now());
+      isConcurrentActEnvironment() &&
+        null === ReactSharedInternals.actQueue &&
+        console.error(
+          "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
+        );
+      workInProgressRoot === root &&
+        (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
+        (workInProgressRootExitStatus === RootSuspendedWithDelay ||
+        (workInProgressRootExitStatus === RootSuspended &&
+          (workInProgressRootRenderLanes & 62914560) ===
+            workInProgressRootRenderLanes &&
+          now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
+          ? (executionContext & RenderContext) === NoContext &&
+            prepareFreshStack(root, 0)
+          : (workInProgressRootPingedLanes |= pingedLanes),
+        workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
+          (workInProgressSuspendedRetryLanes = 0));
+      ensureRootIsScheduled(root);
+    }
+    function retryTimedOutBoundary(boundaryFiber, retryLane) {
+      0 === retryLane && (retryLane = claimNextRetryLane());
+      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
+      null !== boundaryFiber &&
+        (markRootUpdated$1(boundaryFiber, retryLane),
+        ensureRootIsScheduled(boundaryFiber));
+    }
+    function retryDehydratedSuspenseBoundary(boundaryFiber) {
+      var suspenseState = boundaryFiber.memoizedState,
+        retryLane = 0;
+      null !== suspenseState && (retryLane = suspenseState.retryLane);
+      retryTimedOutBoundary(boundaryFiber, retryLane);
+    }
+    function resolveRetryWakeable(boundaryFiber, wakeable) {
+      var retryLane = 0;
+      switch (boundaryFiber.tag) {
+        case 13:
+          var retryCache = boundaryFiber.stateNode;
+          var suspenseState = boundaryFiber.memoizedState;
+          null !== suspenseState && (retryLane = suspenseState.retryLane);
+          break;
+        case 19:
+          retryCache = boundaryFiber.stateNode;
+          break;
+        case 22:
+          retryCache = boundaryFiber.stateNode._retryCache;
+          break;
+        default:
+          throw Error(
+            "Pinged unknown suspense boundary type. This is probably a bug in React."
+          );
+      }
+      null !== retryCache && retryCache.delete(wakeable);
+      retryTimedOutBoundary(boundaryFiber, retryLane);
+    }
+    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(
+      root$jscomp$0,
+      parentFiber,
+      isInStrictMode
+    ) {
+      if (0 !== (parentFiber.subtreeFlags & 67117056))
+        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+          var root = root$jscomp$0,
+            fiber = parentFiber,
+            isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
+          isStrictModeFiber = isInStrictMode || isStrictModeFiber;
+          22 !== fiber.tag
+            ? fiber.flags & 67108864
+              ? isStrictModeFiber &&
+                runWithFiberInDEV(
+                  fiber,
+                  doubleInvokeEffectsOnFiber,
+                  root,
+                  fiber,
+                  (fiber.mode & NoStrictPassiveEffectsMode) === NoMode
+                )
+              : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
+                  root,
+                  fiber,
+                  isStrictModeFiber
+                )
+            : null === fiber.memoizedState &&
+              (isStrictModeFiber && fiber.flags & 8192
+                ? runWithFiberInDEV(
+                    fiber,
+                    doubleInvokeEffectsOnFiber,
+                    root,
+                    fiber
+                  )
+                : fiber.subtreeFlags & 67108864 &&
+                  runWithFiberInDEV(
+                    fiber,
+                    recursivelyTraverseAndDoubleInvokeEffectsInDEV,
+                    root,
+                    fiber,
+                    isStrictModeFiber
+                  ));
+          parentFiber = parentFiber.sibling;
+        }
+    }
+    function doubleInvokeEffectsOnFiber(root, fiber) {
+      var shouldDoubleInvokePassiveEffects =
+        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;
+      setIsStrictModeForDevtools(!0);
+      try {
+        disappearLayoutEffects(fiber),
+          shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber),
+          reappearLayoutEffects(root, fiber.alternate, fiber, !1),
+          shouldDoubleInvokePassiveEffects &&
+            reconnectPassiveEffects(root, fiber, 0, null, !1, 0);
+      } finally {
+        setIsStrictModeForDevtools(!1);
+      }
+    }
+    function commitDoubleInvokeEffectsInDEV(root) {
+      var doubleInvokeEffects = !0;
+      root.current.mode & (StrictLegacyMode | StrictEffectsMode) ||
+        (doubleInvokeEffects = !1);
+      recursivelyTraverseAndDoubleInvokeEffectsInDEV(
+        root,
+        root.current,
+        doubleInvokeEffects
+      );
+    }
+    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
+      if ((executionContext & RenderContext) === NoContext) {
+        var tag = fiber.tag;
+        if (
+          3 === tag ||
+          1 === tag ||
+          0 === tag ||
+          11 === tag ||
+          14 === tag ||
+          15 === tag
+        ) {
+          tag = getComponentNameFromFiber(fiber) || "ReactComponent";
+          if (null !== didWarnStateUpdateForNotYetMountedComponent) {
+            if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
+            didWarnStateUpdateForNotYetMountedComponent.add(tag);
+          } else didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);
+          runWithFiberInDEV(fiber, function () {
+            console.error(
+              "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
+            );
+          });
+        }
+      }
+    }
+    function restorePendingUpdaters(root, lanes) {
+      isDevToolsPresent &&
+        root.memoizedUpdaters.forEach(function (schedulingFiber) {
+          addFiberToLanesMap(root, schedulingFiber, lanes);
+        });
+    }
+    function scheduleCallback$1(priorityLevel, callback) {
+      var actQueue = ReactSharedInternals.actQueue;
+      return null !== actQueue
+        ? (actQueue.push(callback), fakeActCallbackNode$1)
+        : scheduleCallback$3(priorityLevel, callback);
+    }
+    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
+      isConcurrentActEnvironment() &&
+        null === ReactSharedInternals.actQueue &&
+        runWithFiberInDEV(fiber, function () {
+          console.error(
+            "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
+            getComponentNameFromFiber(fiber)
+          );
+        });
+    }
+    function ensureRootIsScheduled(root) {
+      root !== lastScheduledRoot &&
+        null === root.next &&
+        (null === lastScheduledRoot
+          ? (firstScheduledRoot = lastScheduledRoot = root)
+          : (lastScheduledRoot = lastScheduledRoot.next = root));
+      mightHavePendingSyncWork = !0;
+      null !== ReactSharedInternals.actQueue
+        ? didScheduleMicrotask_act ||
+          ((didScheduleMicrotask_act = !0), scheduleImmediateRootScheduleTask())
+        : didScheduleMicrotask ||
+          ((didScheduleMicrotask = !0), scheduleImmediateRootScheduleTask());
+    }
+    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
+      if (!isFlushingWork && mightHavePendingSyncWork) {
+        isFlushingWork = !0;
+        do {
+          var didPerformSomeWork = !1;
+          for (var root = firstScheduledRoot; null !== root; ) {
+            if (!onlyLegacy)
+              if (0 !== syncTransitionLanes) {
+                var pendingLanes = root.pendingLanes;
+                if (0 === pendingLanes) var nextLanes = 0;
+                else {
+                  var suspendedLanes = root.suspendedLanes,
+                    pingedLanes = root.pingedLanes;
+                  nextLanes =
+                    (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
+                  nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
+                  nextLanes =
+                    nextLanes & 201326677
+                      ? (nextLanes & 201326677) | 1
+                      : nextLanes
+                        ? nextLanes | 2
+                        : 0;
+                }
+                0 !== nextLanes &&
+                  ((didPerformSomeWork = !0),
+                  performSyncWorkOnRoot(root, nextLanes));
+              } else
+                (nextLanes = workInProgressRootRenderLanes),
+                  (nextLanes = getNextLanes(
+                    root,
+                    root === workInProgressRoot ? nextLanes : 0,
+                    null !== root.cancelPendingCommit ||
+                      root.timeoutHandle !== noTimeout
+                  )),
+                  0 === (nextLanes & 3) ||
+                    checkIfRootIsPrerendering(root, nextLanes) ||
+                    ((didPerformSomeWork = !0),
+                    performSyncWorkOnRoot(root, nextLanes));
+            root = root.next;
+          }
+        } while (didPerformSomeWork);
+        isFlushingWork = !1;
+      }
+    }
+    function processRootScheduleInImmediateTask() {
+      schedulerEvent = window.event;
+      processRootScheduleInMicrotask();
+    }
+    function processRootScheduleInMicrotask() {
+      mightHavePendingSyncWork =
+        didScheduleMicrotask_act =
+        didScheduleMicrotask =
+          !1;
+      var syncTransitionLanes = 0;
+      0 !== currentEventTransitionLane &&
+        (shouldAttemptEagerTransition() &&
+          (syncTransitionLanes = currentEventTransitionLane),
+        (currentEventTransitionLane = 0));
+      for (
+        var currentTime = now$1(), prev = null, root = firstScheduledRoot;
+        null !== root;
+
+      ) {
+        var next = root.next,
+          nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
+        if (0 === nextLanes)
+          (root.next = null),
+            null === prev ? (firstScheduledRoot = next) : (prev.next = next),
+            null === next && (lastScheduledRoot = prev);
+        else if (
+          ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
+        )
+          mightHavePendingSyncWork = !0;
+        root = next;
+      }
+      flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
+    }
+    function scheduleTaskForRootDuringMicrotask(root, currentTime) {
+      for (
+        var suspendedLanes = root.suspendedLanes,
+          pingedLanes = root.pingedLanes,
+          expirationTimes = root.expirationTimes,
+          lanes = root.pendingLanes & -62914561;
+        0 < lanes;
+
+      ) {
+        var index = 31 - clz32(lanes),
+          lane = 1 << index,
+          expirationTime = expirationTimes[index];
+        if (-1 === expirationTime) {
+          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
+            expirationTimes[index] = computeExpirationTime(lane, currentTime);
+        } else expirationTime <= currentTime && (root.expiredLanes |= lane);
+        lanes &= ~lane;
+      }
+      currentTime = workInProgressRoot;
+      suspendedLanes = workInProgressRootRenderLanes;
+      suspendedLanes = getNextLanes(
+        root,
+        root === currentTime ? suspendedLanes : 0,
+        null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
+      );
+      pingedLanes = root.callbackNode;
+      if (
+        0 === suspendedLanes ||
+        (root === currentTime &&
+          (workInProgressSuspendedReason === SuspendedOnData ||
+            workInProgressSuspendedReason === SuspendedOnAction)) ||
+        null !== root.cancelPendingCommit
+      )
+        return (
+          null !== pingedLanes && cancelCallback(pingedLanes),
+          (root.callbackNode = null),
+          (root.callbackPriority = 0)
+        );
+      if (
+        0 !== (suspendedLanes & 3) &&
+        !checkIfRootIsPrerendering(root, suspendedLanes)
+      )
+        return (
+          null !== pingedLanes && cancelCallback(pingedLanes),
+          (root.callbackPriority = 2),
+          (root.callbackNode = null),
+          2
+        );
+      currentTime = suspendedLanes & -suspendedLanes;
+      if (
+        currentTime !== root.callbackPriority ||
+        (null !== ReactSharedInternals.actQueue &&
+          pingedLanes !== fakeActCallbackNode)
+      )
+        cancelCallback(pingedLanes);
+      else return currentTime;
+      switch (lanesToEventPriority(suspendedLanes)) {
+        case DiscreteEventPriority:
+        case ContinuousEventPriority:
+          suspendedLanes = UserBlockingPriority;
+          break;
+        case DefaultEventPriority:
+          suspendedLanes = NormalPriority$1;
+          break;
+        case IdleEventPriority:
+          suspendedLanes = IdlePriority;
+          break;
+        default:
+          suspendedLanes = NormalPriority$1;
+      }
+      pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
+      null !== ReactSharedInternals.actQueue
+        ? (ReactSharedInternals.actQueue.push(pingedLanes),
+          (suspendedLanes = fakeActCallbackNode))
+        : (suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes));
+      root.callbackPriority = currentTime;
+      root.callbackNode = suspendedLanes;
+      return currentTime;
+    }
+    function performWorkOnRootViaSchedulerTask(root, didTimeout) {
+      nestedUpdateScheduled = currentUpdateIsNested = !1;
+      schedulerEvent = window.event;
+      if (
+        pendingEffectsStatus !== NO_PENDING_EFFECTS &&
+        pendingEffectsStatus !== PENDING_PASSIVE_PHASE
+      )
+        return (root.callbackNode = null), (root.callbackPriority = 0), null;
+      var originalCallbackNode = root.callbackNode;
+      if (flushPendingEffects(!0) && root.callbackNode !== originalCallbackNode)
+        return null;
+      var workInProgressRootRenderLanes$jscomp$0 =
+        workInProgressRootRenderLanes;
+      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
+        root,
+        root === workInProgressRoot
+          ? workInProgressRootRenderLanes$jscomp$0
+          : 0,
+        null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
+      );
+      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
+      performWorkOnRoot(
+        root,
+        workInProgressRootRenderLanes$jscomp$0,
+        didTimeout
+      );
+      scheduleTaskForRootDuringMicrotask(root, now$1());
+      return null != root.callbackNode &&
+        root.callbackNode === originalCallbackNode
+        ? performWorkOnRootViaSchedulerTask.bind(null, root)
+        : null;
+    }
+    function performSyncWorkOnRoot(root, lanes) {
+      if (flushPendingEffects()) return null;
+      currentUpdateIsNested = nestedUpdateScheduled;
+      nestedUpdateScheduled = !1;
+      performWorkOnRoot(root, lanes, !0);
+    }
+    function cancelCallback(callbackNode) {
+      callbackNode !== fakeActCallbackNode &&
+        null !== callbackNode &&
+        cancelCallback$1(callbackNode);
+    }
+    function scheduleImmediateRootScheduleTask() {
+      null !== ReactSharedInternals.actQueue &&
+        ReactSharedInternals.actQueue.push(function () {
+          processRootScheduleInMicrotask();
+          return null;
+        });
+      scheduleMicrotask(function () {
+        (executionContext & (RenderContext | CommitContext)) !== NoContext
+          ? scheduleCallback$3(
+              ImmediatePriority,
+              processRootScheduleInImmediateTask
+            )
+          : processRootScheduleInMicrotask();
+      });
+    }
+    function requestTransitionLane() {
+      0 === currentEventTransitionLane &&
+        (currentEventTransitionLane = claimNextTransitionLane());
+      return currentEventTransitionLane;
+    }
+    function coerceFormActionProp(actionProp) {
+      if (
+        null == actionProp ||
+        "symbol" === typeof actionProp ||
+        "boolean" === typeof actionProp
+      )
+        return null;
+      if ("function" === typeof actionProp) return actionProp;
+      checkAttributeStringCoercion(actionProp, "action");
+      return sanitizeURL("" + actionProp);
+    }
+    function createFormDataWithSubmitter(form, submitter) {
+      var temp = submitter.ownerDocument.createElement("input");
+      temp.name = submitter.name;
+      temp.value = submitter.value;
+      form.id && temp.setAttribute("form", form.id);
+      submitter.parentNode.insertBefore(temp, submitter);
+      form = new FormData(form);
+      temp.parentNode.removeChild(temp);
+      return form;
+    }
+    function extractEvents$1(
+      dispatchQueue,
+      domEventName,
+      maybeTargetInst,
+      nativeEvent,
+      nativeEventTarget
+    ) {
+      if (
+        "submit" === domEventName &&
+        maybeTargetInst &&
+        maybeTargetInst.stateNode === nativeEventTarget
+      ) {
+        var action = coerceFormActionProp(
+            (nativeEventTarget[internalPropsKey] || null).action
+          ),
+          submitter = nativeEvent.submitter;
+        submitter &&
+          ((domEventName = (domEventName = submitter[internalPropsKey] || null)
+            ? coerceFormActionProp(domEventName.formAction)
+            : submitter.getAttribute("formAction")),
+          null !== domEventName &&
+            ((action = domEventName), (submitter = null)));
+        var event = new SyntheticEvent(
+          "action",
+          "action",
+          null,
+          nativeEvent,
+          nativeEventTarget
+        );
+        dispatchQueue.push({
+          event: event,
+          listeners: [
+            {
+              instance: null,
+              listener: function () {
+                if (nativeEvent.defaultPrevented) {
+                  if (0 !== currentEventTransitionLane) {
+                    var formData = submitter
+                        ? createFormDataWithSubmitter(
+                            nativeEventTarget,
+                            submitter
+                          )
+                        : new FormData(nativeEventTarget),
+                      pendingState = {
+                        pending: !0,
+                        data: formData,
+                        method: nativeEventTarget.method,
+                        action: action
+                      };
+                    Object.freeze(pendingState);
+                    startHostTransition(
+                      maybeTargetInst,
+                      pendingState,
+                      null,
+                      formData
+                    );
+                  }
+                } else
+                  "function" === typeof action &&
+                    (event.preventDefault(),
+                    (formData = submitter
+                      ? createFormDataWithSubmitter(
+                          nativeEventTarget,
+                          submitter
+                        )
+                      : new FormData(nativeEventTarget)),
+                    (pendingState = {
+                      pending: !0,
+                      data: formData,
+                      method: nativeEventTarget.method,
+                      action: action
+                    }),
+                    Object.freeze(pendingState),
+                    startHostTransition(
+                      maybeTargetInst,
+                      pendingState,
+                      action,
+                      formData
+                    ));
+              },
+              currentTarget: nativeEventTarget
+            }
+          ]
+        });
+      }
+    }
+    function executeDispatch(event, listener, currentTarget) {
+      event.currentTarget = currentTarget;
+      try {
+        listener(event);
+      } catch (error) {
+        reportGlobalError(error);
+      }
+      event.currentTarget = null;
+    }
+    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
+      eventSystemFlags = 0 !== (eventSystemFlags & 4);
+      for (var i = 0; i < dispatchQueue.length; i++) {
+        var _dispatchQueue$i = dispatchQueue[i];
+        a: {
+          var previousInstance = void 0,
+            event = _dispatchQueue$i.event;
+          _dispatchQueue$i = _dispatchQueue$i.listeners;
+          if (eventSystemFlags)
+            for (
+              var i$jscomp$0 = _dispatchQueue$i.length - 1;
+              0 <= i$jscomp$0;
+              i$jscomp$0--
+            ) {
+              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
+                instance = _dispatchListeners$i.instance,
+                currentTarget = _dispatchListeners$i.currentTarget;
+              _dispatchListeners$i = _dispatchListeners$i.listener;
+              if (instance !== previousInstance && event.isPropagationStopped())
+                break a;
+              null !== instance
+                ? runWithFiberInDEV(
+                    instance,
+                    executeDispatch,
+                    event,
+                    _dispatchListeners$i,
+                    currentTarget
+                  )
+                : executeDispatch(event, _dispatchListeners$i, currentTarget);
+              previousInstance = instance;
+            }
+          else
+            for (
+              i$jscomp$0 = 0;
+              i$jscomp$0 < _dispatchQueue$i.length;
+              i$jscomp$0++
+            ) {
+              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
+              instance = _dispatchListeners$i.instance;
+              currentTarget = _dispatchListeners$i.currentTarget;
+              _dispatchListeners$i = _dispatchListeners$i.listener;
+              if (instance !== previousInstance && event.isPropagationStopped())
+                break a;
+              null !== instance
+                ? runWithFiberInDEV(
+                    instance,
+                    executeDispatch,
+                    event,
+                    _dispatchListeners$i,
+                    currentTarget
+                  )
+                : executeDispatch(event, _dispatchListeners$i, currentTarget);
+              previousInstance = instance;
+            }
+        }
+      }
+    }
+    function listenToNonDelegatedEvent(domEventName, targetElement) {
+      nonDelegatedEvents.has(domEventName) ||
+        console.error(
+          'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
+          domEventName
+        );
+      var listenerSet = targetElement[internalEventHandlersKey];
+      void 0 === listenerSet &&
+        (listenerSet = targetElement[internalEventHandlersKey] = new Set());
+      var listenerSetKey = domEventName + "__bubble";
+      listenerSet.has(listenerSetKey) ||
+        (addTrappedEventListener(targetElement, domEventName, 2, !1),
+        listenerSet.add(listenerSetKey));
+    }
+    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
+      nonDelegatedEvents.has(domEventName) &&
+        !isCapturePhaseListener &&
+        console.error(
+          'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
+          domEventName
+        );
+      var eventSystemFlags = 0;
+      isCapturePhaseListener && (eventSystemFlags |= 4);
+      addTrappedEventListener(
+        target,
+        domEventName,
+        eventSystemFlags,
+        isCapturePhaseListener
+      );
+    }
+    function listenToAllSupportedEvents(rootContainerElement) {
+      if (!rootContainerElement[listeningMarker]) {
+        rootContainerElement[listeningMarker] = !0;
+        allNativeEvents.forEach(function (domEventName) {
+          "selectionchange" !== domEventName &&
+            (nonDelegatedEvents.has(domEventName) ||
+              listenToNativeEvent(domEventName, !1, rootContainerElement),
+            listenToNativeEvent(domEventName, !0, rootContainerElement));
+        });
+        var ownerDocument =
+          9 === rootContainerElement.nodeType
+            ? rootContainerElement
+            : rootContainerElement.ownerDocument;
+        null === ownerDocument ||
+          ownerDocument[listeningMarker] ||
+          ((ownerDocument[listeningMarker] = !0),
+          listenToNativeEvent("selectionchange", !1, ownerDocument));
+      }
+    }
+    function addTrappedEventListener(
+      targetContainer,
+      domEventName,
+      eventSystemFlags,
+      isCapturePhaseListener
+    ) {
+      switch (getEventPriority(domEventName)) {
+        case DiscreteEventPriority:
+          var listenerWrapper = dispatchDiscreteEvent;
+          break;
+        case ContinuousEventPriority:
+          listenerWrapper = dispatchContinuousEvent;
+          break;
+        default:
+          listenerWrapper = dispatchEvent;
+      }
+      eventSystemFlags = listenerWrapper.bind(
+        null,
+        domEventName,
+        eventSystemFlags,
+        targetContainer
+      );
+      listenerWrapper = void 0;
+      !passiveBrowserEventsSupported ||
+        ("touchstart" !== domEventName &&
+          "touchmove" !== domEventName &&
+          "wheel" !== domEventName) ||
+        (listenerWrapper = !0);
+      isCapturePhaseListener
+        ? void 0 !== listenerWrapper
+          ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
+              capture: !0,
+              passive: listenerWrapper
+            })
+          : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
+        : void 0 !== listenerWrapper
+          ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
+              passive: listenerWrapper
+            })
+          : targetContainer.addEventListener(
+              domEventName,
+              eventSystemFlags,
+              !1
+            );
+    }
+    function dispatchEventForPluginEventSystem(
+      domEventName,
+      eventSystemFlags,
+      nativeEvent,
+      targetInst$jscomp$0,
+      targetContainer
+    ) {
+      var ancestorInst = targetInst$jscomp$0;
+      if (
+        0 === (eventSystemFlags & 1) &&
+        0 === (eventSystemFlags & 2) &&
+        null !== targetInst$jscomp$0
+      )
+        a: for (;;) {
+          if (null === targetInst$jscomp$0) return;
+          var nodeTag = targetInst$jscomp$0.tag;
+          if (3 === nodeTag || 4 === nodeTag) {
+            var container = targetInst$jscomp$0.stateNode.containerInfo;
+            if (
+              container === targetContainer ||
+              (8 === container.nodeType &&
+                container.parentNode === targetContainer)
+            )
+              break;
+            if (4 === nodeTag)
+              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
+                var grandTag = nodeTag.tag;
+                if (3 === grandTag || 4 === grandTag)
+                  if (
+                    ((grandTag = nodeTag.stateNode.containerInfo),
+                    grandTag === targetContainer ||
+                      (8 === grandTag.nodeType &&
+                        grandTag.parentNode === targetContainer))
+                  )
+                    return;
+                nodeTag = nodeTag.return;
+              }
+            for (; null !== container; ) {
+              nodeTag = getClosestInstanceFromNode(container);
+              if (null === nodeTag) return;
+              grandTag = nodeTag.tag;
+              if (
+                5 === grandTag ||
+                6 === grandTag ||
+                26 === grandTag ||
+                27 === grandTag
+              ) {
+                targetInst$jscomp$0 = ancestorInst = nodeTag;
+                continue a;
+              }
+              container = container.parentNode;
+            }
+          }
+          targetInst$jscomp$0 = targetInst$jscomp$0.return;
+        }
+      batchedUpdates$1(function () {
+        var targetInst = ancestorInst,
+          nativeEventTarget = getEventTarget(nativeEvent),
+          dispatchQueue = [];
+        a: {
+          var reactName = topLevelEventsToReactNames.get(domEventName);
+          if (void 0 !== reactName) {
+            var SyntheticEventCtor = SyntheticEvent,
+              reactEventType = domEventName;
+            switch (domEventName) {
+              case "keypress":
+                if (0 === getEventCharCode(nativeEvent)) break a;
+              case "keydown":
+              case "keyup":
+                SyntheticEventCtor = SyntheticKeyboardEvent;
+                break;
+              case "focusin":
+                reactEventType = "focus";
+                SyntheticEventCtor = SyntheticFocusEvent;
+                break;
+              case "focusout":
+                reactEventType = "blur";
+                SyntheticEventCtor = SyntheticFocusEvent;
+                break;
+              case "beforeblur":
+              case "afterblur":
+                SyntheticEventCtor = SyntheticFocusEvent;
+                break;
+              case "click":
+                if (2 === nativeEvent.button) break a;
+              case "auxclick":
+              case "dblclick":
+              case "mousedown":
+              case "mousemove":
+              case "mouseup":
+              case "mouseout":
+              case "mouseover":
+              case "contextmenu":
+                SyntheticEventCtor = SyntheticMouseEvent;
+                break;
+              case "drag":
+              case "dragend":
+              case "dragenter":
+              case "dragexit":
+              case "dragleave":
+              case "dragover":
+              case "dragstart":
+              case "drop":
+                SyntheticEventCtor = SyntheticDragEvent;
+                break;
+              case "touchcancel":
+              case "touchend":
+              case "touchmove":
+              case "touchstart":
+                SyntheticEventCtor = SyntheticTouchEvent;
+                break;
+              case ANIMATION_END:
+              case ANIMATION_ITERATION:
+              case ANIMATION_START:
+                SyntheticEventCtor = SyntheticAnimationEvent;
+                break;
+              case TRANSITION_END:
+                SyntheticEventCtor = SyntheticTransitionEvent;
+                break;
+              case "scroll":
+              case "scrollend":
+                SyntheticEventCtor = SyntheticUIEvent;
+                break;
+              case "wheel":
+                SyntheticEventCtor = SyntheticWheelEvent;
+                break;
+              case "copy":
+              case "cut":
+              case "paste":
+                SyntheticEventCtor = SyntheticClipboardEvent;
+                break;
+              case "gotpointercapture":
+              case "lostpointercapture":
+              case "pointercancel":
+              case "pointerdown":
+              case "pointermove":
+              case "pointerout":
+              case "pointerover":
+              case "pointerup":
+                SyntheticEventCtor = SyntheticPointerEvent;
+                break;
+              case "toggle":
+              case "beforetoggle":
+                SyntheticEventCtor = SyntheticToggleEvent;
+            }
+            var inCapturePhase = 0 !== (eventSystemFlags & 4),
+              accumulateTargetOnly =
+                !inCapturePhase &&
+                ("scroll" === domEventName || "scrollend" === domEventName),
+              reactEventName = inCapturePhase
+                ? null !== reactName
+                  ? reactName + "Capture"
+                  : null
+                : reactName;
+            inCapturePhase = [];
+            for (
+              var instance = targetInst, lastHostComponent;
+              null !== instance;
+
+            ) {
+              var _instance2 = instance;
+              lastHostComponent = _instance2.stateNode;
+              _instance2 = _instance2.tag;
+              (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
+                null === lastHostComponent ||
+                null === reactEventName ||
+                ((_instance2 = getListener(instance, reactEventName)),
+                null != _instance2 &&
+                  inCapturePhase.push(
+                    createDispatchListener(
+                      instance,
+                      _instance2,
+                      lastHostComponent
+                    )
+                  ));
+              if (accumulateTargetOnly) break;
+              instance = instance.return;
+            }
+            0 < inCapturePhase.length &&
+              ((reactName = new SyntheticEventCtor(
+                reactName,
+                reactEventType,
+                null,
+                nativeEvent,
+                nativeEventTarget
+              )),
+              dispatchQueue.push({
+                event: reactName,
+                listeners: inCapturePhase
+              }));
+          }
+        }
+        if (0 === (eventSystemFlags & 7)) {
+          a: {
+            reactName =
+              "mouseover" === domEventName || "pointerover" === domEventName;
+            SyntheticEventCtor =
+              "mouseout" === domEventName || "pointerout" === domEventName;
+            if (
+              reactName &&
+              nativeEvent !== currentReplayingEvent &&
+              (reactEventType =
+                nativeEvent.relatedTarget || nativeEvent.fromElement) &&
+              (getClosestInstanceFromNode(reactEventType) ||
+                reactEventType[internalContainerInstanceKey])
+            )
+              break a;
+            if (SyntheticEventCtor || reactName) {
+              reactName =
+                nativeEventTarget.window === nativeEventTarget
+                  ? nativeEventTarget
+                  : (reactName = nativeEventTarget.ownerDocument)
+                    ? reactName.defaultView || reactName.parentWindow
+                    : window;
+              if (SyntheticEventCtor) {
+                if (
+                  ((reactEventType =
+                    nativeEvent.relatedTarget || nativeEvent.toElement),
+                  (SyntheticEventCtor = targetInst),
+                  (reactEventType = reactEventType
+                    ? getClosestInstanceFromNode(reactEventType)
+                    : null),
+                  null !== reactEventType &&
+                    ((accumulateTargetOnly =
+                      getNearestMountedFiber(reactEventType)),
+                    (inCapturePhase = reactEventType.tag),
+                    reactEventType !== accumulateTargetOnly ||
+                      (5 !== inCapturePhase &&
+                        27 !== inCapturePhase &&
+                        6 !== inCapturePhase)))
+                )
+                  reactEventType = null;
+              } else (SyntheticEventCtor = null), (reactEventType = targetInst);
+              if (SyntheticEventCtor !== reactEventType) {
+                inCapturePhase = SyntheticMouseEvent;
+                _instance2 = "onMouseLeave";
+                reactEventName = "onMouseEnter";
+                instance = "mouse";
+                if (
+                  "pointerout" === domEventName ||
+                  "pointerover" === domEventName
+                )
+                  (inCapturePhase = SyntheticPointerEvent),
+                    (_instance2 = "onPointerLeave"),
+                    (reactEventName = "onPointerEnter"),
+                    (instance = "pointer");
+                accumulateTargetOnly =
+                  null == SyntheticEventCtor
+                    ? reactName
+                    : getNodeFromInstance(SyntheticEventCtor);
+                lastHostComponent =
+                  null == reactEventType
+                    ? reactName
+                    : getNodeFromInstance(reactEventType);
+                reactName = new inCapturePhase(
+                  _instance2,
+                  instance + "leave",
+                  SyntheticEventCtor,
+                  nativeEvent,
+                  nativeEventTarget
+                );
+                reactName.target = accumulateTargetOnly;
+                reactName.relatedTarget = lastHostComponent;
+                _instance2 = null;
+                getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
+                  ((inCapturePhase = new inCapturePhase(
+                    reactEventName,
+                    instance + "enter",
+                    reactEventType,
+                    nativeEvent,
+                    nativeEventTarget
+                  )),
+                  (inCapturePhase.target = lastHostComponent),
+                  (inCapturePhase.relatedTarget = accumulateTargetOnly),
+                  (_instance2 = inCapturePhase));
+                accumulateTargetOnly = _instance2;
+                if (SyntheticEventCtor && reactEventType)
+                  b: {
+                    inCapturePhase = SyntheticEventCtor;
+                    reactEventName = reactEventType;
+                    instance = 0;
+                    for (
+                      lastHostComponent = inCapturePhase;
+                      lastHostComponent;
+                      lastHostComponent = getParent(lastHostComponent)
+                    )
+                      instance++;
+                    lastHostComponent = 0;
+                    for (
+                      _instance2 = reactEventName;
+                      _instance2;
+                      _instance2 = getParent(_instance2)
+                    )
+                      lastHostComponent++;
+                    for (; 0 < instance - lastHostComponent; )
+                      (inCapturePhase = getParent(inCapturePhase)), instance--;
+                    for (; 0 < lastHostComponent - instance; )
+                      (reactEventName = getParent(reactEventName)),
+                        lastHostComponent--;
+                    for (; instance--; ) {
+                      if (
+                        inCapturePhase === reactEventName ||
+                        (null !== reactEventName &&
+                          inCapturePhase === reactEventName.alternate)
+                      )
+                        break b;
+                      inCapturePhase = getParent(inCapturePhase);
+                      reactEventName = getParent(reactEventName);
+                    }
+                    inCapturePhase = null;
+                  }
+                else inCapturePhase = null;
+                null !== SyntheticEventCtor &&
+                  accumulateEnterLeaveListenersForEvent(
+                    dispatchQueue,
+                    reactName,
+                    SyntheticEventCtor,
+                    inCapturePhase,
+                    !1
+                  );
+                null !== reactEventType &&
+                  null !== accumulateTargetOnly &&
+                  accumulateEnterLeaveListenersForEvent(
+                    dispatchQueue,
+                    accumulateTargetOnly,
+                    reactEventType,
+                    inCapturePhase,
+                    !0
+                  );
+              }
+            }
+          }
+          a: {
+            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
+            SyntheticEventCtor =
+              reactName.nodeName && reactName.nodeName.toLowerCase();
+            if (
+              "select" === SyntheticEventCtor ||
+              ("input" === SyntheticEventCtor && "file" === reactName.type)
+            )
+              var getTargetInstFunc = getTargetInstForChangeEvent;
+            else if (isTextInputElement(reactName))
+              if (isInputEventSupported)
+                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
+              else {
+                getTargetInstFunc = getTargetInstForInputEventPolyfill;
+                var handleEventFunc = handleEventsForInputEventPolyfill;
+              }
+            else
+              (SyntheticEventCtor = reactName.nodeName),
+                !SyntheticEventCtor ||
+                "input" !== SyntheticEventCtor.toLowerCase() ||
+                ("checkbox" !== reactName.type && "radio" !== reactName.type)
+                  ? targetInst &&
+                    isCustomElement(targetInst.elementType) &&
+                    (getTargetInstFunc = getTargetInstForChangeEvent)
+                  : (getTargetInstFunc = getTargetInstForClickEvent);
+            if (
+              getTargetInstFunc &&
+              (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
+            ) {
+              createAndAccumulateChangeEvent(
+                dispatchQueue,
+                getTargetInstFunc,
+                nativeEvent,
+                nativeEventTarget
+              );
+              break a;
+            }
+            handleEventFunc &&
+              handleEventFunc(domEventName, reactName, targetInst);
+            "focusout" === domEventName &&
+              targetInst &&
+              "number" === reactName.type &&
+              null != targetInst.memoizedProps.value &&
+              setDefaultValue(reactName, "number", reactName.value);
+          }
+          handleEventFunc = targetInst
+            ? getNodeFromInstance(targetInst)
+            : window;
+          switch (domEventName) {
+            case "focusin":
+              if (
+                isTextInputElement(handleEventFunc) ||
+                "true" === handleEventFunc.contentEditable
+              )
+                (activeElement = handleEventFunc),
+                  (activeElementInst = targetInst),
+                  (lastSelection = null);
+              break;
+            case "focusout":
+              lastSelection = activeElementInst = activeElement = null;
+              break;
+            case "mousedown":
+              mouseDown = !0;
+              break;
+            case "contextmenu":
+            case "mouseup":
+            case "dragend":
+              mouseDown = !1;
+              constructSelectEvent(
+                dispatchQueue,
+                nativeEvent,
+                nativeEventTarget
+              );
+              break;
+            case "selectionchange":
+              if (skipSelectionChangeEvent) break;
+            case "keydown":
+            case "keyup":
+              constructSelectEvent(
+                dispatchQueue,
+                nativeEvent,
+                nativeEventTarget
+              );
+          }
+          var fallbackData;
+          if (canUseCompositionEvent)
+            b: {
+              switch (domEventName) {
+                case "compositionstart":
+                  var eventType = "onCompositionStart";
+                  break b;
+                case "compositionend":
+                  eventType = "onCompositionEnd";
+                  break b;
+                case "compositionupdate":
+                  eventType = "onCompositionUpdate";
+                  break b;
+              }
+              eventType = void 0;
+            }
+          else
+            isComposing
+              ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
+                (eventType = "onCompositionEnd")
+              : "keydown" === domEventName &&
+                nativeEvent.keyCode === START_KEYCODE &&
+                (eventType = "onCompositionStart");
+          eventType &&
+            (useFallbackCompositionData &&
+              "ko" !== nativeEvent.locale &&
+              (isComposing || "onCompositionStart" !== eventType
+                ? "onCompositionEnd" === eventType &&
+                  isComposing &&
+                  (fallbackData = getData())
+                : ((root = nativeEventTarget),
+                  (startText = "value" in root ? root.value : root.textContent),
+                  (isComposing = !0))),
+            (handleEventFunc = accumulateTwoPhaseListeners(
+              targetInst,
+              eventType
+            )),
+            0 < handleEventFunc.length &&
+              ((eventType = new SyntheticCompositionEvent(
+                eventType,
+                domEventName,
+                null,
+                nativeEvent,
+                nativeEventTarget
+              )),
+              dispatchQueue.push({
+                event: eventType,
+                listeners: handleEventFunc
+              }),
+              fallbackData
+                ? (eventType.data = fallbackData)
+                : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
+                  null !== fallbackData && (eventType.data = fallbackData))));
+          if (
+            (fallbackData = canUseTextInputEvent
+              ? getNativeBeforeInputChars(domEventName, nativeEvent)
+              : getFallbackBeforeInputChars(domEventName, nativeEvent))
+          )
+            (eventType = accumulateTwoPhaseListeners(
+              targetInst,
+              "onBeforeInput"
+            )),
+              0 < eventType.length &&
+                ((handleEventFunc = new SyntheticInputEvent(
+                  "onBeforeInput",
+                  "beforeinput",
+                  null,
+                  nativeEvent,
+                  nativeEventTarget
+                )),
+                dispatchQueue.push({
+                  event: handleEventFunc,
+                  listeners: eventType
+                }),
+                (handleEventFunc.data = fallbackData));
+          extractEvents$1(
+            dispatchQueue,
+            domEventName,
+            targetInst,
+            nativeEvent,
+            nativeEventTarget
+          );
+        }
+        processDispatchQueue(dispatchQueue, eventSystemFlags);
+      });
+    }
+    function createDispatchListener(instance, listener, currentTarget) {
+      return {
+        instance: instance,
+        listener: listener,
+        currentTarget: currentTarget
+      };
+    }
+    function accumulateTwoPhaseListeners(targetFiber, reactName) {
+      for (
+        var captureName = reactName + "Capture", listeners = [];
+        null !== targetFiber;
+
+      ) {
+        var _instance3 = targetFiber,
+          stateNode = _instance3.stateNode;
+        _instance3 = _instance3.tag;
+        (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
+          null === stateNode ||
+          ((_instance3 = getListener(targetFiber, captureName)),
+          null != _instance3 &&
+            listeners.unshift(
+              createDispatchListener(targetFiber, _instance3, stateNode)
+            ),
+          (_instance3 = getListener(targetFiber, reactName)),
+          null != _instance3 &&
+            listeners.push(
+              createDispatchListener(targetFiber, _instance3, stateNode)
+            ));
+        targetFiber = targetFiber.return;
+      }
+      return listeners;
+    }
+    function getParent(inst) {
+      if (null === inst) return null;
+      do inst = inst.return;
+      while (inst && 5 !== inst.tag && 27 !== inst.tag);
+      return inst ? inst : null;
+    }
+    function accumulateEnterLeaveListenersForEvent(
+      dispatchQueue,
+      event,
+      target,
+      common,
+      inCapturePhase
+    ) {
+      for (
+        var registrationName = event._reactName, listeners = [];
+        null !== target && target !== common;
+
+      ) {
+        var _instance4 = target,
+          alternate = _instance4.alternate,
+          stateNode = _instance4.stateNode;
+        _instance4 = _instance4.tag;
+        if (null !== alternate && alternate === common) break;
+        (5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4) ||
+          null === stateNode ||
+          ((alternate = stateNode),
+          inCapturePhase
+            ? ((stateNode = getListener(target, registrationName)),
+              null != stateNode &&
+                listeners.unshift(
+                  createDispatchListener(target, stateNode, alternate)
+                ))
+            : inCapturePhase ||
+              ((stateNode = getListener(target, registrationName)),
+              null != stateNode &&
+                listeners.push(
+                  createDispatchListener(target, stateNode, alternate)
+                )));
+        target = target.return;
+      }
+      0 !== listeners.length &&
+        dispatchQueue.push({ event: event, listeners: listeners });
+    }
+    function validatePropertiesInDevelopment(type, props) {
+      validateProperties$2(type, props);
+      ("input" !== type && "textarea" !== type && "select" !== type) ||
+        null == props ||
+        null !== props.value ||
+        didWarnValueNull ||
+        ((didWarnValueNull = !0),
+        "select" === type && props.multiple
+          ? console.error(
+              "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
+              type
+            )
+          : console.error(
+              "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
+              type
+            ));
+      var eventRegistry = {
+        registrationNameDependencies: registrationNameDependencies,
+        possibleRegistrationNames: possibleRegistrationNames
+      };
+      isCustomElement(type) ||
+        "string" === typeof props.is ||
+        warnUnknownProperties(type, props, eventRegistry);
+      props.contentEditable &&
+        !props.suppressContentEditableWarning &&
+        null != props.children &&
+        console.error(
+          "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
+        );
+    }
+    function warnForPropDifference(
+      propName,
+      serverValue,
+      clientValue,
+      serverDifferences
+    ) {
+      serverValue !== clientValue &&
+        ((clientValue = normalizeMarkupForTextOrAttribute(clientValue)),
+        normalizeMarkupForTextOrAttribute(serverValue) !== clientValue &&
+          (serverDifferences[propName] = serverValue));
+    }
+    function warnForExtraAttributes(
+      domElement,
+      attributeNames,
+      serverDifferences
+    ) {
+      attributeNames.forEach(function (attributeName) {
+        serverDifferences[getPropNameFromAttributeName(attributeName)] =
+          "style" === attributeName
+            ? getStylesObjectFromElement(domElement)
+            : domElement.getAttribute(attributeName);
+      });
+    }
+    function warnForInvalidEventListener(registrationName, listener) {
+      !1 === listener
+        ? console.error(
+            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
+            registrationName,
+            registrationName,
+            registrationName
+          )
+        : console.error(
+            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
+            registrationName,
+            typeof listener
+          );
+    }
+    function normalizeHTML(parent, html) {
+      parent =
+        parent.namespaceURI === MATH_NAMESPACE ||
+        parent.namespaceURI === SVG_NAMESPACE
+          ? parent.ownerDocument.createElementNS(
+              parent.namespaceURI,
+              parent.tagName
+            )
+          : parent.ownerDocument.createElement(parent.tagName);
+      parent.innerHTML = html;
+      return parent.innerHTML;
+    }
+    function normalizeMarkupForTextOrAttribute(markup) {
+      willCoercionThrow(markup) &&
+        (console.error(
+          "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
+          typeName(markup)
+        ),
+        testStringCoercion(markup));
+      return ("string" === typeof markup ? markup : "" + markup)
+        .replace(NORMALIZE_NEWLINES_REGEX, "\n")
+        .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
+    }
+    function checkForUnmatchedText(serverText, clientText) {
+      clientText = normalizeMarkupForTextOrAttribute(clientText);
+      return normalizeMarkupForTextOrAttribute(serverText) === clientText
+        ? !0
+        : !1;
+    }
+    function noop$1() {}
+    function setProp(domElement, tag, key, value, props, prevValue) {
+      switch (key) {
+        case "children":
+          if ("string" === typeof value)
+            validateTextNesting(value, tag),
+              "body" === tag ||
+                ("textarea" === tag && "" === value) ||
+                setTextContent(domElement, value);
+          else if ("number" === typeof value || "bigint" === typeof value)
+            validateTextNesting("" + value, tag),
+              "body" !== tag && setTextContent(domElement, "" + value);
+          else return;
+          break;
+        case "className":
+          setValueForKnownAttribute(domElement, "class", value);
+          break;
+        case "tabIndex":
+          setValueForKnownAttribute(domElement, "tabindex", value);
+          break;
+        case "dir":
+        case "role":
+        case "viewBox":
+        case "width":
+        case "height":
+          setValueForKnownAttribute(domElement, key, value);
+          break;
+        case "style":
+          setValueForStyles(domElement, value, prevValue);
+          return;
+        case "data":
+          if ("object" !== tag) {
+            setValueForKnownAttribute(domElement, "data", value);
+            break;
+          }
+        case "src":
+        case "href":
+          if ("" === value && ("a" !== tag || "href" !== key)) {
+            "src" === key
+              ? console.error(
+                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
+                  key,
+                  key
+                )
+              : console.error(
+                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
+                  key,
+                  key
+                );
+            domElement.removeAttribute(key);
+            break;
+          }
+          if (
+            null == value ||
+            "function" === typeof value ||
+            "symbol" === typeof value ||
+            "boolean" === typeof value
+          ) {
+            domElement.removeAttribute(key);
+            break;
+          }
+          checkAttributeStringCoercion(value, key);
+          value = sanitizeURL("" + value);
+          domElement.setAttribute(key, value);
+          break;
+        case "action":
+        case "formAction":
+          null != value &&
+            ("form" === tag
+              ? "formAction" === key
+                ? console.error(
+                    "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
+                  )
+                : "function" === typeof value &&
+                  ((null == props.encType && null == props.method) ||
+                    didWarnFormActionMethod ||
+                    ((didWarnFormActionMethod = !0),
+                    console.error(
+                      "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
+                    )),
+                  null == props.target ||
+                    didWarnFormActionTarget ||
+                    ((didWarnFormActionTarget = !0),
+                    console.error(
+                      "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
+                    )))
+              : "input" === tag || "button" === tag
+                ? "action" === key
+                  ? console.error(
+                      "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
+                    )
+                  : "input" !== tag ||
+                      "submit" === props.type ||
+                      "image" === props.type ||
+                      didWarnFormActionType
+                    ? "button" !== tag ||
+                      null == props.type ||
+                      "submit" === props.type ||
+                      didWarnFormActionType
+                      ? "function" === typeof value &&
+                        (null == props.name ||
+                          didWarnFormActionName ||
+                          ((didWarnFormActionName = !0),
+                          console.error(
+                            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
+                          )),
+                        (null == props.formEncType &&
+                          null == props.formMethod) ||
+                          didWarnFormActionMethod ||
+                          ((didWarnFormActionMethod = !0),
+                          console.error(
+                            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
+                          )),
+                        null == props.formTarget ||
+                          didWarnFormActionTarget ||
+                          ((didWarnFormActionTarget = !0),
+                          console.error(
+                            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
+                          )))
+                      : ((didWarnFormActionType = !0),
+                        console.error(
+                          'A button can only specify a formAction along with type="submit" or no type.'
+                        ))
+                    : ((didWarnFormActionType = !0),
+                      console.error(
+                        'An input can only specify a formAction along with type="submit" or type="image".'
+                      ))
+                : "action" === key
+                  ? console.error(
+                      "You can only pass the action prop to <form>."
+                    )
+                  : console.error(
+                      "You can only pass the formAction prop to <input> or <button>."
+                    ));
+          if ("function" === typeof value) {
+            domElement.setAttribute(
+              key,
+              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
+            );
+            break;
+          } else
+            "function" === typeof prevValue &&
+              ("formAction" === key
+                ? ("input" !== tag &&
+                    setProp(domElement, tag, "name", props.name, props, null),
+                  setProp(
+                    domElement,
+                    tag,
+                    "formEncType",
+                    props.formEncType,
+                    props,
+                    null
+                  ),
+                  setProp(
+                    domElement,
+                    tag,
+                    "formMethod",
+                    props.formMethod,
+                    props,
+                    null
+                  ),
+                  setProp(
+                    domElement,
+                    tag,
+                    "formTarget",
+                    props.formTarget,
+                    props,
+                    null
+                  ))
+                : (setProp(
+                    domElement,
+                    tag,
+                    "encType",
+                    props.encType,
+                    props,
+                    null
+                  ),
+                  setProp(domElement, tag, "method", props.method, props, null),
+                  setProp(
+                    domElement,
+                    tag,
+                    "target",
+                    props.target,
+                    props,
+                    null
+                  )));
+          if (
+            null == value ||
+            "symbol" === typeof value ||
+            "boolean" === typeof value
+          ) {
+            domElement.removeAttribute(key);
+            break;
+          }
+          checkAttributeStringCoercion(value, key);
+          value = sanitizeURL("" + value);
+          domElement.setAttribute(key, value);
+          break;
+        case "onClick":
+          null != value &&
+            ("function" !== typeof value &&
+              warnForInvalidEventListener(key, value),
+            (domElement.onclick = noop$1));
+          return;
+        case "onScroll":
+          null != value &&
+            ("function" !== typeof value &&
+              warnForInvalidEventListener(key, value),
+            listenToNonDelegatedEvent("scroll", domElement));
+          return;
+        case "onScrollEnd":
+          null != value &&
+            ("function" !== typeof value &&
+              warnForInvalidEventListener(key, value),
+            listenToNonDelegatedEvent("scrollend", domElement));
+          return;
+        case "dangerouslySetInnerHTML":
+          if (null != value) {
+            if ("object" !== typeof value || !("__html" in value))
+              throw Error(
+                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
+              );
+            key = value.__html;
+            if (null != key) {
+              if (null != props.children)
+                throw Error(
+                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
+                );
+              domElement.innerHTML = key;
+            }
+          }
+          break;
+        case "multiple":
+          domElement.multiple =
+            value && "function" !== typeof value && "symbol" !== typeof value;
+          break;
+        case "muted":
+          domElement.muted =
+            value && "function" !== typeof value && "symbol" !== typeof value;
+          break;
+        case "suppressContentEditableWarning":
+        case "suppressHydrationWarning":
+        case "defaultValue":
+        case "defaultChecked":
+        case "innerHTML":
+        case "ref":
+          break;
+        case "autoFocus":
+          break;
+        case "xlinkHref":
+          if (
+            null == value ||
+            "function" === typeof value ||
+            "boolean" === typeof value ||
+            "symbol" === typeof value
+          ) {
+            domElement.removeAttribute("xlink:href");
+            break;
+          }
+          checkAttributeStringCoercion(value, key);
+          key = sanitizeURL("" + value);
+          domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
+          break;
+        case "contentEditable":
+        case "spellCheck":
+        case "draggable":
+        case "value":
+        case "autoReverse":
+        case "externalResourcesRequired":
+        case "focusable":
+        case "preserveAlpha":
+          null != value &&
+          "function" !== typeof value &&
+          "symbol" !== typeof value
+            ? (checkAttributeStringCoercion(value, key),
+              domElement.setAttribute(key, "" + value))
+            : domElement.removeAttribute(key);
+          break;
+        case "inert":
+          "" !== value ||
+            didWarnForNewBooleanPropsWithEmptyValue[key] ||
+            ((didWarnForNewBooleanPropsWithEmptyValue[key] = !0),
+            console.error(
+              "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
+              key
+            ));
+        case "allowFullScreen":
+        case "async":
+        case "autoPlay":
+        case "controls":
+        case "default":
+        case "defer":
+        case "disabled":
+        case "disablePictureInPicture":
+        case "disableRemotePlayback":
+        case "formNoValidate":
+        case "hidden":
+        case "loop":
+        case "noModule":
+        case "noValidate":
+        case "open":
+        case "playsInline":
+        case "readOnly":
+        case "required":
+        case "reversed":
+        case "scoped":
+        case "seamless":
+        case "itemScope":
+          value && "function" !== typeof value && "symbol" !== typeof value
+            ? domElement.setAttribute(key, "")
+            : domElement.removeAttribute(key);
+          break;
+        case "capture":
+        case "download":
+          !0 === value
+            ? domElement.setAttribute(key, "")
+            : !1 !== value &&
+                null != value &&
+                "function" !== typeof value &&
+                "symbol" !== typeof value
+              ? (checkAttributeStringCoercion(value, key),
+                domElement.setAttribute(key, value))
+              : domElement.removeAttribute(key);
+          break;
+        case "cols":
+        case "rows":
+        case "size":
+        case "span":
+          null != value &&
+          "function" !== typeof value &&
+          "symbol" !== typeof value &&
+          !isNaN(value) &&
+          1 <= value
+            ? (checkAttributeStringCoercion(value, key),
+              domElement.setAttribute(key, value))
+            : domElement.removeAttribute(key);
+          break;
+        case "rowSpan":
+        case "start":
+          null == value ||
+          "function" === typeof value ||
+          "symbol" === typeof value ||
+          isNaN(value)
+            ? domElement.removeAttribute(key)
+            : (checkAttributeStringCoercion(value, key),
+              domElement.setAttribute(key, value));
+          break;
+        case "popover":
+          listenToNonDelegatedEvent("beforetoggle", domElement);
+          listenToNonDelegatedEvent("toggle", domElement);
+          setValueForAttribute(domElement, "popover", value);
+          break;
+        case "xlinkActuate":
+          setValueForNamespacedAttribute(
+            domElement,
+            xlinkNamespace,
+            "xlink:actuate",
+            value
+          );
+          break;
+        case "xlinkArcrole":
+          setValueForNamespacedAttribute(
+            domElement,
+            xlinkNamespace,
+            "xlink:arcrole",
+            value
+          );
+          break;
+        case "xlinkRole":
+          setValueForNamespacedAttribute(
+            domElement,
+            xlinkNamespace,
+            "xlink:role",
+            value
+          );
+          break;
+        case "xlinkShow":
+          setValueForNamespacedAttribute(
+            domElement,
+            xlinkNamespace,
+            "xlink:show",
+            value
+          );
+          break;
+        case "xlinkTitle":
+          setValueForNamespacedAttribute(
+            domElement,
+            xlinkNamespace,
+            "xlink:title",
+            value
+          );
+          break;
+        case "xlinkType":
+          setValueForNamespacedAttribute(
+            domElement,
+            xlinkNamespace,
+            "xlink:type",
+            value
+          );
+          break;
+        case "xmlBase":
+          setValueForNamespacedAttribute(
+            domElement,
+            xmlNamespace,
+            "xml:base",
+            value
+          );
+          break;
+        case "xmlLang":
+          setValueForNamespacedAttribute(
+            domElement,
+            xmlNamespace,
+            "xml:lang",
+            value
+          );
+          break;
+        case "xmlSpace":
+          setValueForNamespacedAttribute(
+            domElement,
+            xmlNamespace,
+            "xml:space",
+            value
+          );
+          break;
+        case "is":
+          null != prevValue &&
+            console.error(
+              'Cannot update the "is" prop after it has been initialized.'
+            );
+          setValueForAttribute(domElement, "is", value);
+          break;
+        case "innerText":
+        case "textContent":
+          return;
+        case "popoverTarget":
+          didWarnPopoverTargetObject ||
+            null == value ||
+            "object" !== typeof value ||
+            ((didWarnPopoverTargetObject = !0),
+            console.error(
+              "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
+              value
+            ));
+        default:
+          if (
+            !(2 < key.length) ||
+            ("o" !== key[0] && "O" !== key[0]) ||
+            ("n" !== key[1] && "N" !== key[1])
+          )
+            (key = getAttributeAlias(key)),
+              setValueForAttribute(domElement, key, value);
+          else {
+            registrationNameDependencies.hasOwnProperty(key) &&
+              null != value &&
+              "function" !== typeof value &&
+              warnForInvalidEventListener(key, value);
+            return;
+          }
+      }
+      viewTransitionMutationContext = !0;
+    }
+    function setPropOnCustomElement(
+      domElement,
+      tag,
+      key,
+      value,
+      props,
+      prevValue
+    ) {
+      switch (key) {
+        case "style":
+          setValueForStyles(domElement, value, prevValue);
+          return;
+        case "dangerouslySetInnerHTML":
+          if (null != value) {
+            if ("object" !== typeof value || !("__html" in value))
+              throw Error(
+                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
+              );
+            key = value.__html;
+            if (null != key) {
+              if (null != props.children)
+                throw Error(
+                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
+                );
+              domElement.innerHTML = key;
+            }
+          }
+          break;
+        case "children":
+          if ("string" === typeof value) setTextContent(domElement, value);
+          else if ("number" === typeof value || "bigint" === typeof value)
+            setTextContent(domElement, "" + value);
+          else return;
+          break;
+        case "onScroll":
+          null != value &&
+            ("function" !== typeof value &&
+              warnForInvalidEventListener(key, value),
+            listenToNonDelegatedEvent("scroll", domElement));
+          return;
+        case "onScrollEnd":
+          null != value &&
+            ("function" !== typeof value &&
+              warnForInvalidEventListener(key, value),
+            listenToNonDelegatedEvent("scrollend", domElement));
+          return;
+        case "onClick":
+          null != value &&
+            ("function" !== typeof value &&
+              warnForInvalidEventListener(key, value),
+            (domElement.onclick = noop$1));
+          return;
+        case "suppressContentEditableWarning":
+        case "suppressHydrationWarning":
+        case "innerHTML":
+        case "ref":
+          return;
+        case "innerText":
+        case "textContent":
+          return;
+        default:
+          if (registrationNameDependencies.hasOwnProperty(key))
+            null != value &&
+              "function" !== typeof value &&
+              warnForInvalidEventListener(key, value);
+          else
+            a: {
+              if (
+                "o" === key[0] &&
+                "n" === key[1] &&
+                ((props = key.endsWith("Capture")),
+                (tag = key.slice(2, props ? key.length - 7 : void 0)),
+                (prevValue = domElement[internalPropsKey] || null),
+                (prevValue = null != prevValue ? prevValue[key] : null),
+                "function" === typeof prevValue &&
+                  domElement.removeEventListener(tag, prevValue, props),
+                "function" === typeof value)
+              ) {
+                "function" !== typeof prevValue &&
+                  null !== prevValue &&
+                  (key in domElement
+                    ? (domElement[key] = null)
+                    : domElement.hasAttribute(key) &&
+                      domElement.removeAttribute(key));
+                domElement.addEventListener(tag, value, props);
+                break a;
+              }
+              viewTransitionMutationContext = !0;
+              key in domElement
+                ? (domElement[key] = value)
+                : !0 === value
+                  ? domElement.setAttribute(key, "")
+                  : setValueForAttribute(domElement, key, value);
+            }
+          return;
+      }
+      viewTransitionMutationContext = !0;
+    }
+    function setInitialProperties(domElement, tag, props) {
+      validatePropertiesInDevelopment(tag, props);
+      switch (tag) {
+        case "div":
+        case "span":
+        case "svg":
+        case "path":
+        case "a":
+        case "g":
+        case "p":
+        case "li":
+          break;
+        case "img":
+          listenToNonDelegatedEvent("error", domElement);
+          listenToNonDelegatedEvent("load", domElement);
+          var hasSrc = !1,
+            hasSrcSet = !1,
+            propKey;
+          for (propKey in props)
+            if (props.hasOwnProperty(propKey)) {
+              var propValue = props[propKey];
+              if (null != propValue)
+                switch (propKey) {
+                  case "src":
+                    hasSrc = !0;
+                    break;
+                  case "srcSet":
+                    hasSrcSet = !0;
+                    break;
+                  case "children":
+                  case "dangerouslySetInnerHTML":
+                    throw Error(
+                      tag +
+                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                    );
+                  default:
+                    setProp(domElement, tag, propKey, propValue, props, null);
+                }
+            }
+          hasSrcSet &&
+            setProp(domElement, tag, "srcSet", props.srcSet, props, null);
+          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
+          return;
+        case "input":
+          checkControlledValueProps("input", props);
+          listenToNonDelegatedEvent("invalid", domElement);
+          var defaultValue = (propKey = propValue = hasSrcSet = null),
+            checked = null,
+            defaultChecked = null;
+          for (hasSrc in props)
+            if (props.hasOwnProperty(hasSrc)) {
+              var _propValue = props[hasSrc];
+              if (null != _propValue)
+                switch (hasSrc) {
+                  case "name":
+                    hasSrcSet = _propValue;
+                    break;
+                  case "type":
+                    propValue = _propValue;
+                    break;
+                  case "checked":
+                    checked = _propValue;
+                    break;
+                  case "defaultChecked":
+                    defaultChecked = _propValue;
+                    break;
+                  case "value":
+                    propKey = _propValue;
+                    break;
+                  case "defaultValue":
+                    defaultValue = _propValue;
+                    break;
+                  case "children":
+                  case "dangerouslySetInnerHTML":
+                    if (null != _propValue)
+                      throw Error(
+                        tag +
+                          " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                      );
+                    break;
+                  default:
+                    setProp(domElement, tag, hasSrc, _propValue, props, null);
+                }
+            }
+          validateInputProps(domElement, props);
+          initInput(
+            domElement,
+            propKey,
+            defaultValue,
+            checked,
+            defaultChecked,
+            propValue,
+            hasSrcSet,
+            !1
+          );
+          track(domElement);
+          return;
+        case "select":
+          checkControlledValueProps("select", props);
+          listenToNonDelegatedEvent("invalid", domElement);
+          hasSrc = propValue = propKey = null;
+          for (hasSrcSet in props)
+            if (
+              props.hasOwnProperty(hasSrcSet) &&
+              ((defaultValue = props[hasSrcSet]), null != defaultValue)
+            )
+              switch (hasSrcSet) {
+                case "value":
+                  propKey = defaultValue;
+                  break;
+                case "defaultValue":
+                  propValue = defaultValue;
+                  break;
+                case "multiple":
+                  hasSrc = defaultValue;
+                default:
+                  setProp(
+                    domElement,
+                    tag,
+                    hasSrcSet,
+                    defaultValue,
+                    props,
+                    null
+                  );
+              }
+          validateSelectProps(domElement, props);
+          tag = propKey;
+          props = propValue;
+          domElement.multiple = !!hasSrc;
+          null != tag
+            ? updateOptions(domElement, !!hasSrc, tag, !1)
+            : null != props && updateOptions(domElement, !!hasSrc, props, !0);
+          return;
+        case "textarea":
+          checkControlledValueProps("textarea", props);
+          listenToNonDelegatedEvent("invalid", domElement);
+          propKey = hasSrcSet = hasSrc = null;
+          for (propValue in props)
+            if (
+              props.hasOwnProperty(propValue) &&
+              ((defaultValue = props[propValue]), null != defaultValue)
+            )
+              switch (propValue) {
+                case "value":
+                  hasSrc = defaultValue;
+                  break;
+                case "defaultValue":
+                  hasSrcSet = defaultValue;
+                  break;
+                case "children":
+                  propKey = defaultValue;
+                  break;
+                case "dangerouslySetInnerHTML":
+                  if (null != defaultValue)
+                    throw Error(
+                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
+                    );
+                  break;
+                default:
+                  setProp(
+                    domElement,
+                    tag,
+                    propValue,
+                    defaultValue,
+                    props,
+                    null
+                  );
+              }
+          validateTextareaProps(domElement, props);
+          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
+          track(domElement);
+          return;
+        case "option":
+          validateOptionProps(domElement, props);
+          for (checked in props)
+            if (
+              props.hasOwnProperty(checked) &&
+              ((hasSrc = props[checked]), null != hasSrc)
+            )
+              switch (checked) {
+                case "selected":
+                  domElement.selected =
+                    hasSrc &&
+                    "function" !== typeof hasSrc &&
+                    "symbol" !== typeof hasSrc;
+                  break;
+                default:
+                  setProp(domElement, tag, checked, hasSrc, props, null);
+              }
+          return;
+        case "dialog":
+          listenToNonDelegatedEvent("cancel", domElement);
+          listenToNonDelegatedEvent("close", domElement);
+          break;
+        case "iframe":
+        case "object":
+          listenToNonDelegatedEvent("load", domElement);
+          break;
+        case "video":
+        case "audio":
+          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
+            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
+          break;
+        case "image":
+          listenToNonDelegatedEvent("error", domElement);
+          listenToNonDelegatedEvent("load", domElement);
+          break;
+        case "details":
+          listenToNonDelegatedEvent("toggle", domElement);
+          break;
+        case "embed":
+        case "source":
+        case "link":
+          listenToNonDelegatedEvent("error", domElement),
+            listenToNonDelegatedEvent("load", domElement);
+        case "area":
+        case "base":
+        case "br":
+        case "col":
+        case "hr":
+        case "keygen":
+        case "meta":
+        case "param":
+        case "track":
+        case "wbr":
+        case "menuitem":
+          for (defaultChecked in props)
+            if (
+              props.hasOwnProperty(defaultChecked) &&
+              ((hasSrc = props[defaultChecked]), null != hasSrc)
+            )
+              switch (defaultChecked) {
+                case "children":
+                case "dangerouslySetInnerHTML":
+                  throw Error(
+                    tag +
+                      " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                  );
+                default:
+                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
+              }
+          return;
+        default:
+          if (isCustomElement(tag)) {
+            for (_propValue in props)
+              props.hasOwnProperty(_propValue) &&
+                ((hasSrc = props[_propValue]),
+                void 0 !== hasSrc &&
+                  setPropOnCustomElement(
+                    domElement,
+                    tag,
+                    _propValue,
+                    hasSrc,
+                    props,
+                    void 0
+                  ));
+            return;
+          }
+      }
+      for (defaultValue in props)
+        props.hasOwnProperty(defaultValue) &&
+          ((hasSrc = props[defaultValue]),
+          null != hasSrc &&
+            setProp(domElement, tag, defaultValue, hasSrc, props, null));
+    }
+    function updateProperties(domElement, tag, lastProps, nextProps) {
+      validatePropertiesInDevelopment(tag, nextProps);
+      switch (tag) {
+        case "div":
+        case "span":
+        case "svg":
+        case "path":
+        case "a":
+        case "g":
+        case "p":
+        case "li":
+          break;
+        case "input":
+          var name = null,
+            type = null,
+            value = null,
+            defaultValue = null,
+            lastDefaultValue = null,
+            checked = null,
+            defaultChecked = null;
+          for (propKey in lastProps) {
+            var lastProp = lastProps[propKey];
+            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
+              switch (propKey) {
+                case "checked":
+                  break;
+                case "value":
+                  break;
+                case "defaultValue":
+                  lastDefaultValue = lastProp;
+                default:
+                  nextProps.hasOwnProperty(propKey) ||
+                    setProp(
+                      domElement,
+                      tag,
+                      propKey,
+                      null,
+                      nextProps,
+                      lastProp
+                    );
+              }
+          }
+          for (var _propKey8 in nextProps) {
+            var propKey = nextProps[_propKey8];
+            lastProp = lastProps[_propKey8];
+            if (
+              nextProps.hasOwnProperty(_propKey8) &&
+              (null != propKey || null != lastProp)
+            )
+              switch (_propKey8) {
+                case "type":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
+                  type = propKey;
+                  break;
+                case "name":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
+                  name = propKey;
+                  break;
+                case "checked":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
+                  checked = propKey;
+                  break;
+                case "defaultChecked":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
+                  defaultChecked = propKey;
+                  break;
+                case "value":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
+                  value = propKey;
+                  break;
+                case "defaultValue":
+                  propKey !== lastProp && (viewTransitionMutationContext = !0);
+                  defaultValue = propKey;
+                  break;
+                case "children":
+                case "dangerouslySetInnerHTML":
+                  if (null != propKey)
+                    throw Error(
+                      tag +
+                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                    );
+                  break;
+                default:
+                  propKey !== lastProp &&
+                    setProp(
+                      domElement,
+                      tag,
+                      _propKey8,
+                      propKey,
+                      nextProps,
+                      lastProp
+                    );
+              }
+          }
+          tag =
+            "checkbox" === lastProps.type || "radio" === lastProps.type
+              ? null != lastProps.checked
+              : null != lastProps.value;
+          nextProps =
+            "checkbox" === nextProps.type || "radio" === nextProps.type
+              ? null != nextProps.checked
+              : null != nextProps.value;
+          tag ||
+            !nextProps ||
+            didWarnUncontrolledToControlled ||
+            (console.error(
+              "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
+            ),
+            (didWarnUncontrolledToControlled = !0));
+          !tag ||
+            nextProps ||
+            didWarnControlledToUncontrolled ||
+            (console.error(
+              "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
+            ),
+            (didWarnControlledToUncontrolled = !0));
+          updateInput(
+            domElement,
+            value,
+            defaultValue,
+            lastDefaultValue,
+            checked,
+            defaultChecked,
+            type,
+            name
+          );
+          return;
+        case "select":
+          propKey = value = defaultValue = _propKey8 = null;
+          for (type in lastProps)
+            if (
+              ((lastDefaultValue = lastProps[type]),
+              lastProps.hasOwnProperty(type) && null != lastDefaultValue)
+            )
+              switch (type) {
+                case "value":
+                  break;
+                case "multiple":
+                  propKey = lastDefaultValue;
+                default:
+                  nextProps.hasOwnProperty(type) ||
+                    setProp(
+                      domElement,
+                      tag,
+                      type,
+                      null,
+                      nextProps,
+                      lastDefaultValue
+                    );
+              }
+          for (name in nextProps)
+            if (
+              ((type = nextProps[name]),
+              (lastDefaultValue = lastProps[name]),
+              nextProps.hasOwnProperty(name) &&
+                (null != type || null != lastDefaultValue))
+            )
+              switch (name) {
+                case "value":
+                  type !== lastDefaultValue &&
+                    (viewTransitionMutationContext = !0);
+                  _propKey8 = type;
+                  break;
+                case "defaultValue":
+                  type !== lastDefaultValue &&
+                    (viewTransitionMutationContext = !0);
+                  defaultValue = type;
+                  break;
+                case "multiple":
+                  type !== lastDefaultValue &&
+                    (viewTransitionMutationContext = !0),
+                    (value = type);
+                default:
+                  type !== lastDefaultValue &&
+                    setProp(
+                      domElement,
+                      tag,
+                      name,
+                      type,
+                      nextProps,
+                      lastDefaultValue
+                    );
+              }
+          nextProps = defaultValue;
+          tag = value;
+          lastProps = propKey;
+          null != _propKey8
+            ? updateOptions(domElement, !!tag, _propKey8, !1)
+            : !!lastProps !== !!tag &&
+              (null != nextProps
+                ? updateOptions(domElement, !!tag, nextProps, !0)
+                : updateOptions(domElement, !!tag, tag ? [] : "", !1));
+          return;
+        case "textarea":
+          propKey = _propKey8 = null;
+          for (defaultValue in lastProps)
+            if (
+              ((name = lastProps[defaultValue]),
+              lastProps.hasOwnProperty(defaultValue) &&
+                null != name &&
+                !nextProps.hasOwnProperty(defaultValue))
+            )
+              switch (defaultValue) {
+                case "value":
+                  break;
+                case "children":
+                  break;
+                default:
+                  setProp(domElement, tag, defaultValue, null, nextProps, name);
+              }
+          for (value in nextProps)
+            if (
+              ((name = nextProps[value]),
+              (type = lastProps[value]),
+              nextProps.hasOwnProperty(value) && (null != name || null != type))
+            )
+              switch (value) {
+                case "value":
+                  name !== type && (viewTransitionMutationContext = !0);
+                  _propKey8 = name;
+                  break;
+                case "defaultValue":
+                  name !== type && (viewTransitionMutationContext = !0);
+                  propKey = name;
+                  break;
+                case "children":
+                  break;
+                case "dangerouslySetInnerHTML":
+                  if (null != name)
+                    throw Error(
+                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
+                    );
+                  break;
+                default:
+                  name !== type &&
+                    setProp(domElement, tag, value, name, nextProps, type);
+              }
+          updateTextarea(domElement, _propKey8, propKey);
+          return;
+        case "option":
+          for (var _propKey13 in lastProps)
+            if (
+              ((_propKey8 = lastProps[_propKey13]),
+              lastProps.hasOwnProperty(_propKey13) &&
+                null != _propKey8 &&
+                !nextProps.hasOwnProperty(_propKey13))
+            )
+              switch (_propKey13) {
+                case "selected":
+                  domElement.selected = !1;
+                  break;
+                default:
+                  setProp(
+                    domElement,
+                    tag,
+                    _propKey13,
+                    null,
+                    nextProps,
+                    _propKey8
+                  );
+              }
+          for (lastDefaultValue in nextProps)
+            if (
+              ((_propKey8 = nextProps[lastDefaultValue]),
+              (propKey = lastProps[lastDefaultValue]),
+              nextProps.hasOwnProperty(lastDefaultValue) &&
+                _propKey8 !== propKey &&
+                (null != _propKey8 || null != propKey))
+            )
+              switch (lastDefaultValue) {
+                case "selected":
+                  _propKey8 !== propKey && (viewTransitionMutationContext = !0);
+                  domElement.selected =
+                    _propKey8 &&
+                    "function" !== typeof _propKey8 &&
+                    "symbol" !== typeof _propKey8;
+                  break;
+                default:
+                  setProp(
+                    domElement,
+                    tag,
+                    lastDefaultValue,
+                    _propKey8,
+                    nextProps,
+                    propKey
+                  );
+              }
+          return;
+        case "img":
+        case "link":
+        case "area":
+        case "base":
+        case "br":
+        case "col":
+        case "embed":
+        case "hr":
+        case "keygen":
+        case "meta":
+        case "param":
+        case "source":
+        case "track":
+        case "wbr":
+        case "menuitem":
+          for (var _propKey15 in lastProps)
+            (_propKey8 = lastProps[_propKey15]),
+              lastProps.hasOwnProperty(_propKey15) &&
+                null != _propKey8 &&
+                !nextProps.hasOwnProperty(_propKey15) &&
+                setProp(
+                  domElement,
+                  tag,
+                  _propKey15,
+                  null,
+                  nextProps,
+                  _propKey8
+                );
+          for (checked in nextProps)
+            if (
+              ((_propKey8 = nextProps[checked]),
+              (propKey = lastProps[checked]),
+              nextProps.hasOwnProperty(checked) &&
+                _propKey8 !== propKey &&
+                (null != _propKey8 || null != propKey))
+            )
+              switch (checked) {
+                case "children":
+                case "dangerouslySetInnerHTML":
+                  if (null != _propKey8)
+                    throw Error(
+                      tag +
+                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
+                    );
+                  break;
+                default:
+                  setProp(
+                    domElement,
+                    tag,
+                    checked,
+                    _propKey8,
+                    nextProps,
+                    propKey
+                  );
+              }
+          return;
+        default:
+          if (isCustomElement(tag)) {
+            for (var _propKey17 in lastProps)
+              (_propKey8 = lastProps[_propKey17]),
+                lastProps.hasOwnProperty(_propKey17) &&
+                  void 0 !== _propKey8 &&
+                  !nextProps.hasOwnProperty(_propKey17) &&
+                  setPropOnCustomElement(
+                    domElement,
+                    tag,
+                    _propKey17,
+                    void 0,
+                    nextProps,
+                    _propKey8
+                  );
+            for (defaultChecked in nextProps)
+              (_propKey8 = nextProps[defaultChecked]),
+                (propKey = lastProps[defaultChecked]),
+                !nextProps.hasOwnProperty(defaultChecked) ||
+                  _propKey8 === propKey ||
+                  (void 0 === _propKey8 && void 0 === propKey) ||
+                  setPropOnCustomElement(
+                    domElement,
+                    tag,
+                    defaultChecked,
+                    _propKey8,
+                    nextProps,
+                    propKey
+                  );
+            return;
+          }
+      }
+      for (var _propKey19 in lastProps)
+        (_propKey8 = lastProps[_propKey19]),
+          lastProps.hasOwnProperty(_propKey19) &&
+            null != _propKey8 &&
+            !nextProps.hasOwnProperty(_propKey19) &&
+            setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
+      for (lastProp in nextProps)
+        (_propKey8 = nextProps[lastProp]),
+          (propKey = lastProps[lastProp]),
+          !nextProps.hasOwnProperty(lastProp) ||
+            _propKey8 === propKey ||
+            (null == _propKey8 && null == propKey) ||
+            setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
+    }
+    function getPropNameFromAttributeName(attrName) {
+      switch (attrName) {
+        case "class":
+          return "className";
+        case "for":
+          return "htmlFor";
+        default:
+          return attrName;
+      }
+    }
+    function getStylesObjectFromElement(domElement) {
+      var serverValueInObjectForm = {};
+      domElement = domElement.style;
+      for (var i = 0; i < domElement.length; i++) {
+        var styleName = domElement[i];
+        serverValueInObjectForm[styleName] =
+          domElement.getPropertyValue(styleName);
+      }
+      return serverValueInObjectForm;
+    }
+    function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
+      if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
+        console.error(
+          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
+        );
+      else {
+        var clientValue;
+        var delimiter = (clientValue = ""),
+          styleName;
+        for (styleName in value$jscomp$0)
+          if (value$jscomp$0.hasOwnProperty(styleName)) {
+            var value = value$jscomp$0[styleName];
+            null != value &&
+              "boolean" !== typeof value &&
+              "" !== value &&
+              (0 === styleName.indexOf("--")
+                ? (checkCSSPropertyStringCoercion(value, styleName),
+                  (clientValue +=
+                    delimiter + styleName + ":" + ("" + value).trim()))
+                : "number" !== typeof value ||
+                    0 === value ||
+                    unitlessNumbers.has(styleName)
+                  ? (checkCSSPropertyStringCoercion(value, styleName),
+                    (clientValue +=
+                      delimiter +
+                      styleName
+                        .replace(uppercasePattern, "-$1")
+                        .toLowerCase()
+                        .replace(msPattern$1, "-ms-") +
+                      ":" +
+                      ("" + value).trim()))
+                  : (clientValue +=
+                      delimiter +
+                      styleName
+                        .replace(uppercasePattern, "-$1")
+                        .toLowerCase()
+                        .replace(msPattern$1, "-ms-") +
+                      ":" +
+                      value +
+                      "px"),
+              (delimiter = ";"));
+          }
+        clientValue = clientValue || null;
+        value$jscomp$0 = domElement.getAttribute("style");
+        value$jscomp$0 !== clientValue &&
+          ((clientValue = normalizeMarkupForTextOrAttribute(clientValue)),
+          normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue &&
+            (serverDifferences.style = getStylesObjectFromElement(domElement)));
+      }
+    }
+    function hydrateAttribute(
+      domElement,
+      propKey,
+      attributeName,
+      value,
+      extraAttributes,
+      serverDifferences
+    ) {
+      extraAttributes.delete(attributeName);
+      domElement = domElement.getAttribute(attributeName);
+      if (null === domElement)
+        switch (typeof value) {
+          case "undefined":
+          case "function":
+          case "symbol":
+          case "boolean":
+            return;
+        }
+      else if (null != value)
+        switch (typeof value) {
+          case "function":
+          case "symbol":
+          case "boolean":
+            break;
+          default:
+            if (
+              (checkAttributeStringCoercion(value, propKey),
+              domElement === "" + value)
+            )
+              return;
+        }
+      warnForPropDifference(propKey, domElement, value, serverDifferences);
+    }
+    function hydrateBooleanAttribute(
+      domElement,
+      propKey,
+      attributeName,
+      value,
+      extraAttributes,
+      serverDifferences
+    ) {
+      extraAttributes.delete(attributeName);
+      domElement = domElement.getAttribute(attributeName);
+      if (null === domElement) {
+        switch (typeof value) {
+          case "function":
+          case "symbol":
+            return;
+        }
+        if (!value) return;
+      } else
+        switch (typeof value) {
+          case "function":
+          case "symbol":
+            break;
+          default:
+            if (value) return;
+        }
+      warnForPropDifference(propKey, domElement, value, serverDifferences);
+    }
+    function hydrateBooleanishAttribute(
+      domElement,
+      propKey,
+      attributeName,
+      value,
+      extraAttributes,
+      serverDifferences
+    ) {
+      extraAttributes.delete(attributeName);
+      domElement = domElement.getAttribute(attributeName);
+      if (null === domElement)
+        switch (typeof value) {
+          case "undefined":
+          case "function":
+          case "symbol":
+            return;
+        }
+      else if (null != value)
+        switch (typeof value) {
+          case "function":
+          case "symbol":
+            break;
+          default:
+            if (
+              (checkAttributeStringCoercion(value, attributeName),
+              domElement === "" + value)
+            )
+              return;
+        }
+      warnForPropDifference(propKey, domElement, value, serverDifferences);
+    }
+    function hydrateNumericAttribute(
+      domElement,
+      propKey,
+      attributeName,
+      value,
+      extraAttributes,
+      serverDifferences
+    ) {
+      extraAttributes.delete(attributeName);
+      domElement = domElement.getAttribute(attributeName);
+      if (null === domElement)
+        switch (typeof value) {
+          case "undefined":
+          case "function":
+          case "symbol":
+          case "boolean":
+            return;
+          default:
+            if (isNaN(value)) return;
+        }
+      else if (null != value)
+        switch (typeof value) {
+          case "function":
+          case "symbol":
+          case "boolean":
+            break;
+          default:
+            if (
+              !isNaN(value) &&
+              (checkAttributeStringCoercion(value, propKey),
+              domElement === "" + value)
+            )
+              return;
+        }
+      warnForPropDifference(propKey, domElement, value, serverDifferences);
+    }
+    function hydrateSanitizedAttribute(
+      domElement,
+      propKey,
+      attributeName,
+      value,
+      extraAttributes,
+      serverDifferences
+    ) {
+      extraAttributes.delete(attributeName);
+      domElement = domElement.getAttribute(attributeName);
+      if (null === domElement)
+        switch (typeof value) {
+          case "undefined":
+          case "function":
+          case "symbol":
+          case "boolean":
+            return;
+        }
+      else if (null != value)
+        switch (typeof value) {
+          case "function":
+          case "symbol":
+          case "boolean":
+            break;
+          default:
+            if (
+              (checkAttributeStringCoercion(value, propKey),
+              (attributeName = sanitizeURL("" + value)),
+              domElement === attributeName)
+            )
+              return;
+        }
+      warnForPropDifference(propKey, domElement, value, serverDifferences);
+    }
+    function diffHydratedProperties(domElement, tag, props, hostContext) {
+      for (
+        var serverDifferences = {},
+          extraAttributes = new Set(),
+          attributes = domElement.attributes,
+          i = 0;
+        i < attributes.length;
+        i++
+      )
+        switch (attributes[i].name.toLowerCase()) {
+          case "value":
+            break;
+          case "checked":
+            break;
+          case "selected":
+            break;
+          default:
+            extraAttributes.add(attributes[i].name);
+        }
+      if (isCustomElement(tag))
+        for (var propKey in props) {
+          if (props.hasOwnProperty(propKey)) {
+            var value = props[propKey];
+            if (null != value)
+              if (registrationNameDependencies.hasOwnProperty(propKey))
+                "function" !== typeof value &&
+                  warnForInvalidEventListener(propKey, value);
+              else if (!0 !== props.suppressHydrationWarning)
+                switch (propKey) {
+                  case "children":
+                    ("string" !== typeof value && "number" !== typeof value) ||
+                      warnForPropDifference(
+                        "children",
+                        domElement.textContent,
+                        value,
+                        serverDifferences
+                      );
+                    continue;
+                  case "suppressContentEditableWarning":
+                  case "suppressHydrationWarning":
+                  case "defaultValue":
+                  case "defaultChecked":
+                  case "innerHTML":
+                  case "ref":
+                    continue;
+                  case "dangerouslySetInnerHTML":
+                    attributes = domElement.innerHTML;
+                    value = value ? value.__html : void 0;
+                    null != value &&
+                      ((value = normalizeHTML(domElement, value)),
+                      warnForPropDifference(
+                        propKey,
+                        attributes,
+                        value,
+                        serverDifferences
+                      ));
+                    continue;
+                  case "style":
+                    extraAttributes.delete(propKey);
+                    diffHydratedStyles(domElement, value, serverDifferences);
+                    continue;
+                  case "offsetParent":
+                  case "offsetTop":
+                  case "offsetLeft":
+                  case "offsetWidth":
+                  case "offsetHeight":
+                  case "isContentEditable":
+                  case "outerText":
+                  case "outerHTML":
+                    extraAttributes.delete(propKey.toLowerCase());
+                    console.error(
+                      "Assignment to read-only property will result in a no-op: `%s`",
+                      propKey
+                    );
+                    continue;
+                  case "className":
+                    extraAttributes.delete("class");
+                    attributes = getValueForAttributeOnCustomComponent(
+                      domElement,
+                      "class",
+                      value
+                    );
+                    warnForPropDifference(
+                      "className",
+                      attributes,
+                      value,
+                      serverDifferences
+                    );
+                    continue;
+                  default:
+                    hostContext.context === HostContextNamespaceNone &&
+                    "svg" !== tag &&
+                    "math" !== tag
+                      ? extraAttributes.delete(propKey.toLowerCase())
+                      : extraAttributes.delete(propKey),
+                      (attributes = getValueForAttributeOnCustomComponent(
+                        domElement,
+                        propKey,
+                        value
+                      )),
+                      warnForPropDifference(
+                        propKey,
+                        attributes,
+                        value,
+                        serverDifferences
+                      );
+                }
+          }
+        }
+      else
+        for (value in props)
+          if (
+            props.hasOwnProperty(value) &&
+            ((propKey = props[value]), null != propKey)
+          )
+            if (registrationNameDependencies.hasOwnProperty(value))
+              "function" !== typeof propKey &&
+                warnForInvalidEventListener(value, propKey);
+            else if (!0 !== props.suppressHydrationWarning)
+              switch (value) {
+                case "children":
+                  ("string" !== typeof propKey &&
+                    "number" !== typeof propKey) ||
+                    warnForPropDifference(
+                      "children",
+                      domElement.textContent,
+                      propKey,
+                      serverDifferences
+                    );
+                  continue;
+                case "suppressContentEditableWarning":
+                case "suppressHydrationWarning":
+                case "value":
+                case "checked":
+                case "selected":
+                case "defaultValue":
+                case "defaultChecked":
+                case "innerHTML":
+                case "ref":
+                  continue;
+                case "dangerouslySetInnerHTML":
+                  attributes = domElement.innerHTML;
+                  propKey = propKey ? propKey.__html : void 0;
+                  null != propKey &&
+                    ((propKey = normalizeHTML(domElement, propKey)),
+                    attributes !== propKey &&
+                      (serverDifferences[value] = { __html: attributes }));
+                  continue;
+                case "className":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "class",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "tabIndex":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "tabindex",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "style":
+                  extraAttributes.delete(value);
+                  diffHydratedStyles(domElement, propKey, serverDifferences);
+                  continue;
+                case "multiple":
+                  extraAttributes.delete(value);
+                  warnForPropDifference(
+                    value,
+                    domElement.multiple,
+                    propKey,
+                    serverDifferences
+                  );
+                  continue;
+                case "muted":
+                  extraAttributes.delete(value);
+                  warnForPropDifference(
+                    value,
+                    domElement.muted,
+                    propKey,
+                    serverDifferences
+                  );
+                  continue;
+                case "autoFocus":
+                  extraAttributes.delete("autofocus");
+                  warnForPropDifference(
+                    value,
+                    domElement.autofocus,
+                    propKey,
+                    serverDifferences
+                  );
+                  continue;
+                case "data":
+                  if ("object" !== tag) {
+                    extraAttributes.delete(value);
+                    attributes = domElement.getAttribute("data");
+                    warnForPropDifference(
+                      value,
+                      attributes,
+                      propKey,
+                      serverDifferences
+                    );
+                    continue;
+                  }
+                case "src":
+                case "href":
+                  if (
+                    !(
+                      "" !== propKey ||
+                      ("a" === tag && "href" === value) ||
+                      ("object" === tag && "data" === value)
+                    )
+                  ) {
+                    "src" === value
+                      ? console.error(
+                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
+                          value,
+                          value
+                        )
+                      : console.error(
+                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
+                          value,
+                          value
+                        );
+                    continue;
+                  }
+                  hydrateSanitizedAttribute(
+                    domElement,
+                    value,
+                    value,
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "action":
+                case "formAction":
+                  attributes = domElement.getAttribute(value);
+                  if ("function" === typeof propKey) {
+                    extraAttributes.delete(value.toLowerCase());
+                    "formAction" === value
+                      ? (extraAttributes.delete("name"),
+                        extraAttributes.delete("formenctype"),
+                        extraAttributes.delete("formmethod"),
+                        extraAttributes.delete("formtarget"))
+                      : (extraAttributes.delete("enctype"),
+                        extraAttributes.delete("method"),
+                        extraAttributes.delete("target"));
+                    continue;
+                  } else if (attributes === EXPECTED_FORM_ACTION_URL) {
+                    extraAttributes.delete(value.toLowerCase());
+                    warnForPropDifference(
+                      value,
+                      "function",
+                      propKey,
+                      serverDifferences
+                    );
+                    continue;
+                  }
+                  hydrateSanitizedAttribute(
+                    domElement,
+                    value,
+                    value.toLowerCase(),
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "xlinkHref":
+                  hydrateSanitizedAttribute(
+                    domElement,
+                    value,
+                    "xlink:href",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "contentEditable":
+                  hydrateBooleanishAttribute(
+                    domElement,
+                    value,
+                    "contenteditable",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "spellCheck":
+                  hydrateBooleanishAttribute(
+                    domElement,
+                    value,
+                    "spellcheck",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "draggable":
+                case "autoReverse":
+                case "externalResourcesRequired":
+                case "focusable":
+                case "preserveAlpha":
+                  hydrateBooleanishAttribute(
+                    domElement,
+                    value,
+                    value,
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "allowFullScreen":
+                case "async":
+                case "autoPlay":
+                case "controls":
+                case "default":
+                case "defer":
+                case "disabled":
+                case "disablePictureInPicture":
+                case "disableRemotePlayback":
+                case "formNoValidate":
+                case "hidden":
+                case "loop":
+                case "noModule":
+                case "noValidate":
+                case "open":
+                case "playsInline":
+                case "readOnly":
+                case "required":
+                case "reversed":
+                case "scoped":
+                case "seamless":
+                case "itemScope":
+                  hydrateBooleanAttribute(
+                    domElement,
+                    value,
+                    value.toLowerCase(),
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "capture":
+                case "download":
+                  a: {
+                    i = domElement;
+                    var attributeName = (attributes = value),
+                      serverDifferences$jscomp$0 = serverDifferences;
+                    extraAttributes.delete(attributeName);
+                    i = i.getAttribute(attributeName);
+                    if (null === i)
+                      switch (typeof propKey) {
+                        case "undefined":
+                        case "function":
+                        case "symbol":
+                          break a;
+                        default:
+                          if (!1 === propKey) break a;
+                      }
+                    else if (null != propKey)
+                      switch (typeof propKey) {
+                        case "function":
+                        case "symbol":
+                          break;
+                        case "boolean":
+                          if (!0 === propKey && "" === i) break a;
+                          break;
+                        default:
+                          if (
+                            (checkAttributeStringCoercion(propKey, attributes),
+                            i === "" + propKey)
+                          )
+                            break a;
+                      }
+                    warnForPropDifference(
+                      attributes,
+                      i,
+                      propKey,
+                      serverDifferences$jscomp$0
+                    );
+                  }
+                  continue;
+                case "cols":
+                case "rows":
+                case "size":
+                case "span":
+                  a: {
+                    i = domElement;
+                    attributeName = attributes = value;
+                    serverDifferences$jscomp$0 = serverDifferences;
+                    extraAttributes.delete(attributeName);
+                    i = i.getAttribute(attributeName);
+                    if (null === i)
+                      switch (typeof propKey) {
+                        case "undefined":
+                        case "function":
+                        case "symbol":
+                        case "boolean":
+                          break a;
+                        default:
+                          if (isNaN(propKey) || 1 > propKey) break a;
+                      }
+                    else if (null != propKey)
+                      switch (typeof propKey) {
+                        case "function":
+                        case "symbol":
+                        case "boolean":
+                          break;
+                        default:
+                          if (
+                            !(isNaN(propKey) || 1 > propKey) &&
+                            (checkAttributeStringCoercion(propKey, attributes),
+                            i === "" + propKey)
+                          )
+                            break a;
+                      }
+                    warnForPropDifference(
+                      attributes,
+                      i,
+                      propKey,
+                      serverDifferences$jscomp$0
+                    );
+                  }
+                  continue;
+                case "rowSpan":
+                  hydrateNumericAttribute(
+                    domElement,
+                    value,
+                    "rowspan",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "start":
+                  hydrateNumericAttribute(
+                    domElement,
+                    value,
+                    value,
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "xHeight":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "x-height",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "xlinkActuate":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "xlink:actuate",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "xlinkArcrole":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "xlink:arcrole",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "xlinkRole":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "xlink:role",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "xlinkShow":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "xlink:show",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "xlinkTitle":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "xlink:title",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "xlinkType":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "xlink:type",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "xmlBase":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "xml:base",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "xmlLang":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "xml:lang",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "xmlSpace":
+                  hydrateAttribute(
+                    domElement,
+                    value,
+                    "xml:space",
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                case "inert":
+                  "" !== propKey ||
+                    didWarnForNewBooleanPropsWithEmptyValue[value] ||
+                    ((didWarnForNewBooleanPropsWithEmptyValue[value] = !0),
+                    console.error(
+                      "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
+                      value
+                    ));
+                  hydrateBooleanAttribute(
+                    domElement,
+                    value,
+                    value,
+                    propKey,
+                    extraAttributes,
+                    serverDifferences
+                  );
+                  continue;
+                default:
+                  if (
+                    !(2 < value.length) ||
+                    ("o" !== value[0] && "O" !== value[0]) ||
+                    ("n" !== value[1] && "N" !== value[1])
+                  ) {
+                    i = getAttributeAlias(value);
+                    attributes = !1;
+                    hostContext.context === HostContextNamespaceNone &&
+                    "svg" !== tag &&
+                    "math" !== tag
+                      ? extraAttributes.delete(i.toLowerCase())
+                      : ((attributeName = value.toLowerCase()),
+                        (attributeName = possibleStandardNames.hasOwnProperty(
+                          attributeName
+                        )
+                          ? possibleStandardNames[attributeName] || null
+                          : null),
+                        null !== attributeName &&
+                          attributeName !== value &&
+                          ((attributes = !0),
+                          extraAttributes.delete(attributeName)),
+                        extraAttributes.delete(i));
+                    a: if (
+                      ((attributeName = domElement),
+                      (serverDifferences$jscomp$0 = i),
+                      (i = propKey),
+                      isAttributeNameSafe(serverDifferences$jscomp$0))
+                    )
+                      if (
+                        attributeName.hasAttribute(serverDifferences$jscomp$0)
+                      )
+                        (attributeName = attributeName.getAttribute(
+                          serverDifferences$jscomp$0
+                        )),
+                          checkAttributeStringCoercion(
+                            i,
+                            serverDifferences$jscomp$0
+                          ),
+                          (i = attributeName === "" + i ? i : attributeName);
+                      else {
+                        switch (typeof i) {
+                          case "function":
+                          case "symbol":
+                            break a;
+                          case "boolean":
+                            if (
+                              ((attributeName = serverDifferences$jscomp$0
+                                .toLowerCase()
+                                .slice(0, 5)),
+                              "data-" !== attributeName &&
+                                "aria-" !== attributeName)
+                            )
+                              break a;
+                        }
+                        i = void 0 === i ? void 0 : null;
+                      }
+                    else i = void 0;
+                    attributes ||
+                      warnForPropDifference(
+                        value,
+                        i,
+                        propKey,
+                        serverDifferences
+                      );
+                  }
+              }
+      0 < extraAttributes.size &&
+        !0 !== props.suppressHydrationWarning &&
+        warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
+      return 0 === Object.keys(serverDifferences).length
+        ? null
+        : serverDifferences;
+    }
+    function propNamesListJoin(list, combinator) {
+      switch (list.length) {
+        case 0:
+          return "";
+        case 1:
+          return list[0];
+        case 2:
+          return list[0] + " " + combinator + " " + list[1];
+        default:
+          return (
+            list.slice(0, -1).join(", ") +
+            ", " +
+            combinator +
+            " " +
+            list[list.length - 1]
+          );
+      }
+    }
+    function getOwnerDocumentFromRootContainer(rootContainerElement) {
+      return 9 === rootContainerElement.nodeType
+        ? rootContainerElement
+        : rootContainerElement.ownerDocument;
+    }
+    function getOwnHostContext(namespaceURI) {
+      switch (namespaceURI) {
+        case SVG_NAMESPACE:
+          return HostContextNamespaceSvg;
+        case MATH_NAMESPACE:
+          return HostContextNamespaceMath;
+        default:
+          return HostContextNamespaceNone;
+      }
+    }
+    function getChildHostContextProd(parentNamespace, type) {
+      if (parentNamespace === HostContextNamespaceNone)
+        switch (type) {
+          case "svg":
+            return HostContextNamespaceSvg;
+          case "math":
+            return HostContextNamespaceMath;
+          default:
+            return HostContextNamespaceNone;
+        }
+      return parentNamespace === HostContextNamespaceSvg &&
+        "foreignObject" === type
+        ? HostContextNamespaceNone
+        : parentNamespace;
+    }
+    function shouldSetTextContent(type, props) {
+      return (
+        "textarea" === type ||
+        "noscript" === type ||
+        "string" === typeof props.children ||
+        "number" === typeof props.children ||
+        "bigint" === typeof props.children ||
+        ("object" === typeof props.dangerouslySetInnerHTML &&
+          null !== props.dangerouslySetInnerHTML &&
+          null != props.dangerouslySetInnerHTML.__html)
+      );
+    }
+    function shouldAttemptEagerTransition() {
+      var event = window.event;
+      if (event && "popstate" === event.type) {
+        if (event === currentPopstateTransitionEvent) return !1;
+        currentPopstateTransitionEvent = event;
+        return !0;
+      }
+      currentPopstateTransitionEvent = null;
+      return !1;
+    }
+    function resolveEventType() {
+      var event = window.event;
+      return event && event !== schedulerEvent ? event.type : null;
+    }
+    function resolveEventTimeStamp() {
+      var event = window.event;
+      return event && event !== schedulerEvent ? event.timeStamp : -1.1;
+    }
+    function handleErrorInNextTick(error) {
+      setTimeout(function () {
+        throw error;
+      });
+    }
+    function commitMount(domElement, type, newProps) {
+      switch (type) {
+        case "button":
+        case "input":
+        case "select":
+        case "textarea":
+          newProps.autoFocus && domElement.focus();
+          break;
+        case "img":
+          newProps.src
+            ? (domElement.src = newProps.src)
+            : newProps.srcSet && (domElement.srcset = newProps.srcSet);
+      }
+    }
+    function commitUpdate(domElement, type, oldProps, newProps) {
+      updateProperties(domElement, type, oldProps, newProps);
+      domElement[internalPropsKey] = newProps;
+    }
+    function resetTextContent(domElement) {
+      setTextContent(domElement, "");
+    }
+    function commitTextUpdate(textInstance, oldText, newText) {
+      textInstance.nodeValue = newText;
+    }
+    function removeChild(parentInstance, child) {
+      parentInstance.removeChild(child);
+    }
+    function removeChildFromContainer(container, child) {
+      8 === container.nodeType
+        ? container.parentNode.removeChild(child)
+        : container.removeChild(child);
+    }
+    function clearSuspenseBoundary(parentInstance, suspenseInstance) {
+      var node = suspenseInstance,
+        depth = 0;
+      do {
+        var nextNode = node.nextSibling;
+        parentInstance.removeChild(node);
+        if (nextNode && 8 === nextNode.nodeType)
+          if (((node = nextNode.data), node === SUSPENSE_END_DATA)) {
+            if (0 === depth) {
+              parentInstance.removeChild(nextNode);
+              retryIfBlockedOn(suspenseInstance);
+              return;
+            }
+            depth--;
+          } else
+            (node !== SUSPENSE_START_DATA &&
+              node !== SUSPENSE_PENDING_START_DATA &&
+              node !== SUSPENSE_FALLBACK_START_DATA) ||
+              depth++;
+        node = nextNode;
+      } while (node);
+      retryIfBlockedOn(suspenseInstance);
+    }
+    function hideInstance(instance) {
+      instance = instance.style;
+      "function" === typeof instance.setProperty
+        ? instance.setProperty("display", "none", "important")
+        : (instance.display = "none");
+    }
+    function hideTextInstance(textInstance) {
+      textInstance.nodeValue = "";
+    }
+    function unhideInstance(instance, props) {
+      props = props[STYLE];
+      props =
+        void 0 !== props && null !== props && props.hasOwnProperty("display")
+          ? props.display
+          : null;
+      instance.style.display =
+        null == props || "boolean" === typeof props ? "" : ("" + props).trim();
+    }
+    function unhideTextInstance(textInstance, text) {
+      textInstance.nodeValue = text;
+    }
+    function restoreViewTransitionName(instance, props) {
+      props = props[STYLE];
+      var viewTransitionName =
+        null != props
+          ? props.hasOwnProperty("viewTransitionName")
+            ? props.viewTransitionName
+            : props.hasOwnProperty("view-transition-name")
+              ? props["view-transition-name"]
+              : null
+          : null;
+      instance.style.viewTransitionName =
+        null == viewTransitionName || "boolean" === typeof viewTransitionName
+          ? ""
+          : ("" + viewTransitionName).trim();
+      props =
+        null != props
+          ? props.hasOwnProperty("viewTransitionClass")
+            ? props.viewTransitionClass
+            : props.hasOwnProperty("view-transition-class")
+              ? props["view-transition-class"]
+              : null
+          : null;
+      instance.style.viewTransitionClass =
+        null == props || "boolean" === typeof props ? "" : ("" + props).trim();
+    }
+    function measureInstance(instance) {
+      var ownerWindow = instance.ownerDocument.defaultView,
+        rect = instance.getBoundingClientRect();
+      instance = getComputedStyle(instance);
+      return {
+        rect: rect,
+        abs: "absolute" === instance.position || "fixed" === instance.position,
+        clip:
+          "none" !== instance.clipPath ||
+          "visible" !== instance.overflow ||
+          "none" !== instance.filter ||
+          "none" !== instance.mask ||
+          "none" !== instance.mask ||
+          "0px" !== instance.borderRadius,
+        view:
+          0 <= rect.bottom &&
+          0 <= rect.right &&
+          rect.top <= ownerWindow.innerHeight &&
+          rect.left <= ownerWindow.innerWidth
+      };
+    }
+    function startViewTransition(
+      rootContainer,
+      mutationCallback,
+      layoutCallback,
+      afterMutationCallback,
+      spawnedWorkCallback,
+      passiveCallback
+    ) {
+      var ownerDocument =
+        9 === rootContainer.nodeType
+          ? rootContainer
+          : rootContainer.ownerDocument;
+      try {
+        var transition = ownerDocument.startViewTransition({
+          update: function () {
+            var ownerWindow = ownerDocument.defaultView;
+            ownerWindow =
+              ownerWindow.navigation && ownerWindow.navigation.transition;
+            var previousFontLoadingStatus = ownerDocument.fonts.status;
+            mutationCallback();
+            if (
+              "loaded" === previousFontLoadingStatus &&
+              (ownerDocument.documentElement.clientHeight,
+              "loading" === ownerDocument.fonts.status)
+            )
+              return (
+                (previousFontLoadingStatus = Promise.race([
+                  ownerDocument.fonts.ready,
+                  new Promise(function (resolve) {
+                    return setTimeout(resolve, SUSPENSEY_FONT_TIMEOUT);
+                  })
+                ]).then(layoutCallback, layoutCallback)),
+                (ownerWindow
+                  ? Promise.allSettled([
+                      ownerWindow.finished,
+                      previousFontLoadingStatus
+                    ])
+                  : previousFontLoadingStatus
+                ).then(afterMutationCallback, afterMutationCallback)
+              );
+            layoutCallback();
+            if (ownerWindow)
+              return ownerWindow.finished.then(
+                afterMutationCallback,
+                afterMutationCallback
+              );
+            afterMutationCallback();
+          },
+          types: null
+        });
+        ownerDocument.__reactViewTransition = transition;
+        transition.ready.then(void 0, function (reason) {
+          "object" === typeof reason &&
+            null !== reason &&
+            "TimeoutError" === reason.name &&
+            console.error(
+              "A ViewTransition timed out because a Navigation stalled. This can happen if a Navigation is blocked on React itself. Such as if it's resolved inside useEffect. This can be solved by moving the resolution to useLayoutEffect."
+            );
+        });
+        transition.ready.then(spawnedWorkCallback, spawnedWorkCallback);
+        transition.finished.then(function () {
+          ownerDocument.__reactViewTransition = null;
+          passiveCallback();
+        });
+        return !0;
+      } catch (x) {
+        return !1;
+      }
+    }
+    function ViewTransitionPseudoElement(pseudo, name) {
+      this._scope = document.documentElement;
+      this._selector = "::view-transition-" + pseudo + "(" + name + ")";
+    }
+    function createViewTransitionInstance(name) {
+      return {
+        name: name,
+        group: new ViewTransitionPseudoElement("group", name),
+        imagePair: new ViewTransitionPseudoElement("image-pair", name),
+        old: new ViewTransitionPseudoElement("old", name),
+        new: new ViewTransitionPseudoElement("new", name)
+      };
+    }
+    function clearContainerSparingly(container) {
+      var nextNode = container.firstChild;
+      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
+      for (; nextNode; ) {
+        var node = nextNode;
+        nextNode = nextNode.nextSibling;
+        switch (node.nodeName) {
+          case "HTML":
+          case "HEAD":
+          case "BODY":
+            clearContainerSparingly(node);
+            detachDeletedInstance(node);
+            continue;
+          case "SCRIPT":
+          case "STYLE":
+            continue;
+          case "LINK":
+            if ("stylesheet" === node.rel.toLowerCase()) continue;
+        }
+        container.removeChild(node);
+      }
+    }
+    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
+      for (; 1 === instance.nodeType; ) {
+        var anyProps = props;
+        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
+          if (
+            !inRootOrSingleton &&
+            ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
+          )
+            break;
+        } else if (!inRootOrSingleton)
+          if ("input" === type && "hidden" === instance.type) {
+            checkAttributeStringCoercion(anyProps.name, "name");
+            var name = null == anyProps.name ? null : "" + anyProps.name;
+            if (
+              "hidden" === anyProps.type &&
+              instance.getAttribute("name") === name
+            )
+              return instance;
+          } else return instance;
+        else if (!instance[internalHoistableMarker])
+          switch (type) {
+            case "meta":
+              if (!instance.hasAttribute("itemprop")) break;
+              return instance;
+            case "link":
+              name = instance.getAttribute("rel");
+              if (
+                "stylesheet" === name &&
+                instance.hasAttribute("data-precedence")
+              )
+                break;
+              else if (
+                name !== anyProps.rel ||
+                instance.getAttribute("href") !==
+                  (null == anyProps.href || "" === anyProps.href
+                    ? null
+                    : anyProps.href) ||
+                instance.getAttribute("crossorigin") !==
+                  (null == anyProps.crossOrigin
+                    ? null
+                    : anyProps.crossOrigin) ||
+                instance.getAttribute("title") !==
+                  (null == anyProps.title ? null : anyProps.title)
+              )
+                break;
+              return instance;
+            case "style":
+              if (instance.hasAttribute("data-precedence")) break;
+              return instance;
+            case "script":
+              name = instance.getAttribute("src");
+              if (
+                (name !== (null == anyProps.src ? null : anyProps.src) ||
+                  instance.getAttribute("type") !==
+                    (null == anyProps.type ? null : anyProps.type) ||
+                  instance.getAttribute("crossorigin") !==
+                    (null == anyProps.crossOrigin
+                      ? null
+                      : anyProps.crossOrigin)) &&
+                name &&
+                instance.hasAttribute("async") &&
+                !instance.hasAttribute("itemprop")
+              )
+                break;
+              return instance;
+            default:
+              return instance;
+          }
+        instance = getNextHydratable(instance.nextSibling);
+        if (null === instance) break;
+      }
+      return null;
+    }
+    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
+      if ("" === text) return null;
+      for (; 3 !== instance.nodeType; ) {
+        if (
+          (1 !== instance.nodeType ||
+            "INPUT" !== instance.nodeName ||
+            "hidden" !== instance.type) &&
+          !inRootOrSingleton
+        )
+          return null;
+        instance = getNextHydratable(instance.nextSibling);
+        if (null === instance) return null;
+      }
+      return instance;
+    }
+    function isSuspenseInstanceFallback(instance) {
+      return (
+        instance.data === SUSPENSE_FALLBACK_START_DATA ||
+        (instance.data === SUSPENSE_PENDING_START_DATA &&
+          instance.ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE)
+      );
+    }
+    function registerSuspenseInstanceRetry(instance, callback) {
+      var ownerDocument = instance.ownerDocument;
+      if (
+        instance.data !== SUSPENSE_PENDING_START_DATA ||
+        ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE
+      )
+        callback();
+      else {
+        var listener = function () {
+          callback();
+          ownerDocument.removeEventListener("DOMContentLoaded", listener);
+        };
+        ownerDocument.addEventListener("DOMContentLoaded", listener);
+        instance._reactRetry = listener;
+      }
+    }
+    function getNextHydratable(node) {
+      for (; null != node; node = node.nextSibling) {
+        var nodeType = node.nodeType;
+        if (1 === nodeType || 3 === nodeType) break;
+        if (8 === nodeType) {
+          nodeType = node.data;
+          if (
+            nodeType === SUSPENSE_START_DATA ||
+            nodeType === SUSPENSE_FALLBACK_START_DATA ||
+            nodeType === SUSPENSE_PENDING_START_DATA ||
+            nodeType === FORM_STATE_IS_MATCHING ||
+            nodeType === FORM_STATE_IS_NOT_MATCHING
+          )
+            break;
+          if (nodeType === SUSPENSE_END_DATA) return null;
+        }
+      }
+      return node;
+    }
+    function describeHydratableInstanceForDevWarnings(instance) {
+      if (1 === instance.nodeType) {
+        for (
+          var JSCompiler_temp_const = instance.nodeName.toLowerCase(),
+            serverDifferences = {},
+            attributes = instance.attributes,
+            i = 0;
+          i < attributes.length;
+          i++
+        ) {
+          var attr = attributes[i];
+          serverDifferences[getPropNameFromAttributeName(attr.name)] =
+            "style" === attr.name.toLowerCase()
+              ? getStylesObjectFromElement(instance)
+              : attr.value;
+        }
+        return { type: JSCompiler_temp_const, props: serverDifferences };
+      }
+      return 8 === instance.nodeType
+        ? { type: "Suspense", props: {} }
+        : instance.nodeValue;
+    }
+    function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
+      return null === parentProps ||
+        !0 !== parentProps[SUPPRESS_HYDRATION_WARNING]
+        ? (textInstance.nodeValue === text
+            ? (textInstance = null)
+            : ((text = normalizeMarkupForTextOrAttribute(text)),
+              (textInstance =
+                normalizeMarkupForTextOrAttribute(textInstance.nodeValue) ===
+                text
+                  ? null
+                  : textInstance.nodeValue)),
+          textInstance)
+        : null;
+    }
+    function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
+      suspenseInstance = suspenseInstance.nextSibling;
+      for (var depth = 0; suspenseInstance; ) {
+        if (8 === suspenseInstance.nodeType) {
+          var data = suspenseInstance.data;
+          if (data === SUSPENSE_END_DATA) {
+            if (0 === depth)
+              return getNextHydratable(suspenseInstance.nextSibling);
+            depth--;
+          } else
+            (data !== SUSPENSE_START_DATA &&
+              data !== SUSPENSE_FALLBACK_START_DATA &&
+              data !== SUSPENSE_PENDING_START_DATA) ||
+              depth++;
+        }
+        suspenseInstance = suspenseInstance.nextSibling;
+      }
+      return null;
+    }
+    function getParentSuspenseInstance(targetInstance) {
+      targetInstance = targetInstance.previousSibling;
+      for (var depth = 0; targetInstance; ) {
+        if (8 === targetInstance.nodeType) {
+          var data = targetInstance.data;
+          if (
+            data === SUSPENSE_START_DATA ||
+            data === SUSPENSE_FALLBACK_START_DATA ||
+            data === SUSPENSE_PENDING_START_DATA
+          ) {
+            if (0 === depth) return targetInstance;
+            depth--;
+          } else data === SUSPENSE_END_DATA && depth++;
+        }
+        targetInstance = targetInstance.previousSibling;
+      }
+      return null;
+    }
+    function commitHydratedContainer(container) {
+      retryIfBlockedOn(container);
+    }
+    function commitHydratedSuspenseInstance(suspenseInstance) {
+      retryIfBlockedOn(suspenseInstance);
+    }
+    function getBoundingRect(node) {
+      node = node.getBoundingClientRect();
+      return {
+        x: node.left,
+        y: node.top,
+        width: node.width,
+        height: node.height
+      };
+    }
+    function isHiddenSubtree(fiber) {
+      return 5 === fiber.tag && !0 === fiber.memoizedProps.hidden;
+    }
+    function setFocusIfFocusable(node) {
+      function handleFocus() {
+        didFocus = !0;
+      }
+      var didFocus = !1;
+      try {
+        node.addEventListener("focus", handleFocus),
+          (node.focus || HTMLElement.prototype.focus).call(node);
+      } finally {
+        node.removeEventListener("focus", handleFocus);
+      }
+      return didFocus;
+    }
+    function setupIntersectionObserver(targets, callback, options) {
+      var rectRatioCache = new Map();
+      targets.forEach(function (target) {
+        rectRatioCache.set(target, { rect: getBoundingRect(target), ratio: 0 });
+      });
+      var observer = new IntersectionObserver(function (entries) {
+        entries.forEach(function (entry) {
+          var boundingClientRect = entry.boundingClientRect;
+          rectRatioCache.set(entry.target, {
+            rect: {
+              x: boundingClientRect.left,
+              y: boundingClientRect.top,
+              width: boundingClientRect.width,
+              height: boundingClientRect.height
+            },
+            ratio: entry.intersectionRatio
+          });
+        });
+        callback(Array.from(rectRatioCache.values()));
+      }, options);
+      targets.forEach(function (target) {
+        observer.observe(target);
+      });
+      return {
+        disconnect: function () {
+          return observer.disconnect();
+        },
+        observe: function (target) {
+          rectRatioCache.set(target, {
+            rect: getBoundingRect(target),
+            ratio: 0
+          });
+          observer.observe(target);
+        },
+        unobserve: function (target) {
+          rectRatioCache.delete(target);
+          observer.unobserve(target);
+        }
+      };
+    }
+    function resolveSingletonInstance(
+      type,
+      props,
+      rootContainerInstance,
+      hostContext,
+      validateDOMNestingDev
+    ) {
+      validateDOMNestingDev &&
+        validateDOMNesting(type, hostContext.ancestorInfo);
+      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
+      switch (type) {
+        case "html":
+          type = props.documentElement;
+          if (!type)
+            throw Error(
+              "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
+            );
+          return type;
+        case "head":
+          type = props.head;
+          if (!type)
+            throw Error(
+              "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
+            );
+          return type;
+        case "body":
+          type = props.body;
+          if (!type)
+            throw Error(
+              "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
+            );
+          return type;
+        default:
+          throw Error(
+            "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
+          );
+      }
+    }
+    function acquireSingletonInstance(
+      type,
+      props,
+      instance,
+      internalInstanceHandle
+    ) {
+      if (getInstanceFromNode(instance)) {
+        var tagName = instance.tagName.toLowerCase();
+        console.error(
+          "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
+          tagName,
+          tagName,
+          tagName
+        );
+      }
+      switch (type) {
+        case "html":
+        case "head":
+        case "body":
+          break;
+        default:
+          console.error(
+            "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
+          );
+      }
+      for (tagName = instance.attributes; tagName.length; )
+        instance.removeAttributeNode(tagName[0]);
+      setInitialProperties(instance, type, props);
+      instance[internalInstanceKey] = internalInstanceHandle;
+      instance[internalPropsKey] = props;
+    }
+    function getHoistableRoot(container) {
+      return "function" === typeof container.getRootNode
+        ? container.getRootNode()
+        : container.ownerDocument;
+    }
+    function preconnectAs(rel, href, crossOrigin) {
+      var ownerDocument = globalDocument;
+      if (ownerDocument && "string" === typeof href && href) {
+        var limitedEscapedHref =
+          escapeSelectorAttributeValueInsideDoubleQuotes(href);
+        limitedEscapedHref =
+          'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
+        "string" === typeof crossOrigin &&
+          (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
+        preconnectsSet.has(limitedEscapedHref) ||
+          (preconnectsSet.add(limitedEscapedHref),
+          (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
+          null === ownerDocument.querySelector(limitedEscapedHref) &&
+            ((href = ownerDocument.createElement("link")),
+            setInitialProperties(href, "link", rel),
+            markNodeAsHoistable(href),
+            ownerDocument.head.appendChild(href)));
+      }
+    }
+    function getResource(type, currentProps, pendingProps, currentResource) {
+      var resourceRoot = (resourceRoot = rootInstanceStackCursor.current)
+        ? getHoistableRoot(resourceRoot)
+        : null;
+      if (!resourceRoot)
+        throw Error(
+          '"resourceRoot" was expected to exist. This is a bug in React.'
+        );
+      switch (type) {
+        case "meta":
+        case "title":
+          return null;
+        case "style":
+          return "string" === typeof pendingProps.precedence &&
+            "string" === typeof pendingProps.href
+            ? ((pendingProps = getStyleKey(pendingProps.href)),
+              (currentProps =
+                getResourcesFromRoot(resourceRoot).hoistableStyles),
+              (currentResource = currentProps.get(pendingProps)),
+              currentResource ||
+                ((currentResource = {
+                  type: "style",
+                  instance: null,
+                  count: 0,
+                  state: null
+                }),
+                currentProps.set(pendingProps, currentResource)),
+              currentResource)
+            : { type: "void", instance: null, count: 0, state: null };
+        case "link":
+          if (
+            "stylesheet" === pendingProps.rel &&
+            "string" === typeof pendingProps.href &&
+            "string" === typeof pendingProps.precedence
+          ) {
+            type = getStyleKey(pendingProps.href);
+            var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles,
+              _resource = _styles.get(type);
+            if (
+              !_resource &&
+              ((resourceRoot = resourceRoot.ownerDocument || resourceRoot),
+              (_resource = {
+                type: "stylesheet",
+                instance: null,
+                count: 0,
+                state: { loading: NotLoaded, preload: null }
+              }),
+              _styles.set(type, _resource),
+              (_styles = resourceRoot.querySelector(
+                getStylesheetSelectorFromKey(type)
+              )) &&
+                !_styles._p &&
+                ((_resource.instance = _styles),
+                (_resource.state.loading = Loaded | Inserted)),
+              !preloadPropsMap.has(type))
+            ) {
+              var preloadProps = {
+                rel: "preload",
+                as: "style",
+                href: pendingProps.href,
+                crossOrigin: pendingProps.crossOrigin,
+                integrity: pendingProps.integrity,
+                media: pendingProps.media,
+                hrefLang: pendingProps.hrefLang,
+                referrerPolicy: pendingProps.referrerPolicy
+              };
+              preloadPropsMap.set(type, preloadProps);
+              _styles ||
+                preloadStylesheet(
+                  resourceRoot,
+                  type,
+                  preloadProps,
+                  _resource.state
+                );
+            }
+            if (currentProps && null === currentResource)
+              throw (
+                ((pendingProps =
+                  "\n\n  - " +
+                  describeLinkForResourceErrorDEV(currentProps) +
+                  "\n  + " +
+                  describeLinkForResourceErrorDEV(pendingProps)),
+                Error(
+                  "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." +
+                    pendingProps
+                ))
+              );
+            return _resource;
+          }
+          if (currentProps && null !== currentResource)
+            throw (
+              ((pendingProps =
+                "\n\n  - " +
+                describeLinkForResourceErrorDEV(currentProps) +
+                "\n  + " +
+                describeLinkForResourceErrorDEV(pendingProps)),
+              Error(
+                "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." +
+                  pendingProps
+              ))
+            );
+          return null;
+        case "script":
+          return (
+            (currentProps = pendingProps.async),
+            (pendingProps = pendingProps.src),
+            "string" === typeof pendingProps &&
+            currentProps &&
+            "function" !== typeof currentProps &&
+            "symbol" !== typeof currentProps
+              ? ((pendingProps = getScriptKey(pendingProps)),
+                (currentProps =
+                  getResourcesFromRoot(resourceRoot).hoistableScripts),
+                (currentResource = currentProps.get(pendingProps)),
+                currentResource ||
+                  ((currentResource = {
+                    type: "script",
+                    instance: null,
+                    count: 0,
+                    state: null
+                  }),
+                  currentProps.set(pendingProps, currentResource)),
+                currentResource)
+              : { type: "void", instance: null, count: 0, state: null }
+          );
+        default:
+          throw Error(
+            'getResource encountered a type it did not expect: "' +
+              type +
+              '". this is a bug in React.'
+          );
+      }
+    }
+    function describeLinkForResourceErrorDEV(props) {
+      var describedProps = 0,
+        description = "<link";
+      "string" === typeof props.rel
+        ? (describedProps++, (description += ' rel="' + props.rel + '"'))
+        : hasOwnProperty.call(props, "rel") &&
+          (describedProps++,
+          (description +=
+            ' rel="' +
+            (null === props.rel ? "null" : "invalid type " + typeof props.rel) +
+            '"'));
+      "string" === typeof props.href
+        ? (describedProps++, (description += ' href="' + props.href + '"'))
+        : hasOwnProperty.call(props, "href") &&
+          (describedProps++,
+          (description +=
+            ' href="' +
+            (null === props.href
+              ? "null"
+              : "invalid type " + typeof props.href) +
+            '"'));
+      "string" === typeof props.precedence
+        ? (describedProps++,
+          (description += ' precedence="' + props.precedence + '"'))
+        : hasOwnProperty.call(props, "precedence") &&
+          (describedProps++,
+          (description +=
+            " precedence={" +
+            (null === props.precedence
+              ? "null"
+              : "invalid type " + typeof props.precedence) +
+            "}"));
+      Object.getOwnPropertyNames(props).length > describedProps &&
+        (description += " ...");
+      return description + " />";
+    }
+    function getStyleKey(href) {
+      return (
+        'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"'
+      );
+    }
+    function getStylesheetSelectorFromKey(key) {
+      return 'link[rel="stylesheet"][' + key + "]";
+    }
+    function stylesheetPropsFromRawProps(rawProps) {
+      return assign({}, rawProps, {
+        "data-precedence": rawProps.precedence,
+        precedence: null
+      });
+    }
+    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
+      ownerDocument.querySelector(
+        'link[rel="preload"][as="style"][' + key + "]"
+      )
+        ? (state.loading = Loaded)
+        : ((key = ownerDocument.createElement("link")),
+          (state.preload = key),
+          key.addEventListener("load", function () {
+            return (state.loading |= Loaded);
+          }),
+          key.addEventListener("error", function () {
+            return (state.loading |= Errored);
+          }),
+          setInitialProperties(key, "link", preloadProps),
+          markNodeAsHoistable(key),
+          ownerDocument.head.appendChild(key));
+    }
+    function getScriptKey(src) {
+      return (
+        '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]'
+      );
+    }
+    function getScriptSelectorFromKey(key) {
+      return "script[async]" + key;
+    }
+    function acquireResource(hoistableRoot, resource, props) {
+      resource.count++;
+      if (null === resource.instance)
+        switch (resource.type) {
+          case "style":
+            var instance = hoistableRoot.querySelector(
+              'style[data-href~="' +
+                escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
+                '"]'
+            );
+            if (instance)
+              return (
+                (resource.instance = instance),
+                markNodeAsHoistable(instance),
+                instance
+              );
+            var styleProps = assign({}, props, {
+              "data-href": props.href,
+              "data-precedence": props.precedence,
+              href: null,
+              precedence: null
+            });
+            instance = (
+              hoistableRoot.ownerDocument || hoistableRoot
+            ).createElement("style");
+            markNodeAsHoistable(instance);
+            setInitialProperties(instance, "style", styleProps);
+            insertStylesheet(instance, props.precedence, hoistableRoot);
+            return (resource.instance = instance);
+          case "stylesheet":
+            styleProps = getStyleKey(props.href);
+            var _instance = hoistableRoot.querySelector(
+              getStylesheetSelectorFromKey(styleProps)
+            );
+            if (_instance)
+              return (
+                (resource.state.loading |= Inserted),
+                (resource.instance = _instance),
+                markNodeAsHoistable(_instance),
+                _instance
+              );
+            instance = stylesheetPropsFromRawProps(props);
+            (styleProps = preloadPropsMap.get(styleProps)) &&
+              adoptPreloadPropsForStylesheet(instance, styleProps);
+            _instance = (
+              hoistableRoot.ownerDocument || hoistableRoot
+            ).createElement("link");
+            markNodeAsHoistable(_instance);
+            var linkInstance = _instance;
+            linkInstance._p = new Promise(function (resolve, reject) {
+              linkInstance.onload = resolve;
+              linkInstance.onerror = reject;
+            });
+            setInitialProperties(_instance, "link", instance);
+            resource.state.loading |= Inserted;
+            insertStylesheet(_instance, props.precedence, hoistableRoot);
+            return (resource.instance = _instance);
+          case "script":
+            _instance = getScriptKey(props.src);
+            if (
+              (styleProps = hoistableRoot.querySelector(
+                getScriptSelectorFromKey(_instance)
+              ))
+            )
+              return (
+                (resource.instance = styleProps),
+                markNodeAsHoistable(styleProps),
+                styleProps
+              );
+            instance = props;
+            if ((styleProps = preloadPropsMap.get(_instance)))
+              (instance = assign({}, props)),
+                adoptPreloadPropsForScript(instance, styleProps);
+            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
+            styleProps = hoistableRoot.createElement("script");
+            markNodeAsHoistable(styleProps);
+            setInitialProperties(styleProps, "link", instance);
+            hoistableRoot.head.appendChild(styleProps);
+            return (resource.instance = styleProps);
+          case "void":
+            return null;
+          default:
+            throw Error(
+              'acquireResource encountered a resource type it did not expect: "' +
+                resource.type +
+                '". this is a bug in React.'
+            );
+        }
+      else
+        "stylesheet" === resource.type &&
+          (resource.state.loading & Inserted) === NotLoaded &&
+          ((instance = resource.instance),
+          (resource.state.loading |= Inserted),
+          insertStylesheet(instance, props.precedence, hoistableRoot));
+      return resource.instance;
+    }
+    function insertStylesheet(instance, precedence, root) {
+      for (
+        var nodes = root.querySelectorAll(
+            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
+          ),
+          last = nodes.length ? nodes[nodes.length - 1] : null,
+          prior = last,
+          i = 0;
+        i < nodes.length;
+        i++
+      ) {
+        var node = nodes[i];
+        if (node.dataset.precedence === precedence) prior = node;
+        else if (prior !== last) break;
+      }
+      prior
+        ? prior.parentNode.insertBefore(instance, prior.nextSibling)
+        : ((precedence = 9 === root.nodeType ? root.head : root),
+          precedence.insertBefore(instance, precedence.firstChild));
+    }
+    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
+      null == stylesheetProps.crossOrigin &&
+        (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
+      null == stylesheetProps.referrerPolicy &&
+        (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
+      null == stylesheetProps.title &&
+        (stylesheetProps.title = preloadProps.title);
+    }
+    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
+      null == scriptProps.crossOrigin &&
+        (scriptProps.crossOrigin = preloadProps.crossOrigin);
+      null == scriptProps.referrerPolicy &&
+        (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
+      null == scriptProps.integrity &&
+        (scriptProps.integrity = preloadProps.integrity);
+    }
+    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
+      if (null === tagCaches) {
+        var cache = new Map();
+        var caches = (tagCaches = new Map());
+        caches.set(ownerDocument, cache);
+      } else
+        (caches = tagCaches),
+          (cache = caches.get(ownerDocument)),
+          cache || ((cache = new Map()), caches.set(ownerDocument, cache));
+      if (cache.has(type)) return cache;
+      cache.set(type, null);
+      ownerDocument = ownerDocument.getElementsByTagName(type);
+      for (caches = 0; caches < ownerDocument.length; caches++) {
+        var node = ownerDocument[caches];
+        if (
+          !(
+            node[internalHoistableMarker] ||
+            node[internalInstanceKey] ||
+            ("link" === type && "stylesheet" === node.getAttribute("rel"))
+          ) &&
+          node.namespaceURI !== SVG_NAMESPACE
+        ) {
+          var nodeKey = node.getAttribute(keyAttribute) || "";
+          nodeKey = type + nodeKey;
+          var existing = cache.get(nodeKey);
+          existing ? existing.push(node) : cache.set(nodeKey, [node]);
+        }
+      }
+      return cache;
+    }
+    function mountHoistable(hoistableRoot, type, instance) {
+      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
+      hoistableRoot.head.insertBefore(
+        instance,
+        "title" === type ? hoistableRoot.querySelector("head > title") : null
+      );
+    }
+    function isHostHoistableType(type, props, hostContext) {
+      var outsideHostContainerContext =
+        !hostContext.ancestorInfo.containerTagInScope;
+      if (
+        hostContext.context === HostContextNamespaceSvg ||
+        null != props.itemProp
+      )
+        return (
+          !outsideHostContainerContext ||
+            null == props.itemProp ||
+            ("meta" !== type &&
+              "title" !== type &&
+              "style" !== type &&
+              "link" !== type &&
+              "script" !== type) ||
+            console.error(
+              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
+              type,
+              type
+            ),
+          !1
+        );
+      switch (type) {
+        case "meta":
+        case "title":
+          return !0;
+        case "style":
+          if (
+            "string" !== typeof props.precedence ||
+            "string" !== typeof props.href ||
+            "" === props.href
+          ) {
+            outsideHostContainerContext &&
+              console.error(
+                'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
+              );
+            break;
+          }
+          return !0;
+        case "link":
+          if (
+            "string" !== typeof props.rel ||
+            "string" !== typeof props.href ||
+            "" === props.href ||
+            props.onLoad ||
+            props.onError
+          ) {
+            if (
+              "stylesheet" === props.rel &&
+              "string" === typeof props.precedence
+            ) {
+              type = props.href;
+              var onError = props.onError,
+                disabled = props.disabled;
+              hostContext = [];
+              props.onLoad && hostContext.push("`onLoad`");
+              onError && hostContext.push("`onError`");
+              null != disabled && hostContext.push("`disabled`");
+              onError = propNamesListJoin(hostContext, "and");
+              onError += 1 === hostContext.length ? " prop" : " props";
+              disabled =
+                1 === hostContext.length ? "an " + onError : "the " + onError;
+              hostContext.length &&
+                console.error(
+                  'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
+                  type,
+                  disabled,
+                  onError
+                );
+            }
+            outsideHostContainerContext &&
+              ("string" !== typeof props.rel ||
+              "string" !== typeof props.href ||
+              "" === props.href
+                ? console.error(
+                    "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
+                  )
+                : (props.onError || props.onLoad) &&
+                  console.error(
+                    "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
+                  ));
+            break;
+          }
+          switch (props.rel) {
+            case "stylesheet":
+              return (
+                (type = props.precedence),
+                (props = props.disabled),
+                "string" !== typeof type &&
+                  outsideHostContainerContext &&
+                  console.error(
+                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
+                  ),
+                "string" === typeof type && null == props
+              );
+            default:
+              return !0;
+          }
+        case "script":
+          type =
+            props.async &&
+            "function" !== typeof props.async &&
+            "symbol" !== typeof props.async;
+          if (
+            !type ||
+            props.onLoad ||
+            props.onError ||
+            !props.src ||
+            "string" !== typeof props.src
+          ) {
+            outsideHostContainerContext &&
+              (type
+                ? props.onLoad || props.onError
+                  ? console.error(
+                      "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
+                    )
+                  : console.error(
+                      "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
+                    )
+                : console.error(
+                    'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
+                  ));
+            break;
+          }
+          return !0;
+        case "noscript":
+        case "template":
+          outsideHostContainerContext &&
+            console.error(
+              "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
+              type
+            );
+      }
+      return !1;
+    }
+    function preloadResource(resource) {
+      return "stylesheet" === resource.type &&
+        (resource.state.loading & Settled) === NotLoaded
+        ? !1
+        : !0;
+    }
+    function noop() {}
+    function suspendResource(hoistableRoot, resource, props) {
+      if (null === suspendedState)
+        throw Error(
+          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
+        );
+      var state = suspendedState;
+      if (
+        "stylesheet" === resource.type &&
+        ("string" !== typeof props.media ||
+          !1 !== matchMedia(props.media).matches) &&
+        (resource.state.loading & Inserted) === NotLoaded
+      ) {
+        if (null === resource.instance) {
+          var key = getStyleKey(props.href),
+            instance = hoistableRoot.querySelector(
+              getStylesheetSelectorFromKey(key)
+            );
+          if (instance) {
+            hoistableRoot = instance._p;
+            null !== hoistableRoot &&
+              "object" === typeof hoistableRoot &&
+              "function" === typeof hoistableRoot.then &&
+              (state.count++,
+              (state = onUnsuspend.bind(state)),
+              hoistableRoot.then(state, state));
+            resource.state.loading |= Inserted;
+            resource.instance = instance;
+            markNodeAsHoistable(instance);
+            return;
+          }
+          instance = hoistableRoot.ownerDocument || hoistableRoot;
+          props = stylesheetPropsFromRawProps(props);
+          (key = preloadPropsMap.get(key)) &&
+            adoptPreloadPropsForStylesheet(props, key);
+          instance = instance.createElement("link");
+          markNodeAsHoistable(instance);
+          var linkInstance = instance;
+          linkInstance._p = new Promise(function (resolve, reject) {
+            linkInstance.onload = resolve;
+            linkInstance.onerror = reject;
+          });
+          setInitialProperties(instance, "link", props);
+          resource.instance = instance;
+        }
+        null === state.stylesheets && (state.stylesheets = new Map());
+        state.stylesheets.set(resource, hoistableRoot);
+        (hoistableRoot = resource.state.preload) &&
+          (resource.state.loading & Settled) === NotLoaded &&
+          (state.count++,
+          (resource = onUnsuspend.bind(state)),
+          hoistableRoot.addEventListener("load", resource),
+          hoistableRoot.addEventListener("error", resource));
+      }
+    }
+    function waitForCommitToBeReady() {
+      if (null === suspendedState)
+        throw Error(
+          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
+        );
+      var state = suspendedState;
+      state.stylesheets &&
+        0 === state.count &&
+        insertSuspendedStylesheets(state, state.stylesheets);
+      return 0 < state.count
+        ? function (commit) {
+            var stylesheetTimer = setTimeout(function () {
+              state.stylesheets &&
+                insertSuspendedStylesheets(state, state.stylesheets);
+              if (state.unsuspend) {
+                var unsuspend = state.unsuspend;
+                state.unsuspend = null;
+                unsuspend();
+              }
+            }, 6e4);
+            state.unsuspend = commit;
+            return function () {
+              state.unsuspend = null;
+              clearTimeout(stylesheetTimer);
+            };
+          }
+        : null;
+    }
+    function onUnsuspend() {
+      this.count--;
+      if (0 === this.count)
+        if (this.stylesheets)
+          insertSuspendedStylesheets(this, this.stylesheets);
+        else if (this.unsuspend) {
+          var unsuspend = this.unsuspend;
+          this.unsuspend = null;
+          unsuspend();
+        }
+    }
+    function insertSuspendedStylesheets(state, resources) {
+      state.stylesheets = null;
+      null !== state.unsuspend &&
+        (state.count++,
+        (precedencesByRoot = new Map()),
+        resources.forEach(insertStylesheetIntoRoot, state),
+        (precedencesByRoot = null),
+        onUnsuspend.call(state));
+    }
+    function insertStylesheetIntoRoot(root, resource) {
+      if (!(resource.state.loading & Inserted)) {
+        var precedences = precedencesByRoot.get(root);
+        if (precedences) var last = precedences.get(LAST_PRECEDENCE);
+        else {
+          precedences = new Map();
+          precedencesByRoot.set(root, precedences);
+          for (
+            var nodes = root.querySelectorAll(
+                "link[data-precedence],style[data-precedence]"
+              ),
+              i = 0;
+            i < nodes.length;
+            i++
+          ) {
+            var node = nodes[i];
+            if (
+              "LINK" === node.nodeName ||
+              "not all" !== node.getAttribute("media")
+            )
+              precedences.set(node.dataset.precedence, node), (last = node);
+          }
+          last && precedences.set(LAST_PRECEDENCE, last);
+        }
+        nodes = resource.instance;
+        node = nodes.getAttribute("data-precedence");
+        i = precedences.get(node) || last;
+        i === last && precedences.set(LAST_PRECEDENCE, nodes);
+        precedences.set(node, nodes);
+        this.count++;
+        last = onUnsuspend.bind(this);
+        nodes.addEventListener("load", last);
+        nodes.addEventListener("error", last);
+        i
+          ? i.parentNode.insertBefore(nodes, i.nextSibling)
+          : ((root = 9 === root.nodeType ? root.head : root),
+            root.insertBefore(nodes, root.firstChild));
+        resource.state.loading |= Inserted;
+      }
+    }
+    function FiberRootNode(
+      containerInfo,
+      tag,
+      hydrate,
+      identifierPrefix,
+      onUncaughtError,
+      onCaughtError,
+      onRecoverableError,
+      formState
+    ) {
+      this.tag = 1;
+      this.containerInfo = containerInfo;
+      this.pingCache = this.current = this.pendingChildren = null;
+      this.timeoutHandle = noTimeout;
+      this.callbackNode =
+        this.next =
+        this.pendingContext =
+        this.context =
+        this.cancelPendingCommit =
+          null;
+      this.callbackPriority = 0;
+      this.expirationTimes = createLaneMap(-1);
+      this.entangledLanes =
+        this.shellSuspendCounter =
+        this.errorRecoveryDisabledLanes =
+        this.expiredLanes =
+        this.warmLanes =
+        this.pingedLanes =
+        this.suspendedLanes =
+        this.pendingLanes =
+          0;
+      this.entanglements = createLaneMap(0);
+      this.hiddenUpdates = createLaneMap(null);
+      this.identifierPrefix = identifierPrefix;
+      this.onUncaughtError = onUncaughtError;
+      this.onCaughtError = onCaughtError;
+      this.onRecoverableError = onRecoverableError;
+      this.pooledCache = null;
+      this.pooledCacheLanes = 0;
+      this.formState = formState;
+      this.incompleteTransitions = new Map();
+      this.passiveEffectDuration = this.effectDuration = -0;
+      this.memoizedUpdaters = new Set();
+      containerInfo = this.pendingUpdatersLaneMap = [];
+      for (tag = 0; 31 > tag; tag++) containerInfo.push(new Set());
+      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
+    }
+    function createFiberRoot(
+      containerInfo,
+      tag,
+      hydrate,
+      initialChildren,
+      hydrationCallbacks,
+      isStrictMode,
+      identifierPrefix,
+      onUncaughtError,
+      onCaughtError,
+      onRecoverableError,
+      transitionCallbacks,
+      formState
+    ) {
+      containerInfo = new FiberRootNode(
+        containerInfo,
+        tag,
+        hydrate,
+        identifierPrefix,
+        onUncaughtError,
+        onCaughtError,
+        onRecoverableError,
+        formState
+      );
+      tag = ConcurrentMode;
+      !0 === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
+      isDevToolsPresent && (tag |= ProfileMode);
+      isStrictMode = createFiber(3, null, null, tag);
+      containerInfo.current = isStrictMode;
+      isStrictMode.stateNode = containerInfo;
+      tag = createCache();
+      retainCache(tag);
+      containerInfo.pooledCache = tag;
+      retainCache(tag);
+      isStrictMode.memoizedState = {
+        element: initialChildren,
+        isDehydrated: hydrate,
+        cache: tag
+      };
+      initializeUpdateQueue(isStrictMode);
+      return containerInfo;
+    }
+    function getContextForSubtree(parentComponent) {
+      if (!parentComponent) return emptyContextObject;
+      parentComponent = emptyContextObject;
+      return parentComponent;
+    }
+    function updateContainerImpl(
+      rootFiber,
+      lane,
+      element,
+      container,
+      parentComponent,
+      callback
+    ) {
+      if (
+        injectedHook &&
+        "function" === typeof injectedHook.onScheduleFiberRoot
+      )
+        try {
+          injectedHook.onScheduleFiberRoot(rendererID, container, element);
+        } catch (err) {
+          hasLoggedError ||
+            ((hasLoggedError = !0),
+            console.error(
+              "React instrumentation encountered an error: %s",
+              err
+            ));
+        }
+      parentComponent = getContextForSubtree(parentComponent);
+      null === container.context
+        ? (container.context = parentComponent)
+        : (container.pendingContext = parentComponent);
+      isRendering &&
+        null !== current &&
+        !didWarnAboutNestedUpdates &&
+        ((didWarnAboutNestedUpdates = !0),
+        console.error(
+          "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
+          getComponentNameFromFiber(current) || "Unknown"
+        ));
+      container = createUpdate(lane);
+      container.payload = { element: element };
+      callback = void 0 === callback ? null : callback;
+      null !== callback &&
+        ("function" !== typeof callback &&
+          console.error(
+            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
+            callback
+          ),
+        (container.callback = callback));
+      element = enqueueUpdate(rootFiber, container, lane);
+      null !== element &&
+        (startUpdateTimerByLane(lane),
+        scheduleUpdateOnFiber(element, rootFiber, lane),
+        entangleTransitions(element, rootFiber, lane));
+    }
+    function markRetryLaneImpl(fiber, retryLane) {
+      fiber = fiber.memoizedState;
+      if (null !== fiber && null !== fiber.dehydrated) {
+        var a = fiber.retryLane;
+        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
+      }
+    }
+    function markRetryLaneIfNotHydrated(fiber, retryLane) {
+      markRetryLaneImpl(fiber, retryLane);
+      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
+    }
+    function attemptContinuousHydration(fiber) {
+      if (13 === fiber.tag) {
+        var root = enqueueConcurrentRenderForLane(fiber, 67108864);
+        null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
+        markRetryLaneIfNotHydrated(fiber, 67108864);
+      }
+    }
+    function getCurrentFiberForDevTools() {
+      return current;
+    }
+    function dispatchDiscreteEvent(
+      domEventName,
+      eventSystemFlags,
+      container,
+      nativeEvent
+    ) {
+      var prevTransition = ReactSharedInternals.T;
+      ReactSharedInternals.T = null;
+      var previousPriority = ReactDOMSharedInternals.p;
+      try {
+        (ReactDOMSharedInternals.p = DiscreteEventPriority),
+          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
+      } finally {
+        (ReactDOMSharedInternals.p = previousPriority),
+          (ReactSharedInternals.T = prevTransition);
+      }
+    }
+    function dispatchContinuousEvent(
+      domEventName,
+      eventSystemFlags,
+      container,
+      nativeEvent
+    ) {
+      var prevTransition = ReactSharedInternals.T;
+      ReactSharedInternals.T = null;
+      var previousPriority = ReactDOMSharedInternals.p;
+      try {
+        (ReactDOMSharedInternals.p = ContinuousEventPriority),
+          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
+      } finally {
+        (ReactDOMSharedInternals.p = previousPriority),
+          (ReactSharedInternals.T = prevTransition);
+      }
+    }
+    function dispatchEvent(
+      domEventName,
+      eventSystemFlags,
+      targetContainer,
+      nativeEvent
+    ) {
+      if (_enabled) {
+        var blockedOn = findInstanceBlockingEvent(nativeEvent);
+        if (null === blockedOn)
+          dispatchEventForPluginEventSystem(
+            domEventName,
+            eventSystemFlags,
+            nativeEvent,
+            return_targetInst,
+            targetContainer
+          ),
+            clearIfContinuousEvent(domEventName, nativeEvent);
+        else if (
+          queueIfContinuousEvent(
+            blockedOn,
+            domEventName,
+            eventSystemFlags,
+            targetContainer,
+            nativeEvent
+          )
+        )
+          nativeEvent.stopPropagation();
+        else if (
+          (clearIfContinuousEvent(domEventName, nativeEvent),
+          eventSystemFlags & 4 &&
+            -1 < discreteReplayableEvents.indexOf(domEventName))
+        ) {
+          for (; null !== blockedOn; ) {
+            var fiber = getInstanceFromNode(blockedOn);
+            if (null !== fiber)
+              switch (fiber.tag) {
+                case 3:
+                  fiber = fiber.stateNode;
+                  if (fiber.current.memoizedState.isDehydrated) {
+                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
+                    if (0 !== lanes) {
+                      var root = fiber;
+                      root.pendingLanes |= 2;
+                      for (root.entangledLanes |= 2; lanes; ) {
+                        var lane = 1 << (31 - clz32(lanes));
+                        root.entanglements[1] |= lane;
+                        lanes &= ~lane;
+                      }
+                      ensureRootIsScheduled(fiber);
+                      (executionContext & (RenderContext | CommitContext)) ===
+                        NoContext &&
+                        ((workInProgressRootRenderTargetTime =
+                          now$1() + RENDER_TIMEOUT_MS),
+                        flushSyncWorkAcrossRoots_impl(0, !1));
+                    }
+                  }
+                  break;
+                case 13:
+                  (root = enqueueConcurrentRenderForLane(fiber, 2)),
+                    null !== root && scheduleUpdateOnFiber(root, fiber, 2),
+                    flushSyncWork$1(),
+                    markRetryLaneIfNotHydrated(fiber, 2);
+              }
+            fiber = findInstanceBlockingEvent(nativeEvent);
+            null === fiber &&
+              dispatchEventForPluginEventSystem(
+                domEventName,
+                eventSystemFlags,
+                nativeEvent,
+                return_targetInst,
+                targetContainer
+              );
+            if (fiber === blockedOn) break;
+            blockedOn = fiber;
+          }
+          null !== blockedOn && nativeEvent.stopPropagation();
+        } else
+          dispatchEventForPluginEventSystem(
+            domEventName,
+            eventSystemFlags,
+            nativeEvent,
+            null,
+            targetContainer
+          );
+      }
+    }
+    function findInstanceBlockingEvent(nativeEvent) {
+      nativeEvent = getEventTarget(nativeEvent);
+      return findInstanceBlockingTarget(nativeEvent);
+    }
+    function findInstanceBlockingTarget(targetNode) {
+      return_targetInst = null;
+      targetNode = getClosestInstanceFromNode(targetNode);
+      if (null !== targetNode) {
+        var nearestMounted = getNearestMountedFiber(targetNode);
+        if (null === nearestMounted) targetNode = null;
+        else {
+          var tag = nearestMounted.tag;
+          if (13 === tag) {
+            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
+            if (null !== targetNode) return targetNode;
+            targetNode = null;
+          } else if (3 === tag) {
+            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
+              return 3 === nearestMounted.tag
+                ? nearestMounted.stateNode.containerInfo
+                : null;
+            targetNode = null;
+          } else nearestMounted !== targetNode && (targetNode = null);
+        }
+      }
+      return_targetInst = targetNode;
+      return null;
+    }
+    function getEventPriority(domEventName) {
+      switch (domEventName) {
+        case "beforetoggle":
+        case "cancel":
+        case "click":
+        case "close":
+        case "contextmenu":
+        case "copy":
+        case "cut":
+        case "auxclick":
+        case "dblclick":
+        case "dragend":
+        case "dragstart":
+        case "drop":
+        case "focusin":
+        case "focusout":
+        case "input":
+        case "invalid":
+        case "keydown":
+        case "keypress":
+        case "keyup":
+        case "mousedown":
+        case "mouseup":
+        case "paste":
+        case "pause":
+        case "play":
+        case "pointercancel":
+        case "pointerdown":
+        case "pointerup":
+        case "ratechange":
+        case "reset":
+        case "resize":
+        case "seeked":
+        case "submit":
+        case "toggle":
+        case "touchcancel":
+        case "touchend":
+        case "touchstart":
+        case "volumechange":
+        case "change":
+        case "selectionchange":
+        case "textInput":
+        case "compositionstart":
+        case "compositionend":
+        case "compositionupdate":
+        case "beforeblur":
+        case "afterblur":
+        case "beforeinput":
+        case "blur":
+        case "fullscreenchange":
+        case "focus":
+        case "hashchange":
+        case "popstate":
+        case "select":
+        case "selectstart":
+          return DiscreteEventPriority;
+        case "drag":
+        case "dragenter":
+        case "dragexit":
+        case "dragleave":
+        case "dragover":
+        case "mousemove":
+        case "mouseout":
+        case "mouseover":
+        case "pointermove":
+        case "pointerout":
+        case "pointerover":
+        case "scroll":
+        case "touchmove":
+        case "wheel":
+        case "mouseenter":
+        case "mouseleave":
+        case "pointerenter":
+        case "pointerleave":
+          return ContinuousEventPriority;
+        case "message":
+          switch (getCurrentPriorityLevel()) {
+            case ImmediatePriority:
+              return DiscreteEventPriority;
+            case UserBlockingPriority:
+              return ContinuousEventPriority;
+            case NormalPriority$1:
+            case LowPriority:
+              return DefaultEventPriority;
+            case IdlePriority:
+              return IdleEventPriority;
+            default:
+              return DefaultEventPriority;
+          }
+        default:
+          return DefaultEventPriority;
+      }
+    }
+    function clearIfContinuousEvent(domEventName, nativeEvent) {
+      switch (domEventName) {
+        case "focusin":
+        case "focusout":
+          queuedFocus = null;
+          break;
+        case "dragenter":
+        case "dragleave":
+          queuedDrag = null;
+          break;
+        case "mouseover":
+        case "mouseout":
+          queuedMouse = null;
+          break;
+        case "pointerover":
+        case "pointerout":
+          queuedPointers.delete(nativeEvent.pointerId);
+          break;
+        case "gotpointercapture":
+        case "lostpointercapture":
+          queuedPointerCaptures.delete(nativeEvent.pointerId);
+      }
+    }
+    function accumulateOrCreateContinuousQueuedReplayableEvent(
+      existingQueuedEvent,
+      blockedOn,
+      domEventName,
+      eventSystemFlags,
+      targetContainer,
+      nativeEvent
+    ) {
+      if (
+        null === existingQueuedEvent ||
+        existingQueuedEvent.nativeEvent !== nativeEvent
+      )
+        return (
+          (existingQueuedEvent = {
+            blockedOn: blockedOn,
+            domEventName: domEventName,
+            eventSystemFlags: eventSystemFlags,
+            nativeEvent: nativeEvent,
+            targetContainers: [targetContainer]
+          }),
+          null !== blockedOn &&
+            ((blockedOn = getInstanceFromNode(blockedOn)),
+            null !== blockedOn && attemptContinuousHydration(blockedOn)),
+          existingQueuedEvent
+        );
+      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
+      blockedOn = existingQueuedEvent.targetContainers;
+      null !== targetContainer &&
+        -1 === blockedOn.indexOf(targetContainer) &&
+        blockedOn.push(targetContainer);
+      return existingQueuedEvent;
+    }
+    function queueIfContinuousEvent(
+      blockedOn,
+      domEventName,
+      eventSystemFlags,
+      targetContainer,
+      nativeEvent
+    ) {
+      switch (domEventName) {
+        case "focusin":
+          return (
+            (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
+              queuedFocus,
+              blockedOn,
+              domEventName,
+              eventSystemFlags,
+              targetContainer,
+              nativeEvent
+            )),
+            !0
+          );
+        case "dragenter":
+          return (
+            (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
+              queuedDrag,
+              blockedOn,
+              domEventName,
+              eventSystemFlags,
+              targetContainer,
+              nativeEvent
+            )),
+            !0
+          );
+        case "mouseover":
+          return (
+            (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
+              queuedMouse,
+              blockedOn,
+              domEventName,
+              eventSystemFlags,
+              targetContainer,
+              nativeEvent
+            )),
+            !0
+          );
+        case "pointerover":
+          var pointerId = nativeEvent.pointerId;
+          queuedPointers.set(
+            pointerId,
+            accumulateOrCreateContinuousQueuedReplayableEvent(
+              queuedPointers.get(pointerId) || null,
+              blockedOn,
+              domEventName,
+              eventSystemFlags,
+              targetContainer,
+              nativeEvent
+            )
+          );
+          return !0;
+        case "gotpointercapture":
+          return (
+            (pointerId = nativeEvent.pointerId),
+            queuedPointerCaptures.set(
+              pointerId,
+              accumulateOrCreateContinuousQueuedReplayableEvent(
+                queuedPointerCaptures.get(pointerId) || null,
+                blockedOn,
+                domEventName,
+                eventSystemFlags,
+                targetContainer,
+                nativeEvent
+              )
+            ),
+            !0
+          );
+      }
+      return !1;
+    }
+    function attemptExplicitHydrationTarget(queuedTarget) {
+      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
+      if (null !== targetInst) {
+        var nearestMounted = getNearestMountedFiber(targetInst);
+        if (null !== nearestMounted)
+          if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
+            if (
+              ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
+              null !== targetInst)
+            ) {
+              queuedTarget.blockedOn = targetInst;
+              runWithPriority(queuedTarget.priority, function () {
+                if (13 === nearestMounted.tag) {
+                  var lane = requestUpdateLane(nearestMounted);
+                  lane = getBumpedLaneForHydrationByLane(lane);
+                  var root = enqueueConcurrentRenderForLane(
+                    nearestMounted,
+                    lane
+                  );
+                  null !== root &&
+                    scheduleUpdateOnFiber(root, nearestMounted, lane);
+                  markRetryLaneIfNotHydrated(nearestMounted, lane);
+                }
+              });
+              return;
+            }
+          } else if (
+            3 === targetInst &&
+            nearestMounted.stateNode.current.memoizedState.isDehydrated
+          ) {
+            queuedTarget.blockedOn =
+              3 === nearestMounted.tag
+                ? nearestMounted.stateNode.containerInfo
+                : null;
+            return;
+          }
+      }
+      queuedTarget.blockedOn = null;
+    }
+    function attemptReplayContinuousQueuedEvent(queuedEvent) {
+      if (null !== queuedEvent.blockedOn) return !1;
+      for (
+        var targetContainers = queuedEvent.targetContainers;
+        0 < targetContainers.length;
+
+      ) {
+        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
+        if (null === nextBlockedOn) {
+          nextBlockedOn = queuedEvent.nativeEvent;
+          var nativeEventClone = new nextBlockedOn.constructor(
+              nextBlockedOn.type,
+              nextBlockedOn
+            ),
+            event = nativeEventClone;
+          null !== currentReplayingEvent &&
+            console.error(
+              "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
+            );
+          currentReplayingEvent = event;
+          nextBlockedOn.target.dispatchEvent(nativeEventClone);
+          null === currentReplayingEvent &&
+            console.error(
+              "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
+            );
+          currentReplayingEvent = null;
+        } else
+          return (
+            (targetContainers = getInstanceFromNode(nextBlockedOn)),
+            null !== targetContainers &&
+              attemptContinuousHydration(targetContainers),
+            (queuedEvent.blockedOn = nextBlockedOn),
+            !1
+          );
+        targetContainers.shift();
+      }
+      return !0;
+    }
+    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
+      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
+    }
+    function replayUnblockedEvents() {
+      hasScheduledReplayAttempt = !1;
+      null !== queuedFocus &&
+        attemptReplayContinuousQueuedEvent(queuedFocus) &&
+        (queuedFocus = null);
+      null !== queuedDrag &&
+        attemptReplayContinuousQueuedEvent(queuedDrag) &&
+        (queuedDrag = null);
+      null !== queuedMouse &&
+        attemptReplayContinuousQueuedEvent(queuedMouse) &&
+        (queuedMouse = null);
+      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
+      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
+    }
+    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
+      queuedEvent.blockedOn === unblocked &&
+        ((queuedEvent.blockedOn = null),
+        hasScheduledReplayAttempt ||
+          ((hasScheduledReplayAttempt = !0),
+          Scheduler.unstable_scheduleCallback(
+            Scheduler.unstable_NormalPriority,
+            replayUnblockedEvents
+          )));
+    }
+    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
+      lastScheduledReplayQueue !== formReplayingQueue &&
+        ((lastScheduledReplayQueue = formReplayingQueue),
+        Scheduler.unstable_scheduleCallback(
+          Scheduler.unstable_NormalPriority,
+          function () {
+            lastScheduledReplayQueue === formReplayingQueue &&
+              (lastScheduledReplayQueue = null);
+            for (var i = 0; i < formReplayingQueue.length; i += 3) {
+              var form = formReplayingQueue[i],
+                submitterOrAction = formReplayingQueue[i + 1],
+                formData = formReplayingQueue[i + 2];
+              if ("function" !== typeof submitterOrAction)
+                if (
+                  null === findInstanceBlockingTarget(submitterOrAction || form)
+                )
+                  continue;
+                else break;
+              var formInst = getInstanceFromNode(form);
+              null !== formInst &&
+                (formReplayingQueue.splice(i, 3),
+                (i -= 3),
+                (form = {
+                  pending: !0,
+                  data: formData,
+                  method: form.method,
+                  action: submitterOrAction
+                }),
+                Object.freeze(form),
+                startHostTransition(
+                  formInst,
+                  form,
+                  submitterOrAction,
+                  formData
+                ));
+            }
+          }
+        ));
+    }
+    function retryIfBlockedOn(unblocked) {
+      function unblock(queuedEvent) {
+        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
+      }
+      null !== queuedFocus &&
+        scheduleCallbackIfUnblocked(queuedFocus, unblocked);
+      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
+      null !== queuedMouse &&
+        scheduleCallbackIfUnblocked(queuedMouse, unblocked);
+      queuedPointers.forEach(unblock);
+      queuedPointerCaptures.forEach(unblock);
+      for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
+        var queuedTarget = queuedExplicitHydrationTargets[i];
+        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
+      }
+      for (
+        ;
+        0 < queuedExplicitHydrationTargets.length &&
+        ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);
+
+      )
+        attemptExplicitHydrationTarget(i),
+          null === i.blockedOn && queuedExplicitHydrationTargets.shift();
+      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
+      if (null != i)
+        for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
+          var form = i[queuedTarget],
+            submitterOrAction = i[queuedTarget + 1],
+            formProps = form[internalPropsKey] || null;
+          if ("function" === typeof submitterOrAction)
+            formProps || scheduleReplayQueueIfNeeded(i);
+          else if (formProps) {
+            var action = null;
+            if (
+              submitterOrAction &&
+              submitterOrAction.hasAttribute("formAction")
+            )
+              if (
+                ((form = submitterOrAction),
+                (formProps = submitterOrAction[internalPropsKey] || null))
+              )
+                action = formProps.formAction;
+              else {
+                if (null !== findInstanceBlockingTarget(form)) continue;
+              }
+            else action = formProps.action;
+            "function" === typeof action
+              ? (i[queuedTarget + 1] = action)
+              : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
+            scheduleReplayQueueIfNeeded(i);
+          }
+        }
+    }
+    function ReactDOMRoot(internalRoot) {
+      this._internalRoot = internalRoot;
+    }
+    function ReactDOMHydrationRoot(internalRoot) {
+      this._internalRoot = internalRoot;
+    }
+    function warnIfReactDOMContainerInDEV(container) {
+      container[internalContainerInstanceKey] &&
+        (container._reactRootContainer
+          ? console.error(
+              "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
+            )
+          : console.error(
+              "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
+            ));
+    }
+    var Scheduler = require("scheduler"),
+      React = require("react"),
+      ReactDOM = require("react-dom"),
+      assign = Object.assign,
+      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
+      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
+      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
+      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
+      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
+      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
+      REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
+      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
+      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
+      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
+      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
+      REACT_MEMO_TYPE = Symbol.for("react.memo"),
+      REACT_LAZY_TYPE = Symbol.for("react.lazy");
+    Symbol.for("react.scope");
+    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
+      REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
+    Symbol.for("react.tracing_marker");
+    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+      REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+      REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
+      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+      ASYNC_ITERATOR = Symbol.asyncIterator,
+      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
+      isArrayImpl = Array.isArray,
+      ReactSharedInternals =
+        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
+      ReactDOMSharedInternals =
+        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
+      NotPending = Object.freeze({
+        pending: !1,
+        data: null,
+        method: null,
+        action: null
+      }),
+      valueStack = [];
+    var fiberStack = [];
+    var index$jscomp$0 = -1,
+      contextStackCursor = createCursor(null),
+      contextFiberStackCursor = createCursor(null),
+      rootInstanceStackCursor = createCursor(null),
+      hostTransitionProviderCursor = createCursor(null),
+      hasOwnProperty = Object.prototype.hasOwnProperty,
+      scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
+      cancelCallback$1 = Scheduler.unstable_cancelCallback,
+      shouldYield = Scheduler.unstable_shouldYield,
+      requestPaint = Scheduler.unstable_requestPaint,
+      now$1 = Scheduler.unstable_now,
+      getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
+      ImmediatePriority = Scheduler.unstable_ImmediatePriority,
+      UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
+      NormalPriority$1 = Scheduler.unstable_NormalPriority,
+      LowPriority = Scheduler.unstable_LowPriority,
+      IdlePriority = Scheduler.unstable_IdlePriority,
+      log$1 = Scheduler.log,
+      unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
+      rendererID = null,
+      injectedHook = null,
+      hasLoggedError = !1,
+      isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__,
+      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
+      log = Math.log,
+      LN2 = Math.LN2,
+      nextTransitionLane = 128,
+      nextRetryLane = 4194304,
+      DiscreteEventPriority = 2,
+      ContinuousEventPriority = 8,
+      DefaultEventPriority = 32,
+      IdleEventPriority = 268435456,
+      randomKey = Math.random().toString(36).slice(2),
+      internalInstanceKey = "__reactFiber$" + randomKey,
+      internalPropsKey = "__reactProps$" + randomKey,
+      internalContainerInstanceKey = "__reactContainer$" + randomKey,
+      internalEventHandlersKey = "__reactEvents$" + randomKey,
+      internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
+      internalEventHandlesSetKey = "__reactHandles$" + randomKey,
+      internalRootNodeResourcesKey = "__reactResources$" + randomKey,
+      internalHoistableMarker = "__reactMarker$" + randomKey,
+      tagToRoleMappings = {
+        ARTICLE: "article",
+        ASIDE: "complementary",
+        BODY: "document",
+        BUTTON: "button",
+        DATALIST: "listbox",
+        DD: "definition",
+        DETAILS: "group",
+        DIALOG: "dialog",
+        DT: "term",
+        FIELDSET: "group",
+        FIGURE: "figure",
+        FORM: "form",
+        FOOTER: "contentinfo",
+        H1: "heading",
+        H2: "heading",
+        H3: "heading",
+        H4: "heading",
+        H5: "heading",
+        H6: "heading",
+        HEADER: "banner",
+        HR: "separator",
+        LEGEND: "legend",
+        LI: "listitem",
+        MATH: "math",
+        MAIN: "main",
+        MENU: "list",
+        NAV: "navigation",
+        OL: "list",
+        OPTGROUP: "group",
+        OPTION: "option",
+        OUTPUT: "status",
+        PROGRESS: "progressbar",
+        SECTION: "region",
+        SUMMARY: "button",
+        TABLE: "table",
+        TBODY: "rowgroup",
+        TEXTAREA: "textbox",
+        TFOOT: "rowgroup",
+        TD: "cell",
+        TH: "columnheader",
+        THEAD: "rowgroup",
+        TR: "row",
+        UL: "list"
+      },
+      allNativeEvents = new Set(),
+      registrationNameDependencies = {},
+      possibleRegistrationNames = {},
+      hasReadOnlyValue = {
+        button: !0,
+        checkbox: !0,
+        image: !0,
+        hidden: !0,
+        radio: !0,
+        reset: !0,
+        submit: !0
+      },
+      VALID_ATTRIBUTE_NAME_REGEX = RegExp(
+        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
+      ),
+      illegalAttributeNameCache = {},
+      validatedAttributeNameCache = {},
+      viewTransitionMutationContext = !1,
+      disabledDepth = 0,
+      prevLog,
+      prevInfo,
+      prevWarn,
+      prevError,
+      prevGroup,
+      prevGroupCollapsed,
+      prevGroupEnd;
+    disabledLog.__reactDisabledLog = !0;
+    var prefix,
+      suffix,
+      reentry = !1;
+    var componentFrameCache = new (
+      "function" === typeof WeakMap ? WeakMap : Map
+    )();
+    var current = null,
+      isRendering = !1,
+      escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g,
+      didWarnValueDefaultValue$1 = !1,
+      didWarnCheckedDefaultChecked = !1,
+      didWarnSelectedSetOnOption = !1,
+      didWarnInvalidChild = !1,
+      didWarnInvalidInnerHTML = !1;
+    var didWarnValueDefaultValue = !1;
+    var valuePropNames = ["value", "defaultValue"],
+      didWarnValDefaultVal = !1,
+      needsEscaping = /["'&<>\n\t]|^\s|\s$/,
+      specialTags =
+        "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
+          " "
+        ),
+      inScopeTags =
+        "applet caption html table td th marquee object template foreignObject desc title".split(
+          " "
+        ),
+      buttonScopeTags = inScopeTags.concat(["button"]),
+      impliedEndTags = "dd dt li option optgroup p rp rt".split(" "),
+      emptyAncestorInfoDev = {
+        current: null,
+        formTag: null,
+        aTagInScope: null,
+        buttonTagInScope: null,
+        nobrTagInScope: null,
+        pTagInButtonScope: null,
+        listItemTagAutoclosing: null,
+        dlItemTagAutoclosing: null,
+        containerTagInScope: null
+      },
+      didWarn = {},
+      shorthandToLonghand = {
+        animation:
+          "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
+            " "
+          ),
+        background:
+          "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
+            " "
+          ),
+        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
+        border:
+          "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
+            " "
+          ),
+        borderBlockEnd: [
+          "borderBlockEndColor",
+          "borderBlockEndStyle",
+          "borderBlockEndWidth"
+        ],
+        borderBlockStart: [
+          "borderBlockStartColor",
+          "borderBlockStartStyle",
+          "borderBlockStartWidth"
+        ],
+        borderBottom: [
+          "borderBottomColor",
+          "borderBottomStyle",
+          "borderBottomWidth"
+        ],
+        borderColor: [
+          "borderBottomColor",
+          "borderLeftColor",
+          "borderRightColor",
+          "borderTopColor"
+        ],
+        borderImage: [
+          "borderImageOutset",
+          "borderImageRepeat",
+          "borderImageSlice",
+          "borderImageSource",
+          "borderImageWidth"
+        ],
+        borderInlineEnd: [
+          "borderInlineEndColor",
+          "borderInlineEndStyle",
+          "borderInlineEndWidth"
+        ],
+        borderInlineStart: [
+          "borderInlineStartColor",
+          "borderInlineStartStyle",
+          "borderInlineStartWidth"
+        ],
+        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
+        borderRadius: [
+          "borderBottomLeftRadius",
+          "borderBottomRightRadius",
+          "borderTopLeftRadius",
+          "borderTopRightRadius"
+        ],
+        borderRight: [
+          "borderRightColor",
+          "borderRightStyle",
+          "borderRightWidth"
+        ],
+        borderStyle: [
+          "borderBottomStyle",
+          "borderLeftStyle",
+          "borderRightStyle",
+          "borderTopStyle"
+        ],
+        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
+        borderWidth: [
+          "borderBottomWidth",
+          "borderLeftWidth",
+          "borderRightWidth",
+          "borderTopWidth"
+        ],
+        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
+        columns: ["columnCount", "columnWidth"],
+        flex: ["flexBasis", "flexGrow", "flexShrink"],
+        flexFlow: ["flexDirection", "flexWrap"],
+        font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
+          " "
+        ),
+        fontVariant:
+          "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
+            " "
+          ),
+        gap: ["columnGap", "rowGap"],
+        grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
+          " "
+        ),
+        gridArea: [
+          "gridColumnEnd",
+          "gridColumnStart",
+          "gridRowEnd",
+          "gridRowStart"
+        ],
+        gridColumn: ["gridColumnEnd", "gridColumnStart"],
+        gridColumnGap: ["columnGap"],
+        gridGap: ["columnGap", "rowGap"],
+        gridRow: ["gridRowEnd", "gridRowStart"],
+        gridRowGap: ["rowGap"],
+        gridTemplate: [
+          "gridTemplateAreas",
+          "gridTemplateColumns",
+          "gridTemplateRows"
+        ],
+        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
+        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
+        marker: ["markerEnd", "markerMid", "markerStart"],
+        mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
+          " "
+        ),
+        maskPosition: ["maskPositionX", "maskPositionY"],
+        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
+        overflow: ["overflowX", "overflowY"],
+        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
+        placeContent: ["alignContent", "justifyContent"],
+        placeItems: ["alignItems", "justifyItems"],
+        placeSelf: ["alignSelf", "justifySelf"],
+        textDecoration: [
+          "textDecorationColor",
+          "textDecorationLine",
+          "textDecorationStyle"
+        ],
+        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
+        transition: [
+          "transitionDelay",
+          "transitionDuration",
+          "transitionProperty",
+          "transitionTimingFunction"
+        ],
+        wordWrap: ["overflowWrap"]
+      },
+      uppercasePattern = /([A-Z])/g,
+      msPattern$1 = /^ms-/,
+      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,
+      msPattern = /^-ms-/,
+      hyphenPattern = /-(.)/g,
+      badStyleValueWithSemicolonPattern = /;\s*$/,
+      warnedStyleNames = {},
+      warnedStyleValues = {},
+      warnedForNaNValue = !1,
+      warnedForInfinityValue = !1,
+      unitlessNumbers = new Set(
+        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
+          " "
+        )
+      ),
+      MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML",
+      SVG_NAMESPACE = "http://www.w3.org/2000/svg",
+      aliases = new Map([
+        ["acceptCharset", "accept-charset"],
+        ["htmlFor", "for"],
+        ["httpEquiv", "http-equiv"],
+        ["crossOrigin", "crossorigin"],
+        ["accentHeight", "accent-height"],
+        ["alignmentBaseline", "alignment-baseline"],
+        ["arabicForm", "arabic-form"],
+        ["baselineShift", "baseline-shift"],
+        ["capHeight", "cap-height"],
+        ["clipPath", "clip-path"],
+        ["clipRule", "clip-rule"],
+        ["colorInterpolation", "color-interpolation"],
+        ["colorInterpolationFilters", "color-interpolation-filters"],
+        ["colorProfile", "color-profile"],
+        ["colorRendering", "color-rendering"],
+        ["dominantBaseline", "dominant-baseline"],
+        ["enableBackground", "enable-background"],
+        ["fillOpacity", "fill-opacity"],
+        ["fillRule", "fill-rule"],
+        ["floodColor", "flood-color"],
+        ["floodOpacity", "flood-opacity"],
+        ["fontFamily", "font-family"],
+        ["fontSize", "font-size"],
+        ["fontSizeAdjust", "font-size-adjust"],
+        ["fontStretch", "font-stretch"],
+        ["fontStyle", "font-style"],
+        ["fontVariant", "font-variant"],
+        ["fontWeight", "font-weight"],
+        ["glyphName", "glyph-name"],
+        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
+        ["glyphOrientationVertical", "glyph-orientation-vertical"],
+        ["horizAdvX", "horiz-adv-x"],
+        ["horizOriginX", "horiz-origin-x"],
+        ["imageRendering", "image-rendering"],
+        ["letterSpacing", "letter-spacing"],
+        ["lightingColor", "lighting-color"],
+        ["markerEnd", "marker-end"],
+        ["markerMid", "marker-mid"],
+        ["markerStart", "marker-start"],
+        ["overlinePosition", "overline-position"],
+        ["overlineThickness", "overline-thickness"],
+        ["paintOrder", "paint-order"],
+        ["panose-1", "panose-1"],
+        ["pointerEvents", "pointer-events"],
+        ["renderingIntent", "rendering-intent"],
+        ["shapeRendering", "shape-rendering"],
+        ["stopColor", "stop-color"],
+        ["stopOpacity", "stop-opacity"],
+        ["strikethroughPosition", "strikethrough-position"],
+        ["strikethroughThickness", "strikethrough-thickness"],
+        ["strokeDasharray", "stroke-dasharray"],
+        ["strokeDashoffset", "stroke-dashoffset"],
+        ["strokeLinecap", "stroke-linecap"],
+        ["strokeLinejoin", "stroke-linejoin"],
+        ["strokeMiterlimit", "stroke-miterlimit"],
+        ["strokeOpacity", "stroke-opacity"],
+        ["strokeWidth", "stroke-width"],
+        ["textAnchor", "text-anchor"],
+        ["textDecoration", "text-decoration"],
+        ["textRendering", "text-rendering"],
+        ["transformOrigin", "transform-origin"],
+        ["underlinePosition", "underline-position"],
+        ["underlineThickness", "underline-thickness"],
+        ["unicodeBidi", "unicode-bidi"],
+        ["unicodeRange", "unicode-range"],
+        ["unitsPerEm", "units-per-em"],
+        ["vAlphabetic", "v-alphabetic"],
+        ["vHanging", "v-hanging"],
+        ["vIdeographic", "v-ideographic"],
+        ["vMathematical", "v-mathematical"],
+        ["vectorEffect", "vector-effect"],
+        ["vertAdvY", "vert-adv-y"],
+        ["vertOriginX", "vert-origin-x"],
+        ["vertOriginY", "vert-origin-y"],
+        ["wordSpacing", "word-spacing"],
+        ["writingMode", "writing-mode"],
+        ["xmlnsXlink", "xmlns:xlink"],
+        ["xHeight", "x-height"]
+      ]),
+      possibleStandardNames = {
+        accept: "accept",
+        acceptcharset: "acceptCharset",
+        "accept-charset": "acceptCharset",
+        accesskey: "accessKey",
+        action: "action",
+        allowfullscreen: "allowFullScreen",
+        alt: "alt",
+        as: "as",
+        async: "async",
+        autocapitalize: "autoCapitalize",
+        autocomplete: "autoComplete",
+        autocorrect: "autoCorrect",
+        autofocus: "autoFocus",
+        autoplay: "autoPlay",
+        autosave: "autoSave",
+        capture: "capture",
+        cellpadding: "cellPadding",
+        cellspacing: "cellSpacing",
+        challenge: "challenge",
+        charset: "charSet",
+        checked: "checked",
+        children: "children",
+        cite: "cite",
+        class: "className",
+        classid: "classID",
+        classname: "className",
+        cols: "cols",
+        colspan: "colSpan",
+        content: "content",
+        contenteditable: "contentEditable",
+        contextmenu: "contextMenu",
+        controls: "controls",
+        controlslist: "controlsList",
+        coords: "coords",
+        crossorigin: "crossOrigin",
+        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
+        data: "data",
+        datetime: "dateTime",
+        default: "default",
+        defaultchecked: "defaultChecked",
+        defaultvalue: "defaultValue",
+        defer: "defer",
+        dir: "dir",
+        disabled: "disabled",
+        disablepictureinpicture: "disablePictureInPicture",
+        disableremoteplayback: "disableRemotePlayback",
+        download: "download",
+        draggable: "draggable",
+        enctype: "encType",
+        enterkeyhint: "enterKeyHint",
+        fetchpriority: "fetchPriority",
+        for: "htmlFor",
+        form: "form",
+        formmethod: "formMethod",
+        formaction: "formAction",
+        formenctype: "formEncType",
+        formnovalidate: "formNoValidate",
+        formtarget: "formTarget",
+        frameborder: "frameBorder",
+        headers: "headers",
+        height: "height",
+        hidden: "hidden",
+        high: "high",
+        href: "href",
+        hreflang: "hrefLang",
+        htmlfor: "htmlFor",
+        httpequiv: "httpEquiv",
+        "http-equiv": "httpEquiv",
+        icon: "icon",
+        id: "id",
+        imagesizes: "imageSizes",
+        imagesrcset: "imageSrcSet",
+        inert: "inert",
+        innerhtml: "innerHTML",
+        inputmode: "inputMode",
+        integrity: "integrity",
+        is: "is",
+        itemid: "itemID",
+        itemprop: "itemProp",
+        itemref: "itemRef",
+        itemscope: "itemScope",
+        itemtype: "itemType",
+        keyparams: "keyParams",
+        keytype: "keyType",
+        kind: "kind",
+        label: "label",
+        lang: "lang",
+        list: "list",
+        loop: "loop",
+        low: "low",
+        manifest: "manifest",
+        marginwidth: "marginWidth",
+        marginheight: "marginHeight",
+        max: "max",
+        maxlength: "maxLength",
+        media: "media",
+        mediagroup: "mediaGroup",
+        method: "method",
+        min: "min",
+        minlength: "minLength",
+        multiple: "multiple",
+        muted: "muted",
+        name: "name",
+        nomodule: "noModule",
+        nonce: "nonce",
+        novalidate: "noValidate",
+        open: "open",
+        optimum: "optimum",
+        pattern: "pattern",
+        placeholder: "placeholder",
+        playsinline: "playsInline",
+        poster: "poster",
+        preload: "preload",
+        profile: "profile",
+        radiogroup: "radioGroup",
+        readonly: "readOnly",
+        referrerpolicy: "referrerPolicy",
+        rel: "rel",
+        required: "required",
+        reversed: "reversed",
+        role: "role",
+        rows: "rows",
+        rowspan: "rowSpan",
+        sandbox: "sandbox",
+        scope: "scope",
+        scoped: "scoped",
+        scrolling: "scrolling",
+        seamless: "seamless",
+        selected: "selected",
+        shape: "shape",
+        size: "size",
+        sizes: "sizes",
+        span: "span",
+        spellcheck: "spellCheck",
+        src: "src",
+        srcdoc: "srcDoc",
+        srclang: "srcLang",
+        srcset: "srcSet",
+        start: "start",
+        step: "step",
+        style: "style",
+        summary: "summary",
+        tabindex: "tabIndex",
+        target: "target",
+        title: "title",
+        type: "type",
+        usemap: "useMap",
+        value: "value",
+        width: "width",
+        wmode: "wmode",
+        wrap: "wrap",
+        about: "about",
+        accentheight: "accentHeight",
+        "accent-height": "accentHeight",
+        accumulate: "accumulate",
+        additive: "additive",
+        alignmentbaseline: "alignmentBaseline",
+        "alignment-baseline": "alignmentBaseline",
+        allowreorder: "allowReorder",
+        alphabetic: "alphabetic",
+        amplitude: "amplitude",
+        arabicform: "arabicForm",
+        "arabic-form": "arabicForm",
+        ascent: "ascent",
+        attributename: "attributeName",
+        attributetype: "attributeType",
+        autoreverse: "autoReverse",
+        azimuth: "azimuth",
+        basefrequency: "baseFrequency",
+        baselineshift: "baselineShift",
+        "baseline-shift": "baselineShift",
+        baseprofile: "baseProfile",
+        bbox: "bbox",
+        begin: "begin",
+        bias: "bias",
+        by: "by",
+        calcmode: "calcMode",
+        capheight: "capHeight",
+        "cap-height": "capHeight",
+        clip: "clip",
+        clippath: "clipPath",
+        "clip-path": "clipPath",
+        clippathunits: "clipPathUnits",
+        cliprule: "clipRule",
+        "clip-rule": "clipRule",
+        color: "color",
+        colorinterpolation: "colorInterpolation",
+        "color-interpolation": "colorInterpolation",
+        colorinterpolationfilters: "colorInterpolationFilters",
+        "color-interpolation-filters": "colorInterpolationFilters",
+        colorprofile: "colorProfile",
+        "color-profile": "colorProfile",
+        colorrendering: "colorRendering",
+        "color-rendering": "colorRendering",
+        contentscripttype: "contentScriptType",
+        contentstyletype: "contentStyleType",
+        cursor: "cursor",
+        cx: "cx",
+        cy: "cy",
+        d: "d",
+        datatype: "datatype",
+        decelerate: "decelerate",
+        descent: "descent",
+        diffuseconstant: "diffuseConstant",
+        direction: "direction",
+        display: "display",
+        divisor: "divisor",
+        dominantbaseline: "dominantBaseline",
+        "dominant-baseline": "dominantBaseline",
+        dur: "dur",
+        dx: "dx",
+        dy: "dy",
+        edgemode: "edgeMode",
+        elevation: "elevation",
+        enablebackground: "enableBackground",
+        "enable-background": "enableBackground",
+        end: "end",
+        exponent: "exponent",
+        externalresourcesrequired: "externalResourcesRequired",
+        fill: "fill",
+        fillopacity: "fillOpacity",
+        "fill-opacity": "fillOpacity",
+        fillrule: "fillRule",
+        "fill-rule": "fillRule",
+        filter: "filter",
+        filterres: "filterRes",
+        filterunits: "filterUnits",
+        floodopacity: "floodOpacity",
+        "flood-opacity": "floodOpacity",
+        floodcolor: "floodColor",
+        "flood-color": "floodColor",
+        focusable: "focusable",
+        fontfamily: "fontFamily",
+        "font-family": "fontFamily",
+        fontsize: "fontSize",
+        "font-size": "fontSize",
+        fontsizeadjust: "fontSizeAdjust",
+        "font-size-adjust": "fontSizeAdjust",
+        fontstretch: "fontStretch",
+        "font-stretch": "fontStretch",
+        fontstyle: "fontStyle",
+        "font-style": "fontStyle",
+        fontvariant: "fontVariant",
+        "font-variant": "fontVariant",
+        fontweight: "fontWeight",
+        "font-weight": "fontWeight",
+        format: "format",
+        from: "from",
+        fx: "fx",
+        fy: "fy",
+        g1: "g1",
+        g2: "g2",
+        glyphname: "glyphName",
+        "glyph-name": "glyphName",
+        glyphorientationhorizontal: "glyphOrientationHorizontal",
+        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
+        glyphorientationvertical: "glyphOrientationVertical",
+        "glyph-orientation-vertical": "glyphOrientationVertical",
+        glyphref: "glyphRef",
+        gradienttransform: "gradientTransform",
+        gradientunits: "gradientUnits",
+        hanging: "hanging",
+        horizadvx: "horizAdvX",
+        "horiz-adv-x": "horizAdvX",
+        horizoriginx: "horizOriginX",
+        "horiz-origin-x": "horizOriginX",
+        ideographic: "ideographic",
+        imagerendering: "imageRendering",
+        "image-rendering": "imageRendering",
+        in2: "in2",
+        in: "in",
+        inlist: "inlist",
+        intercept: "intercept",
+        k1: "k1",
+        k2: "k2",
+        k3: "k3",
+        k4: "k4",
+        k: "k",
+        kernelmatrix: "kernelMatrix",
+        kernelunitlength: "kernelUnitLength",
+        kerning: "kerning",
+        keypoints: "keyPoints",
+        keysplines: "keySplines",
+        keytimes: "keyTimes",
+        lengthadjust: "lengthAdjust",
+        letterspacing: "letterSpacing",
+        "letter-spacing": "letterSpacing",
+        lightingcolor: "lightingColor",
+        "lighting-color": "lightingColor",
+        limitingconeangle: "limitingConeAngle",
+        local: "local",
+        markerend: "markerEnd",
+        "marker-end": "markerEnd",
+        markerheight: "markerHeight",
+        markermid: "markerMid",
+        "marker-mid": "markerMid",
+        markerstart: "markerStart",
+        "marker-start": "markerStart",
+        markerunits: "markerUnits",
+        markerwidth: "markerWidth",
+        mask: "mask",
+        maskcontentunits: "maskContentUnits",
+        maskunits: "maskUnits",
+        mathematical: "mathematical",
+        mode: "mode",
+        numoctaves: "numOctaves",
+        offset: "offset",
+        opacity: "opacity",
+        operator: "operator",
+        order: "order",
+        orient: "orient",
+        orientation: "orientation",
+        origin: "origin",
+        overflow: "overflow",
+        overlineposition: "overlinePosition",
+        "overline-position": "overlinePosition",
+        overlinethickness: "overlineThickness",
+        "overline-thickness": "overlineThickness",
+        paintorder: "paintOrder",
+        "paint-order": "paintOrder",
+        panose1: "panose1",
+        "panose-1": "panose1",
+        pathlength: "pathLength",
+        patterncontentunits: "patternContentUnits",
+        patterntransform: "patternTransform",
+        patternunits: "patternUnits",
+        pointerevents: "pointerEvents",
+        "pointer-events": "pointerEvents",
+        points: "points",
+        pointsatx: "pointsAtX",
+        pointsaty: "pointsAtY",
+        pointsatz: "pointsAtZ",
+        popover: "popover",
+        popovertarget: "popoverTarget",
+        popovertargetaction: "popoverTargetAction",
+        prefix: "prefix",
+        preservealpha: "preserveAlpha",
+        preserveaspectratio: "preserveAspectRatio",
+        primitiveunits: "primitiveUnits",
+        property: "property",
+        r: "r",
+        radius: "radius",
+        refx: "refX",
+        refy: "refY",
+        renderingintent: "renderingIntent",
+        "rendering-intent": "renderingIntent",
+        repeatcount: "repeatCount",
+        repeatdur: "repeatDur",
+        requiredextensions: "requiredExtensions",
+        requiredfeatures: "requiredFeatures",
+        resource: "resource",
+        restart: "restart",
+        result: "result",
+        results: "results",
+        rotate: "rotate",
+        rx: "rx",
+        ry: "ry",
+        scale: "scale",
+        security: "security",
+        seed: "seed",
+        shaperendering: "shapeRendering",
+        "shape-rendering": "shapeRendering",
+        slope: "slope",
+        spacing: "spacing",
+        specularconstant: "specularConstant",
+        specularexponent: "specularExponent",
+        speed: "speed",
+        spreadmethod: "spreadMethod",
+        startoffset: "startOffset",
+        stddeviation: "stdDeviation",
+        stemh: "stemh",
+        stemv: "stemv",
+        stitchtiles: "stitchTiles",
+        stopcolor: "stopColor",
+        "stop-color": "stopColor",
+        stopopacity: "stopOpacity",
+        "stop-opacity": "stopOpacity",
+        strikethroughposition: "strikethroughPosition",
+        "strikethrough-position": "strikethroughPosition",
+        strikethroughthickness: "strikethroughThickness",
+        "strikethrough-thickness": "strikethroughThickness",
+        string: "string",
+        stroke: "stroke",
+        strokedasharray: "strokeDasharray",
+        "stroke-dasharray": "strokeDasharray",
+        strokedashoffset: "strokeDashoffset",
+        "stroke-dashoffset": "strokeDashoffset",
+        strokelinecap: "strokeLinecap",
+        "stroke-linecap": "strokeLinecap",
+        strokelinejoin: "strokeLinejoin",
+        "stroke-linejoin": "strokeLinejoin",
+        strokemiterlimit: "strokeMiterlimit",
+        "stroke-miterlimit": "strokeMiterlimit",
+        strokewidth: "strokeWidth",
+        "stroke-width": "strokeWidth",
+        strokeopacity: "strokeOpacity",
+        "stroke-opacity": "strokeOpacity",
+        suppresscontenteditablewarning: "suppressContentEditableWarning",
+        suppresshydrationwarning: "suppressHydrationWarning",
+        surfacescale: "surfaceScale",
+        systemlanguage: "systemLanguage",
+        tablevalues: "tableValues",
+        targetx: "targetX",
+        targety: "targetY",
+        textanchor: "textAnchor",
+        "text-anchor": "textAnchor",
+        textdecoration: "textDecoration",
+        "text-decoration": "textDecoration",
+        textlength: "textLength",
+        textrendering: "textRendering",
+        "text-rendering": "textRendering",
+        to: "to",
+        transform: "transform",
+        transformorigin: "transformOrigin",
+        "transform-origin": "transformOrigin",
+        typeof: "typeof",
+        u1: "u1",
+        u2: "u2",
+        underlineposition: "underlinePosition",
+        "underline-position": "underlinePosition",
+        underlinethickness: "underlineThickness",
+        "underline-thickness": "underlineThickness",
+        unicode: "unicode",
+        unicodebidi: "unicodeBidi",
+        "unicode-bidi": "unicodeBidi",
+        unicoderange: "unicodeRange",
+        "unicode-range": "unicodeRange",
+        unitsperem: "unitsPerEm",
+        "units-per-em": "unitsPerEm",
+        unselectable: "unselectable",
+        valphabetic: "vAlphabetic",
+        "v-alphabetic": "vAlphabetic",
+        values: "values",
+        vectoreffect: "vectorEffect",
+        "vector-effect": "vectorEffect",
+        version: "version",
+        vertadvy: "vertAdvY",
+        "vert-adv-y": "vertAdvY",
+        vertoriginx: "vertOriginX",
+        "vert-origin-x": "vertOriginX",
+        vertoriginy: "vertOriginY",
+        "vert-origin-y": "vertOriginY",
+        vhanging: "vHanging",
+        "v-hanging": "vHanging",
+        videographic: "vIdeographic",
+        "v-ideographic": "vIdeographic",
+        viewbox: "viewBox",
+        viewtarget: "viewTarget",
+        visibility: "visibility",
+        vmathematical: "vMathematical",
+        "v-mathematical": "vMathematical",
+        vocab: "vocab",
+        widths: "widths",
+        wordspacing: "wordSpacing",
+        "word-spacing": "wordSpacing",
+        writingmode: "writingMode",
+        "writing-mode": "writingMode",
+        x1: "x1",
+        x2: "x2",
+        x: "x",
+        xchannelselector: "xChannelSelector",
+        xheight: "xHeight",
+        "x-height": "xHeight",
+        xlinkactuate: "xlinkActuate",
+        "xlink:actuate": "xlinkActuate",
+        xlinkarcrole: "xlinkArcrole",
+        "xlink:arcrole": "xlinkArcrole",
+        xlinkhref: "xlinkHref",
+        "xlink:href": "xlinkHref",
+        xlinkrole: "xlinkRole",
+        "xlink:role": "xlinkRole",
+        xlinkshow: "xlinkShow",
+        "xlink:show": "xlinkShow",
+        xlinktitle: "xlinkTitle",
+        "xlink:title": "xlinkTitle",
+        xlinktype: "xlinkType",
+        "xlink:type": "xlinkType",
+        xmlbase: "xmlBase",
+        "xml:base": "xmlBase",
+        xmllang: "xmlLang",
+        "xml:lang": "xmlLang",
+        xmlns: "xmlns",
+        "xml:space": "xmlSpace",
+        xmlnsxlink: "xmlnsXlink",
+        "xmlns:xlink": "xmlnsXlink",
+        xmlspace: "xmlSpace",
+        y1: "y1",
+        y2: "y2",
+        y: "y",
+        ychannelselector: "yChannelSelector",
+        z: "z",
+        zoomandpan: "zoomAndPan"
+      },
+      ariaProperties = {
+        "aria-current": 0,
+        "aria-description": 0,
+        "aria-details": 0,
+        "aria-disabled": 0,
+        "aria-hidden": 0,
+        "aria-invalid": 0,
+        "aria-keyshortcuts": 0,
+        "aria-label": 0,
+        "aria-roledescription": 0,
+        "aria-autocomplete": 0,
+        "aria-checked": 0,
+        "aria-expanded": 0,
+        "aria-haspopup": 0,
+        "aria-level": 0,
+        "aria-modal": 0,
+        "aria-multiline": 0,
+        "aria-multiselectable": 0,
+        "aria-orientation": 0,
+        "aria-placeholder": 0,
+        "aria-pressed": 0,
+        "aria-readonly": 0,
+        "aria-required": 0,
+        "aria-selected": 0,
+        "aria-sort": 0,
+        "aria-valuemax": 0,
+        "aria-valuemin": 0,
+        "aria-valuenow": 0,
+        "aria-valuetext": 0,
+        "aria-atomic": 0,
+        "aria-busy": 0,
+        "aria-live": 0,
+        "aria-relevant": 0,
+        "aria-dropeffect": 0,
+        "aria-grabbed": 0,
+        "aria-activedescendant": 0,
+        "aria-colcount": 0,
+        "aria-colindex": 0,
+        "aria-colspan": 0,
+        "aria-controls": 0,
+        "aria-describedby": 0,
+        "aria-errormessage": 0,
+        "aria-flowto": 0,
+        "aria-labelledby": 0,
+        "aria-owns": 0,
+        "aria-posinset": 0,
+        "aria-rowcount": 0,
+        "aria-rowindex": 0,
+        "aria-rowspan": 0,
+        "aria-setsize": 0
+      },
+      warnedProperties$1 = {},
+      rARIA$1 = RegExp(
+        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
+      ),
+      rARIACamel$1 = RegExp(
+        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
+      ),
+      didWarnValueNull = !1,
+      warnedProperties = {},
+      EVENT_NAME_REGEX = /^on./,
+      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,
+      rARIA = RegExp(
+        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
+      ),
+      rARIACamel = RegExp(
+        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
+      ),
+      isJavaScriptProtocol =
+        /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i,
+      currentReplayingEvent = null,
+      restoreTarget = null,
+      restoreQueue = null,
+      isInsideEventHandler = !1,
+      canUseDOM = !(
+        "undefined" === typeof window ||
+        "undefined" === typeof window.document ||
+        "undefined" === typeof window.document.createElement
+      ),
+      passiveBrowserEventsSupported = !1;
+    if (canUseDOM)
+      try {
+        var options$jscomp$0 = {};
+        Object.defineProperty(options$jscomp$0, "passive", {
+          get: function () {
+            passiveBrowserEventsSupported = !0;
+          }
+        });
+        window.addEventListener("test", options$jscomp$0, options$jscomp$0);
+        window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
+      } catch (e) {
+        passiveBrowserEventsSupported = !1;
+      }
+    var root = null,
+      startText = null,
+      fallbackText = null,
+      EventInterface = {
+        eventPhase: 0,
+        bubbles: 0,
+        cancelable: 0,
+        timeStamp: function (event) {
+          return event.timeStamp || Date.now();
+        },
+        defaultPrevented: 0,
+        isTrusted: 0
+      },
+      SyntheticEvent = createSyntheticEvent(EventInterface),
+      UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
+      SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
+      lastMovementX,
+      lastMovementY,
+      lastMouseEvent,
+      MouseEventInterface = assign({}, UIEventInterface, {
+        screenX: 0,
+        screenY: 0,
+        clientX: 0,
+        clientY: 0,
+        pageX: 0,
+        pageY: 0,
+        ctrlKey: 0,
+        shiftKey: 0,
+        altKey: 0,
+        metaKey: 0,
+        getModifierState: getEventModifierState,
+        button: 0,
+        buttons: 0,
+        relatedTarget: function (event) {
+          return void 0 === event.relatedTarget
+            ? event.fromElement === event.srcElement
+              ? event.toElement
+              : event.fromElement
+            : event.relatedTarget;
+        },
+        movementX: function (event) {
+          if ("movementX" in event) return event.movementX;
+          event !== lastMouseEvent &&
+            (lastMouseEvent && "mousemove" === event.type
+              ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
+                (lastMovementY = event.screenY - lastMouseEvent.screenY))
+              : (lastMovementY = lastMovementX = 0),
+            (lastMouseEvent = event));
+          return lastMovementX;
+        },
+        movementY: function (event) {
+          return "movementY" in event ? event.movementY : lastMovementY;
+        }
+      }),
+      SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
+      DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
+      SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
+      FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
+      SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
+      AnimationEventInterface = assign({}, EventInterface, {
+        animationName: 0,
+        elapsedTime: 0,
+        pseudoElement: 0
+      }),
+      SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
+      ClipboardEventInterface = assign({}, EventInterface, {
+        clipboardData: function (event) {
+          return "clipboardData" in event
+            ? event.clipboardData
+            : window.clipboardData;
+        }
+      }),
+      SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
+      CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
+      SyntheticCompositionEvent = createSyntheticEvent(
+        CompositionEventInterface
+      ),
+      SyntheticInputEvent = SyntheticCompositionEvent,
+      normalizeKey = {
+        Esc: "Escape",
+        Spacebar: " ",
+        Left: "ArrowLeft",
+        Up: "ArrowUp",
+        Right: "ArrowRight",
+        Down: "ArrowDown",
+        Del: "Delete",
+        Win: "OS",
+        Menu: "ContextMenu",
+        Apps: "ContextMenu",
+        Scroll: "ScrollLock",
+        MozPrintableKey: "Unidentified"
+      },
+      translateToKey = {
+        8: "Backspace",
+        9: "Tab",
+        12: "Clear",
+        13: "Enter",
+        16: "Shift",
+        17: "Control",
+        18: "Alt",
+        19: "Pause",
+        20: "CapsLock",
+        27: "Escape",
+        32: " ",
+        33: "PageUp",
+        34: "PageDown",
+        35: "End",
+        36: "Home",
+        37: "ArrowLeft",
+        38: "ArrowUp",
+        39: "ArrowRight",
+        40: "ArrowDown",
+        45: "Insert",
+        46: "Delete",
+        112: "F1",
+        113: "F2",
+        114: "F3",
+        115: "F4",
+        116: "F5",
+        117: "F6",
+        118: "F7",
+        119: "F8",
+        120: "F9",
+        121: "F10",
+        122: "F11",
+        123: "F12",
+        144: "NumLock",
+        145: "ScrollLock",
+        224: "Meta"
+      },
+      modifierKeyToProp = {
+        Alt: "altKey",
+        Control: "ctrlKey",
+        Meta: "metaKey",
+        Shift: "shiftKey"
+      },
+      KeyboardEventInterface = assign({}, UIEventInterface, {
+        key: function (nativeEvent) {
+          if (nativeEvent.key) {
+            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
+            if ("Unidentified" !== key) return key;
+          }
+          return "keypress" === nativeEvent.type
+            ? ((nativeEvent = getEventCharCode(nativeEvent)),
+              13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
+            : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
+              ? translateToKey[nativeEvent.keyCode] || "Unidentified"
+              : "";
+        },
+        code: 0,
+        location: 0,
+        ctrlKey: 0,
+        shiftKey: 0,
+        altKey: 0,
+        metaKey: 0,
+        repeat: 0,
+        locale: 0,
+        getModifierState: getEventModifierState,
+        charCode: function (event) {
+          return "keypress" === event.type ? getEventCharCode(event) : 0;
+        },
+        keyCode: function (event) {
+          return "keydown" === event.type || "keyup" === event.type
+            ? event.keyCode
+            : 0;
+        },
+        which: function (event) {
+          return "keypress" === event.type
+            ? getEventCharCode(event)
+            : "keydown" === event.type || "keyup" === event.type
+              ? event.keyCode
+              : 0;
+        }
+      }),
+      SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
+      PointerEventInterface = assign({}, MouseEventInterface, {
+        pointerId: 0,
+        width: 0,
+        height: 0,
+        pressure: 0,
+        tangentialPressure: 0,
+        tiltX: 0,
+        tiltY: 0,
+        twist: 0,
+        pointerType: 0,
+        isPrimary: 0
+      }),
+      SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
+      TouchEventInterface = assign({}, UIEventInterface, {
+        touches: 0,
+        targetTouches: 0,
+        changedTouches: 0,
+        altKey: 0,
+        metaKey: 0,
+        ctrlKey: 0,
+        shiftKey: 0,
+        getModifierState: getEventModifierState
+      }),
+      SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
+      TransitionEventInterface = assign({}, EventInterface, {
+        propertyName: 0,
+        elapsedTime: 0,
+        pseudoElement: 0
+      }),
+      SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
+      WheelEventInterface = assign({}, MouseEventInterface, {
+        deltaX: function (event) {
+          return "deltaX" in event
+            ? event.deltaX
+            : "wheelDeltaX" in event
+              ? -event.wheelDeltaX
+              : 0;
+        },
+        deltaY: function (event) {
+          return "deltaY" in event
+            ? event.deltaY
+            : "wheelDeltaY" in event
+              ? -event.wheelDeltaY
+              : "wheelDelta" in event
+                ? -event.wheelDelta
+                : 0;
+        },
+        deltaZ: 0,
+        deltaMode: 0
+      }),
+      SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
+      ToggleEventInterface = assign({}, EventInterface, {
+        newState: 0,
+        oldState: 0
+      }),
+      SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
+      END_KEYCODES = [9, 13, 27, 32],
+      START_KEYCODE = 229,
+      canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
+      documentMode = null;
+    canUseDOM &&
+      "documentMode" in document &&
+      (documentMode = document.documentMode);
+    var canUseTextInputEvent =
+        canUseDOM && "TextEvent" in window && !documentMode,
+      useFallbackCompositionData =
+        canUseDOM &&
+        (!canUseCompositionEvent ||
+          (documentMode && 8 < documentMode && 11 >= documentMode)),
+      SPACEBAR_CODE = 32,
+      SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE),
+      hasSpaceKeypress = !1,
+      isComposing = !1,
+      supportedInputTypes = {
+        color: !0,
+        date: !0,
+        datetime: !0,
+        "datetime-local": !0,
+        email: !0,
+        month: !0,
+        number: !0,
+        password: !0,
+        range: !0,
+        search: !0,
+        tel: !0,
+        text: !0,
+        time: !0,
+        url: !0,
+        week: !0
+      },
+      activeElement$1 = null,
+      activeElementInst$1 = null,
+      isInputEventSupported = !1;
+    canUseDOM &&
+      (isInputEventSupported =
+        isEventSupported("input") &&
+        (!document.documentMode || 9 < document.documentMode));
+    var objectIs = "function" === typeof Object.is ? Object.is : is,
+      skipSelectionChangeEvent =
+        canUseDOM && "documentMode" in document && 11 >= document.documentMode,
+      activeElement = null,
+      activeElementInst = null,
+      lastSelection = null,
+      mouseDown = !1,
+      vendorPrefixes = {
+        animationend: makePrefixMap("Animation", "AnimationEnd"),
+        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
+        animationstart: makePrefixMap("Animation", "AnimationStart"),
+        transitionrun: makePrefixMap("Transition", "TransitionRun"),
+        transitionstart: makePrefixMap("Transition", "TransitionStart"),
+        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
+        transitionend: makePrefixMap("Transition", "TransitionEnd")
+      },
+      prefixedEventNames = {},
+      style = {};
+    canUseDOM &&
+      ((style = document.createElement("div").style),
+      "AnimationEvent" in window ||
+        (delete vendorPrefixes.animationend.animation,
+        delete vendorPrefixes.animationiteration.animation,
+        delete vendorPrefixes.animationstart.animation),
+      "TransitionEvent" in window ||
+        delete vendorPrefixes.transitionend.transition);
+    var ANIMATION_END = getVendorPrefixedEventName("animationend"),
+      ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
+      ANIMATION_START = getVendorPrefixedEventName("animationstart"),
+      TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
+      TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
+      TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
+      TRANSITION_END = getVendorPrefixedEventName("transitionend"),
+      topLevelEventsToReactNames = new Map(),
+      simpleEventPluginEvents =
+        "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
+          " "
+        ),
+      CapturedStacks = new WeakMap(),
+      OffscreenVisible = 1,
+      OffscreenDetached = 2,
+      OffscreenPassiveEffectsConnected = 4,
+      concurrentQueues = [],
+      concurrentQueuesIndex = 0,
+      concurrentlyUpdatedLanes = 0,
+      emptyContextObject = {};
+    Object.freeze(emptyContextObject);
+    var resolveFamily = null,
+      failedBoundaries = null,
+      NoMode = 0,
+      ConcurrentMode = 1,
+      ProfileMode = 2,
+      StrictLegacyMode = 8,
+      StrictEffectsMode = 16,
+      NoStrictPassiveEffectsMode = 64,
+      now = Scheduler.unstable_now,
+      renderStartTime = -0,
+      commitStartTime = -0,
+      commitEndTime = -0,
+      commitErrors = null,
+      profilerStartTime = -1.1,
+      profilerEffectDuration = -0,
+      componentEffectDuration = -0,
+      componentEffectStartTime = -1.1,
+      componentEffectEndTime = -1.1,
+      componentEffectErrors = null,
+      blockingClampTime = -0,
+      blockingUpdateTime = -1.1,
+      blockingEventTime = -1.1,
+      blockingEventType = null,
+      blockingEventIsRepeat = !1,
+      blockingSpawnedUpdate = !1,
+      blockingSuspendedTime = -1.1,
+      transitionClampTime = -0,
+      transitionStartTime = -1.1,
+      transitionUpdateTime = -1.1,
+      transitionEventTime = -1.1,
+      transitionEventType = null,
+      transitionEventIsRepeat = !1,
+      transitionSuspendedTime = -1.1,
+      yieldReason = 0,
+      yieldStartTime = -1.1,
+      currentUpdateIsNested = !1,
+      nestedUpdateScheduled = !1,
+      supportsUserTiming =
+        "undefined" !== typeof performance &&
+        "function" === typeof performance.measure,
+      COMPONENTS_TRACK = "Components \u269b",
+      reusableComponentDevToolDetails = {
+        color: "primary",
+        track: COMPONENTS_TRACK
+      },
+      reusableComponentOptions = {
+        start: -0,
+        end: -0,
+        detail: { devtools: reusableComponentDevToolDetails }
+      },
+      LANES_TRACK_GROUP = "Scheduler \u269b",
+      reusableLaneDevToolDetails = {
+        color: "primary",
+        track: "Blocking",
+        trackGroup: LANES_TRACK_GROUP
+      },
+      reusableLaneOptions = {
+        start: -0,
+        end: -0,
+        detail: { devtools: reusableLaneDevToolDetails }
+      },
+      blockingLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Blocking",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
+      transitionLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Transition",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
+      suspenseLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Suspense",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
+      idleLaneMarker = {
+        startTime: 0.003,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Idle",
+            trackGroup: LANES_TRACK_GROUP
+          }
+        }
+      },
+      valueCursor = createCursor(null);
+    var rendererCursorDEV = createCursor(null);
+    var rendererSigil = {};
+    var currentlyRenderingFiber$1 = null,
+      lastContextDependency = null,
+      isDisallowedContextReadInDEV = !1,
+      currentEntangledListeners = null,
+      currentEntangledPendingCount = 0,
+      currentEntangledLane = 0,
+      currentEntangledActionThenable = null,
+      UpdateState = 0,
+      ReplaceState = 1,
+      ForceUpdate = 2,
+      CaptureUpdate = 3,
+      hasForceUpdate = !1;
+    var didWarnUpdateInsideUpdate = !1;
+    var currentlyProcessingQueue = null;
+    var didReadFromEntangledAsyncAction = !1,
+      NoFlags = 0,
+      HasEffect = 1,
+      Insertion = 2,
+      Layout = 4,
+      Passive = 8,
+      AbortControllerLocal =
+        "undefined" !== typeof AbortController
+          ? AbortController
+          : function () {
+              var listeners = [],
+                signal = (this.signal = {
+                  aborted: !1,
+                  addEventListener: function (type, listener) {
+                    listeners.push(listener);
+                  }
+                });
+              this.abort = function () {
+                signal.aborted = !0;
+                listeners.forEach(function (listener) {
+                  return listener();
+                });
+              };
+            },
+      scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
+      NormalPriority = Scheduler.unstable_NormalPriority,
+      CacheContext = {
+        $$typeof: REACT_CONTEXT_TYPE,
+        Consumer: null,
+        Provider: null,
+        _currentValue: null,
+        _currentValue2: null,
+        _threadCount: 0,
+        _currentRenderer: null,
+        _currentRenderer2: null
+      },
+      ReactStrictModeWarnings = {
+        recordUnsafeLifecycleWarnings: function () {},
+        flushPendingUnsafeLifecycleWarnings: function () {},
+        recordLegacyContextWarning: function () {},
+        flushLegacyContextWarning: function () {},
+        discardPendingWarnings: function () {}
+      },
+      pendingComponentWillMountWarnings = [],
+      pendingUNSAFE_ComponentWillMountWarnings = [],
+      pendingComponentWillReceivePropsWarnings = [],
+      pendingUNSAFE_ComponentWillReceivePropsWarnings = [],
+      pendingComponentWillUpdateWarnings = [],
+      pendingUNSAFE_ComponentWillUpdateWarnings = [],
+      didWarnAboutUnsafeLifecycles = new Set();
+    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (
+      fiber,
+      instance
+    ) {
+      didWarnAboutUnsafeLifecycles.has(fiber.type) ||
+        ("function" === typeof instance.componentWillMount &&
+          !0 !== instance.componentWillMount.__suppressDeprecationWarning &&
+          pendingComponentWillMountWarnings.push(fiber),
+        fiber.mode & StrictLegacyMode &&
+          "function" === typeof instance.UNSAFE_componentWillMount &&
+          pendingUNSAFE_ComponentWillMountWarnings.push(fiber),
+        "function" === typeof instance.componentWillReceiveProps &&
+          !0 !==
+            instance.componentWillReceiveProps.__suppressDeprecationWarning &&
+          pendingComponentWillReceivePropsWarnings.push(fiber),
+        fiber.mode & StrictLegacyMode &&
+          "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
+          pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber),
+        "function" === typeof instance.componentWillUpdate &&
+          !0 !== instance.componentWillUpdate.__suppressDeprecationWarning &&
+          pendingComponentWillUpdateWarnings.push(fiber),
+        fiber.mode & StrictLegacyMode &&
+          "function" === typeof instance.UNSAFE_componentWillUpdate &&
+          pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
+    };
+    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
+      var componentWillMountUniqueNames = new Set();
+      0 < pendingComponentWillMountWarnings.length &&
+        (pendingComponentWillMountWarnings.forEach(function (fiber) {
+          componentWillMountUniqueNames.add(
+            getComponentNameFromFiber(fiber) || "Component"
+          );
+          didWarnAboutUnsafeLifecycles.add(fiber.type);
+        }),
+        (pendingComponentWillMountWarnings = []));
+      var UNSAFE_componentWillMountUniqueNames = new Set();
+      0 < pendingUNSAFE_ComponentWillMountWarnings.length &&
+        (pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
+          UNSAFE_componentWillMountUniqueNames.add(
+            getComponentNameFromFiber(fiber) || "Component"
+          );
+          didWarnAboutUnsafeLifecycles.add(fiber.type);
+        }),
+        (pendingUNSAFE_ComponentWillMountWarnings = []));
+      var componentWillReceivePropsUniqueNames = new Set();
+      0 < pendingComponentWillReceivePropsWarnings.length &&
+        (pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
+          componentWillReceivePropsUniqueNames.add(
+            getComponentNameFromFiber(fiber) || "Component"
+          );
+          didWarnAboutUnsafeLifecycles.add(fiber.type);
+        }),
+        (pendingComponentWillReceivePropsWarnings = []));
+      var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
+      0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length &&
+        (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
+          function (fiber) {
+            UNSAFE_componentWillReceivePropsUniqueNames.add(
+              getComponentNameFromFiber(fiber) || "Component"
+            );
+            didWarnAboutUnsafeLifecycles.add(fiber.type);
+          }
+        ),
+        (pendingUNSAFE_ComponentWillReceivePropsWarnings = []));
+      var componentWillUpdateUniqueNames = new Set();
+      0 < pendingComponentWillUpdateWarnings.length &&
+        (pendingComponentWillUpdateWarnings.forEach(function (fiber) {
+          componentWillUpdateUniqueNames.add(
+            getComponentNameFromFiber(fiber) || "Component"
+          );
+          didWarnAboutUnsafeLifecycles.add(fiber.type);
+        }),
+        (pendingComponentWillUpdateWarnings = []));
+      var UNSAFE_componentWillUpdateUniqueNames = new Set();
+      0 < pendingUNSAFE_ComponentWillUpdateWarnings.length &&
+        (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
+          UNSAFE_componentWillUpdateUniqueNames.add(
+            getComponentNameFromFiber(fiber) || "Component"
+          );
+          didWarnAboutUnsafeLifecycles.add(fiber.type);
+        }),
+        (pendingUNSAFE_ComponentWillUpdateWarnings = []));
+      if (0 < UNSAFE_componentWillMountUniqueNames.size) {
+        var sortedNames = setToSortedString(
+          UNSAFE_componentWillMountUniqueNames
+        );
+        console.error(
+          "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
+          sortedNames
+        );
+      }
+      0 < UNSAFE_componentWillReceivePropsUniqueNames.size &&
+        ((sortedNames = setToSortedString(
+          UNSAFE_componentWillReceivePropsUniqueNames
+        )),
+        console.error(
+          "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
+          sortedNames
+        ));
+      0 < UNSAFE_componentWillUpdateUniqueNames.size &&
+        ((sortedNames = setToSortedString(
+          UNSAFE_componentWillUpdateUniqueNames
+        )),
+        console.error(
+          "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
+          sortedNames
+        ));
+      0 < componentWillMountUniqueNames.size &&
+        ((sortedNames = setToSortedString(componentWillMountUniqueNames)),
+        console.warn(
+          "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
+          sortedNames
+        ));
+      0 < componentWillReceivePropsUniqueNames.size &&
+        ((sortedNames = setToSortedString(
+          componentWillReceivePropsUniqueNames
+        )),
+        console.warn(
+          "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
+          sortedNames
+        ));
+      0 < componentWillUpdateUniqueNames.size &&
+        ((sortedNames = setToSortedString(componentWillUpdateUniqueNames)),
+        console.warn(
+          "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
+          sortedNames
+        ));
+    };
+    var pendingLegacyContextWarning = new Map(),
+      didWarnAboutLegacyContext = new Set();
+    ReactStrictModeWarnings.recordLegacyContextWarning = function (
+      fiber,
+      instance
+    ) {
+      var strictRoot = null;
+      for (var node = fiber; null !== node; )
+        node.mode & StrictLegacyMode && (strictRoot = node),
+          (node = node.return);
+      null === strictRoot
+        ? console.error(
+            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
+          )
+        : !didWarnAboutLegacyContext.has(fiber.type) &&
+          ((node = pendingLegacyContextWarning.get(strictRoot)),
+          null != fiber.type.contextTypes ||
+            null != fiber.type.childContextTypes ||
+            (null !== instance &&
+              "function" === typeof instance.getChildContext)) &&
+          (void 0 === node &&
+            ((node = []), pendingLegacyContextWarning.set(strictRoot, node)),
+          node.push(fiber));
+    };
+    ReactStrictModeWarnings.flushLegacyContextWarning = function () {
+      pendingLegacyContextWarning.forEach(function (fiberArray) {
+        if (0 !== fiberArray.length) {
+          var firstFiber = fiberArray[0],
+            uniqueNames = new Set();
+          fiberArray.forEach(function (fiber) {
+            uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
+            didWarnAboutLegacyContext.add(fiber.type);
+          });
+          var sortedNames = setToSortedString(uniqueNames);
+          runWithFiberInDEV(firstFiber, function () {
+            console.error(
+              "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
+              sortedNames
+            );
+          });
+        }
+      });
+    };
+    ReactStrictModeWarnings.discardPendingWarnings = function () {
+      pendingComponentWillMountWarnings = [];
+      pendingUNSAFE_ComponentWillMountWarnings = [];
+      pendingComponentWillReceivePropsWarnings = [];
+      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
+      pendingComponentWillUpdateWarnings = [];
+      pendingUNSAFE_ComponentWillUpdateWarnings = [];
+      pendingLegacyContextWarning = new Map();
+    };
+    var fakeInternalInstance = {};
+    var didWarnAboutStateAssignmentForComponent = new Set();
+    var didWarnAboutUninitializedState = new Set();
+    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
+    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
+    var didWarnAboutDirectlyAssigningPropsToState = new Set();
+    var didWarnAboutUndefinedDerivedState = new Set();
+    var didWarnAboutContextTypes$1 = new Set();
+    var didWarnAboutChildContextTypes = new Set();
+    var didWarnAboutInvalidateContextType = new Set();
+    var didWarnOnInvalidCallback = new Set();
+    Object.freeze(fakeInternalInstance);
+    var classComponentUpdater = {
+        enqueueSetState: function (inst, payload, callback) {
+          inst = inst._reactInternals;
+          var lane = requestUpdateLane(inst),
+            update = createUpdate(lane);
+          update.payload = payload;
+          void 0 !== callback &&
+            null !== callback &&
+            (warnOnInvalidCallback(callback), (update.callback = callback));
+          payload = enqueueUpdate(inst, update, lane);
+          null !== payload &&
+            (startUpdateTimerByLane(lane),
+            scheduleUpdateOnFiber(payload, inst, lane),
+            entangleTransitions(payload, inst, lane));
+        },
+        enqueueReplaceState: function (inst, payload, callback) {
+          inst = inst._reactInternals;
+          var lane = requestUpdateLane(inst),
+            update = createUpdate(lane);
+          update.tag = ReplaceState;
+          update.payload = payload;
+          void 0 !== callback &&
+            null !== callback &&
+            (warnOnInvalidCallback(callback), (update.callback = callback));
+          payload = enqueueUpdate(inst, update, lane);
+          null !== payload &&
+            (startUpdateTimerByLane(lane),
+            scheduleUpdateOnFiber(payload, inst, lane),
+            entangleTransitions(payload, inst, lane));
+        },
+        enqueueForceUpdate: function (inst, callback) {
+          inst = inst._reactInternals;
+          var lane = requestUpdateLane(inst),
+            update = createUpdate(lane);
+          update.tag = ForceUpdate;
+          void 0 !== callback &&
+            null !== callback &&
+            (warnOnInvalidCallback(callback), (update.callback = callback));
+          callback = enqueueUpdate(inst, update, lane);
+          null !== callback &&
+            (startUpdateTimerByLane(lane),
+            scheduleUpdateOnFiber(callback, inst, lane),
+            entangleTransitions(callback, inst, lane));
+        }
+      },
+      forkStack = [],
+      forkStackIndex = 0,
+      treeForkProvider = null,
+      treeForkCount = 0,
+      idStack = [],
+      idStackIndex = 0,
+      treeContextProvider = null,
+      treeContextId = 1,
+      treeContextOverflow = "",
+      SuspenseException = Error(
+        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
+      ),
+      SuspenseyCommitException = Error(
+        "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
+      ),
+      SuspenseActionException = Error(
+        "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
+      ),
+      noopSuspenseyCommitThenable = {
+        then: function () {
+          console.error(
+            'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
+          );
+        }
+      },
+      suspendedThenable = null,
+      needsToResetSuspendedThenableDEV = !1,
+      currentTreeHiddenStackCursor = createCursor(null),
+      prevEntangledRenderLanesCursor = createCursor(0),
+      prevOnStartTransitionFinish = ReactSharedInternals.S;
+    ReactSharedInternals.S = function (transition, returnValue) {
+      if (
+        "object" === typeof returnValue &&
+        null !== returnValue &&
+        "function" === typeof returnValue.then
+      ) {
+        if (0 > transitionStartTime && 0 > transitionUpdateTime) {
+          transitionStartTime = now();
+          var newEventTime = resolveEventTimeStamp(),
+            newEventType = resolveEventType();
+          if (
+            newEventTime !== transitionEventTime ||
+            newEventType !== transitionEventType
+          )
+            transitionEventIsRepeat = !1;
+          transitionEventTime = newEventTime;
+          transitionEventType = newEventType;
+        }
+        entangleAsyncAction(transition, returnValue);
+      }
+      null !== prevOnStartTransitionFinish &&
+        prevOnStartTransitionFinish(transition, returnValue);
+    };
+    var resumedCache = createCursor(null),
+      didWarnUncachedGetSnapshot;
+    var didWarnAboutMismatchedHooksForComponent = new Set();
+    var didWarnAboutUseWrappedInTryCatch = new Set();
+    var didWarnAboutAsyncClientComponent = new Set();
+    var didWarnAboutUseFormState = new Set();
+    var renderLanes = 0,
+      currentlyRenderingFiber = null,
+      currentHook = null,
+      workInProgressHook = null,
+      didScheduleRenderPhaseUpdate = !1,
+      didScheduleRenderPhaseUpdateDuringThisPass = !1,
+      shouldDoubleInvokeUserFnsInHooksDEV = !1,
+      localIdCounter = 0,
+      thenableIndexCounter$1 = 0,
+      thenableState$1 = null,
+      globalClientIdCounter$1 = 0,
+      RE_RENDER_LIMIT = 25,
+      currentHookNameInDev = null,
+      hookTypesDev = null,
+      hookTypesUpdateIndexDev = -1,
+      ignorePreviousDependencies = !1,
+      ContextOnlyDispatcher = {
+        readContext: readContext,
+        use: use,
+        useCallback: throwInvalidHookError,
+        useContext: throwInvalidHookError,
+        useEffect: throwInvalidHookError,
+        useImperativeHandle: throwInvalidHookError,
+        useLayoutEffect: throwInvalidHookError,
+        useInsertionEffect: throwInvalidHookError,
+        useMemo: throwInvalidHookError,
+        useReducer: throwInvalidHookError,
+        useRef: throwInvalidHookError,
+        useState: throwInvalidHookError,
+        useDebugValue: throwInvalidHookError,
+        useDeferredValue: throwInvalidHookError,
+        useTransition: throwInvalidHookError,
+        useSyncExternalStore: throwInvalidHookError,
+        useId: throwInvalidHookError,
+        useHostTransitionStatus: throwInvalidHookError,
+        useFormState: throwInvalidHookError,
+        useActionState: throwInvalidHookError,
+        useOptimistic: throwInvalidHookError,
+        useMemoCache: throwInvalidHookError,
+        useCacheRefresh: throwInvalidHookError
+      };
+    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
+    var HooksDispatcherOnMountInDEV = null,
+      HooksDispatcherOnMountWithHookTypesInDEV = null,
+      HooksDispatcherOnUpdateInDEV = null,
+      HooksDispatcherOnRerenderInDEV = null,
+      InvalidNestedHooksDispatcherOnMountInDEV = null,
+      InvalidNestedHooksDispatcherOnUpdateInDEV = null,
+      InvalidNestedHooksDispatcherOnRerenderInDEV = null;
+    HooksDispatcherOnMountInDEV = {
+      readContext: function (context) {
+        return readContext(context);
+      },
+      use: use,
+      useCallback: function (callback, deps) {
+        currentHookNameInDev = "useCallback";
+        mountHookTypesDev();
+        checkDepsAreArrayDev(deps);
+        return mountCallback(callback, deps);
+      },
+      useContext: function (context) {
+        currentHookNameInDev = "useContext";
+        mountHookTypesDev();
+        return readContext(context);
+      },
+      useEffect: function (create, deps) {
+        currentHookNameInDev = "useEffect";
+        mountHookTypesDev();
+        checkDepsAreArrayDev(deps);
+        return mountEffect(create, deps);
+      },
+      useImperativeHandle: function (ref, create, deps) {
+        currentHookNameInDev = "useImperativeHandle";
+        mountHookTypesDev();
+        checkDepsAreArrayDev(deps);
+        return mountImperativeHandle(ref, create, deps);
+      },
+      useInsertionEffect: function (create, deps) {
+        currentHookNameInDev = "useInsertionEffect";
+        mountHookTypesDev();
+        checkDepsAreArrayDev(deps);
+        mountEffectImpl(4, Insertion, create, deps);
+      },
+      useLayoutEffect: function (create, deps) {
+        currentHookNameInDev = "useLayoutEffect";
+        mountHookTypesDev();
+        checkDepsAreArrayDev(deps);
+        return mountLayoutEffect(create, deps);
+      },
+      useMemo: function (create, deps) {
+        currentHookNameInDev = "useMemo";
+        mountHookTypesDev();
+        checkDepsAreArrayDev(deps);
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
+        try {
+          return mountMemo(create, deps);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useReducer: function (reducer, initialArg, init) {
+        currentHookNameInDev = "useReducer";
+        mountHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
+        try {
+          return mountReducer(reducer, initialArg, init);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useRef: function (initialValue) {
+        currentHookNameInDev = "useRef";
+        mountHookTypesDev();
+        return mountRef(initialValue);
+      },
+      useState: function (initialState) {
+        currentHookNameInDev = "useState";
+        mountHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
+        try {
+          return mountState(initialState);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useDebugValue: function () {
+        currentHookNameInDev = "useDebugValue";
+        mountHookTypesDev();
+      },
+      useDeferredValue: function (value, initialValue) {
+        currentHookNameInDev = "useDeferredValue";
+        mountHookTypesDev();
+        return mountDeferredValue(value, initialValue);
+      },
+      useTransition: function () {
+        currentHookNameInDev = "useTransition";
+        mountHookTypesDev();
+        return mountTransition();
+      },
+      useSyncExternalStore: function (
+        subscribe,
+        getSnapshot,
+        getServerSnapshot
+      ) {
+        currentHookNameInDev = "useSyncExternalStore";
+        mountHookTypesDev();
+        return mountSyncExternalStore(
+          subscribe,
+          getSnapshot,
+          getServerSnapshot
+        );
+      },
+      useId: function () {
+        currentHookNameInDev = "useId";
+        mountHookTypesDev();
+        return mountId();
+      },
+      useFormState: function (action, initialState) {
+        currentHookNameInDev = "useFormState";
+        mountHookTypesDev();
+        warnOnUseFormStateInDev();
+        return mountActionState(action, initialState);
+      },
+      useActionState: function (action, initialState) {
+        currentHookNameInDev = "useActionState";
+        mountHookTypesDev();
+        return mountActionState(action, initialState);
+      },
+      useOptimistic: function (passthrough) {
+        currentHookNameInDev = "useOptimistic";
+        mountHookTypesDev();
+        return mountOptimistic(passthrough);
+      },
+      useHostTransitionStatus: useHostTransitionStatus,
+      useMemoCache: useMemoCache,
+      useCacheRefresh: function () {
+        currentHookNameInDev = "useCacheRefresh";
+        mountHookTypesDev();
+        return mountRefresh();
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        mountHookTypesDev();
+        return mountEvent(callback);
+      }
+    };
+    HooksDispatcherOnMountWithHookTypesInDEV = {
+      readContext: function (context) {
+        return readContext(context);
+      },
+      use: use,
+      useCallback: function (callback, deps) {
+        currentHookNameInDev = "useCallback";
+        updateHookTypesDev();
+        return mountCallback(callback, deps);
+      },
+      useContext: function (context) {
+        currentHookNameInDev = "useContext";
+        updateHookTypesDev();
+        return readContext(context);
+      },
+      useEffect: function (create, deps) {
+        currentHookNameInDev = "useEffect";
+        updateHookTypesDev();
+        return mountEffect(create, deps);
+      },
+      useImperativeHandle: function (ref, create, deps) {
+        currentHookNameInDev = "useImperativeHandle";
+        updateHookTypesDev();
+        return mountImperativeHandle(ref, create, deps);
+      },
+      useInsertionEffect: function (create, deps) {
+        currentHookNameInDev = "useInsertionEffect";
+        updateHookTypesDev();
+        mountEffectImpl(4, Insertion, create, deps);
+      },
+      useLayoutEffect: function (create, deps) {
+        currentHookNameInDev = "useLayoutEffect";
+        updateHookTypesDev();
+        return mountLayoutEffect(create, deps);
+      },
+      useMemo: function (create, deps) {
+        currentHookNameInDev = "useMemo";
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
+        try {
+          return mountMemo(create, deps);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useReducer: function (reducer, initialArg, init) {
+        currentHookNameInDev = "useReducer";
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
+        try {
+          return mountReducer(reducer, initialArg, init);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useRef: function (initialValue) {
+        currentHookNameInDev = "useRef";
+        updateHookTypesDev();
+        return mountRef(initialValue);
+      },
+      useState: function (initialState) {
+        currentHookNameInDev = "useState";
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
+        try {
+          return mountState(initialState);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useDebugValue: function () {
+        currentHookNameInDev = "useDebugValue";
+        updateHookTypesDev();
+      },
+      useDeferredValue: function (value, initialValue) {
+        currentHookNameInDev = "useDeferredValue";
+        updateHookTypesDev();
+        return mountDeferredValue(value, initialValue);
+      },
+      useTransition: function () {
+        currentHookNameInDev = "useTransition";
+        updateHookTypesDev();
+        return mountTransition();
+      },
+      useSyncExternalStore: function (
+        subscribe,
+        getSnapshot,
+        getServerSnapshot
+      ) {
+        currentHookNameInDev = "useSyncExternalStore";
+        updateHookTypesDev();
+        return mountSyncExternalStore(
+          subscribe,
+          getSnapshot,
+          getServerSnapshot
+        );
+      },
+      useId: function () {
+        currentHookNameInDev = "useId";
+        updateHookTypesDev();
+        return mountId();
+      },
+      useActionState: function (action, initialState) {
+        currentHookNameInDev = "useActionState";
+        updateHookTypesDev();
+        return mountActionState(action, initialState);
+      },
+      useFormState: function (action, initialState) {
+        currentHookNameInDev = "useFormState";
+        updateHookTypesDev();
+        warnOnUseFormStateInDev();
+        return mountActionState(action, initialState);
+      },
+      useOptimistic: function (passthrough) {
+        currentHookNameInDev = "useOptimistic";
+        updateHookTypesDev();
+        return mountOptimistic(passthrough);
+      },
+      useHostTransitionStatus: useHostTransitionStatus,
+      useMemoCache: useMemoCache,
+      useCacheRefresh: function () {
+        currentHookNameInDev = "useCacheRefresh";
+        updateHookTypesDev();
+        return mountRefresh();
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        updateHookTypesDev();
+        return mountEvent(callback);
+      }
+    };
+    HooksDispatcherOnUpdateInDEV = {
+      readContext: function (context) {
+        return readContext(context);
+      },
+      use: use,
+      useCallback: function (callback, deps) {
+        currentHookNameInDev = "useCallback";
+        updateHookTypesDev();
+        return updateCallback(callback, deps);
+      },
+      useContext: function (context) {
+        currentHookNameInDev = "useContext";
+        updateHookTypesDev();
+        return readContext(context);
+      },
+      useEffect: function (create, deps) {
+        currentHookNameInDev = "useEffect";
+        updateHookTypesDev();
+        updateEffectImpl(2048, Passive, create, deps);
+      },
+      useImperativeHandle: function (ref, create, deps) {
+        currentHookNameInDev = "useImperativeHandle";
+        updateHookTypesDev();
+        return updateImperativeHandle(ref, create, deps);
+      },
+      useInsertionEffect: function (create, deps) {
+        currentHookNameInDev = "useInsertionEffect";
+        updateHookTypesDev();
+        return updateEffectImpl(4, Insertion, create, deps);
+      },
+      useLayoutEffect: function (create, deps) {
+        currentHookNameInDev = "useLayoutEffect";
+        updateHookTypesDev();
+        return updateEffectImpl(4, Layout, create, deps);
+      },
+      useMemo: function (create, deps) {
+        currentHookNameInDev = "useMemo";
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
+        try {
+          return updateMemo(create, deps);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useReducer: function (reducer, initialArg, init) {
+        currentHookNameInDev = "useReducer";
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
+        try {
+          return updateReducer(reducer, initialArg, init);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useRef: function () {
+        currentHookNameInDev = "useRef";
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useState: function () {
+        currentHookNameInDev = "useState";
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
+        try {
+          return updateReducer(basicStateReducer);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useDebugValue: function () {
+        currentHookNameInDev = "useDebugValue";
+        updateHookTypesDev();
+      },
+      useDeferredValue: function (value, initialValue) {
+        currentHookNameInDev = "useDeferredValue";
+        updateHookTypesDev();
+        return updateDeferredValue(value, initialValue);
+      },
+      useTransition: function () {
+        currentHookNameInDev = "useTransition";
+        updateHookTypesDev();
+        return updateTransition();
+      },
+      useSyncExternalStore: function (
+        subscribe,
+        getSnapshot,
+        getServerSnapshot
+      ) {
+        currentHookNameInDev = "useSyncExternalStore";
+        updateHookTypesDev();
+        return updateSyncExternalStore(
+          subscribe,
+          getSnapshot,
+          getServerSnapshot
+        );
+      },
+      useId: function () {
+        currentHookNameInDev = "useId";
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useFormState: function (action) {
+        currentHookNameInDev = "useFormState";
+        updateHookTypesDev();
+        warnOnUseFormStateInDev();
+        return updateActionState(action);
+      },
+      useActionState: function (action) {
+        currentHookNameInDev = "useActionState";
+        updateHookTypesDev();
+        return updateActionState(action);
+      },
+      useOptimistic: function (passthrough, reducer) {
+        currentHookNameInDev = "useOptimistic";
+        updateHookTypesDev();
+        return updateOptimistic(passthrough, reducer);
+      },
+      useHostTransitionStatus: useHostTransitionStatus,
+      useMemoCache: useMemoCache,
+      useCacheRefresh: function () {
+        currentHookNameInDev = "useCacheRefresh";
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        updateHookTypesDev();
+        return updateEvent(callback);
+      }
+    };
+    HooksDispatcherOnRerenderInDEV = {
+      readContext: function (context) {
+        return readContext(context);
+      },
+      use: use,
+      useCallback: function (callback, deps) {
+        currentHookNameInDev = "useCallback";
+        updateHookTypesDev();
+        return updateCallback(callback, deps);
+      },
+      useContext: function (context) {
+        currentHookNameInDev = "useContext";
+        updateHookTypesDev();
+        return readContext(context);
+      },
+      useEffect: function (create, deps) {
+        currentHookNameInDev = "useEffect";
+        updateHookTypesDev();
+        updateEffectImpl(2048, Passive, create, deps);
+      },
+      useImperativeHandle: function (ref, create, deps) {
+        currentHookNameInDev = "useImperativeHandle";
+        updateHookTypesDev();
+        return updateImperativeHandle(ref, create, deps);
+      },
+      useInsertionEffect: function (create, deps) {
+        currentHookNameInDev = "useInsertionEffect";
+        updateHookTypesDev();
+        return updateEffectImpl(4, Insertion, create, deps);
+      },
+      useLayoutEffect: function (create, deps) {
+        currentHookNameInDev = "useLayoutEffect";
+        updateHookTypesDev();
+        return updateEffectImpl(4, Layout, create, deps);
+      },
+      useMemo: function (create, deps) {
+        currentHookNameInDev = "useMemo";
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
+        try {
+          return updateMemo(create, deps);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useReducer: function (reducer, initialArg, init) {
+        currentHookNameInDev = "useReducer";
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
+        try {
+          return rerenderReducer(reducer, initialArg, init);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useRef: function () {
+        currentHookNameInDev = "useRef";
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useState: function () {
+        currentHookNameInDev = "useState";
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
+        try {
+          return rerenderReducer(basicStateReducer);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useDebugValue: function () {
+        currentHookNameInDev = "useDebugValue";
+        updateHookTypesDev();
+      },
+      useDeferredValue: function (value, initialValue) {
+        currentHookNameInDev = "useDeferredValue";
+        updateHookTypesDev();
+        return rerenderDeferredValue(value, initialValue);
+      },
+      useTransition: function () {
+        currentHookNameInDev = "useTransition";
+        updateHookTypesDev();
+        return rerenderTransition();
+      },
+      useSyncExternalStore: function (
+        subscribe,
+        getSnapshot,
+        getServerSnapshot
+      ) {
+        currentHookNameInDev = "useSyncExternalStore";
+        updateHookTypesDev();
+        return updateSyncExternalStore(
+          subscribe,
+          getSnapshot,
+          getServerSnapshot
+        );
+      },
+      useId: function () {
+        currentHookNameInDev = "useId";
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useFormState: function (action) {
+        currentHookNameInDev = "useFormState";
+        updateHookTypesDev();
+        warnOnUseFormStateInDev();
+        return rerenderActionState(action);
+      },
+      useActionState: function (action) {
+        currentHookNameInDev = "useActionState";
+        updateHookTypesDev();
+        return rerenderActionState(action);
+      },
+      useOptimistic: function (passthrough, reducer) {
+        currentHookNameInDev = "useOptimistic";
+        updateHookTypesDev();
+        return rerenderOptimistic(passthrough, reducer);
+      },
+      useHostTransitionStatus: useHostTransitionStatus,
+      useMemoCache: useMemoCache,
+      useCacheRefresh: function () {
+        currentHookNameInDev = "useCacheRefresh";
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        updateHookTypesDev();
+        return updateEvent(callback);
+      }
+    };
+    InvalidNestedHooksDispatcherOnMountInDEV = {
+      readContext: function (context) {
+        warnInvalidContextAccess();
+        return readContext(context);
+      },
+      use: function (usable) {
+        warnInvalidHookAccess();
+        return use(usable);
+      },
+      useCallback: function (callback, deps) {
+        currentHookNameInDev = "useCallback";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountCallback(callback, deps);
+      },
+      useContext: function (context) {
+        currentHookNameInDev = "useContext";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return readContext(context);
+      },
+      useEffect: function (create, deps) {
+        currentHookNameInDev = "useEffect";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountEffect(create, deps);
+      },
+      useImperativeHandle: function (ref, create, deps) {
+        currentHookNameInDev = "useImperativeHandle";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountImperativeHandle(ref, create, deps);
+      },
+      useInsertionEffect: function (create, deps) {
+        currentHookNameInDev = "useInsertionEffect";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        mountEffectImpl(4, Insertion, create, deps);
+      },
+      useLayoutEffect: function (create, deps) {
+        currentHookNameInDev = "useLayoutEffect";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountLayoutEffect(create, deps);
+      },
+      useMemo: function (create, deps) {
+        currentHookNameInDev = "useMemo";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
+        try {
+          return mountMemo(create, deps);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useReducer: function (reducer, initialArg, init) {
+        currentHookNameInDev = "useReducer";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
+        try {
+          return mountReducer(reducer, initialArg, init);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useRef: function (initialValue) {
+        currentHookNameInDev = "useRef";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountRef(initialValue);
+      },
+      useState: function (initialState) {
+        currentHookNameInDev = "useState";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
+        try {
+          return mountState(initialState);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useDebugValue: function () {
+        currentHookNameInDev = "useDebugValue";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+      },
+      useDeferredValue: function (value, initialValue) {
+        currentHookNameInDev = "useDeferredValue";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountDeferredValue(value, initialValue);
+      },
+      useTransition: function () {
+        currentHookNameInDev = "useTransition";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountTransition();
+      },
+      useSyncExternalStore: function (
+        subscribe,
+        getSnapshot,
+        getServerSnapshot
+      ) {
+        currentHookNameInDev = "useSyncExternalStore";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountSyncExternalStore(
+          subscribe,
+          getSnapshot,
+          getServerSnapshot
+        );
+      },
+      useId: function () {
+        currentHookNameInDev = "useId";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountId();
+      },
+      useFormState: function (action, initialState) {
+        currentHookNameInDev = "useFormState";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountActionState(action, initialState);
+      },
+      useActionState: function (action, initialState) {
+        currentHookNameInDev = "useActionState";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountActionState(action, initialState);
+      },
+      useOptimistic: function (passthrough) {
+        currentHookNameInDev = "useOptimistic";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountOptimistic(passthrough);
+      },
+      useMemoCache: function (size) {
+        warnInvalidHookAccess();
+        return useMemoCache(size);
+      },
+      useHostTransitionStatus: useHostTransitionStatus,
+      useCacheRefresh: function () {
+        currentHookNameInDev = "useCacheRefresh";
+        mountHookTypesDev();
+        return mountRefresh();
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        warnInvalidHookAccess();
+        mountHookTypesDev();
+        return mountEvent(callback);
+      }
+    };
+    InvalidNestedHooksDispatcherOnUpdateInDEV = {
+      readContext: function (context) {
+        warnInvalidContextAccess();
+        return readContext(context);
+      },
+      use: function (usable) {
+        warnInvalidHookAccess();
+        return use(usable);
+      },
+      useCallback: function (callback, deps) {
+        currentHookNameInDev = "useCallback";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateCallback(callback, deps);
+      },
+      useContext: function (context) {
+        currentHookNameInDev = "useContext";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return readContext(context);
+      },
+      useEffect: function (create, deps) {
+        currentHookNameInDev = "useEffect";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        updateEffectImpl(2048, Passive, create, deps);
+      },
+      useImperativeHandle: function (ref, create, deps) {
+        currentHookNameInDev = "useImperativeHandle";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateImperativeHandle(ref, create, deps);
+      },
+      useInsertionEffect: function (create, deps) {
+        currentHookNameInDev = "useInsertionEffect";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateEffectImpl(4, Insertion, create, deps);
+      },
+      useLayoutEffect: function (create, deps) {
+        currentHookNameInDev = "useLayoutEffect";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateEffectImpl(4, Layout, create, deps);
+      },
+      useMemo: function (create, deps) {
+        currentHookNameInDev = "useMemo";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
+        try {
+          return updateMemo(create, deps);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useReducer: function (reducer, initialArg, init) {
+        currentHookNameInDev = "useReducer";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
+        try {
+          return updateReducer(reducer, initialArg, init);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useRef: function () {
+        currentHookNameInDev = "useRef";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useState: function () {
+        currentHookNameInDev = "useState";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
+        try {
+          return updateReducer(basicStateReducer);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useDebugValue: function () {
+        currentHookNameInDev = "useDebugValue";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+      },
+      useDeferredValue: function (value, initialValue) {
+        currentHookNameInDev = "useDeferredValue";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateDeferredValue(value, initialValue);
+      },
+      useTransition: function () {
+        currentHookNameInDev = "useTransition";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateTransition();
+      },
+      useSyncExternalStore: function (
+        subscribe,
+        getSnapshot,
+        getServerSnapshot
+      ) {
+        currentHookNameInDev = "useSyncExternalStore";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateSyncExternalStore(
+          subscribe,
+          getSnapshot,
+          getServerSnapshot
+        );
+      },
+      useId: function () {
+        currentHookNameInDev = "useId";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useFormState: function (action) {
+        currentHookNameInDev = "useFormState";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateActionState(action);
+      },
+      useActionState: function (action) {
+        currentHookNameInDev = "useActionState";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateActionState(action);
+      },
+      useOptimistic: function (passthrough, reducer) {
+        currentHookNameInDev = "useOptimistic";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateOptimistic(passthrough, reducer);
+      },
+      useMemoCache: function (size) {
+        warnInvalidHookAccess();
+        return useMemoCache(size);
+      },
+      useHostTransitionStatus: useHostTransitionStatus,
+      useCacheRefresh: function () {
+        currentHookNameInDev = "useCacheRefresh";
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateEvent(callback);
+      }
+    };
+    InvalidNestedHooksDispatcherOnRerenderInDEV = {
+      readContext: function (context) {
+        warnInvalidContextAccess();
+        return readContext(context);
+      },
+      use: function (usable) {
+        warnInvalidHookAccess();
+        return use(usable);
+      },
+      useCallback: function (callback, deps) {
+        currentHookNameInDev = "useCallback";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateCallback(callback, deps);
+      },
+      useContext: function (context) {
+        currentHookNameInDev = "useContext";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return readContext(context);
+      },
+      useEffect: function (create, deps) {
+        currentHookNameInDev = "useEffect";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        updateEffectImpl(2048, Passive, create, deps);
+      },
+      useImperativeHandle: function (ref, create, deps) {
+        currentHookNameInDev = "useImperativeHandle";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateImperativeHandle(ref, create, deps);
+      },
+      useInsertionEffect: function (create, deps) {
+        currentHookNameInDev = "useInsertionEffect";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateEffectImpl(4, Insertion, create, deps);
+      },
+      useLayoutEffect: function (create, deps) {
+        currentHookNameInDev = "useLayoutEffect";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateEffectImpl(4, Layout, create, deps);
+      },
+      useMemo: function (create, deps) {
+        currentHookNameInDev = "useMemo";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
+        try {
+          return updateMemo(create, deps);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useReducer: function (reducer, initialArg, init) {
+        currentHookNameInDev = "useReducer";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
+        try {
+          return rerenderReducer(reducer, initialArg, init);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useRef: function () {
+        currentHookNameInDev = "useRef";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useState: function () {
+        currentHookNameInDev = "useState";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        var prevDispatcher = ReactSharedInternals.H;
+        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
+        try {
+          return rerenderReducer(basicStateReducer);
+        } finally {
+          ReactSharedInternals.H = prevDispatcher;
+        }
+      },
+      useDebugValue: function () {
+        currentHookNameInDev = "useDebugValue";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+      },
+      useDeferredValue: function (value, initialValue) {
+        currentHookNameInDev = "useDeferredValue";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return rerenderDeferredValue(value, initialValue);
+      },
+      useTransition: function () {
+        currentHookNameInDev = "useTransition";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return rerenderTransition();
+      },
+      useSyncExternalStore: function (
+        subscribe,
+        getSnapshot,
+        getServerSnapshot
+      ) {
+        currentHookNameInDev = "useSyncExternalStore";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateSyncExternalStore(
+          subscribe,
+          getSnapshot,
+          getServerSnapshot
+        );
+      },
+      useId: function () {
+        currentHookNameInDev = "useId";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useFormState: function (action) {
+        currentHookNameInDev = "useFormState";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return rerenderActionState(action);
+      },
+      useActionState: function (action) {
+        currentHookNameInDev = "useActionState";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return rerenderActionState(action);
+      },
+      useOptimistic: function (passthrough, reducer) {
+        currentHookNameInDev = "useOptimistic";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return rerenderOptimistic(passthrough, reducer);
+      },
+      useMemoCache: function (size) {
+        warnInvalidHookAccess();
+        return useMemoCache(size);
+      },
+      useHostTransitionStatus: useHostTransitionStatus,
+      useCacheRefresh: function () {
+        currentHookNameInDev = "useCacheRefresh";
+        updateHookTypesDev();
+        return updateWorkInProgressHook().memoizedState;
+      },
+      useEffectEvent: function (callback) {
+        currentHookNameInDev = "useEffectEvent";
+        warnInvalidHookAccess();
+        updateHookTypesDev();
+        return updateEvent(callback);
+      }
+    };
+    var callComponent = {
+        "react-stack-bottom-frame": function (Component, props, secondArg) {
+          var wasRendering = isRendering;
+          isRendering = !0;
+          try {
+            return Component(props, secondArg);
+          } finally {
+            isRendering = wasRendering;
+          }
+        }
+      },
+      callComponentInDEV =
+        callComponent["react-stack-bottom-frame"].bind(callComponent),
+      callRender = {
+        "react-stack-bottom-frame": function (instance) {
+          var wasRendering = isRendering;
+          isRendering = !0;
+          try {
+            return instance.render();
+          } finally {
+            isRendering = wasRendering;
+          }
+        }
+      },
+      callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender),
+      callComponentDidMount = {
+        "react-stack-bottom-frame": function (finishedWork, instance) {
+          try {
+            instance.componentDidMount();
+          } catch (error) {
+            captureCommitPhaseError(finishedWork, finishedWork.return, error);
+          }
+        }
+      },
+      callComponentDidMountInDEV = callComponentDidMount[
+        "react-stack-bottom-frame"
+      ].bind(callComponentDidMount),
+      callComponentDidUpdate = {
+        "react-stack-bottom-frame": function (
+          finishedWork,
+          instance,
+          prevProps,
+          prevState,
+          snapshot
+        ) {
+          try {
+            instance.componentDidUpdate(prevProps, prevState, snapshot);
+          } catch (error) {
+            captureCommitPhaseError(finishedWork, finishedWork.return, error);
+          }
+        }
+      },
+      callComponentDidUpdateInDEV = callComponentDidUpdate[
+        "react-stack-bottom-frame"
+      ].bind(callComponentDidUpdate),
+      callComponentDidCatch = {
+        "react-stack-bottom-frame": function (instance, errorInfo) {
+          var stack = errorInfo.stack;
+          instance.componentDidCatch(errorInfo.value, {
+            componentStack: null !== stack ? stack : ""
+          });
+        }
+      },
+      callComponentDidCatchInDEV = callComponentDidCatch[
+        "react-stack-bottom-frame"
+      ].bind(callComponentDidCatch),
+      callComponentWillUnmount = {
+        "react-stack-bottom-frame": function (
+          current,
+          nearestMountedAncestor,
+          instance
+        ) {
+          try {
+            instance.componentWillUnmount();
+          } catch (error) {
+            captureCommitPhaseError(current, nearestMountedAncestor, error);
+          }
+        }
+      },
+      callComponentWillUnmountInDEV = callComponentWillUnmount[
+        "react-stack-bottom-frame"
+      ].bind(callComponentWillUnmount),
+      callCreate = {
+        "react-stack-bottom-frame": function (effect) {
+          null != effect.resourceKind &&
+            console.error(
+              "Expected only SimpleEffects when enableUseResourceEffectHook is disabled, got %s",
+              effect.resourceKind
+            );
+          var create = effect.create;
+          effect = effect.inst;
+          create = create();
+          return (effect.destroy = create);
+        }
+      },
+      callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate),
+      callDestroy = {
+        "react-stack-bottom-frame": function (
+          current,
+          nearestMountedAncestor,
+          destroy
+        ) {
+          try {
+            destroy();
+          } catch (error) {
+            captureCommitPhaseError(current, nearestMountedAncestor, error);
+          }
+        }
+      },
+      callDestroyInDEV =
+        callDestroy["react-stack-bottom-frame"].bind(callDestroy),
+      callLazyInit = {
+        "react-stack-bottom-frame": function (lazy) {
+          var init = lazy._init;
+          return init(lazy._payload);
+        }
+      },
+      callLazyInitInDEV =
+        callLazyInit["react-stack-bottom-frame"].bind(callLazyInit),
+      thenableState = null,
+      thenableIndexCounter = 0,
+      currentDebugInfo = null,
+      didWarnAboutMaps;
+    var didWarnAboutGenerators = (didWarnAboutMaps = !1);
+    var ownerHasKeyUseWarning = {};
+    var ownerHasFunctionTypeWarning = {};
+    var ownerHasSymbolTypeWarning = {};
+    warnForMissingKey = function (returnFiber, workInProgress, child) {
+      if (
+        null !== child &&
+        "object" === typeof child &&
+        child._store &&
+        ((!child._store.validated && null == child.key) ||
+          2 === child._store.validated)
+      ) {
+        if ("object" !== typeof child._store)
+          throw Error(
+            "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
+          );
+        child._store.validated = 1;
+        var componentName = getComponentNameFromFiber(returnFiber),
+          componentKey = componentName || "null";
+        if (!ownerHasKeyUseWarning[componentKey]) {
+          ownerHasKeyUseWarning[componentKey] = !0;
+          child = child._owner;
+          returnFiber = returnFiber._debugOwner;
+          var currentComponentErrorInfo = "";
+          returnFiber &&
+            "number" === typeof returnFiber.tag &&
+            (componentKey = getComponentNameFromFiber(returnFiber)) &&
+            (currentComponentErrorInfo =
+              "\n\nCheck the render method of `" + componentKey + "`.");
+          currentComponentErrorInfo ||
+            (componentName &&
+              (currentComponentErrorInfo =
+                "\n\nCheck the top-level render call using <" +
+                componentName +
+                ">."));
+          var childOwnerAppendix = "";
+          null != child &&
+            returnFiber !== child &&
+            ((componentName = null),
+            "number" === typeof child.tag
+              ? (componentName = getComponentNameFromFiber(child))
+              : "string" === typeof child.name && (componentName = child.name),
+            componentName &&
+              (childOwnerAppendix =
+                " It was passed a child from " + componentName + "."));
+          runWithFiberInDEV(workInProgress, function () {
+            console.error(
+              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
+              currentComponentErrorInfo,
+              childOwnerAppendix
+            );
+          });
+        }
+      }
+    };
+    var reconcileChildFibers = createChildReconciler(!0),
+      mountChildFibers = createChildReconciler(!1),
+      suspenseHandlerStackCursor = createCursor(null),
+      shellBoundary = null,
+      SubtreeSuspenseContextMask = 1,
+      ForceSuspenseFallback = 2,
+      suspenseStackCursor = createCursor(0),
+      reportGlobalError =
+        "function" === typeof reportError
+          ? reportError
+          : function (error) {
+              if (
+                "object" === typeof window &&
+                "function" === typeof window.ErrorEvent
+              ) {
+                var event = new window.ErrorEvent("error", {
+                  bubbles: !0,
+                  cancelable: !0,
+                  message:
+                    "object" === typeof error &&
+                    null !== error &&
+                    "string" === typeof error.message
+                      ? String(error.message)
+                      : String(error),
+                  error: error
+                });
+                if (!window.dispatchEvent(event)) return;
+              } else if (
+                "object" === typeof process &&
+                "function" === typeof process.emit
+              ) {
+                process.emit("uncaughtException", error);
+                return;
+              }
+              console.error(error);
+            },
+      componentName = null,
+      errorBoundaryName = null,
+      SelectiveHydrationException = Error(
+        "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
+      ),
+      didReceiveUpdate = !1;
+    var didWarnAboutBadClass = {};
+    var didWarnAboutContextTypeOnFunctionComponent = {};
+    var didWarnAboutContextTypes = {};
+    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
+    var didWarnAboutReassigningProps = !1;
+    var didWarnAboutRevealOrder = {};
+    var didWarnAboutTailOptions = {};
+    var SUSPENDED_MARKER = {
+        dehydrated: null,
+        treeContext: null,
+        retryLane: 0,
+        hydrationErrors: null
+      },
+      hasWarnedAboutUsingNoValuePropOnContextProvider = !1,
+      didWarnAboutUndefinedSnapshotBeforeUpdate = null;
+    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
+    var offscreenSubtreeIsHidden = !1,
+      offscreenSubtreeWasHidden = !1,
+      needsFormReset = !1,
+      PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
+      nextEffect = null,
+      inProgressLanes = null,
+      inProgressRoot = null,
+      shouldStartViewTransition = !1,
+      viewTransitionContextChanged = !1,
+      viewTransitionCancelableChildren = null,
+      viewTransitionHostInstanceIdx = 0,
+      hostParent = null,
+      hostParentIsContainer = !1,
+      currentHoistableRoot = null,
+      inHydratedSubtree = !1,
+      suspenseyCommitFlag = 8192;
+    var hasBadMapPolyfill = !1;
+    try {
+      var nonExtensibleObject = Object.preventExtensions({});
+      new Map([[nonExtensibleObject, null]]);
+      new Set([nonExtensibleObject]);
+    } catch (e$7) {
+      hasBadMapPolyfill = !0;
+    }
+    var hydrationParentFiber = null,
+      nextHydratableInstance = null,
+      isHydrating = !1,
+      didSuspendOrErrorDEV = !1,
+      hydrationDiffRootDEV = null,
+      hydrationErrors = null,
+      rootOrSingletonContext = !1,
+      HydrationMismatchException = Error(
+        "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
+      ),
+      globalClientIdCounter = 0,
+      DefaultAsyncDispatcher = {
+        getCacheForType: function (resourceType) {
+          var cache = readContext(CacheContext),
+            cacheForType = cache.data.get(resourceType);
+          void 0 === cacheForType &&
+            ((cacheForType = resourceType()),
+            cache.data.set(resourceType, cacheForType));
+          return cacheForType;
+        },
+        getOwner: function () {
+          return current;
+        }
+      },
+      COMPONENT_TYPE = 0,
+      HAS_PSEUDO_CLASS_TYPE = 1,
+      ROLE_TYPE = 2,
+      TEST_NAME_TYPE = 3,
+      TEXT_TYPE = 4;
+    if ("function" === typeof Symbol && Symbol.for) {
+      var symbolFor = Symbol.for;
+      COMPONENT_TYPE = symbolFor("selector.component");
+      HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
+      ROLE_TYPE = symbolFor("selector.role");
+      TEST_NAME_TYPE = symbolFor("selector.test_id");
+      TEXT_TYPE = symbolFor("selector.text");
+    }
+    var commitHooks = [],
+      PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
+      NoContext = 0,
+      RenderContext = 2,
+      CommitContext = 4,
+      RootInProgress = 0,
+      RootFatalErrored = 1,
+      RootErrored = 2,
+      RootSuspended = 3,
+      RootSuspendedWithDelay = 4,
+      RootSuspendedAtTheShell = 6,
+      RootCompleted = 5,
+      executionContext = NoContext,
+      workInProgressRoot = null,
+      workInProgress = null,
+      workInProgressRootRenderLanes = 0,
+      NotSuspended = 0,
+      SuspendedOnError = 1,
+      SuspendedOnData = 2,
+      SuspendedOnImmediate = 3,
+      SuspendedOnInstance = 4,
+      SuspendedOnInstanceAndReadyToContinue = 5,
+      SuspendedOnDeprecatedThrowPromise = 6,
+      SuspendedAndReadyToContinue = 7,
+      SuspendedOnHydration = 8,
+      SuspendedOnAction = 9,
+      workInProgressSuspendedReason = NotSuspended,
+      workInProgressThrownValue = null,
+      workInProgressRootDidSkipSuspendedSiblings = !1,
+      workInProgressRootIsPrerendering = !1,
+      workInProgressRootDidAttachPingListener = !1,
+      entangledRenderLanes = 0,
+      workInProgressRootExitStatus = RootInProgress,
+      workInProgressRootSkippedLanes = 0,
+      workInProgressRootInterleavedUpdatedLanes = 0,
+      workInProgressRootPingedLanes = 0,
+      workInProgressDeferredLane = 0,
+      workInProgressSuspendedRetryLanes = 0,
+      workInProgressRootConcurrentErrors = null,
+      workInProgressRootRecoverableErrors = null,
+      workInProgressAppearingViewTransitions = null,
+      workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
+      globalMostRecentFallbackTime = 0,
+      FALLBACK_THROTTLE_MS = 300,
+      workInProgressRootRenderTargetTime = Infinity,
+      RENDER_TIMEOUT_MS = 500,
+      workInProgressTransitions = null,
+      legacyErrorBoundariesThatAlreadyFailed = null,
+      IMMEDIATE_COMMIT = 0,
+      SUSPENDED_COMMIT = 1,
+      THROTTLED_COMMIT = 2,
+      NO_PENDING_EFFECTS = 0,
+      PENDING_MUTATION_PHASE = 1,
+      PENDING_LAYOUT_PHASE = 2,
+      PENDING_AFTER_MUTATION_PHASE = 3,
+      PENDING_SPAWNED_WORK = 4,
+      PENDING_PASSIVE_PHASE = 5,
+      pendingEffectsStatus = 0,
+      pendingEffectsRoot = null,
+      pendingFinishedWork = null,
+      pendingEffectsLanes = 0,
+      pendingEffectsRemainingLanes = 0,
+      pendingEffectsRenderEndTime = -0,
+      pendingPassiveTransitions = null,
+      pendingRecoverableErrors = null,
+      pendingViewTransitionEvents = null,
+      pendingSuspendedCommitReason = IMMEDIATE_COMMIT,
+      NESTED_UPDATE_LIMIT = 50,
+      nestedUpdateCount = 0,
+      rootWithNestedUpdates = null,
+      isFlushingPassiveEffects = !1,
+      didScheduleUpdateDuringPassiveEffects = !1,
+      NESTED_PASSIVE_UPDATE_LIMIT = 50,
+      nestedPassiveUpdateCount = 0,
+      rootWithPassiveNestedUpdates = null,
+      isRunningInsertionEffect = !1,
+      didWarnStateUpdateForNotYetMountedComponent = null,
+      didWarnAboutUpdateInRender = !1;
+    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();
+    var fakeActCallbackNode$1 = {},
+      firstScheduledRoot = null,
+      lastScheduledRoot = null,
+      didScheduleMicrotask = !1,
+      didScheduleMicrotask_act = !1,
+      mightHavePendingSyncWork = !1,
+      isFlushingWork = !1,
+      currentEventTransitionLane = 0,
+      fakeActCallbackNode = {};
+    (function () {
+      for (var i = 0; i < simpleEventPluginEvents.length; i++) {
+        var eventName = simpleEventPluginEvents[i],
+          domEventName = eventName.toLowerCase();
+        eventName = eventName[0].toUpperCase() + eventName.slice(1);
+        registerSimpleEvent(domEventName, "on" + eventName);
+      }
+      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
+      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
+      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
+      registerSimpleEvent("dblclick", "onDoubleClick");
+      registerSimpleEvent("focusin", "onFocus");
+      registerSimpleEvent("focusout", "onBlur");
+      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
+      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
+      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
+      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
+    })();
+    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
+    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
+    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
+    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
+    registerTwoPhaseEvent(
+      "onChange",
+      "change click focusin focusout input keydown keyup selectionchange".split(
+        " "
+      )
+    );
+    registerTwoPhaseEvent(
+      "onSelect",
+      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
+        " "
+      )
+    );
+    registerTwoPhaseEvent("onBeforeInput", [
+      "compositionend",
+      "keypress",
+      "textInput",
+      "paste"
+    ]);
+    registerTwoPhaseEvent(
+      "onCompositionEnd",
+      "compositionend focusout keydown keypress keyup mousedown".split(" ")
+    );
+    registerTwoPhaseEvent(
+      "onCompositionStart",
+      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
+    );
+    registerTwoPhaseEvent(
+      "onCompositionUpdate",
+      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
+    );
+    var mediaEventTypes =
+        "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
+          " "
+        ),
+      nonDelegatedEvents = new Set(
+        "beforetoggle cancel close invalid load scroll scrollend toggle"
+          .split(" ")
+          .concat(mediaEventTypes)
+      ),
+      listeningMarker = "_reactListening" + Math.random().toString(36).slice(2),
+      didWarnControlledToUncontrolled = !1,
+      didWarnUncontrolledToControlled = !1,
+      didWarnFormActionType = !1,
+      didWarnFormActionName = !1,
+      didWarnFormActionTarget = !1,
+      didWarnFormActionMethod = !1,
+      didWarnPopoverTargetObject = !1;
+    var didWarnForNewBooleanPropsWithEmptyValue = {};
+    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
+      NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g,
+      xlinkNamespace = "http://www.w3.org/1999/xlink",
+      xmlNamespace = "http://www.w3.org/XML/1998/namespace",
+      EXPECTED_FORM_ACTION_URL =
+        "javascript:throw new Error('React form unexpectedly submitted.')",
+      SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning",
+      SUSPENSE_START_DATA = "$",
+      SUSPENSE_END_DATA = "/$",
+      SUSPENSE_PENDING_START_DATA = "$?",
+      SUSPENSE_FALLBACK_START_DATA = "$!",
+      FORM_STATE_IS_MATCHING = "F!",
+      FORM_STATE_IS_NOT_MATCHING = "F",
+      DOCUMENT_READY_STATE_COMPLETE = "complete",
+      STYLE = "style",
+      HostContextNamespaceNone = 0,
+      HostContextNamespaceSvg = 1,
+      HostContextNamespaceMath = 2,
+      eventsEnabled = null,
+      selectionInformation = null,
+      warnedUnknownTags = { dialog: !0, webview: !0 },
+      currentPopstateTransitionEvent = null,
+      schedulerEvent = void 0,
+      scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
+      cancelTimeout =
+        "function" === typeof clearTimeout ? clearTimeout : void 0,
+      noTimeout = -1,
+      localPromise = "function" === typeof Promise ? Promise : void 0,
+      scheduleMicrotask =
+        "function" === typeof queueMicrotask
+          ? queueMicrotask
+          : "undefined" !== typeof localPromise
+            ? function (callback) {
+                return localPromise
+                  .resolve(null)
+                  .then(callback)
+                  .catch(handleErrorInNextTick);
+              }
+            : scheduleTimeout,
+      SUSPENSEY_FONT_TIMEOUT = 500;
+    ViewTransitionPseudoElement.prototype.animate = function (
+      keyframes,
+      options
+    ) {
+      options =
+        "number" === typeof options
+          ? { duration: options }
+          : assign({}, options);
+      options.pseudoElement = this._selector;
+      return this._scope.animate(keyframes, options);
+    };
+    ViewTransitionPseudoElement.prototype.getAnimations = function () {
+      for (
+        var scope = this._scope,
+          selector = this._selector,
+          animations = scope.getAnimations({ subtree: !0 }),
+          result = [],
+          i = 0;
+        i < animations.length;
+        i++
+      ) {
+        var effect = animations[i].effect;
+        null !== effect &&
+          effect.target === scope &&
+          effect.pseudoElement === selector &&
+          result.push(animations[i]);
+      }
+      return result;
+    };
+    var NotLoaded = 0,
+      Loaded = 1,
+      Errored = 2,
+      Settled = 3,
+      Inserted = 4,
+      preloadPropsMap = new Map(),
+      preconnectsSet = new Set(),
+      previousDispatcher = ReactDOMSharedInternals.d;
+    ReactDOMSharedInternals.d = {
+      f: function () {
+        var previousWasRendering = previousDispatcher.f(),
+          wasRendering = flushSyncWork$1();
+        return previousWasRendering || wasRendering;
+      },
+      r: function (form) {
+        var formInst = getInstanceFromNode(form);
+        null !== formInst && 5 === formInst.tag && "form" === formInst.type
+          ? requestFormReset$1(formInst)
+          : previousDispatcher.r(form);
+      },
+      D: function (href) {
+        previousDispatcher.D(href);
+        preconnectAs("dns-prefetch", href, null);
+      },
+      C: function (href, crossOrigin) {
+        previousDispatcher.C(href, crossOrigin);
+        preconnectAs("preconnect", href, crossOrigin);
+      },
+      L: function (href, as, options) {
+        previousDispatcher.L(href, as, options);
+        var ownerDocument = globalDocument;
+        if (ownerDocument && href && as) {
+          var preloadSelector =
+            'link[rel="preload"][as="' +
+            escapeSelectorAttributeValueInsideDoubleQuotes(as) +
+            '"]';
+          "image" === as
+            ? options && options.imageSrcSet
+              ? ((preloadSelector +=
+                  '[imagesrcset="' +
+                  escapeSelectorAttributeValueInsideDoubleQuotes(
+                    options.imageSrcSet
+                  ) +
+                  '"]'),
+                "string" === typeof options.imageSizes &&
+                  (preloadSelector +=
+                    '[imagesizes="' +
+                    escapeSelectorAttributeValueInsideDoubleQuotes(
+                      options.imageSizes
+                    ) +
+                    '"]'))
+              : (preloadSelector +=
+                  '[href="' +
+                  escapeSelectorAttributeValueInsideDoubleQuotes(href) +
+                  '"]')
+            : (preloadSelector +=
+                '[href="' +
+                escapeSelectorAttributeValueInsideDoubleQuotes(href) +
+                '"]');
+          var key = preloadSelector;
+          switch (as) {
+            case "style":
+              key = getStyleKey(href);
+              break;
+            case "script":
+              key = getScriptKey(href);
+          }
+          preloadPropsMap.has(key) ||
+            ((href = assign(
+              {
+                rel: "preload",
+                href:
+                  "image" === as && options && options.imageSrcSet
+                    ? void 0
+                    : href,
+                as: as
+              },
+              options
+            )),
+            preloadPropsMap.set(key, href),
+            null !== ownerDocument.querySelector(preloadSelector) ||
+              ("style" === as &&
+                ownerDocument.querySelector(
+                  getStylesheetSelectorFromKey(key)
+                )) ||
+              ("script" === as &&
+                ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
+              ((as = ownerDocument.createElement("link")),
+              setInitialProperties(as, "link", href),
+              markNodeAsHoistable(as),
+              ownerDocument.head.appendChild(as)));
+        }
+      },
+      m: function (href, options) {
+        previousDispatcher.m(href, options);
+        var ownerDocument = globalDocument;
+        if (ownerDocument && href) {
+          var as =
+              options && "string" === typeof options.as ? options.as : "script",
+            preloadSelector =
+              'link[rel="modulepreload"][as="' +
+              escapeSelectorAttributeValueInsideDoubleQuotes(as) +
+              '"][href="' +
+              escapeSelectorAttributeValueInsideDoubleQuotes(href) +
+              '"]',
+            key = preloadSelector;
+          switch (as) {
+            case "audioworklet":
+            case "paintworklet":
+            case "serviceworker":
+            case "sharedworker":
+            case "worker":
+            case "script":
+              key = getScriptKey(href);
+          }
+          if (
+            !preloadPropsMap.has(key) &&
+            ((href = assign({ rel: "modulepreload", href: href }, options)),
+            preloadPropsMap.set(key, href),
+            null === ownerDocument.querySelector(preloadSelector))
+          ) {
+            switch (as) {
+              case "audioworklet":
+              case "paintworklet":
+              case "serviceworker":
+              case "sharedworker":
+              case "worker":
+              case "script":
+                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
+                  return;
+            }
+            as = ownerDocument.createElement("link");
+            setInitialProperties(as, "link", href);
+            markNodeAsHoistable(as);
+            ownerDocument.head.appendChild(as);
+          }
+        }
+      },
+      X: function (src, options) {
+        previousDispatcher.X(src, options);
+        var ownerDocument = globalDocument;
+        if (ownerDocument && src) {
+          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
+            key = getScriptKey(src),
+            resource = scripts.get(key);
+          resource ||
+            ((resource = ownerDocument.querySelector(
+              getScriptSelectorFromKey(key)
+            )),
+            resource ||
+              ((src = assign({ src: src, async: !0 }, options)),
+              (options = preloadPropsMap.get(key)) &&
+                adoptPreloadPropsForScript(src, options),
+              (resource = ownerDocument.createElement("script")),
+              markNodeAsHoistable(resource),
+              setInitialProperties(resource, "link", src),
+              ownerDocument.head.appendChild(resource)),
+            (resource = {
+              type: "script",
+              instance: resource,
+              count: 1,
+              state: null
+            }),
+            scripts.set(key, resource));
+        }
+      },
+      S: function (href, precedence, options) {
+        previousDispatcher.S(href, precedence, options);
+        var ownerDocument = globalDocument;
+        if (ownerDocument && href) {
+          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
+            key = getStyleKey(href);
+          precedence = precedence || "default";
+          var resource = styles.get(key);
+          if (!resource) {
+            var state = { loading: NotLoaded, preload: null };
+            if (
+              (resource = ownerDocument.querySelector(
+                getStylesheetSelectorFromKey(key)
+              ))
+            )
+              state.loading = Loaded | Inserted;
+            else {
+              href = assign(
+                {
+                  rel: "stylesheet",
+                  href: href,
+                  "data-precedence": precedence
+                },
+                options
+              );
+              (options = preloadPropsMap.get(key)) &&
+                adoptPreloadPropsForStylesheet(href, options);
+              var link = (resource = ownerDocument.createElement("link"));
+              markNodeAsHoistable(link);
+              setInitialProperties(link, "link", href);
+              link._p = new Promise(function (resolve, reject) {
+                link.onload = resolve;
+                link.onerror = reject;
+              });
+              link.addEventListener("load", function () {
+                state.loading |= Loaded;
+              });
+              link.addEventListener("error", function () {
+                state.loading |= Errored;
+              });
+              state.loading |= Inserted;
+              insertStylesheet(resource, precedence, ownerDocument);
+            }
+            resource = {
+              type: "stylesheet",
+              instance: resource,
+              count: 1,
+              state: state
+            };
+            styles.set(key, resource);
+          }
+        }
+      },
+      M: function (src, options) {
+        previousDispatcher.M(src, options);
+        var ownerDocument = globalDocument;
+        if (ownerDocument && src) {
+          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
+            key = getScriptKey(src),
+            resource = scripts.get(key);
+          resource ||
+            ((resource = ownerDocument.querySelector(
+              getScriptSelectorFromKey(key)
+            )),
+            resource ||
+              ((src = assign({ src: src, async: !0, type: "module" }, options)),
+              (options = preloadPropsMap.get(key)) &&
+                adoptPreloadPropsForScript(src, options),
+              (resource = ownerDocument.createElement("script")),
+              markNodeAsHoistable(resource),
+              setInitialProperties(resource, "link", src),
+              ownerDocument.head.appendChild(resource)),
+            (resource = {
+              type: "script",
+              instance: resource,
+              count: 1,
+              state: null
+            }),
+            scripts.set(key, resource));
+        }
+      }
+    };
+    var globalDocument = "undefined" === typeof document ? null : document,
+      tagCaches = null,
+      suspendedState = null,
+      LAST_PRECEDENCE = null,
+      precedencesByRoot = null,
+      NotPendingTransition = NotPending,
+      HostTransitionContext = {
+        $$typeof: REACT_CONTEXT_TYPE,
+        Provider: null,
+        Consumer: null,
+        _currentValue: NotPendingTransition,
+        _currentValue2: NotPendingTransition,
+        _threadCount: 0
+      },
+      badgeFormat = "%c%s%c ",
+      badgeStyle =
+        "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
+      resetStyle = "",
+      pad = " ",
+      bind = Function.prototype.bind;
+    var didWarnAboutNestedUpdates = !1;
+    var overrideHookState = null,
+      overrideHookStateDeletePath = null,
+      overrideHookStateRenamePath = null,
+      overrideProps = null,
+      overridePropsDeletePath = null,
+      overridePropsRenamePath = null,
+      scheduleUpdate = null,
+      setErrorHandler = null,
+      setSuspenseHandler = null;
+    overrideHookState = function (fiber, id, path, value) {
+      id = findHook(fiber, id);
+      null !== id &&
+        ((path = copyWithSetImpl(id.memoizedState, path, 0, value)),
+        (id.memoizedState = path),
+        (id.baseState = path),
+        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
+        (path = enqueueConcurrentRenderForLane(fiber, 2)),
+        null !== path && scheduleUpdateOnFiber(path, fiber, 2));
+    };
+    overrideHookStateDeletePath = function (fiber, id, path) {
+      id = findHook(fiber, id);
+      null !== id &&
+        ((path = copyWithDeleteImpl(id.memoizedState, path, 0)),
+        (id.memoizedState = path),
+        (id.baseState = path),
+        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
+        (path = enqueueConcurrentRenderForLane(fiber, 2)),
+        null !== path && scheduleUpdateOnFiber(path, fiber, 2));
+    };
+    overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
+      id = findHook(fiber, id);
+      null !== id &&
+        ((oldPath = copyWithRename(id.memoizedState, oldPath, newPath)),
+        (id.memoizedState = oldPath),
+        (id.baseState = oldPath),
+        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
+        (oldPath = enqueueConcurrentRenderForLane(fiber, 2)),
+        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
+    };
+    overrideProps = function (fiber, path, value) {
+      fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
+      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
+      path = enqueueConcurrentRenderForLane(fiber, 2);
+      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
+    };
+    overridePropsDeletePath = function (fiber, path) {
+      fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
+      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
+      path = enqueueConcurrentRenderForLane(fiber, 2);
+      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
+    };
+    overridePropsRenamePath = function (fiber, oldPath, newPath) {
+      fiber.pendingProps = copyWithRename(
+        fiber.memoizedProps,
+        oldPath,
+        newPath
+      );
+      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
+      oldPath = enqueueConcurrentRenderForLane(fiber, 2);
+      null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
+    };
+    scheduleUpdate = function (fiber) {
+      var root = enqueueConcurrentRenderForLane(fiber, 2);
+      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
+    };
+    setErrorHandler = function (newShouldErrorImpl) {
+      shouldErrorImpl = newShouldErrorImpl;
+    };
+    setSuspenseHandler = function (newShouldSuspendImpl) {
+      shouldSuspendImpl = newShouldSuspendImpl;
+    };
+    var _enabled = !0,
+      return_targetInst = null,
+      hasScheduledReplayAttempt = !1,
+      queuedFocus = null,
+      queuedDrag = null,
+      queuedMouse = null,
+      queuedPointers = new Map(),
+      queuedPointerCaptures = new Map(),
+      queuedExplicitHydrationTargets = [],
+      discreteReplayableEvents =
+        "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
+          " "
+        ),
+      lastScheduledReplayQueue = null;
+    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
+      function (children) {
+        var root = this._internalRoot;
+        if (null === root) throw Error("Cannot update an unmounted root.");
+        var args = arguments;
+        "function" === typeof args[1]
+          ? console.error(
+              "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
+            )
+          : isValidContainer(args[1])
+            ? console.error(
+                "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
+              )
+            : "undefined" !== typeof args[1] &&
+              console.error(
+                "You passed a second argument to root.render(...) but it only accepts one argument."
+              );
+        args = children;
+        var current = root.current,
+          lane = requestUpdateLane(current);
+        updateContainerImpl(current, lane, args, root, null, null);
+      };
+    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
+      function () {
+        var args = arguments;
+        "function" === typeof args[0] &&
+          console.error(
+            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
+          );
+        args = this._internalRoot;
+        if (null !== args) {
+          this._internalRoot = null;
+          var container = args.containerInfo;
+          (executionContext & (RenderContext | CommitContext)) !== NoContext &&
+            console.error(
+              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
+            );
+          updateContainerImpl(args.current, 2, null, args, null, null);
+          flushSyncWork$1();
+          container[internalContainerInstanceKey] = null;
+        }
+      };
+    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (
+      target
+    ) {
+      if (target) {
+        var updatePriority = resolveUpdatePriority();
+        target = { blockedOn: null, target: target, priority: updatePriority };
+        for (
+          var i = 0;
+          i < queuedExplicitHydrationTargets.length &&
+          0 !== updatePriority &&
+          updatePriority < queuedExplicitHydrationTargets[i].priority;
+          i++
+        );
+        queuedExplicitHydrationTargets.splice(i, 0, target);
+        0 === i && attemptExplicitHydrationTarget(target);
+      }
+    };
+    (function () {
+      var isomorphicReactPackageVersion = React.version;
+      if ("19.1.0-experimental-b3a95caf-20250113" !== isomorphicReactPackageVersion)
+        throw Error(
+          'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
+            (isomorphicReactPackageVersion +
+              "\n  - react-dom:  19.1.0-experimental-b3a95caf-20250113\nLearn more: https://react.dev/warnings/version-mismatch")
+        );
+    })();
+    ("function" === typeof Map &&
+      null != Map.prototype &&
+      "function" === typeof Map.prototype.forEach &&
+      "function" === typeof Set &&
+      null != Set.prototype &&
+      "function" === typeof Set.prototype.clear &&
+      "function" === typeof Set.prototype.forEach) ||
+      console.error(
+        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
+      );
+    ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
+      var fiber = componentOrElement._reactInternals;
+      if (void 0 === fiber) {
+        if ("function" === typeof componentOrElement.render)
+          throw Error("Unable to find node on an unmounted component.");
+        componentOrElement = Object.keys(componentOrElement).join(",");
+        throw Error(
+          "Argument appears to not be a ReactComponent. Keys: " +
+            componentOrElement
+        );
+      }
+      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
+      componentOrElement =
+        null !== componentOrElement
+          ? findCurrentHostFiberImpl(componentOrElement)
+          : null;
+      componentOrElement =
+        null === componentOrElement ? null : componentOrElement.stateNode;
+      return componentOrElement;
+    };
+    if (
+      !(function () {
+        var internals = {
+          bundleType: 1,
+          version: "19.1.0-experimental-b3a95caf-20250113",
+          rendererPackageName: "react-dom",
+          currentDispatcherRef: ReactSharedInternals,
+          reconcilerVersion: "19.1.0-experimental-b3a95caf-20250113"
+        };
+        internals.overrideHookState = overrideHookState;
+        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
+        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
+        internals.overrideProps = overrideProps;
+        internals.overridePropsDeletePath = overridePropsDeletePath;
+        internals.overridePropsRenamePath = overridePropsRenamePath;
+        internals.scheduleUpdate = scheduleUpdate;
+        internals.setErrorHandler = setErrorHandler;
+        internals.setSuspenseHandler = setSuspenseHandler;
+        internals.scheduleRefresh = scheduleRefresh;
+        internals.scheduleRoot = scheduleRoot;
+        internals.setRefreshHandler = setRefreshHandler;
+        internals.getCurrentFiber = getCurrentFiberForDevTools;
+        return injectInternals(internals);
+      })() &&
+      canUseDOM &&
+      window.top === window.self &&
+      ((-1 < navigator.userAgent.indexOf("Chrome") &&
+        -1 === navigator.userAgent.indexOf("Edge")) ||
+        -1 < navigator.userAgent.indexOf("Firefox"))
+    ) {
+      var protocol = window.location.protocol;
+      /^(https?|file):$/.test(protocol) &&
+        console.info(
+          "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" +
+            ("file:" === protocol
+              ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq"
+              : ""),
+          "font-weight:bold"
+        );
+    }
+    exports.createComponentSelector = function (component) {
+      return { $$typeof: COMPONENT_TYPE, value: component };
+    };
+    exports.createHasPseudoClassSelector = function (selectors) {
+      return { $$typeof: HAS_PSEUDO_CLASS_TYPE, value: selectors };
+    };
+    exports.createRoleSelector = function (role) {
+      return { $$typeof: ROLE_TYPE, value: role };
+    };
+    exports.createRoot = function (container, options) {
+      if (!isValidContainer(container))
+        throw Error("Target container is not a DOM element.");
+      warnIfReactDOMContainerInDEV(container);
+      var isStrictMode = !1,
+        identifierPrefix = "",
+        onUncaughtError = defaultOnUncaughtError,
+        onCaughtError = defaultOnCaughtError,
+        onRecoverableError = defaultOnRecoverableError,
+        transitionCallbacks = null;
+      null !== options &&
+        void 0 !== options &&
+        (options.hydrate
+          ? console.warn(
+              "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
+            )
+          : "object" === typeof options &&
+            null !== options &&
+            options.$$typeof === REACT_ELEMENT_TYPE &&
+            console.error(
+              "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
+            ),
+        !0 === options.unstable_strictMode && (isStrictMode = !0),
+        void 0 !== options.identifierPrefix &&
+          (identifierPrefix = options.identifierPrefix),
+        void 0 !== options.onUncaughtError &&
+          (onUncaughtError = options.onUncaughtError),
+        void 0 !== options.onCaughtError &&
+          (onCaughtError = options.onCaughtError),
+        void 0 !== options.onRecoverableError &&
+          (onRecoverableError = options.onRecoverableError),
+        void 0 !== options.unstable_transitionCallbacks &&
+          (transitionCallbacks = options.unstable_transitionCallbacks));
+      options = createFiberRoot(
+        container,
+        1,
+        !1,
+        null,
+        null,
+        isStrictMode,
+        identifierPrefix,
+        onUncaughtError,
+        onCaughtError,
+        onRecoverableError,
+        transitionCallbacks,
+        null
+      );
+      container[internalContainerInstanceKey] = options.current;
+      listenToAllSupportedEvents(
+        8 === container.nodeType ? container.parentNode : container
+      );
+      return new ReactDOMRoot(options);
+    };
+    exports.createTestNameSelector = function (id) {
+      return { $$typeof: TEST_NAME_TYPE, value: id };
+    };
+    exports.createTextSelector = function (text) {
+      return { $$typeof: TEXT_TYPE, value: text };
+    };
+    exports.findAllNodes = findAllNodes;
+    exports.findBoundingRects = function (hostRoot, selectors) {
+      selectors = findAllNodes(hostRoot, selectors);
+      hostRoot = [];
+      for (var i = 0; i < selectors.length; i++)
+        hostRoot.push(getBoundingRect(selectors[i]));
+      for (selectors = hostRoot.length - 1; 0 < selectors; selectors--) {
+        i = hostRoot[selectors];
+        for (
+          var targetLeft = i.x,
+            targetRight = targetLeft + i.width,
+            targetTop = i.y,
+            targetBottom = targetTop + i.height,
+            j = selectors - 1;
+          0 <= j;
+          j--
+        )
+          if (selectors !== j) {
+            var otherRect = hostRoot[j],
+              otherLeft = otherRect.x,
+              otherRight = otherLeft + otherRect.width,
+              otherTop = otherRect.y,
+              otherBottom = otherTop + otherRect.height;
+            if (
+              targetLeft >= otherLeft &&
+              targetTop >= otherTop &&
+              targetRight <= otherRight &&
+              targetBottom <= otherBottom
+            ) {
+              hostRoot.splice(selectors, 1);
+              break;
+            } else if (
+              !(
+                targetLeft !== otherLeft ||
+                i.width !== otherRect.width ||
+                otherBottom < targetTop ||
+                otherTop > targetBottom
+              )
+            ) {
+              otherTop > targetTop &&
+                ((otherRect.height += otherTop - targetTop),
+                (otherRect.y = targetTop));
+              otherBottom < targetBottom &&
+                (otherRect.height = targetBottom - otherTop);
+              hostRoot.splice(selectors, 1);
+              break;
+            } else if (
+              !(
+                targetTop !== otherTop ||
+                i.height !== otherRect.height ||
+                otherRight < targetLeft ||
+                otherLeft > targetRight
+              )
+            ) {
+              otherLeft > targetLeft &&
+                ((otherRect.width += otherLeft - targetLeft),
+                (otherRect.x = targetLeft));
+              otherRight < targetRight &&
+                (otherRect.width = targetRight - otherLeft);
+              hostRoot.splice(selectors, 1);
+              break;
+            }
+          }
+      }
+      return hostRoot;
+    };
+    exports.focusWithin = function (hostRoot, selectors) {
+      hostRoot = findFiberRootForHostRoot(hostRoot);
+      selectors = findPaths(hostRoot, selectors);
+      selectors = Array.from(selectors);
+      for (hostRoot = 0; hostRoot < selectors.length; ) {
+        var fiber = selectors[hostRoot++],
+          tag = fiber.tag;
+        if (!isHiddenSubtree(fiber)) {
+          if (
+            (5 === tag || 26 === tag || 27 === tag) &&
+            setFocusIfFocusable(fiber.stateNode)
+          )
+            return !0;
+          for (fiber = fiber.child; null !== fiber; )
+            selectors.push(fiber), (fiber = fiber.sibling);
+        }
+      }
+      return !1;
+    };
+    exports.getFindAllNodesFailureDescription = function (hostRoot, selectors) {
+      var maxSelectorIndex = 0,
+        matchedNames = [];
+      hostRoot = [findFiberRootForHostRoot(hostRoot), 0];
+      for (var index = 0; index < hostRoot.length; ) {
+        var fiber = hostRoot[index++],
+          tag = fiber.tag,
+          selectorIndex = hostRoot[index++],
+          selector = selectors[selectorIndex];
+        if ((5 !== tag && 26 !== tag && 27 !== tag) || !isHiddenSubtree(fiber))
+          if (
+            (matchSelector(fiber, selector) &&
+              (matchedNames.push(selectorToString(selector)),
+              selectorIndex++,
+              selectorIndex > maxSelectorIndex &&
+                (maxSelectorIndex = selectorIndex)),
+            selectorIndex < selectors.length)
+          )
+            for (fiber = fiber.child; null !== fiber; )
+              hostRoot.push(fiber, selectorIndex), (fiber = fiber.sibling);
+      }
+      if (maxSelectorIndex < selectors.length) {
+        for (
+          hostRoot = [];
+          maxSelectorIndex < selectors.length;
+          maxSelectorIndex++
+        )
+          hostRoot.push(selectorToString(selectors[maxSelectorIndex]));
+        return (
+          "findAllNodes was able to match part of the selector:\n  " +
+          (matchedNames.join(" > ") +
+            "\n\nNo matching component was found for:\n  ") +
+          hostRoot.join(" > ")
+        );
+      }
+      return null;
+    };
+    exports.hydrateRoot = function (container, initialChildren, options) {
+      if (!isValidContainer(container))
+        throw Error("Target container is not a DOM element.");
+      warnIfReactDOMContainerInDEV(container);
+      void 0 === initialChildren &&
+        console.error(
+          "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
+        );
+      var isStrictMode = !1,
+        identifierPrefix = "",
+        onUncaughtError = defaultOnUncaughtError,
+        onCaughtError = defaultOnCaughtError,
+        onRecoverableError = defaultOnRecoverableError,
+        transitionCallbacks = null,
+        formState = null;
+      null !== options &&
+        void 0 !== options &&
+        (!0 === options.unstable_strictMode && (isStrictMode = !0),
+        void 0 !== options.identifierPrefix &&
+          (identifierPrefix = options.identifierPrefix),
+        void 0 !== options.onUncaughtError &&
+          (onUncaughtError = options.onUncaughtError),
+        void 0 !== options.onCaughtError &&
+          (onCaughtError = options.onCaughtError),
+        void 0 !== options.onRecoverableError &&
+          (onRecoverableError = options.onRecoverableError),
+        void 0 !== options.unstable_transitionCallbacks &&
+          (transitionCallbacks = options.unstable_transitionCallbacks),
+        void 0 !== options.formState && (formState = options.formState));
+      initialChildren = createFiberRoot(
+        container,
+        1,
+        !0,
+        initialChildren,
+        null != options ? options : null,
+        isStrictMode,
+        identifierPrefix,
+        onUncaughtError,
+        onCaughtError,
+        onRecoverableError,
+        transitionCallbacks,
+        formState
+      );
+      initialChildren.context = getContextForSubtree(null);
+      options = initialChildren.current;
+      isStrictMode = requestUpdateLane(options);
+      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
+      identifierPrefix = createUpdate(isStrictMode);
+      identifierPrefix.callback = null;
+      enqueueUpdate(options, identifierPrefix, isStrictMode);
+      options = isStrictMode;
+      initialChildren.current.lanes = options;
+      markRootUpdated$1(initialChildren, options);
+      ensureRootIsScheduled(initialChildren);
+      container[internalContainerInstanceKey] = initialChildren.current;
+      listenToAllSupportedEvents(container);
+      return new ReactDOMHydrationRoot(initialChildren);
+    };
+    exports.observeVisibleRects = function (
+      hostRoot,
+      selectors,
+      callback,
+      options
+    ) {
+      function commitHook() {
+        var nextInstanceRoots = findAllNodes(hostRoot, selectors);
+        instanceRoots.forEach(function (target) {
+          0 > nextInstanceRoots.indexOf(target) && unobserve(target);
+        });
+        nextInstanceRoots.forEach(function (target) {
+          0 > instanceRoots.indexOf(target) && observe(target);
+        });
+      }
+      var instanceRoots = findAllNodes(hostRoot, selectors);
+      callback = setupIntersectionObserver(instanceRoots, callback, options);
+      var disconnect = callback.disconnect,
+        observe = callback.observe,
+        unobserve = callback.unobserve;
+      commitHooks.push(commitHook);
+      return {
+        disconnect: function () {
+          var index = commitHooks.indexOf(commitHook);
+          0 <= index && commitHooks.splice(index, 1);
+          disconnect();
+        }
+      };
+    };
+    exports.version = "19.1.0-experimental-b3a95caf-20250113";
+  })();
diff --git a/node_modules/react-dom/cjs/react-dom-unstable_testing.production.js b/node_modules/react-dom/cjs/react-dom-unstable_testing.production.js
new file mode 100644
index 0000000..a0b17ff
--- /dev/null
+++ b/node_modules/react-dom/cjs/react-dom-unstable_testing.production.js
@@ -0,0 +1,16994 @@
+/**
+ * @license React
+ * react-dom-unstable_testing.production.js
+ *
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/*
+ Modernizr 3.0.0pre (Custom Build) | MIT
+*/
+"use strict";
+var Scheduler = require("scheduler"),
+  React = require("react"),
+  ReactDOM = require("react-dom");
+function formatProdErrorMessage(code) {
+  var url = "https://react.dev/errors/" + code;
+  if (1 < arguments.length) {
+    url += "?args[]=" + encodeURIComponent(arguments[1]);
+    for (var i = 2; i < arguments.length; i++)
+      url += "&args[]=" + encodeURIComponent(arguments[i]);
+  }
+  return (
+    "Minified React error #" +
+    code +
+    "; visit " +
+    url +
+    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
+  );
+}
+function isValidContainer(node) {
+  return !(
+    !node ||
+    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
+  );
+}
+function getNearestMountedFiber(fiber) {
+  var node = fiber,
+    nearestMounted = fiber;
+  if (fiber.alternate) for (; node.return; ) node = node.return;
+  else {
+    fiber = node;
+    do
+      (node = fiber),
+        0 !== (node.flags & 4098) && (nearestMounted = node.return),
+        (fiber = node.return);
+    while (fiber);
+  }
+  return 3 === node.tag ? nearestMounted : null;
+}
+function getSuspenseInstanceFromFiber(fiber) {
+  if (13 === fiber.tag) {
+    var suspenseState = fiber.memoizedState;
+    null === suspenseState &&
+      ((fiber = fiber.alternate),
+      null !== fiber && (suspenseState = fiber.memoizedState));
+    if (null !== suspenseState) return suspenseState.dehydrated;
+  }
+  return null;
+}
+function assertIsMounted(fiber) {
+  if (getNearestMountedFiber(fiber) !== fiber)
+    throw Error(formatProdErrorMessage(188));
+}
+function findCurrentFiberUsingSlowPath(fiber) {
+  var alternate = fiber.alternate;
+  if (!alternate) {
+    alternate = getNearestMountedFiber(fiber);
+    if (null === alternate) throw Error(formatProdErrorMessage(188));
+    return alternate !== fiber ? null : fiber;
+  }
+  for (var a = fiber, b = alternate; ; ) {
+    var parentA = a.return;
+    if (null === parentA) break;
+    var parentB = parentA.alternate;
+    if (null === parentB) {
+      b = parentA.return;
+      if (null !== b) {
+        a = b;
+        continue;
+      }
+      break;
+    }
+    if (parentA.child === parentB.child) {
+      for (parentB = parentA.child; parentB; ) {
+        if (parentB === a) return assertIsMounted(parentA), fiber;
+        if (parentB === b) return assertIsMounted(parentA), alternate;
+        parentB = parentB.sibling;
+      }
+      throw Error(formatProdErrorMessage(188));
+    }
+    if (a.return !== b.return) (a = parentA), (b = parentB);
+    else {
+      for (var didFindChild = !1, child$0 = parentA.child; child$0; ) {
+        if (child$0 === a) {
+          didFindChild = !0;
+          a = parentA;
+          b = parentB;
+          break;
+        }
+        if (child$0 === b) {
+          didFindChild = !0;
+          b = parentA;
+          a = parentB;
+          break;
+        }
+        child$0 = child$0.sibling;
+      }
+      if (!didFindChild) {
+        for (child$0 = parentB.child; child$0; ) {
+          if (child$0 === a) {
+            didFindChild = !0;
+            a = parentB;
+            b = parentA;
+            break;
+          }
+          if (child$0 === b) {
+            didFindChild = !0;
+            b = parentB;
+            a = parentA;
+            break;
+          }
+          child$0 = child$0.sibling;
+        }
+        if (!didFindChild) throw Error(formatProdErrorMessage(189));
+      }
+    }
+    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
+  }
+  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
+  return a.stateNode.current === a ? fiber : alternate;
+}
+function findCurrentHostFiberImpl(node) {
+  var tag = node.tag;
+  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
+  for (node = node.child; null !== node; ) {
+    tag = findCurrentHostFiberImpl(node);
+    if (null !== tag) return tag;
+    node = node.sibling;
+  }
+  return null;
+}
+var assign = Object.assign,
+  REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
+  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
+  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
+  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
+  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
+  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
+  REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
+  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
+  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
+  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
+  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
+  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
+  REACT_MEMO_TYPE = Symbol.for("react.memo"),
+  REACT_LAZY_TYPE = Symbol.for("react.lazy");
+Symbol.for("react.scope");
+var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
+  REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
+Symbol.for("react.tracing_marker");
+var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+  REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
+  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+function getIteratorFn(maybeIterable) {
+  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  maybeIterable =
+    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
+    maybeIterable["@@iterator"];
+  return "function" === typeof maybeIterable ? maybeIterable : null;
+}
+var ASYNC_ITERATOR = Symbol.asyncIterator,
+  REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
+function getComponentNameFromType(type) {
+  if (null == type) return null;
+  if ("function" === typeof type)
+    return type.$$typeof === REACT_CLIENT_REFERENCE
+      ? null
+      : type.displayName || type.name || null;
+  if ("string" === typeof type) return type;
+  switch (type) {
+    case REACT_FRAGMENT_TYPE:
+      return "Fragment";
+    case REACT_PORTAL_TYPE:
+      return "Portal";
+    case REACT_PROFILER_TYPE:
+      return "Profiler";
+    case REACT_STRICT_MODE_TYPE:
+      return "StrictMode";
+    case REACT_SUSPENSE_TYPE:
+      return "Suspense";
+    case REACT_SUSPENSE_LIST_TYPE:
+      return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
+  }
+  if ("object" === typeof type)
+    switch (type.$$typeof) {
+      case REACT_CONTEXT_TYPE:
+        return (type.displayName || "Context") + ".Provider";
+      case REACT_CONSUMER_TYPE:
+        return (type._context.displayName || "Context") + ".Consumer";
+      case REACT_FORWARD_REF_TYPE:
+        var innerType = type.render;
+        type = type.displayName;
+        type ||
+          ((type = innerType.displayName || innerType.name || ""),
+          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
+        return type;
+      case REACT_MEMO_TYPE:
+        return (
+          (innerType = type.displayName || null),
+          null !== innerType
+            ? innerType
+            : getComponentNameFromType(type.type) || "Memo"
+        );
+      case REACT_LAZY_TYPE:
+        innerType = type._payload;
+        type = type._init;
+        try {
+          return getComponentNameFromType(type(innerType));
+        } catch (x) {}
+    }
+  return null;
+}
+var isArrayImpl = Array.isArray,
+  ReactSharedInternals =
+    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
+  ReactDOMSharedInternals =
+    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
+  sharedNotPendingObject = {
+    pending: !1,
+    data: null,
+    method: null,
+    action: null
+  },
+  valueStack = [],
+  index = -1;
+function createCursor(defaultValue) {
+  return { current: defaultValue };
+}
+function pop(cursor) {
+  0 > index ||
+    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
+}
+function push(cursor, value) {
+  index++;
+  valueStack[index] = cursor.current;
+  cursor.current = value;
+}
+var contextStackCursor = createCursor(null),
+  contextFiberStackCursor = createCursor(null),
+  rootInstanceStackCursor = createCursor(null),
+  hostTransitionProviderCursor = createCursor(null);
+function pushHostContainer(fiber, nextRootInstance) {
+  push(rootInstanceStackCursor, nextRootInstance);
+  push(contextFiberStackCursor, fiber);
+  push(contextStackCursor, null);
+  fiber = nextRootInstance.nodeType;
+  switch (fiber) {
+    case 9:
+    case 11:
+      nextRootInstance = (nextRootInstance = nextRootInstance.documentElement)
+        ? (nextRootInstance = nextRootInstance.namespaceURI)
+          ? getOwnHostContext(nextRootInstance)
+          : 0
+        : 0;
+      break;
+    default:
+      if (
+        ((fiber = 8 === fiber ? nextRootInstance.parentNode : nextRootInstance),
+        (nextRootInstance = fiber.tagName),
+        (fiber = fiber.namespaceURI))
+      )
+        (fiber = getOwnHostContext(fiber)),
+          (nextRootInstance = getChildHostContextProd(fiber, nextRootInstance));
+      else
+        switch (nextRootInstance) {
+          case "svg":
+            nextRootInstance = 1;
+            break;
+          case "math":
+            nextRootInstance = 2;
+            break;
+          default:
+            nextRootInstance = 0;
+        }
+  }
+  pop(contextStackCursor);
+  push(contextStackCursor, nextRootInstance);
+}
+function popHostContainer() {
+  pop(contextStackCursor);
+  pop(contextFiberStackCursor);
+  pop(rootInstanceStackCursor);
+}
+function pushHostContext(fiber) {
+  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
+  var context = contextStackCursor.current;
+  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
+  context !== JSCompiler_inline_result &&
+    (push(contextFiberStackCursor, fiber),
+    push(contextStackCursor, JSCompiler_inline_result));
+}
+function popHostContext(fiber) {
+  contextFiberStackCursor.current === fiber &&
+    (pop(contextStackCursor), pop(contextFiberStackCursor));
+  hostTransitionProviderCursor.current === fiber &&
+    (pop(hostTransitionProviderCursor),
+    (HostTransitionContext._currentValue = sharedNotPendingObject));
+}
+var hasOwnProperty = Object.prototype.hasOwnProperty,
+  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
+  cancelCallback$1 = Scheduler.unstable_cancelCallback,
+  shouldYield = Scheduler.unstable_shouldYield,
+  requestPaint = Scheduler.unstable_requestPaint,
+  now = Scheduler.unstable_now,
+  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
+  ImmediatePriority = Scheduler.unstable_ImmediatePriority,
+  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
+  NormalPriority$1 = Scheduler.unstable_NormalPriority,
+  LowPriority = Scheduler.unstable_LowPriority,
+  IdlePriority = Scheduler.unstable_IdlePriority,
+  log$1 = Scheduler.log,
+  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
+  rendererID = null,
+  injectedHook = null;
+function setIsStrictModeForDevtools(newIsStrictMode) {
+  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
+  if (injectedHook && "function" === typeof injectedHook.setStrictMode)
+    try {
+      injectedHook.setStrictMode(rendererID, newIsStrictMode);
+    } catch (err) {}
+}
+var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
+  log = Math.log,
+  LN2 = Math.LN2;
+function clz32Fallback(x) {
+  x >>>= 0;
+  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
+}
+var nextTransitionLane = 128,
+  nextRetryLane = 4194304;
+function getHighestPriorityLanes(lanes) {
+  var pendingSyncLanes = lanes & 42;
+  if (0 !== pendingSyncLanes) return pendingSyncLanes;
+  switch (lanes & -lanes) {
+    case 1:
+      return 1;
+    case 2:
+      return 2;
+    case 4:
+      return 4;
+    case 8:
+      return 8;
+    case 16:
+      return 16;
+    case 32:
+      return 32;
+    case 64:
+      return 64;
+    case 128:
+    case 256:
+    case 512:
+    case 1024:
+    case 2048:
+    case 4096:
+    case 8192:
+    case 16384:
+    case 32768:
+    case 65536:
+    case 131072:
+    case 262144:
+    case 524288:
+    case 1048576:
+    case 2097152:
+      return lanes & 4194176;
+    case 4194304:
+    case 8388608:
+    case 16777216:
+    case 33554432:
+      return lanes & 62914560;
+    case 67108864:
+      return 67108864;
+    case 134217728:
+      return 134217728;
+    case 268435456:
+      return 268435456;
+    case 536870912:
+      return 536870912;
+    case 1073741824:
+      return 0;
+    default:
+      return lanes;
+  }
+}
+function getNextLanes(root, wipLanes, rootHasPendingCommit) {
+  var pendingLanes = root.pendingLanes;
+  if (0 === pendingLanes) return 0;
+  var nextLanes = 0,
+    suspendedLanes = root.suspendedLanes,
+    pingedLanes = root.pingedLanes;
+  root = root.warmLanes;
+  var nonIdlePendingLanes = pendingLanes & 134217727;
+  0 !== nonIdlePendingLanes
+    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
+      0 !== pendingLanes
+        ? (nextLanes = getHighestPriorityLanes(pendingLanes))
+        : ((pingedLanes &= nonIdlePendingLanes),
+          0 !== pingedLanes
+            ? (nextLanes = getHighestPriorityLanes(pingedLanes))
+            : rootHasPendingCommit ||
+              ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
+              0 !== rootHasPendingCommit &&
+                (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))
+    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
+      0 !== nonIdlePendingLanes
+        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
+        : 0 !== pingedLanes
+          ? (nextLanes = getHighestPriorityLanes(pingedLanes))
+          : rootHasPendingCommit ||
+            ((rootHasPendingCommit = pendingLanes & ~root),
+            0 !== rootHasPendingCommit &&
+              (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
+  return 0 === nextLanes
+    ? 0
+    : 0 !== wipLanes &&
+        wipLanes !== nextLanes &&
+        0 === (wipLanes & suspendedLanes) &&
+        ((suspendedLanes = nextLanes & -nextLanes),
+        (rootHasPendingCommit = wipLanes & -wipLanes),
+        suspendedLanes >= rootHasPendingCommit ||
+          (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194176)))
+      ? wipLanes
+      : nextLanes;
+}
+function checkIfRootIsPrerendering(root, renderLanes) {
+  return (
+    0 ===
+    (root.pendingLanes &
+      ~(root.suspendedLanes & ~root.pingedLanes) &
+      renderLanes)
+  );
+}
+function computeExpirationTime(lane, currentTime) {
+  switch (lane) {
+    case 1:
+    case 2:
+    case 4:
+    case 8:
+      return currentTime + 250;
+    case 16:
+    case 32:
+    case 64:
+    case 128:
+    case 256:
+    case 512:
+    case 1024:
+    case 2048:
+    case 4096:
+    case 8192:
+    case 16384:
+    case 32768:
+    case 65536:
+    case 131072:
+    case 262144:
+    case 524288:
+    case 1048576:
+    case 2097152:
+      return currentTime + 5e3;
+    case 4194304:
+    case 8388608:
+    case 16777216:
+    case 33554432:
+      return -1;
+    case 67108864:
+    case 134217728:
+    case 268435456:
+    case 536870912:
+    case 1073741824:
+      return -1;
+    default:
+      return -1;
+  }
+}
+function claimNextTransitionLane() {
+  var lane = nextTransitionLane;
+  nextTransitionLane <<= 1;
+  0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
+  return lane;
+}
+function claimNextRetryLane() {
+  var lane = nextRetryLane;
+  nextRetryLane <<= 1;
+  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
+  return lane;
+}
+function createLaneMap(initial) {
+  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
+  return laneMap;
+}
+function markRootUpdated$1(root, updateLane) {
+  root.pendingLanes |= updateLane;
+  268435456 !== updateLane &&
+    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
+}
+function markRootFinished(
+  root,
+  finishedLanes,
+  remainingLanes,
+  spawnedLane,
+  updatedLanes,
+  suspendedRetryLanes
+) {
+  var previouslyPendingLanes = root.pendingLanes;
+  root.pendingLanes = remainingLanes;
+  root.suspendedLanes = 0;
+  root.pingedLanes = 0;
+  root.warmLanes = 0;
+  root.expiredLanes &= remainingLanes;
+  root.entangledLanes &= remainingLanes;
+  root.errorRecoveryDisabledLanes &= remainingLanes;
+  root.shellSuspendCounter = 0;
+  var entanglements = root.entanglements,
+    expirationTimes = root.expirationTimes,
+    hiddenUpdates = root.hiddenUpdates;
+  for (
+    remainingLanes = previouslyPendingLanes & ~remainingLanes;
+    0 < remainingLanes;
+
+  ) {
+    var index$5 = 31 - clz32(remainingLanes),
+      lane = 1 << index$5;
+    entanglements[index$5] = 0;
+    expirationTimes[index$5] = -1;
+    var hiddenUpdatesForLane = hiddenUpdates[index$5];
+    if (null !== hiddenUpdatesForLane)
+      for (
+        hiddenUpdates[index$5] = null, index$5 = 0;
+        index$5 < hiddenUpdatesForLane.length;
+        index$5++
+      ) {
+        var update = hiddenUpdatesForLane[index$5];
+        null !== update && (update.lane &= -536870913);
+      }
+    remainingLanes &= ~lane;
+  }
+  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
+  0 !== suspendedRetryLanes &&
+    0 === updatedLanes &&
+    0 !== root.tag &&
+    (root.suspendedLanes |=
+      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
+}
+function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
+  root.pendingLanes |= spawnedLane;
+  root.suspendedLanes &= ~spawnedLane;
+  var spawnedLaneIndex = 31 - clz32(spawnedLane);
+  root.entangledLanes |= spawnedLane;
+  root.entanglements[spawnedLaneIndex] =
+    root.entanglements[spawnedLaneIndex] |
+    1073741824 |
+    (entangledLanes & 4194218);
+}
+function markRootEntangled(root, entangledLanes) {
+  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
+  for (root = root.entanglements; rootEntangledLanes; ) {
+    var index$6 = 31 - clz32(rootEntangledLanes),
+      lane = 1 << index$6;
+    (lane & entangledLanes) | (root[index$6] & entangledLanes) &&
+      (root[index$6] |= entangledLanes);
+    rootEntangledLanes &= ~lane;
+  }
+}
+function getBumpedLaneForHydrationByLane(lane) {
+  switch (lane) {
+    case 2:
+      lane = 1;
+      break;
+    case 8:
+      lane = 4;
+      break;
+    case 32:
+      lane = 16;
+      break;
+    case 128:
+    case 256:
+    case 512:
+    case 1024:
+    case 2048:
+    case 4096:
+    case 8192:
+    case 16384:
+    case 32768:
+    case 65536:
+    case 131072:
+    case 262144:
+    case 524288:
+    case 1048576:
+    case 2097152:
+    case 4194304:
+    case 8388608:
+    case 16777216:
+    case 33554432:
+      lane = 64;
+      break;
+    case 268435456:
+      lane = 134217728;
+      break;
+    default:
+      lane = 0;
+  }
+  return lane;
+}
+function lanesToEventPriority(lanes) {
+  lanes &= -lanes;
+  return 2 < lanes
+    ? 8 < lanes
+      ? 0 !== (lanes & 134217727)
+        ? 32
+        : 268435456
+      : 8
+    : 2;
+}
+function resolveUpdatePriority() {
+  var updatePriority = ReactDOMSharedInternals.p;
+  if (0 !== updatePriority) return updatePriority;
+  updatePriority = window.event;
+  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
+}
+function runWithPriority(priority, fn) {
+  var previousPriority = ReactDOMSharedInternals.p;
+  try {
+    return (ReactDOMSharedInternals.p = priority), fn();
+  } finally {
+    ReactDOMSharedInternals.p = previousPriority;
+  }
+}
+var randomKey = Math.random().toString(36).slice(2),
+  internalInstanceKey = "__reactFiber$" + randomKey,
+  internalPropsKey = "__reactProps$" + randomKey,
+  internalContainerInstanceKey = "__reactContainer$" + randomKey,
+  internalEventHandlersKey = "__reactEvents$" + randomKey,
+  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
+  internalEventHandlesSetKey = "__reactHandles$" + randomKey,
+  internalRootNodeResourcesKey = "__reactResources$" + randomKey,
+  internalHoistableMarker = "__reactMarker$" + randomKey;
+function detachDeletedInstance(node) {
+  delete node[internalInstanceKey];
+  delete node[internalPropsKey];
+  delete node[internalEventHandlersKey];
+  delete node[internalEventHandlerListenersKey];
+  delete node[internalEventHandlesSetKey];
+}
+function getClosestInstanceFromNode(targetNode) {
+  var targetInst = targetNode[internalInstanceKey];
+  if (targetInst) return targetInst;
+  for (var parentNode = targetNode.parentNode; parentNode; ) {
+    if (
+      (targetInst =
+        parentNode[internalContainerInstanceKey] ||
+        parentNode[internalInstanceKey])
+    ) {
+      parentNode = targetInst.alternate;
+      if (
+        null !== targetInst.child ||
+        (null !== parentNode && null !== parentNode.child)
+      )
+        for (
+          targetNode = getParentSuspenseInstance(targetNode);
+          null !== targetNode;
+
+        ) {
+          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;
+          targetNode = getParentSuspenseInstance(targetNode);
+        }
+      return targetInst;
+    }
+    targetNode = parentNode;
+    parentNode = targetNode.parentNode;
+  }
+  return null;
+}
+function getInstanceFromNode(node) {
+  if (
+    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
+  ) {
+    var tag = node.tag;
+    if (
+      5 === tag ||
+      6 === tag ||
+      13 === tag ||
+      26 === tag ||
+      27 === tag ||
+      3 === tag
+    )
+      return node;
+  }
+  return null;
+}
+function getNodeFromInstance(inst) {
+  var tag = inst.tag;
+  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
+  throw Error(formatProdErrorMessage(33));
+}
+function getResourcesFromRoot(root) {
+  var resources = root[internalRootNodeResourcesKey];
+  resources ||
+    (resources = root[internalRootNodeResourcesKey] =
+      { hoistableStyles: new Map(), hoistableScripts: new Map() });
+  return resources;
+}
+function markNodeAsHoistable(node) {
+  node[internalHoistableMarker] = !0;
+}
+var tagToRoleMappings = {
+  ARTICLE: "article",
+  ASIDE: "complementary",
+  BODY: "document",
+  BUTTON: "button",
+  DATALIST: "listbox",
+  DD: "definition",
+  DETAILS: "group",
+  DIALOG: "dialog",
+  DT: "term",
+  FIELDSET: "group",
+  FIGURE: "figure",
+  FORM: "form",
+  FOOTER: "contentinfo",
+  H1: "heading",
+  H2: "heading",
+  H3: "heading",
+  H4: "heading",
+  H5: "heading",
+  H6: "heading",
+  HEADER: "banner",
+  HR: "separator",
+  LEGEND: "legend",
+  LI: "listitem",
+  MATH: "math",
+  MAIN: "main",
+  MENU: "list",
+  NAV: "navigation",
+  OL: "list",
+  OPTGROUP: "group",
+  OPTION: "option",
+  OUTPUT: "status",
+  PROGRESS: "progressbar",
+  SECTION: "region",
+  SUMMARY: "button",
+  TABLE: "table",
+  TBODY: "rowgroup",
+  TEXTAREA: "textbox",
+  TFOOT: "rowgroup",
+  TD: "cell",
+  TH: "columnheader",
+  THEAD: "rowgroup",
+  TR: "row",
+  UL: "list"
+};
+function getImplicitRole(element) {
+  var mappedByTag = tagToRoleMappings[element.tagName];
+  if (void 0 !== mappedByTag) return mappedByTag;
+  switch (element.tagName) {
+    case "A":
+    case "AREA":
+    case "LINK":
+      if (element.hasAttribute("href")) return "link";
+      break;
+    case "IMG":
+      if (0 < (element.getAttribute("alt") || "").length) return "img";
+      break;
+    case "INPUT":
+      switch (((mappedByTag = element.type), mappedByTag)) {
+        case "button":
+        case "image":
+        case "reset":
+        case "submit":
+          return "button";
+        case "checkbox":
+        case "radio":
+          return mappedByTag;
+        case "range":
+          return "slider";
+        case "email":
+        case "tel":
+        case "text":
+        case "url":
+          return element.hasAttribute("list") ? "combobox" : "textbox";
+        case "search":
+          return element.hasAttribute("list") ? "combobox" : "searchbox";
+        default:
+          return null;
+      }
+    case "SELECT":
+      return element.hasAttribute("multiple") || 1 < element.size
+        ? "listbox"
+        : "combobox";
+  }
+  return null;
+}
+var allNativeEvents = new Set(),
+  registrationNameDependencies = {};
+function registerTwoPhaseEvent(registrationName, dependencies) {
+  registerDirectEvent(registrationName, dependencies);
+  registerDirectEvent(registrationName + "Capture", dependencies);
+}
+function registerDirectEvent(registrationName, dependencies) {
+  registrationNameDependencies[registrationName] = dependencies;
+  for (
+    registrationName = 0;
+    registrationName < dependencies.length;
+    registrationName++
+  )
+    allNativeEvents.add(dependencies[registrationName]);
+}
+var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
+    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
+  ),
+  illegalAttributeNameCache = {},
+  validatedAttributeNameCache = {};
+function isAttributeNameSafe(attributeName) {
+  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
+    return !0;
+  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
+  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
+    return (validatedAttributeNameCache[attributeName] = !0);
+  illegalAttributeNameCache[attributeName] = !0;
+  return !1;
+}
+var viewTransitionMutationContext = !1;
+function setValueForAttribute(node, name, value) {
+  if (isAttributeNameSafe(name))
+    if (null === value) node.removeAttribute(name);
+    else {
+      switch (typeof value) {
+        case "undefined":
+        case "function":
+        case "symbol":
+          node.removeAttribute(name);
+          return;
+        case "boolean":
+          var prefix$8 = name.toLowerCase().slice(0, 5);
+          if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
+            node.removeAttribute(name);
+            return;
+          }
+      }
+      node.setAttribute(name, "" + value);
+    }
+}
+function setValueForKnownAttribute(node, name, value) {
+  if (null === value) node.removeAttribute(name);
+  else {
+    switch (typeof value) {
+      case "undefined":
+      case "function":
+      case "symbol":
+      case "boolean":
+        node.removeAttribute(name);
+        return;
+    }
+    node.setAttribute(name, "" + value);
+  }
+}
+function setValueForNamespacedAttribute(node, namespace, name, value) {
+  if (null === value) node.removeAttribute(name);
+  else {
+    switch (typeof value) {
+      case "undefined":
+      case "function":
+      case "symbol":
+      case "boolean":
+        node.removeAttribute(name);
+        return;
+    }
+    node.setAttributeNS(namespace, name, "" + value);
+  }
+}
+var prefix, suffix;
+function describeBuiltInComponentFrame(name) {
+  if (void 0 === prefix)
+    try {
+      throw Error();
+    } catch (x) {
+      var match = x.stack.trim().match(/\n( *(at )?)/);
+      prefix = (match && match[1]) || "";
+      suffix =
+        -1 < x.stack.indexOf("\n    at")
+          ? " (<anonymous>)"
+          : -1 < x.stack.indexOf("@")
+            ? "@unknown:0:0"
+            : "";
+    }
+  return "\n" + prefix + name + suffix;
+}
+var reentry = !1;
+function describeNativeComponentFrame(fn, construct) {
+  if (!fn || reentry) return "";
+  reentry = !0;
+  var previousPrepareStackTrace = Error.prepareStackTrace;
+  Error.prepareStackTrace = void 0;
+  try {
+    var RunInRootFrame = {
+      DetermineComponentFrameRoot: function () {
+        try {
+          if (construct) {
+            var Fake = function () {
+              throw Error();
+            };
+            Object.defineProperty(Fake.prototype, "props", {
+              set: function () {
+                throw Error();
+              }
+            });
+            if ("object" === typeof Reflect && Reflect.construct) {
+              try {
+                Reflect.construct(Fake, []);
+              } catch (x) {
+                var control = x;
+              }
+              Reflect.construct(fn, [], Fake);
+            } else {
+              try {
+                Fake.call();
+              } catch (x$9) {
+                control = x$9;
+              }
+              fn.call(Fake.prototype);
+            }
+          } else {
+            try {
+              throw Error();
+            } catch (x$10) {
+              control = x$10;
+            }
+            (Fake = fn()) &&
+              "function" === typeof Fake.catch &&
+              Fake.catch(function () {});
+          }
+        } catch (sample) {
+          if (sample && control && "string" === typeof sample.stack)
+            return [sample.stack, control.stack];
+        }
+        return [null, null];
+      }
+    };
+    RunInRootFrame.DetermineComponentFrameRoot.displayName =
+      "DetermineComponentFrameRoot";
+    var namePropDescriptor = Object.getOwnPropertyDescriptor(
+      RunInRootFrame.DetermineComponentFrameRoot,
+      "name"
+    );
+    namePropDescriptor &&
+      namePropDescriptor.configurable &&
+      Object.defineProperty(
+        RunInRootFrame.DetermineComponentFrameRoot,
+        "name",
+        { value: "DetermineComponentFrameRoot" }
+      );
+    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
+      sampleStack = _RunInRootFrame$Deter[0],
+      controlStack = _RunInRootFrame$Deter[1];
+    if (sampleStack && controlStack) {
+      var sampleLines = sampleStack.split("\n"),
+        controlLines = controlStack.split("\n");
+      for (
+        namePropDescriptor = RunInRootFrame = 0;
+        RunInRootFrame < sampleLines.length &&
+        !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");
+
+      )
+        RunInRootFrame++;
+      for (
+        ;
+        namePropDescriptor < controlLines.length &&
+        !controlLines[namePropDescriptor].includes(
+          "DetermineComponentFrameRoot"
+        );
+
+      )
+        namePropDescriptor++;
+      if (
+        RunInRootFrame === sampleLines.length ||
+        namePropDescriptor === controlLines.length
+      )
+        for (
+          RunInRootFrame = sampleLines.length - 1,
+            namePropDescriptor = controlLines.length - 1;
+          1 <= RunInRootFrame &&
+          0 <= namePropDescriptor &&
+          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];
+
+        )
+          namePropDescriptor--;
+      for (
+        ;
+        1 <= RunInRootFrame && 0 <= namePropDescriptor;
+        RunInRootFrame--, namePropDescriptor--
+      )
+        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
+          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
+            do
+              if (
+                (RunInRootFrame--,
+                namePropDescriptor--,
+                0 > namePropDescriptor ||
+                  sampleLines[RunInRootFrame] !==
+                    controlLines[namePropDescriptor])
+              ) {
+                var frame =
+                  "\n" +
+                  sampleLines[RunInRootFrame].replace(" at new ", " at ");
+                fn.displayName &&
+                  frame.includes("<anonymous>") &&
+                  (frame = frame.replace("<anonymous>", fn.displayName));
+                return frame;
+              }
+            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
+          }
+          break;
+        }
+    }
+  } finally {
+    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);
+  }
+  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")
+    ? describeBuiltInComponentFrame(previousPrepareStackTrace)
+    : "";
+}
+function describeFiber(fiber) {
+  switch (fiber.tag) {
+    case 26:
+    case 27:
+    case 5:
+      return describeBuiltInComponentFrame(fiber.type);
+    case 16:
+      return describeBuiltInComponentFrame("Lazy");
+    case 13:
+      return describeBuiltInComponentFrame("Suspense");
+    case 19:
+      return describeBuiltInComponentFrame("SuspenseList");
+    case 0:
+    case 15:
+      return describeNativeComponentFrame(fiber.type, !1);
+    case 11:
+      return describeNativeComponentFrame(fiber.type.render, !1);
+    case 1:
+      return describeNativeComponentFrame(fiber.type, !0);
+    case 30:
+      return describeBuiltInComponentFrame("ViewTransition");
+    default:
+      return "";
+  }
+}
+function getStackByFiberInDevAndProd(workInProgress) {
+  try {
+    var info = "";
+    do
+      (info += describeFiber(workInProgress)),
+        (workInProgress = workInProgress.return);
+    while (workInProgress);
+    return info;
+  } catch (x) {
+    return "\nError generating stack: " + x.message + "\n" + x.stack;
+  }
+}
+function getToStringValue(value) {
+  switch (typeof value) {
+    case "bigint":
+    case "boolean":
+    case "number":
+    case "string":
+    case "undefined":
+      return value;
+    case "object":
+      return value;
+    default:
+      return "";
+  }
+}
+function isCheckable(elem) {
+  var type = elem.type;
+  return (
+    (elem = elem.nodeName) &&
+    "input" === elem.toLowerCase() &&
+    ("checkbox" === type || "radio" === type)
+  );
+}
+function trackValueOnNode(node) {
+  var valueField = isCheckable(node) ? "checked" : "value",
+    descriptor = Object.getOwnPropertyDescriptor(
+      node.constructor.prototype,
+      valueField
+    ),
+    currentValue = "" + node[valueField];
+  if (
+    !node.hasOwnProperty(valueField) &&
+    "undefined" !== typeof descriptor &&
+    "function" === typeof descriptor.get &&
+    "function" === typeof descriptor.set
+  ) {
+    var get = descriptor.get,
+      set = descriptor.set;
+    Object.defineProperty(node, valueField, {
+      configurable: !0,
+      get: function () {
+        return get.call(this);
+      },
+      set: function (value) {
+        currentValue = "" + value;
+        set.call(this, value);
+      }
+    });
+    Object.defineProperty(node, valueField, {
+      enumerable: descriptor.enumerable
+    });
+    return {
+      getValue: function () {
+        return currentValue;
+      },
+      setValue: function (value) {
+        currentValue = "" + value;
+      },
+      stopTracking: function () {
+        node._valueTracker = null;
+        delete node[valueField];
+      }
+    };
+  }
+}
+function track(node) {
+  node._valueTracker || (node._valueTracker = trackValueOnNode(node));
+}
+function updateValueIfChanged(node) {
+  if (!node) return !1;
+  var tracker = node._valueTracker;
+  if (!tracker) return !0;
+  var lastValue = tracker.getValue();
+  var value = "";
+  node &&
+    (value = isCheckable(node)
+      ? node.checked
+        ? "true"
+        : "false"
+      : node.value);
+  node = value;
+  return node !== lastValue ? (tracker.setValue(node), !0) : !1;
+}
+function getActiveElement(doc) {
+  doc = doc || ("undefined" !== typeof document ? document : void 0);
+  if ("undefined" === typeof doc) return null;
+  try {
+    return doc.activeElement || doc.body;
+  } catch (e) {
+    return doc.body;
+  }
+}
+var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
+function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
+  return value.replace(
+    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
+    function (ch) {
+      return "\\" + ch.charCodeAt(0).toString(16) + " ";
+    }
+  );
+}
+function updateInput(
+  element,
+  value,
+  defaultValue,
+  lastDefaultValue,
+  checked,
+  defaultChecked,
+  type,
+  name
+) {
+  element.name = "";
+  null != type &&
+  "function" !== typeof type &&
+  "symbol" !== typeof type &&
+  "boolean" !== typeof type
+    ? (element.type = type)
+    : element.removeAttribute("type");
+  if (null != value)
+    if ("number" === type) {
+      if ((0 === value && "" === element.value) || element.value != value)
+        element.value = "" + getToStringValue(value);
+    } else
+      element.value !== "" + getToStringValue(value) &&
+        (element.value = "" + getToStringValue(value));
+  else
+    ("submit" !== type && "reset" !== type) || element.removeAttribute("value");
+  null != value
+    ? setDefaultValue(element, type, getToStringValue(value))
+    : null != defaultValue
+      ? setDefaultValue(element, type, getToStringValue(defaultValue))
+      : null != lastDefaultValue && element.removeAttribute("value");
+  null == checked &&
+    null != defaultChecked &&
+    (element.defaultChecked = !!defaultChecked);
+  null != checked &&
+    (element.checked =
+      checked && "function" !== typeof checked && "symbol" !== typeof checked);
+  null != name &&
+  "function" !== typeof name &&
+  "symbol" !== typeof name &&
+  "boolean" !== typeof name
+    ? (element.name = "" + getToStringValue(name))
+    : element.removeAttribute("name");
+}
+function initInput(
+  element,
+  value,
+  defaultValue,
+  checked,
+  defaultChecked,
+  type,
+  name,
+  isHydrating
+) {
+  null != type &&
+    "function" !== typeof type &&
+    "symbol" !== typeof type &&
+    "boolean" !== typeof type &&
+    (element.type = type);
+  if (null != value || null != defaultValue) {
+    if (
+      !(
+        ("submit" !== type && "reset" !== type) ||
+        (void 0 !== value && null !== value)
+      )
+    )
+      return;
+    defaultValue =
+      null != defaultValue ? "" + getToStringValue(defaultValue) : "";
+    value = null != value ? "" + getToStringValue(value) : defaultValue;
+    isHydrating || value === element.value || (element.value = value);
+    element.defaultValue = value;
+  }
+  checked = null != checked ? checked : defaultChecked;
+  checked =
+    "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
+  element.checked = isHydrating ? element.checked : !!checked;
+  element.defaultChecked = !!checked;
+  null != name &&
+    "function" !== typeof name &&
+    "symbol" !== typeof name &&
+    "boolean" !== typeof name &&
+    (element.name = name);
+}
+function setDefaultValue(node, type, value) {
+  ("number" === type && getActiveElement(node.ownerDocument) === node) ||
+    node.defaultValue === "" + value ||
+    (node.defaultValue = "" + value);
+}
+function updateOptions(node, multiple, propValue, setDefaultSelected) {
+  node = node.options;
+  if (multiple) {
+    multiple = {};
+    for (var i = 0; i < propValue.length; i++)
+      multiple["$" + propValue[i]] = !0;
+    for (propValue = 0; propValue < node.length; propValue++)
+      (i = multiple.hasOwnProperty("$" + node[propValue].value)),
+        node[propValue].selected !== i && (node[propValue].selected = i),
+        i && setDefaultSelected && (node[propValue].defaultSelected = !0);
+  } else {
+    propValue = "" + getToStringValue(propValue);
+    multiple = null;
+    for (i = 0; i < node.length; i++) {
+      if (node[i].value === propValue) {
+        node[i].selected = !0;
+        setDefaultSelected && (node[i].defaultSelected = !0);
+        return;
+      }
+      null !== multiple || node[i].disabled || (multiple = node[i]);
+    }
+    null !== multiple && (multiple.selected = !0);
+  }
+}
+function updateTextarea(element, value, defaultValue) {
+  if (
+    null != value &&
+    ((value = "" + getToStringValue(value)),
+    value !== element.value && (element.value = value),
+    null == defaultValue)
+  ) {
+    element.defaultValue !== value && (element.defaultValue = value);
+    return;
+  }
+  element.defaultValue =
+    null != defaultValue ? "" + getToStringValue(defaultValue) : "";
+}
+function initTextarea(element, value, defaultValue, children) {
+  if (null == value) {
+    if (null != children) {
+      if (null != defaultValue) throw Error(formatProdErrorMessage(92));
+      if (isArrayImpl(children)) {
+        if (1 < children.length) throw Error(formatProdErrorMessage(93));
+        children = children[0];
+      }
+      defaultValue = children;
+    }
+    null == defaultValue && (defaultValue = "");
+    value = defaultValue;
+  }
+  defaultValue = getToStringValue(value);
+  element.defaultValue = defaultValue;
+  children = element.textContent;
+  children === defaultValue &&
+    "" !== children &&
+    null !== children &&
+    (element.value = children);
+}
+function setTextContent(node, text) {
+  if (text) {
+    var firstChild = node.firstChild;
+    if (
+      firstChild &&
+      firstChild === node.lastChild &&
+      3 === firstChild.nodeType
+    ) {
+      firstChild.nodeValue = text;
+      return;
+    }
+  }
+  node.textContent = text;
+}
+var unitlessNumbers = new Set(
+  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
+    " "
+  )
+);
+function setValueForStyle(style, styleName, value) {
+  var isCustomProperty = 0 === styleName.indexOf("--");
+  null == value || "boolean" === typeof value || "" === value
+    ? isCustomProperty
+      ? style.setProperty(styleName, "")
+      : "float" === styleName
+        ? (style.cssFloat = "")
+        : (style[styleName] = "")
+    : isCustomProperty
+      ? style.setProperty(styleName, value)
+      : "number" !== typeof value ||
+          0 === value ||
+          unitlessNumbers.has(styleName)
+        ? "float" === styleName
+          ? (style.cssFloat = value)
+          : (style[styleName] = ("" + value).trim())
+        : (style[styleName] = value + "px");
+}
+function setValueForStyles(node, styles, prevStyles) {
+  if (null != styles && "object" !== typeof styles)
+    throw Error(formatProdErrorMessage(62));
+  node = node.style;
+  if (null != prevStyles) {
+    for (var styleName in prevStyles)
+      !prevStyles.hasOwnProperty(styleName) ||
+        (null != styles && styles.hasOwnProperty(styleName)) ||
+        (0 === styleName.indexOf("--")
+          ? node.setProperty(styleName, "")
+          : "float" === styleName
+            ? (node.cssFloat = "")
+            : (node[styleName] = ""),
+        (viewTransitionMutationContext = !0));
+    for (var styleName$16 in styles)
+      (styleName = styles[styleName$16]),
+        styles.hasOwnProperty(styleName$16) &&
+          prevStyles[styleName$16] !== styleName &&
+          (setValueForStyle(node, styleName$16, styleName),
+          (viewTransitionMutationContext = !0));
+  } else
+    for (var styleName$17 in styles)
+      styles.hasOwnProperty(styleName$17) &&
+        setValueForStyle(node, styleName$17, styles[styleName$17]);
+}
+function isCustomElement(tagName) {
+  if (-1 === tagName.indexOf("-")) return !1;
+  switch (tagName) {
+    case "annotation-xml":
+    case "color-profile":
+    case "font-face":
+    case "font-face-src":
+    case "font-face-uri":
+    case "font-face-format":
+    case "font-face-name":
+    case "missing-glyph":
+      return !1;
+    default:
+      return !0;
+  }
+}
+var aliases = new Map([
+    ["acceptCharset", "accept-charset"],
+    ["htmlFor", "for"],
+    ["httpEquiv", "http-equiv"],
+    ["crossOrigin", "crossorigin"],
+    ["accentHeight", "accent-height"],
+    ["alignmentBaseline", "alignment-baseline"],
+    ["arabicForm", "arabic-form"],
+    ["baselineShift", "baseline-shift"],
+    ["capHeight", "cap-height"],
+    ["clipPath", "clip-path"],
+    ["clipRule", "clip-rule"],
+    ["colorInterpolation", "color-interpolation"],
+    ["colorInterpolationFilters", "color-interpolation-filters"],
+    ["colorProfile", "color-profile"],
+    ["colorRendering", "color-rendering"],
+    ["dominantBaseline", "dominant-baseline"],
+    ["enableBackground", "enable-background"],
+    ["fillOpacity", "fill-opacity"],
+    ["fillRule", "fill-rule"],
+    ["floodColor", "flood-color"],
+    ["floodOpacity", "flood-opacity"],
+    ["fontFamily", "font-family"],
+    ["fontSize", "font-size"],
+    ["fontSizeAdjust", "font-size-adjust"],
+    ["fontStretch", "font-stretch"],
+    ["fontStyle", "font-style"],
+    ["fontVariant", "font-variant"],
+    ["fontWeight", "font-weight"],
+    ["glyphName", "glyph-name"],
+    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
+    ["glyphOrientationVertical", "glyph-orientation-vertical"],
+    ["horizAdvX", "horiz-adv-x"],
+    ["horizOriginX", "horiz-origin-x"],
+    ["imageRendering", "image-rendering"],
+    ["letterSpacing", "letter-spacing"],
+    ["lightingColor", "lighting-color"],
+    ["markerEnd", "marker-end"],
+    ["markerMid", "marker-mid"],
+    ["markerStart", "marker-start"],
+    ["overlinePosition", "overline-position"],
+    ["overlineThickness", "overline-thickness"],
+    ["paintOrder", "paint-order"],
+    ["panose-1", "panose-1"],
+    ["pointerEvents", "pointer-events"],
+    ["renderingIntent", "rendering-intent"],
+    ["shapeRendering", "shape-rendering"],
+    ["stopColor", "stop-color"],
+    ["stopOpacity", "stop-opacity"],
+    ["strikethroughPosition", "strikethrough-position"],
+    ["strikethroughThickness", "strikethrough-thickness"],
+    ["strokeDasharray", "stroke-dasharray"],
+    ["strokeDashoffset", "stroke-dashoffset"],
+    ["strokeLinecap", "stroke-linecap"],
+    ["strokeLinejoin", "stroke-linejoin"],
+    ["strokeMiterlimit", "stroke-miterlimit"],
+    ["strokeOpacity", "stroke-opacity"],
+    ["strokeWidth", "stroke-width"],
+    ["textAnchor", "text-anchor"],
+    ["textDecoration", "text-decoration"],
+    ["textRendering", "text-rendering"],
+    ["transformOrigin", "transform-origin"],
+    ["underlinePosition", "underline-position"],
+    ["underlineThickness", "underline-thickness"],
+    ["unicodeBidi", "unicode-bidi"],
+    ["unicodeRange", "unicode-range"],
+    ["unitsPerEm", "units-per-em"],
+    ["vAlphabetic", "v-alphabetic"],
+    ["vHanging", "v-hanging"],
+    ["vIdeographic", "v-ideographic"],
+    ["vMathematical", "v-mathematical"],
+    ["vectorEffect", "vector-effect"],
+    ["vertAdvY", "vert-adv-y"],
+    ["vertOriginX", "vert-origin-x"],
+    ["vertOriginY", "vert-origin-y"],
+    ["wordSpacing", "word-spacing"],
+    ["writingMode", "writing-mode"],
+    ["xmlnsXlink", "xmlns:xlink"],
+    ["xHeight", "x-height"]
+  ]),
+  isJavaScriptProtocol =
+    /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
+function sanitizeURL(url) {
+  return isJavaScriptProtocol.test("" + url)
+    ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
+    : url;
+}
+var currentReplayingEvent = null;
+function getEventTarget(nativeEvent) {
+  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
+  nativeEvent.correspondingUseElement &&
+    (nativeEvent = nativeEvent.correspondingUseElement);
+  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
+}
+var restoreTarget = null,
+  restoreQueue = null;
+function restoreStateOfTarget(target) {
+  var internalInstance = getInstanceFromNode(target);
+  if (internalInstance && (target = internalInstance.stateNode)) {
+    var props = target[internalPropsKey] || null;
+    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {
+      case "input":
+        updateInput(
+          target,
+          props.value,
+          props.defaultValue,
+          props.defaultValue,
+          props.checked,
+          props.defaultChecked,
+          props.type,
+          props.name
+        );
+        internalInstance = props.name;
+        if ("radio" === props.type && null != internalInstance) {
+          for (props = target; props.parentNode; ) props = props.parentNode;
+          props = props.querySelectorAll(
+            'input[name="' +
+              escapeSelectorAttributeValueInsideDoubleQuotes(
+                "" + internalInstance
+              ) +
+              '"][type="radio"]'
+          );
+          for (
+            internalInstance = 0;
+            internalInstance < props.length;
+            internalInstance++
+          ) {
+            var otherNode = props[internalInstance];
+            if (otherNode !== target && otherNode.form === target.form) {
+              var otherProps = otherNode[internalPropsKey] || null;
+              if (!otherProps) throw Error(formatProdErrorMessage(90));
+              updateInput(
+                otherNode,
+                otherProps.value,
+                otherProps.defaultValue,
+                otherProps.defaultValue,
+                otherProps.checked,
+                otherProps.defaultChecked,
+                otherProps.type,
+                otherProps.name
+              );
+            }
+          }
+          for (
+            internalInstance = 0;
+            internalInstance < props.length;
+            internalInstance++
+          )
+            (otherNode = props[internalInstance]),
+              otherNode.form === target.form && updateValueIfChanged(otherNode);
+        }
+        break a;
+      case "textarea":
+        updateTextarea(target, props.value, props.defaultValue);
+        break a;
+      case "select":
+        (internalInstance = props.value),
+          null != internalInstance &&
+            updateOptions(target, !!props.multiple, internalInstance, !1);
+    }
+  }
+}
+var isInsideEventHandler = !1;
+function batchedUpdates$1(fn, a, b) {
+  if (isInsideEventHandler) return fn(a, b);
+  isInsideEventHandler = !0;
+  try {
+    var JSCompiler_inline_result = fn(a);
+    return JSCompiler_inline_result;
+  } finally {
+    if (
+      ((isInsideEventHandler = !1),
+      null !== restoreTarget || null !== restoreQueue)
+    )
+      if (
+        (flushSyncWork$1(),
+        restoreTarget &&
+          ((a = restoreTarget),
+          (fn = restoreQueue),
+          (restoreQueue = restoreTarget = null),
+          restoreStateOfTarget(a),
+          fn))
+      )
+        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
+  }
+}
+function getListener(inst, registrationName) {
+  var stateNode = inst.stateNode;
+  if (null === stateNode) return null;
+  var props = stateNode[internalPropsKey] || null;
+  if (null === props) return null;
+  stateNode = props[registrationName];
+  a: switch (registrationName) {
+    case "onClick":
+    case "onClickCapture":
+    case "onDoubleClick":
+    case "onDoubleClickCapture":
+    case "onMouseDown":
+    case "onMouseDownCapture":
+    case "onMouseMove":
+    case "onMouseMoveCapture":
+    case "onMouseUp":
+    case "onMouseUpCapture":
+    case "onMouseEnter":
+      (props = !props.disabled) ||
+        ((inst = inst.type),
+        (props = !(
+          "button" === inst ||
+          "input" === inst ||
+          "select" === inst ||
+          "textarea" === inst
+        )));
+      inst = !props;
+      break a;
+    default:
+      inst = !1;
+  }
+  if (inst) return null;
+  if (stateNode && "function" !== typeof stateNode)
+    throw Error(
+      formatProdErrorMessage(231, registrationName, typeof stateNode)
+    );
+  return stateNode;
+}
+var canUseDOM = !(
+    "undefined" === typeof window ||
+    "undefined" === typeof window.document ||
+    "undefined" === typeof window.document.createElement
+  ),
+  passiveBrowserEventsSupported = !1;
+if (canUseDOM)
+  try {
+    var options = {};
+    Object.defineProperty(options, "passive", {
+      get: function () {
+        passiveBrowserEventsSupported = !0;
+      }
+    });
+    window.addEventListener("test", options, options);
+    window.removeEventListener("test", options, options);
+  } catch (e) {
+    passiveBrowserEventsSupported = !1;
+  }
+var root = null,
+  startText = null,
+  fallbackText = null;
+function getData() {
+  if (fallbackText) return fallbackText;
+  var start,
+    startValue = startText,
+    startLength = startValue.length,
+    end,
+    endValue = "value" in root ? root.value : root.textContent,
+    endLength = endValue.length;
+  for (
+    start = 0;
+    start < startLength && startValue[start] === endValue[start];
+    start++
+  );
+  var minEnd = startLength - start;
+  for (
+    end = 1;
+    end <= minEnd &&
+    startValue[startLength - end] === endValue[endLength - end];
+    end++
+  );
+  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
+}
+function getEventCharCode(nativeEvent) {
+  var keyCode = nativeEvent.keyCode;
+  "charCode" in nativeEvent
+    ? ((nativeEvent = nativeEvent.charCode),
+      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
+    : (nativeEvent = keyCode);
+  10 === nativeEvent && (nativeEvent = 13);
+  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
+}
+function functionThatReturnsTrue() {
+  return !0;
+}
+function functionThatReturnsFalse() {
+  return !1;
+}
+function createSyntheticEvent(Interface) {
+  function SyntheticBaseEvent(
+    reactName,
+    reactEventType,
+    targetInst,
+    nativeEvent,
+    nativeEventTarget
+  ) {
+    this._reactName = reactName;
+    this._targetInst = targetInst;
+    this.type = reactEventType;
+    this.nativeEvent = nativeEvent;
+    this.target = nativeEventTarget;
+    this.currentTarget = null;
+    for (var propName in Interface)
+      Interface.hasOwnProperty(propName) &&
+        ((reactName = Interface[propName]),
+        (this[propName] = reactName
+          ? reactName(nativeEvent)
+          : nativeEvent[propName]));
+    this.isDefaultPrevented = (
+      null != nativeEvent.defaultPrevented
+        ? nativeEvent.defaultPrevented
+        : !1 === nativeEvent.returnValue
+    )
+      ? functionThatReturnsTrue
+      : functionThatReturnsFalse;
+    this.isPropagationStopped = functionThatReturnsFalse;
+    return this;
+  }
+  assign(SyntheticBaseEvent.prototype, {
+    preventDefault: function () {
+      this.defaultPrevented = !0;
+      var event = this.nativeEvent;
+      event &&
+        (event.preventDefault
+          ? event.preventDefault()
+          : "unknown" !== typeof event.returnValue && (event.returnValue = !1),
+        (this.isDefaultPrevented = functionThatReturnsTrue));
+    },
+    stopPropagation: function () {
+      var event = this.nativeEvent;
+      event &&
+        (event.stopPropagation
+          ? event.stopPropagation()
+          : "unknown" !== typeof event.cancelBubble &&
+            (event.cancelBubble = !0),
+        (this.isPropagationStopped = functionThatReturnsTrue));
+    },
+    persist: function () {},
+    isPersistent: functionThatReturnsTrue
+  });
+  return SyntheticBaseEvent;
+}
+var EventInterface = {
+    eventPhase: 0,
+    bubbles: 0,
+    cancelable: 0,
+    timeStamp: function (event) {
+      return event.timeStamp || Date.now();
+    },
+    defaultPrevented: 0,
+    isTrusted: 0
+  },
+  SyntheticEvent = createSyntheticEvent(EventInterface),
+  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
+  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
+  lastMovementX,
+  lastMovementY,
+  lastMouseEvent,
+  MouseEventInterface = assign({}, UIEventInterface, {
+    screenX: 0,
+    screenY: 0,
+    clientX: 0,
+    clientY: 0,
+    pageX: 0,
+    pageY: 0,
+    ctrlKey: 0,
+    shiftKey: 0,
+    altKey: 0,
+    metaKey: 0,
+    getModifierState: getEventModifierState,
+    button: 0,
+    buttons: 0,
+    relatedTarget: function (event) {
+      return void 0 === event.relatedTarget
+        ? event.fromElement === event.srcElement
+          ? event.toElement
+          : event.fromElement
+        : event.relatedTarget;
+    },
+    movementX: function (event) {
+      if ("movementX" in event) return event.movementX;
+      event !== lastMouseEvent &&
+        (lastMouseEvent && "mousemove" === event.type
+          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
+            (lastMovementY = event.screenY - lastMouseEvent.screenY))
+          : (lastMovementY = lastMovementX = 0),
+        (lastMouseEvent = event));
+      return lastMovementX;
+    },
+    movementY: function (event) {
+      return "movementY" in event ? event.movementY : lastMovementY;
+    }
+  }),
+  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
+  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
+  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
+  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
+  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
+  AnimationEventInterface = assign({}, EventInterface, {
+    animationName: 0,
+    elapsedTime: 0,
+    pseudoElement: 0
+  }),
+  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
+  ClipboardEventInterface = assign({}, EventInterface, {
+    clipboardData: function (event) {
+      return "clipboardData" in event
+        ? event.clipboardData
+        : window.clipboardData;
+    }
+  }),
+  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
+  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
+  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
+  normalizeKey = {
+    Esc: "Escape",
+    Spacebar: " ",
+    Left: "ArrowLeft",
+    Up: "ArrowUp",
+    Right: "ArrowRight",
+    Down: "ArrowDown",
+    Del: "Delete",
+    Win: "OS",
+    Menu: "ContextMenu",
+    Apps: "ContextMenu",
+    Scroll: "ScrollLock",
+    MozPrintableKey: "Unidentified"
+  },
+  translateToKey = {
+    8: "Backspace",
+    9: "Tab",
+    12: "Clear",
+    13: "Enter",
+    16: "Shift",
+    17: "Control",
+    18: "Alt",
+    19: "Pause",
+    20: "CapsLock",
+    27: "Escape",
+    32: " ",
+    33: "PageUp",
+    34: "PageDown",
+    35: "End",
+    36: "Home",
+    37: "ArrowLeft",
+    38: "ArrowUp",
+    39: "ArrowRight",
+    40: "ArrowDown",
+    45: "Insert",
+    46: "Delete",
+    112: "F1",
+    113: "F2",
+    114: "F3",
+    115: "F4",
+    116: "F5",
+    117: "F6",
+    118: "F7",
+    119: "F8",
+    120: "F9",
+    121: "F10",
+    122: "F11",
+    123: "F12",
+    144: "NumLock",
+    145: "ScrollLock",
+    224: "Meta"
+  },
+  modifierKeyToProp = {
+    Alt: "altKey",
+    Control: "ctrlKey",
+    Meta: "metaKey",
+    Shift: "shiftKey"
+  };
+function modifierStateGetter(keyArg) {
+  var nativeEvent = this.nativeEvent;
+  return nativeEvent.getModifierState
+    ? nativeEvent.getModifierState(keyArg)
+    : (keyArg = modifierKeyToProp[keyArg])
+      ? !!nativeEvent[keyArg]
+      : !1;
+}
+function getEventModifierState() {
+  return modifierStateGetter;
+}
+var KeyboardEventInterface = assign({}, UIEventInterface, {
+    key: function (nativeEvent) {
+      if (nativeEvent.key) {
+        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
+        if ("Unidentified" !== key) return key;
+      }
+      return "keypress" === nativeEvent.type
+        ? ((nativeEvent = getEventCharCode(nativeEvent)),
+          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
+        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
+          ? translateToKey[nativeEvent.keyCode] || "Unidentified"
+          : "";
+    },
+    code: 0,
+    location: 0,
+    ctrlKey: 0,
+    shiftKey: 0,
+    altKey: 0,
+    metaKey: 0,
+    repeat: 0,
+    locale: 0,
+    getModifierState: getEventModifierState,
+    charCode: function (event) {
+      return "keypress" === event.type ? getEventCharCode(event) : 0;
+    },
+    keyCode: function (event) {
+      return "keydown" === event.type || "keyup" === event.type
+        ? event.keyCode
+        : 0;
+    },
+    which: function (event) {
+      return "keypress" === event.type
+        ? getEventCharCode(event)
+        : "keydown" === event.type || "keyup" === event.type
+          ? event.keyCode
+          : 0;
+    }
+  }),
+  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
+  PointerEventInterface = assign({}, MouseEventInterface, {
+    pointerId: 0,
+    width: 0,
+    height: 0,
+    pressure: 0,
+    tangentialPressure: 0,
+    tiltX: 0,
+    tiltY: 0,
+    twist: 0,
+    pointerType: 0,
+    isPrimary: 0
+  }),
+  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
+  TouchEventInterface = assign({}, UIEventInterface, {
+    touches: 0,
+    targetTouches: 0,
+    changedTouches: 0,
+    altKey: 0,
+    metaKey: 0,
+    ctrlKey: 0,
+    shiftKey: 0,
+    getModifierState: getEventModifierState
+  }),
+  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
+  TransitionEventInterface = assign({}, EventInterface, {
+    propertyName: 0,
+    elapsedTime: 0,
+    pseudoElement: 0
+  }),
+  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
+  WheelEventInterface = assign({}, MouseEventInterface, {
+    deltaX: function (event) {
+      return "deltaX" in event
+        ? event.deltaX
+        : "wheelDeltaX" in event
+          ? -event.wheelDeltaX
+          : 0;
+    },
+    deltaY: function (event) {
+      return "deltaY" in event
+        ? event.deltaY
+        : "wheelDeltaY" in event
+          ? -event.wheelDeltaY
+          : "wheelDelta" in event
+            ? -event.wheelDelta
+            : 0;
+    },
+    deltaZ: 0,
+    deltaMode: 0
+  }),
+  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
+  ToggleEventInterface = assign({}, EventInterface, {
+    newState: 0,
+    oldState: 0
+  }),
+  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
+  END_KEYCODES = [9, 13, 27, 32],
+  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
+  documentMode = null;
+canUseDOM &&
+  "documentMode" in document &&
+  (documentMode = document.documentMode);
+var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
+  useFallbackCompositionData =
+    canUseDOM &&
+    (!canUseCompositionEvent ||
+      (documentMode && 8 < documentMode && 11 >= documentMode)),
+  SPACEBAR_CHAR = String.fromCharCode(32),
+  hasSpaceKeypress = !1;
+function isFallbackCompositionEnd(domEventName, nativeEvent) {
+  switch (domEventName) {
+    case "keyup":
+      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
+    case "keydown":
+      return 229 !== nativeEvent.keyCode;
+    case "keypress":
+    case "mousedown":
+    case "focusout":
+      return !0;
+    default:
+      return !1;
+  }
+}
+function getDataFromCustomEvent(nativeEvent) {
+  nativeEvent = nativeEvent.detail;
+  return "object" === typeof nativeEvent && "data" in nativeEvent
+    ? nativeEvent.data
+    : null;
+}
+var isComposing = !1;
+function getNativeBeforeInputChars(domEventName, nativeEvent) {
+  switch (domEventName) {
+    case "compositionend":
+      return getDataFromCustomEvent(nativeEvent);
+    case "keypress":
+      if (32 !== nativeEvent.which) return null;
+      hasSpaceKeypress = !0;
+      return SPACEBAR_CHAR;
+    case "textInput":
+      return (
+        (domEventName = nativeEvent.data),
+        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName
+      );
+    default:
+      return null;
+  }
+}
+function getFallbackBeforeInputChars(domEventName, nativeEvent) {
+  if (isComposing)
+    return "compositionend" === domEventName ||
+      (!canUseCompositionEvent &&
+        isFallbackCompositionEnd(domEventName, nativeEvent))
+      ? ((domEventName = getData()),
+        (fallbackText = startText = root = null),
+        (isComposing = !1),
+        domEventName)
+      : null;
+  switch (domEventName) {
+    case "paste":
+      return null;
+    case "keypress":
+      if (
+        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||
+        (nativeEvent.ctrlKey && nativeEvent.altKey)
+      ) {
+        if (nativeEvent.char && 1 < nativeEvent.char.length)
+          return nativeEvent.char;
+        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
+      }
+      return null;
+    case "compositionend":
+      return useFallbackCompositionData && "ko" !== nativeEvent.locale
+        ? null
+        : nativeEvent.data;
+    default:
+      return null;
+  }
+}
+var supportedInputTypes = {
+  color: !0,
+  date: !0,
+  datetime: !0,
+  "datetime-local": !0,
+  email: !0,
+  month: !0,
+  number: !0,
+  password: !0,
+  range: !0,
+  search: !0,
+  tel: !0,
+  text: !0,
+  time: !0,
+  url: !0,
+  week: !0
+};
+function isTextInputElement(elem) {
+  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
+  return "input" === nodeName
+    ? !!supportedInputTypes[elem.type]
+    : "textarea" === nodeName
+      ? !0
+      : !1;
+}
+function createAndAccumulateChangeEvent(
+  dispatchQueue,
+  inst,
+  nativeEvent,
+  target
+) {
+  restoreTarget
+    ? restoreQueue
+      ? restoreQueue.push(target)
+      : (restoreQueue = [target])
+    : (restoreTarget = target);
+  inst = accumulateTwoPhaseListeners(inst, "onChange");
+  0 < inst.length &&
+    ((nativeEvent = new SyntheticEvent(
+      "onChange",
+      "change",
+      null,
+      nativeEvent,
+      target
+    )),
+    dispatchQueue.push({ event: nativeEvent, listeners: inst }));
+}
+var activeElement$1 = null,
+  activeElementInst$1 = null;
+function runEventInBatch(dispatchQueue) {
+  processDispatchQueue(dispatchQueue, 0);
+}
+function getInstIfValueChanged(targetInst) {
+  var targetNode = getNodeFromInstance(targetInst);
+  if (updateValueIfChanged(targetNode)) return targetInst;
+}
+function getTargetInstForChangeEvent(domEventName, targetInst) {
+  if ("change" === domEventName) return targetInst;
+}
+var isInputEventSupported = !1;
+if (canUseDOM) {
+  var JSCompiler_inline_result$jscomp$286;
+  if (canUseDOM) {
+    var isSupported$jscomp$inline_428 = "oninput" in document;
+    if (!isSupported$jscomp$inline_428) {
+      var element$jscomp$inline_429 = document.createElement("div");
+      element$jscomp$inline_429.setAttribute("oninput", "return;");
+      isSupported$jscomp$inline_428 =
+        "function" === typeof element$jscomp$inline_429.oninput;
+    }
+    JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_428;
+  } else JSCompiler_inline_result$jscomp$286 = !1;
+  isInputEventSupported =
+    JSCompiler_inline_result$jscomp$286 &&
+    (!document.documentMode || 9 < document.documentMode);
+}
+function stopWatchingForValueChange() {
+  activeElement$1 &&
+    (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
+    (activeElementInst$1 = activeElement$1 = null));
+}
+function handlePropertyChange(nativeEvent) {
+  if (
+    "value" === nativeEvent.propertyName &&
+    getInstIfValueChanged(activeElementInst$1)
+  ) {
+    var dispatchQueue = [];
+    createAndAccumulateChangeEvent(
+      dispatchQueue,
+      activeElementInst$1,
+      nativeEvent,
+      getEventTarget(nativeEvent)
+    );
+    batchedUpdates$1(runEventInBatch, dispatchQueue);
+  }
+}
+function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
+  "focusin" === domEventName
+    ? (stopWatchingForValueChange(),
+      (activeElement$1 = target),
+      (activeElementInst$1 = targetInst),
+      activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
+    : "focusout" === domEventName && stopWatchingForValueChange();
+}
+function getTargetInstForInputEventPolyfill(domEventName) {
+  if (
+    "selectionchange" === domEventName ||
+    "keyup" === domEventName ||
+    "keydown" === domEventName
+  )
+    return getInstIfValueChanged(activeElementInst$1);
+}
+function getTargetInstForClickEvent(domEventName, targetInst) {
+  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
+}
+function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
+  if ("input" === domEventName || "change" === domEventName)
+    return getInstIfValueChanged(targetInst);
+}
+function is(x, y) {
+  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
+}
+var objectIs = "function" === typeof Object.is ? Object.is : is;
+function shallowEqual(objA, objB) {
+  if (objectIs(objA, objB)) return !0;
+  if (
+    "object" !== typeof objA ||
+    null === objA ||
+    "object" !== typeof objB ||
+    null === objB
+  )
+    return !1;
+  var keysA = Object.keys(objA),
+    keysB = Object.keys(objB);
+  if (keysA.length !== keysB.length) return !1;
+  for (keysB = 0; keysB < keysA.length; keysB++) {
+    var currentKey = keysA[keysB];
+    if (
+      !hasOwnProperty.call(objB, currentKey) ||
+      !objectIs(objA[currentKey], objB[currentKey])
+    )
+      return !1;
+  }
+  return !0;
+}
+function getLeafNode(node) {
+  for (; node && node.firstChild; ) node = node.firstChild;
+  return node;
+}
+function getNodeForCharacterOffset(root, offset) {
+  var node = getLeafNode(root);
+  root = 0;
+  for (var nodeEnd; node; ) {
+    if (3 === node.nodeType) {
+      nodeEnd = root + node.textContent.length;
+      if (root <= offset && nodeEnd >= offset)
+        return { node: node, offset: offset - root };
+      root = nodeEnd;
+    }
+    a: {
+      for (; node; ) {
+        if (node.nextSibling) {
+          node = node.nextSibling;
+          break a;
+        }
+        node = node.parentNode;
+      }
+      node = void 0;
+    }
+    node = getLeafNode(node);
+  }
+}
+function containsNode(outerNode, innerNode) {
+  return outerNode && innerNode
+    ? outerNode === innerNode
+      ? !0
+      : outerNode && 3 === outerNode.nodeType
+        ? !1
+        : innerNode && 3 === innerNode.nodeType
+          ? containsNode(outerNode, innerNode.parentNode)
+          : "contains" in outerNode
+            ? outerNode.contains(innerNode)
+            : outerNode.compareDocumentPosition
+              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
+              : !1
+    : !1;
+}
+function getActiveElementDeep(containerInfo) {
+  containerInfo =
+    null != containerInfo &&
+    null != containerInfo.ownerDocument &&
+    null != containerInfo.ownerDocument.defaultView
+      ? containerInfo.ownerDocument.defaultView
+      : window;
+  for (
+    var element = getActiveElement(containerInfo.document);
+    element instanceof containerInfo.HTMLIFrameElement;
+
+  ) {
+    try {
+      var JSCompiler_inline_result =
+        "string" === typeof element.contentWindow.location.href;
+    } catch (err) {
+      JSCompiler_inline_result = !1;
+    }
+    if (JSCompiler_inline_result) containerInfo = element.contentWindow;
+    else break;
+    element = getActiveElement(containerInfo.document);
+  }
+  return element;
+}
+function hasSelectionCapabilities(elem) {
+  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
+  return (
+    nodeName &&
+    (("input" === nodeName &&
+      ("text" === elem.type ||
+        "search" === elem.type ||
+        "tel" === elem.type ||
+        "url" === elem.type ||
+        "password" === elem.type)) ||
+      "textarea" === nodeName ||
+      "true" === elem.contentEditable)
+  );
+}
+var skipSelectionChangeEvent =
+    canUseDOM && "documentMode" in document && 11 >= document.documentMode,
+  activeElement = null,
+  activeElementInst = null,
+  lastSelection = null,
+  mouseDown = !1;
+function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
+  var doc =
+    nativeEventTarget.window === nativeEventTarget
+      ? nativeEventTarget.document
+      : 9 === nativeEventTarget.nodeType
+        ? nativeEventTarget
+        : nativeEventTarget.ownerDocument;
+  mouseDown ||
+    null == activeElement ||
+    activeElement !== getActiveElement(doc) ||
+    ((doc = activeElement),
+    "selectionStart" in doc && hasSelectionCapabilities(doc)
+      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
+      : ((doc = (
+          (doc.ownerDocument && doc.ownerDocument.defaultView) ||
+          window
+        ).getSelection()),
+        (doc = {
+          anchorNode: doc.anchorNode,
+          anchorOffset: doc.anchorOffset,
+          focusNode: doc.focusNode,
+          focusOffset: doc.focusOffset
+        })),
+    (lastSelection && shallowEqual(lastSelection, doc)) ||
+      ((lastSelection = doc),
+      (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
+      0 < doc.length &&
+        ((nativeEvent = new SyntheticEvent(
+          "onSelect",
+          "select",
+          null,
+          nativeEvent,
+          nativeEventTarget
+        )),
+        dispatchQueue.push({ event: nativeEvent, listeners: doc }),
+        (nativeEvent.target = activeElement))));
+}
+function makePrefixMap(styleProp, eventName) {
+  var prefixes = {};
+  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
+  prefixes["Webkit" + styleProp] = "webkit" + eventName;
+  prefixes["Moz" + styleProp] = "moz" + eventName;
+  return prefixes;
+}
+var vendorPrefixes = {
+    animationend: makePrefixMap("Animation", "AnimationEnd"),
+    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
+    animationstart: makePrefixMap("Animation", "AnimationStart"),
+    transitionrun: makePrefixMap("Transition", "TransitionRun"),
+    transitionstart: makePrefixMap("Transition", "TransitionStart"),
+    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
+    transitionend: makePrefixMap("Transition", "TransitionEnd")
+  },
+  prefixedEventNames = {},
+  style = {};
+canUseDOM &&
+  ((style = document.createElement("div").style),
+  "AnimationEvent" in window ||
+    (delete vendorPrefixes.animationend.animation,
+    delete vendorPrefixes.animationiteration.animation,
+    delete vendorPrefixes.animationstart.animation),
+  "TransitionEvent" in window ||
+    delete vendorPrefixes.transitionend.transition);
+function getVendorPrefixedEventName(eventName) {
+  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
+  if (!vendorPrefixes[eventName]) return eventName;
+  var prefixMap = vendorPrefixes[eventName],
+    styleProp;
+  for (styleProp in prefixMap)
+    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
+      return (prefixedEventNames[eventName] = prefixMap[styleProp]);
+  return eventName;
+}
+var ANIMATION_END = getVendorPrefixedEventName("animationend"),
+  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
+  ANIMATION_START = getVendorPrefixedEventName("animationstart"),
+  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
+  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
+  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
+  TRANSITION_END = getVendorPrefixedEventName("transitionend"),
+  topLevelEventsToReactNames = new Map(),
+  simpleEventPluginEvents =
+    "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
+      " "
+    );
+function registerSimpleEvent(domEventName, reactName) {
+  topLevelEventsToReactNames.set(domEventName, reactName);
+  registerTwoPhaseEvent(reactName, [domEventName]);
+}
+var CapturedStacks = new WeakMap();
+function createCapturedValueAtFiber(value, source) {
+  if ("object" === typeof value && null !== value) {
+    var existing = CapturedStacks.get(value);
+    if (void 0 !== existing) return existing;
+    source = {
+      value: value,
+      source: source,
+      stack: getStackByFiberInDevAndProd(source)
+    };
+    CapturedStacks.set(value, source);
+    return source;
+  }
+  return {
+    value: value,
+    source: source,
+    stack: getStackByFiberInDevAndProd(source)
+  };
+}
+var concurrentQueues = [],
+  concurrentQueuesIndex = 0,
+  concurrentlyUpdatedLanes = 0;
+function finishQueueingConcurrentUpdates() {
+  for (
+    var endIndex = concurrentQueuesIndex,
+      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
+    i < endIndex;
+
+  ) {
+    var fiber = concurrentQueues[i];
+    concurrentQueues[i++] = null;
+    var queue = concurrentQueues[i];
+    concurrentQueues[i++] = null;
+    var update = concurrentQueues[i];
+    concurrentQueues[i++] = null;
+    var lane = concurrentQueues[i];
+    concurrentQueues[i++] = null;
+    if (null !== queue && null !== update) {
+      var pending = queue.pending;
+      null === pending
+        ? (update.next = update)
+        : ((update.next = pending.next), (pending.next = update));
+      queue.pending = update;
+    }
+    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
+  }
+}
+function enqueueUpdate$1(fiber, queue, update, lane) {
+  concurrentQueues[concurrentQueuesIndex++] = fiber;
+  concurrentQueues[concurrentQueuesIndex++] = queue;
+  concurrentQueues[concurrentQueuesIndex++] = update;
+  concurrentQueues[concurrentQueuesIndex++] = lane;
+  concurrentlyUpdatedLanes |= lane;
+  fiber.lanes |= lane;
+  fiber = fiber.alternate;
+  null !== fiber && (fiber.lanes |= lane);
+}
+function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
+  enqueueUpdate$1(fiber, queue, update, lane);
+  return getRootForUpdatedFiber(fiber);
+}
+function enqueueConcurrentRenderForLane(fiber, lane) {
+  enqueueUpdate$1(fiber, null, null, lane);
+  return getRootForUpdatedFiber(fiber);
+}
+function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
+  sourceFiber.lanes |= lane;
+  var alternate = sourceFiber.alternate;
+  null !== alternate && (alternate.lanes |= lane);
+  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
+    (parent.childLanes |= lane),
+      (alternate = parent.alternate),
+      null !== alternate && (alternate.childLanes |= lane),
+      22 === parent.tag &&
+        ((sourceFiber = parent.stateNode),
+        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),
+      (sourceFiber = parent),
+      (parent = parent.return);
+  isHidden &&
+    null !== update &&
+    3 === sourceFiber.tag &&
+    ((parent = sourceFiber.stateNode),
+    (isHidden = 31 - clz32(lane)),
+    (parent = parent.hiddenUpdates),
+    (sourceFiber = parent[isHidden]),
+    null === sourceFiber
+      ? (parent[isHidden] = [update])
+      : sourceFiber.push(update),
+    (update.lane = lane | 536870912));
+}
+function getRootForUpdatedFiber(sourceFiber) {
+  if (50 < nestedUpdateCount)
+    throw (
+      ((nestedUpdateCount = 0),
+      (rootWithNestedUpdates = null),
+      Error(formatProdErrorMessage(185)))
+    );
+  for (var parent = sourceFiber.return; null !== parent; )
+    (sourceFiber = parent), (parent = sourceFiber.return);
+  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
+}
+var emptyContextObject = {},
+  valueCursor = createCursor(null),
+  currentlyRenderingFiber$1 = null,
+  lastContextDependency = null;
+function pushProvider(providerFiber, context, nextValue) {
+  push(valueCursor, context._currentValue);
+  context._currentValue = nextValue;
+}
+function popProvider(context) {
+  context._currentValue = valueCursor.current;
+  pop(valueCursor);
+}
+function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
+  for (; null !== parent; ) {
+    var alternate = parent.alternate;
+    (parent.childLanes & renderLanes) !== renderLanes
+      ? ((parent.childLanes |= renderLanes),
+        null !== alternate && (alternate.childLanes |= renderLanes))
+      : null !== alternate &&
+        (alternate.childLanes & renderLanes) !== renderLanes &&
+        (alternate.childLanes |= renderLanes);
+    if (parent === propagationRoot) break;
+    parent = parent.return;
+  }
+}
+function propagateContextChanges(
+  workInProgress,
+  contexts,
+  renderLanes,
+  forcePropagateEntireTree
+) {
+  var fiber = workInProgress.child;
+  null !== fiber && (fiber.return = workInProgress);
+  for (; null !== fiber; ) {
+    var list = fiber.dependencies;
+    if (null !== list) {
+      var nextFiber = fiber.child;
+      list = list.firstContext;
+      a: for (; null !== list; ) {
+        var dependency = list;
+        list = fiber;
+        for (var i = 0; i < contexts.length; i++)
+          if (dependency.context === contexts[i]) {
+            list.lanes |= renderLanes;
+            dependency = list.alternate;
+            null !== dependency && (dependency.lanes |= renderLanes);
+            scheduleContextWorkOnParentPath(
+              list.return,
+              renderLanes,
+              workInProgress
+            );
+            forcePropagateEntireTree || (nextFiber = null);
+            break a;
+          }
+        list = dependency.next;
+      }
+    } else if (18 === fiber.tag) {
+      nextFiber = fiber.return;
+      if (null === nextFiber) throw Error(formatProdErrorMessage(341));
+      nextFiber.lanes |= renderLanes;
+      list = nextFiber.alternate;
+      null !== list && (list.lanes |= renderLanes);
+      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
+      nextFiber = null;
+    } else nextFiber = fiber.child;
+    if (null !== nextFiber) nextFiber.return = fiber;
+    else
+      for (nextFiber = fiber; null !== nextFiber; ) {
+        if (nextFiber === workInProgress) {
+          nextFiber = null;
+          break;
+        }
+        fiber = nextFiber.sibling;
+        if (null !== fiber) {
+          fiber.return = nextFiber.return;
+          nextFiber = fiber;
+          break;
+        }
+        nextFiber = nextFiber.return;
+      }
+    fiber = nextFiber;
+  }
+}
+function propagateParentContextChanges(
+  current,
+  workInProgress,
+  renderLanes,
+  forcePropagateEntireTree
+) {
+  current = null;
+  for (
+    var parent = workInProgress, isInsidePropagationBailout = !1;
+    null !== parent;
+
+  ) {
+    if (!isInsidePropagationBailout)
+      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
+      else if (0 !== (parent.flags & 262144)) break;
+    if (10 === parent.tag) {
+      var currentParent = parent.alternate;
+      if (null === currentParent) throw Error(formatProdErrorMessage(387));
+      currentParent = currentParent.memoizedProps;
+      if (null !== currentParent) {
+        var context = parent.type;
+        objectIs(parent.pendingProps.value, currentParent.value) ||
+          (null !== current ? current.push(context) : (current = [context]));
+      }
+    } else if (parent === hostTransitionProviderCursor.current) {
+      currentParent = parent.alternate;
+      if (null === currentParent) throw Error(formatProdErrorMessage(387));
+      currentParent.memoizedState.memoizedState !==
+        parent.memoizedState.memoizedState &&
+        (null !== current
+          ? current.push(HostTransitionContext)
+          : (current = [HostTransitionContext]));
+    }
+    parent = parent.return;
+  }
+  null !== current &&
+    propagateContextChanges(
+      workInProgress,
+      current,
+      renderLanes,
+      forcePropagateEntireTree
+    );
+  workInProgress.flags |= 262144;
+}
+function checkIfContextChanged(currentDependencies) {
+  for (
+    currentDependencies = currentDependencies.firstContext;
+    null !== currentDependencies;
+
+  ) {
+    if (
+      !objectIs(
+        currentDependencies.context._currentValue,
+        currentDependencies.memoizedValue
+      )
+    )
+      return !0;
+    currentDependencies = currentDependencies.next;
+  }
+  return !1;
+}
+function prepareToReadContext(workInProgress) {
+  currentlyRenderingFiber$1 = workInProgress;
+  lastContextDependency = null;
+  workInProgress = workInProgress.dependencies;
+  null !== workInProgress && (workInProgress.firstContext = null);
+}
+function readContext(context) {
+  return readContextForConsumer(currentlyRenderingFiber$1, context);
+}
+function readContextDuringReconciliation(consumer, context) {
+  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
+  return readContextForConsumer(consumer, context);
+}
+function readContextForConsumer(consumer, context) {
+  var value = context._currentValue;
+  context = { context: context, memoizedValue: value, next: null };
+  if (null === lastContextDependency) {
+    if (null === consumer) throw Error(formatProdErrorMessage(308));
+    lastContextDependency = context;
+    consumer.dependencies = { lanes: 0, firstContext: context };
+    consumer.flags |= 524288;
+  } else lastContextDependency = lastContextDependency.next = context;
+  return value;
+}
+var currentEntangledListeners = null,
+  currentEntangledPendingCount = 0,
+  currentEntangledLane = 0,
+  currentEntangledActionThenable = null;
+function entangleAsyncAction(transition, thenable) {
+  if (null === currentEntangledListeners) {
+    var entangledListeners = (currentEntangledListeners = []);
+    currentEntangledPendingCount = 0;
+    currentEntangledLane = requestTransitionLane();
+    currentEntangledActionThenable = {
+      status: "pending",
+      value: void 0,
+      then: function (resolve) {
+        entangledListeners.push(resolve);
+      }
+    };
+  }
+  currentEntangledPendingCount++;
+  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
+  return thenable;
+}
+function pingEngtangledActionScope() {
+  if (
+    0 === --currentEntangledPendingCount &&
+    null !== currentEntangledListeners
+  ) {
+    null !== currentEntangledActionThenable &&
+      (currentEntangledActionThenable.status = "fulfilled");
+    var listeners = currentEntangledListeners;
+    currentEntangledListeners = null;
+    currentEntangledLane = 0;
+    currentEntangledActionThenable = null;
+    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
+  }
+}
+function chainThenableValue(thenable, result) {
+  var listeners = [],
+    thenableWithOverride = {
+      status: "pending",
+      value: null,
+      reason: null,
+      then: function (resolve) {
+        listeners.push(resolve);
+      }
+    };
+  thenable.then(
+    function () {
+      thenableWithOverride.status = "fulfilled";
+      thenableWithOverride.value = result;
+      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
+    },
+    function (error) {
+      thenableWithOverride.status = "rejected";
+      thenableWithOverride.reason = error;
+      for (error = 0; error < listeners.length; error++)
+        (0, listeners[error])(void 0);
+    }
+  );
+  return thenableWithOverride;
+}
+var hasForceUpdate = !1;
+function initializeUpdateQueue(fiber) {
+  fiber.updateQueue = {
+    baseState: fiber.memoizedState,
+    firstBaseUpdate: null,
+    lastBaseUpdate: null,
+    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
+    callbacks: null
+  };
+}
+function cloneUpdateQueue(current, workInProgress) {
+  current = current.updateQueue;
+  workInProgress.updateQueue === current &&
+    (workInProgress.updateQueue = {
+      baseState: current.baseState,
+      firstBaseUpdate: current.firstBaseUpdate,
+      lastBaseUpdate: current.lastBaseUpdate,
+      shared: current.shared,
+      callbacks: null
+    });
+}
+function createUpdate(lane) {
+  return { lane: lane, tag: 0, payload: null, callback: null, next: null };
+}
+function enqueueUpdate(fiber, update, lane) {
+  var updateQueue = fiber.updateQueue;
+  if (null === updateQueue) return null;
+  updateQueue = updateQueue.shared;
+  if (0 !== (executionContext & 2)) {
+    var pending = updateQueue.pending;
+    null === pending
+      ? (update.next = update)
+      : ((update.next = pending.next), (pending.next = update));
+    updateQueue.pending = update;
+    update = getRootForUpdatedFiber(fiber);
+    markUpdateLaneFromFiberToRoot(fiber, null, lane);
+    return update;
+  }
+  enqueueUpdate$1(fiber, updateQueue, update, lane);
+  return getRootForUpdatedFiber(fiber);
+}
+function entangleTransitions(root, fiber, lane) {
+  fiber = fiber.updateQueue;
+  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194176))) {
+    var queueLanes = fiber.lanes;
+    queueLanes &= root.pendingLanes;
+    lane |= queueLanes;
+    fiber.lanes = lane;
+    markRootEntangled(root, lane);
+  }
+}
+function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
+  var queue = workInProgress.updateQueue,
+    current = workInProgress.alternate;
+  if (
+    null !== current &&
+    ((current = current.updateQueue), queue === current)
+  ) {
+    var newFirst = null,
+      newLast = null;
+    queue = queue.firstBaseUpdate;
+    if (null !== queue) {
+      do {
+        var clone = {
+          lane: queue.lane,
+          tag: queue.tag,
+          payload: queue.payload,
+          callback: null,
+          next: null
+        };
+        null === newLast
+          ? (newFirst = newLast = clone)
+          : (newLast = newLast.next = clone);
+        queue = queue.next;
+      } while (null !== queue);
+      null === newLast
+        ? (newFirst = newLast = capturedUpdate)
+        : (newLast = newLast.next = capturedUpdate);
+    } else newFirst = newLast = capturedUpdate;
+    queue = {
+      baseState: current.baseState,
+      firstBaseUpdate: newFirst,
+      lastBaseUpdate: newLast,
+      shared: current.shared,
+      callbacks: current.callbacks
+    };
+    workInProgress.updateQueue = queue;
+    return;
+  }
+  workInProgress = queue.lastBaseUpdate;
+  null === workInProgress
+    ? (queue.firstBaseUpdate = capturedUpdate)
+    : (workInProgress.next = capturedUpdate);
+  queue.lastBaseUpdate = capturedUpdate;
+}
+var didReadFromEntangledAsyncAction = !1;
+function suspendIfUpdateReadFromEntangledAsyncAction() {
+  if (didReadFromEntangledAsyncAction) {
+    var entangledActionThenable = currentEntangledActionThenable;
+    if (null !== entangledActionThenable) throw entangledActionThenable;
+  }
+}
+function processUpdateQueue(
+  workInProgress$jscomp$0,
+  props,
+  instance$jscomp$0,
+  renderLanes
+) {
+  didReadFromEntangledAsyncAction = !1;
+  var queue = workInProgress$jscomp$0.updateQueue;
+  hasForceUpdate = !1;
+  var firstBaseUpdate = queue.firstBaseUpdate,
+    lastBaseUpdate = queue.lastBaseUpdate,
+    pendingQueue = queue.shared.pending;
+  if (null !== pendingQueue) {
+    queue.shared.pending = null;
+    var lastPendingUpdate = pendingQueue,
+      firstPendingUpdate = lastPendingUpdate.next;
+    lastPendingUpdate.next = null;
+    null === lastBaseUpdate
+      ? (firstBaseUpdate = firstPendingUpdate)
+      : (lastBaseUpdate.next = firstPendingUpdate);
+    lastBaseUpdate = lastPendingUpdate;
+    var current = workInProgress$jscomp$0.alternate;
+    null !== current &&
+      ((current = current.updateQueue),
+      (pendingQueue = current.lastBaseUpdate),
+      pendingQueue !== lastBaseUpdate &&
+        (null === pendingQueue
+          ? (current.firstBaseUpdate = firstPendingUpdate)
+          : (pendingQueue.next = firstPendingUpdate),
+        (current.lastBaseUpdate = lastPendingUpdate)));
+  }
+  if (null !== firstBaseUpdate) {
+    var newState = queue.baseState;
+    lastBaseUpdate = 0;
+    current = firstPendingUpdate = lastPendingUpdate = null;
+    pendingQueue = firstBaseUpdate;
+    do {
+      var updateLane = pendingQueue.lane & -536870913,
+        isHiddenUpdate = updateLane !== pendingQueue.lane;
+      if (
+        isHiddenUpdate
+          ? (workInProgressRootRenderLanes & updateLane) === updateLane
+          : (renderLanes & updateLane) === updateLane
+      ) {
+        0 !== updateLane &&
+          updateLane === currentEntangledLane &&
+          (didReadFromEntangledAsyncAction = !0);
+        null !== current &&
+          (current = current.next =
+            {
+              lane: 0,
+              tag: pendingQueue.tag,
+              payload: pendingQueue.payload,
+              callback: null,
+              next: null
+            });
+        a: {
+          var workInProgress = workInProgress$jscomp$0,
+            update = pendingQueue;
+          updateLane = props;
+          var instance = instance$jscomp$0;
+          switch (update.tag) {
+            case 1:
+              workInProgress = update.payload;
+              if ("function" === typeof workInProgress) {
+                newState = workInProgress.call(instance, newState, updateLane);
+                break a;
+              }
+              newState = workInProgress;
+              break a;
+            case 3:
+              workInProgress.flags = (workInProgress.flags & -65537) | 128;
+            case 0:
+              workInProgress = update.payload;
+              updateLane =
+                "function" === typeof workInProgress
+                  ? workInProgress.call(instance, newState, updateLane)
+                  : workInProgress;
+              if (null === updateLane || void 0 === updateLane) break a;
+              newState = assign({}, newState, updateLane);
+              break a;
+            case 2:
+              hasForceUpdate = !0;
+          }
+        }
+        updateLane = pendingQueue.callback;
+        null !== updateLane &&
+          ((workInProgress$jscomp$0.flags |= 64),
+          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
+          (isHiddenUpdate = queue.callbacks),
+          null === isHiddenUpdate
+            ? (queue.callbacks = [updateLane])
+            : isHiddenUpdate.push(updateLane));
+      } else
+        (isHiddenUpdate = {
+          lane: updateLane,
+          tag: pendingQueue.tag,
+          payload: pendingQueue.payload,
+          callback: pendingQueue.callback,
+          next: null
+        }),
+          null === current
+            ? ((firstPendingUpdate = current = isHiddenUpdate),
+              (lastPendingUpdate = newState))
+            : (current = current.next = isHiddenUpdate),
+          (lastBaseUpdate |= updateLane);
+      pendingQueue = pendingQueue.next;
+      if (null === pendingQueue)
+        if (((pendingQueue = queue.shared.pending), null === pendingQueue))
+          break;
+        else
+          (isHiddenUpdate = pendingQueue),
+            (pendingQueue = isHiddenUpdate.next),
+            (isHiddenUpdate.next = null),
+            (queue.lastBaseUpdate = isHiddenUpdate),
+            (queue.shared.pending = null);
+    } while (1);
+    null === current && (lastPendingUpdate = newState);
+    queue.baseState = lastPendingUpdate;
+    queue.firstBaseUpdate = firstPendingUpdate;
+    queue.lastBaseUpdate = current;
+    null === firstBaseUpdate && (queue.shared.lanes = 0);
+    workInProgressRootSkippedLanes |= lastBaseUpdate;
+    workInProgress$jscomp$0.lanes = lastBaseUpdate;
+    workInProgress$jscomp$0.memoizedState = newState;
+  }
+}
+function callCallback(callback, context) {
+  if ("function" !== typeof callback)
+    throw Error(formatProdErrorMessage(191, callback));
+  callback.call(context);
+}
+function commitCallbacks(updateQueue, context) {
+  var callbacks = updateQueue.callbacks;
+  if (null !== callbacks)
+    for (
+      updateQueue.callbacks = null, updateQueue = 0;
+      updateQueue < callbacks.length;
+      updateQueue++
+    )
+      callCallback(callbacks[updateQueue], context);
+}
+var AbortControllerLocal =
+    "undefined" !== typeof AbortController
+      ? AbortController
+      : function () {
+          var listeners = [],
+            signal = (this.signal = {
+              aborted: !1,
+              addEventListener: function (type, listener) {
+                listeners.push(listener);
+              }
+            });
+          this.abort = function () {
+            signal.aborted = !0;
+            listeners.forEach(function (listener) {
+              return listener();
+            });
+          };
+        },
+  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
+  NormalPriority = Scheduler.unstable_NormalPriority,
+  CacheContext = {
+    $$typeof: REACT_CONTEXT_TYPE,
+    Consumer: null,
+    Provider: null,
+    _currentValue: null,
+    _currentValue2: null,
+    _threadCount: 0
+  };
+function createCache() {
+  return {
+    controller: new AbortControllerLocal(),
+    data: new Map(),
+    refCount: 0
+  };
+}
+function releaseCache(cache) {
+  cache.refCount--;
+  0 === cache.refCount &&
+    scheduleCallback$2(NormalPriority, function () {
+      cache.controller.abort();
+    });
+}
+function applyDerivedStateFromProps(
+  workInProgress,
+  ctor,
+  getDerivedStateFromProps,
+  nextProps
+) {
+  ctor = workInProgress.memoizedState;
+  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
+  getDerivedStateFromProps =
+    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
+      ? ctor
+      : assign({}, ctor, getDerivedStateFromProps);
+  workInProgress.memoizedState = getDerivedStateFromProps;
+  0 === workInProgress.lanes &&
+    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
+}
+var classComponentUpdater = {
+  enqueueSetState: function (inst, payload, callback) {
+    inst = inst._reactInternals;
+    var lane = requestUpdateLane(),
+      update = createUpdate(lane);
+    update.payload = payload;
+    void 0 !== callback && null !== callback && (update.callback = callback);
+    payload = enqueueUpdate(inst, update, lane);
+    null !== payload &&
+      (scheduleUpdateOnFiber(payload, inst, lane),
+      entangleTransitions(payload, inst, lane));
+  },
+  enqueueReplaceState: function (inst, payload, callback) {
+    inst = inst._reactInternals;
+    var lane = requestUpdateLane(),
+      update = createUpdate(lane);
+    update.tag = 1;
+    update.payload = payload;
+    void 0 !== callback && null !== callback && (update.callback = callback);
+    payload = enqueueUpdate(inst, update, lane);
+    null !== payload &&
+      (scheduleUpdateOnFiber(payload, inst, lane),
+      entangleTransitions(payload, inst, lane));
+  },
+  enqueueForceUpdate: function (inst, callback) {
+    inst = inst._reactInternals;
+    var lane = requestUpdateLane(),
+      update = createUpdate(lane);
+    update.tag = 2;
+    void 0 !== callback && null !== callback && (update.callback = callback);
+    callback = enqueueUpdate(inst, update, lane);
+    null !== callback &&
+      (scheduleUpdateOnFiber(callback, inst, lane),
+      entangleTransitions(callback, inst, lane));
+  }
+};
+function checkShouldComponentUpdate(
+  workInProgress,
+  ctor,
+  oldProps,
+  newProps,
+  oldState,
+  newState,
+  nextContext
+) {
+  workInProgress = workInProgress.stateNode;
+  return "function" === typeof workInProgress.shouldComponentUpdate
+    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
+    : ctor.prototype && ctor.prototype.isPureReactComponent
+      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
+      : !0;
+}
+function callComponentWillReceiveProps(
+  workInProgress,
+  instance,
+  newProps,
+  nextContext
+) {
+  workInProgress = instance.state;
+  "function" === typeof instance.componentWillReceiveProps &&
+    instance.componentWillReceiveProps(newProps, nextContext);
+  "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
+    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
+  instance.state !== workInProgress &&
+    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
+}
+function resolveClassComponentProps(Component, baseProps) {
+  var newProps = baseProps;
+  if ("ref" in baseProps) {
+    newProps = {};
+    for (var propName in baseProps)
+      "ref" !== propName && (newProps[propName] = baseProps[propName]);
+  }
+  if ((Component = Component.defaultProps)) {
+    newProps === baseProps && (newProps = assign({}, newProps));
+    for (var propName$28 in Component)
+      void 0 === newProps[propName$28] &&
+        (newProps[propName$28] = Component[propName$28]);
+  }
+  return newProps;
+}
+var forkStack = [],
+  forkStackIndex = 0,
+  treeForkProvider = null,
+  treeForkCount = 0,
+  idStack = [],
+  idStackIndex = 0,
+  treeContextProvider = null,
+  treeContextId = 1,
+  treeContextOverflow = "";
+function getTreeId() {
+  var overflow = treeContextOverflow,
+    idWithLeadingBit = treeContextId;
+  return (
+    (idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))).toString(
+      32
+    ) + overflow
+  );
+}
+function pushTreeFork(workInProgress, totalChildren) {
+  forkStack[forkStackIndex++] = treeForkCount;
+  forkStack[forkStackIndex++] = treeForkProvider;
+  treeForkProvider = workInProgress;
+  treeForkCount = totalChildren;
+}
+function pushTreeId(workInProgress, totalChildren, index) {
+  idStack[idStackIndex++] = treeContextId;
+  idStack[idStackIndex++] = treeContextOverflow;
+  idStack[idStackIndex++] = treeContextProvider;
+  treeContextProvider = workInProgress;
+  var baseIdWithLeadingBit = treeContextId;
+  workInProgress = treeContextOverflow;
+  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
+  baseIdWithLeadingBit &= ~(1 << baseLength);
+  index += 1;
+  var length = 32 - clz32(totalChildren) + baseLength;
+  if (30 < length) {
+    var numberOfOverflowBits = baseLength - (baseLength % 5);
+    length = (
+      baseIdWithLeadingBit &
+      ((1 << numberOfOverflowBits) - 1)
+    ).toString(32);
+    baseIdWithLeadingBit >>= numberOfOverflowBits;
+    baseLength -= numberOfOverflowBits;
+    treeContextId =
+      (1 << (32 - clz32(totalChildren) + baseLength)) |
+      (index << baseLength) |
+      baseIdWithLeadingBit;
+    treeContextOverflow = length + workInProgress;
+  } else
+    (treeContextId =
+      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
+      (treeContextOverflow = workInProgress);
+}
+function pushMaterializedTreeId(workInProgress) {
+  null !== workInProgress.return &&
+    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
+}
+function popTreeContext(workInProgress) {
+  for (; workInProgress === treeForkProvider; )
+    (treeForkProvider = forkStack[--forkStackIndex]),
+      (forkStack[forkStackIndex] = null),
+      (treeForkCount = forkStack[--forkStackIndex]),
+      (forkStack[forkStackIndex] = null);
+  for (; workInProgress === treeContextProvider; )
+    (treeContextProvider = idStack[--idStackIndex]),
+      (idStack[idStackIndex] = null),
+      (treeContextOverflow = idStack[--idStackIndex]),
+      (idStack[idStackIndex] = null),
+      (treeContextId = idStack[--idStackIndex]),
+      (idStack[idStackIndex] = null);
+}
+var SuspenseException = Error(formatProdErrorMessage(460)),
+  SuspenseyCommitException = Error(formatProdErrorMessage(474)),
+  SuspenseActionException = Error(formatProdErrorMessage(542)),
+  noopSuspenseyCommitThenable = { then: function () {} };
+function isThenableResolved(thenable) {
+  thenable = thenable.status;
+  return "fulfilled" === thenable || "rejected" === thenable;
+}
+function noop$3() {}
+function trackUsedThenable(thenableState, thenable, index) {
+  index = thenableState[index];
+  void 0 === index
+    ? thenableState.push(thenable)
+    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));
+  switch (thenable.status) {
+    case "fulfilled":
+      return thenable.value;
+    case "rejected":
+      throw (
+        ((thenableState = thenable.reason),
+        checkIfUseWrappedInAsyncCatch(thenableState),
+        thenableState)
+      );
+    default:
+      if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
+      else {
+        thenableState = workInProgressRoot;
+        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)
+          throw Error(formatProdErrorMessage(482));
+        thenableState = thenable;
+        thenableState.status = "pending";
+        thenableState.then(
+          function (fulfilledValue) {
+            if ("pending" === thenable.status) {
+              var fulfilledThenable = thenable;
+              fulfilledThenable.status = "fulfilled";
+              fulfilledThenable.value = fulfilledValue;
+            }
+          },
+          function (error) {
+            if ("pending" === thenable.status) {
+              var rejectedThenable = thenable;
+              rejectedThenable.status = "rejected";
+              rejectedThenable.reason = error;
+            }
+          }
+        );
+      }
+      switch (thenable.status) {
+        case "fulfilled":
+          return thenable.value;
+        case "rejected":
+          throw (
+            ((thenableState = thenable.reason),
+            checkIfUseWrappedInAsyncCatch(thenableState),
+            thenableState)
+          );
+      }
+      suspendedThenable = thenable;
+      throw SuspenseException;
+  }
+}
+var suspendedThenable = null;
+function getSuspendedThenable() {
+  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
+  var thenable = suspendedThenable;
+  suspendedThenable = null;
+  return thenable;
+}
+function checkIfUseWrappedInAsyncCatch(rejectedReason) {
+  if (
+    rejectedReason === SuspenseException ||
+    rejectedReason === SuspenseActionException
+  )
+    throw Error(formatProdErrorMessage(483));
+}
+var currentTreeHiddenStackCursor = createCursor(null),
+  prevEntangledRenderLanesCursor = createCursor(0);
+function pushHiddenContext(fiber, context) {
+  fiber = entangledRenderLanes;
+  push(prevEntangledRenderLanesCursor, fiber);
+  push(currentTreeHiddenStackCursor, context);
+  entangledRenderLanes = fiber | context.baseLanes;
+}
+function reuseHiddenContextOnStack() {
+  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
+  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
+}
+function popHiddenContext() {
+  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
+  pop(currentTreeHiddenStackCursor);
+  pop(prevEntangledRenderLanesCursor);
+}
+var prevOnStartTransitionFinish = ReactSharedInternals.S;
+ReactSharedInternals.S = function (transition, returnValue) {
+  "object" === typeof returnValue &&
+    null !== returnValue &&
+    "function" === typeof returnValue.then &&
+    entangleAsyncAction(transition, returnValue);
+  null !== prevOnStartTransitionFinish &&
+    prevOnStartTransitionFinish(transition, returnValue);
+};
+var resumedCache = createCursor(null);
+function peekCacheFromPool() {
+  var cacheResumedFromPreviousRender = resumedCache.current;
+  return null !== cacheResumedFromPreviousRender
+    ? cacheResumedFromPreviousRender
+    : workInProgressRoot.pooledCache;
+}
+function pushTransition(offscreenWorkInProgress, prevCachePool) {
+  null === prevCachePool
+    ? push(resumedCache, resumedCache.current)
+    : push(resumedCache, prevCachePool.pool);
+}
+function getSuspendedCache() {
+  var cacheFromPool = peekCacheFromPool();
+  return null === cacheFromPool
+    ? null
+    : { parent: CacheContext._currentValue, pool: cacheFromPool };
+}
+var renderLanes = 0,
+  currentlyRenderingFiber = null,
+  currentHook = null,
+  workInProgressHook = null,
+  didScheduleRenderPhaseUpdate = !1,
+  didScheduleRenderPhaseUpdateDuringThisPass = !1,
+  shouldDoubleInvokeUserFnsInHooksDEV = !1,
+  localIdCounter = 0,
+  thenableIndexCounter$1 = 0,
+  thenableState$1 = null,
+  globalClientIdCounter$1 = 0;
+function throwInvalidHookError() {
+  throw Error(formatProdErrorMessage(321));
+}
+function areHookInputsEqual(nextDeps, prevDeps) {
+  if (null === prevDeps) return !1;
+  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
+    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
+  return !0;
+}
+function renderWithHooks(
+  current,
+  workInProgress,
+  Component,
+  props,
+  secondArg,
+  nextRenderLanes
+) {
+  renderLanes = nextRenderLanes;
+  currentlyRenderingFiber = workInProgress;
+  workInProgress.memoizedState = null;
+  workInProgress.updateQueue = null;
+  workInProgress.lanes = 0;
+  ReactSharedInternals.H =
+    null === current || null === current.memoizedState
+      ? HooksDispatcherOnMount
+      : HooksDispatcherOnUpdate;
+  shouldDoubleInvokeUserFnsInHooksDEV = !1;
+  nextRenderLanes = Component(props, secondArg);
+  shouldDoubleInvokeUserFnsInHooksDEV = !1;
+  didScheduleRenderPhaseUpdateDuringThisPass &&
+    (nextRenderLanes = renderWithHooksAgain(
+      workInProgress,
+      Component,
+      props,
+      secondArg
+    ));
+  finishRenderingHooks(current);
+  return nextRenderLanes;
+}
+function finishRenderingHooks(current) {
+  ReactSharedInternals.H = ContextOnlyDispatcher;
+  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
+  renderLanes = 0;
+  workInProgressHook = currentHook = currentlyRenderingFiber = null;
+  didScheduleRenderPhaseUpdate = !1;
+  thenableIndexCounter$1 = 0;
+  thenableState$1 = null;
+  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
+  null === current ||
+    didReceiveUpdate ||
+    ((current = current.dependencies),
+    null !== current &&
+      checkIfContextChanged(current) &&
+      (didReceiveUpdate = !0));
+}
+function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
+  currentlyRenderingFiber = workInProgress;
+  var numberOfReRenders = 0;
+  do {
+    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
+    thenableIndexCounter$1 = 0;
+    didScheduleRenderPhaseUpdateDuringThisPass = !1;
+    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
+    numberOfReRenders += 1;
+    workInProgressHook = currentHook = null;
+    if (null != workInProgress.updateQueue) {
+      var children = workInProgress.updateQueue;
+      children.lastEffect = null;
+      children.events = null;
+      children.stores = null;
+      null != children.memoCache && (children.memoCache.index = 0);
+    }
+    ReactSharedInternals.H = HooksDispatcherOnRerender;
+    children = Component(props, secondArg);
+  } while (didScheduleRenderPhaseUpdateDuringThisPass);
+  return children;
+}
+function TransitionAwareHostComponent() {
+  var dispatcher = ReactSharedInternals.H,
+    maybeThenable = dispatcher.useState()[0];
+  maybeThenable =
+    "function" === typeof maybeThenable.then
+      ? useThenable(maybeThenable)
+      : maybeThenable;
+  dispatcher = dispatcher.useState()[0];
+  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&
+    (currentlyRenderingFiber.flags |= 1024);
+  return maybeThenable;
+}
+function checkDidRenderIdHook() {
+  var didRenderIdHook = 0 !== localIdCounter;
+  localIdCounter = 0;
+  return didRenderIdHook;
+}
+function bailoutHooks(current, workInProgress, lanes) {
+  workInProgress.updateQueue = current.updateQueue;
+  workInProgress.flags &= -2053;
+  current.lanes &= ~lanes;
+}
+function resetHooksOnUnwind(workInProgress) {
+  if (didScheduleRenderPhaseUpdate) {
+    for (
+      workInProgress = workInProgress.memoizedState;
+      null !== workInProgress;
+
+    ) {
+      var queue = workInProgress.queue;
+      null !== queue && (queue.pending = null);
+      workInProgress = workInProgress.next;
+    }
+    didScheduleRenderPhaseUpdate = !1;
+  }
+  renderLanes = 0;
+  workInProgressHook = currentHook = currentlyRenderingFiber = null;
+  didScheduleRenderPhaseUpdateDuringThisPass = !1;
+  thenableIndexCounter$1 = localIdCounter = 0;
+  thenableState$1 = null;
+}
+function mountWorkInProgressHook() {
+  var hook = {
+    memoizedState: null,
+    baseState: null,
+    baseQueue: null,
+    queue: null,
+    next: null
+  };
+  null === workInProgressHook
+    ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
+    : (workInProgressHook = workInProgressHook.next = hook);
+  return workInProgressHook;
+}
+function updateWorkInProgressHook() {
+  if (null === currentHook) {
+    var nextCurrentHook = currentlyRenderingFiber.alternate;
+    nextCurrentHook =
+      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
+  } else nextCurrentHook = currentHook.next;
+  var nextWorkInProgressHook =
+    null === workInProgressHook
+      ? currentlyRenderingFiber.memoizedState
+      : workInProgressHook.next;
+  if (null !== nextWorkInProgressHook)
+    (workInProgressHook = nextWorkInProgressHook),
+      (currentHook = nextCurrentHook);
+  else {
+    if (null === nextCurrentHook) {
+      if (null === currentlyRenderingFiber.alternate)
+        throw Error(formatProdErrorMessage(467));
+      throw Error(formatProdErrorMessage(310));
+    }
+    currentHook = nextCurrentHook;
+    nextCurrentHook = {
+      memoizedState: currentHook.memoizedState,
+      baseState: currentHook.baseState,
+      baseQueue: currentHook.baseQueue,
+      queue: currentHook.queue,
+      next: null
+    };
+    null === workInProgressHook
+      ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
+          nextCurrentHook)
+      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
+  }
+  return workInProgressHook;
+}
+function createFunctionComponentUpdateQueue() {
+  return { lastEffect: null, events: null, stores: null, memoCache: null };
+}
+function useThenable(thenable) {
+  var index = thenableIndexCounter$1;
+  thenableIndexCounter$1 += 1;
+  null === thenableState$1 && (thenableState$1 = []);
+  thenable = trackUsedThenable(thenableState$1, thenable, index);
+  index = currentlyRenderingFiber;
+  null ===
+    (null === workInProgressHook
+      ? index.memoizedState
+      : workInProgressHook.next) &&
+    ((index = index.alternate),
+    (ReactSharedInternals.H =
+      null === index || null === index.memoizedState
+        ? HooksDispatcherOnMount
+        : HooksDispatcherOnUpdate));
+  return thenable;
+}
+function use(usable) {
+  if (null !== usable && "object" === typeof usable) {
+    if ("function" === typeof usable.then) return useThenable(usable);
+    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
+  }
+  throw Error(formatProdErrorMessage(438, String(usable)));
+}
+function useMemoCache(size) {
+  var memoCache = null,
+    updateQueue = currentlyRenderingFiber.updateQueue;
+  null !== updateQueue && (memoCache = updateQueue.memoCache);
+  if (null == memoCache) {
+    var current = currentlyRenderingFiber.alternate;
+    null !== current &&
+      ((current = current.updateQueue),
+      null !== current &&
+        ((current = current.memoCache),
+        null != current &&
+          (memoCache = {
+            data: current.data.map(function (array) {
+              return array.slice();
+            }),
+            index: 0
+          })));
+  }
+  null == memoCache && (memoCache = { data: [], index: 0 });
+  null === updateQueue &&
+    ((updateQueue = createFunctionComponentUpdateQueue()),
+    (currentlyRenderingFiber.updateQueue = updateQueue));
+  updateQueue.memoCache = memoCache;
+  updateQueue = memoCache.data[memoCache.index];
+  if (void 0 === updateQueue)
+    for (
+      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;
+      current < size;
+      current++
+    )
+      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
+  memoCache.index++;
+  return updateQueue;
+}
+function basicStateReducer(state, action) {
+  return "function" === typeof action ? action(state) : action;
+}
+function updateReducer(reducer) {
+  var hook = updateWorkInProgressHook();
+  return updateReducerImpl(hook, currentHook, reducer);
+}
+function updateReducerImpl(hook, current, reducer) {
+  var queue = hook.queue;
+  if (null === queue) throw Error(formatProdErrorMessage(311));
+  queue.lastRenderedReducer = reducer;
+  var baseQueue = hook.baseQueue,
+    pendingQueue = queue.pending;
+  if (null !== pendingQueue) {
+    if (null !== baseQueue) {
+      var baseFirst = baseQueue.next;
+      baseQueue.next = pendingQueue.next;
+      pendingQueue.next = baseFirst;
+    }
+    current.baseQueue = baseQueue = pendingQueue;
+    queue.pending = null;
+  }
+  pendingQueue = hook.baseState;
+  if (null === baseQueue) hook.memoizedState = pendingQueue;
+  else {
+    current = baseQueue.next;
+    var newBaseQueueFirst = (baseFirst = null),
+      newBaseQueueLast = null,
+      update = current,
+      didReadFromEntangledAsyncAction$33 = !1;
+    do {
+      var updateLane = update.lane & -536870913;
+      if (
+        updateLane !== update.lane
+          ? (workInProgressRootRenderLanes & updateLane) === updateLane
+          : (renderLanes & updateLane) === updateLane
+      ) {
+        var revertLane = update.revertLane;
+        if (0 === revertLane)
+          null !== newBaseQueueLast &&
+            (newBaseQueueLast = newBaseQueueLast.next =
+              {
+                lane: 0,
+                revertLane: 0,
+                action: update.action,
+                hasEagerState: update.hasEagerState,
+                eagerState: update.eagerState,
+                next: null
+              }),
+            updateLane === currentEntangledLane &&
+              (didReadFromEntangledAsyncAction$33 = !0);
+        else if ((renderLanes & revertLane) === revertLane) {
+          update = update.next;
+          revertLane === currentEntangledLane &&
+            (didReadFromEntangledAsyncAction$33 = !0);
+          continue;
+        } else
+          (updateLane = {
+            lane: 0,
+            revertLane: update.revertLane,
+            action: update.action,
+            hasEagerState: update.hasEagerState,
+            eagerState: update.eagerState,
+            next: null
+          }),
+            null === newBaseQueueLast
+              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
+                (baseFirst = pendingQueue))
+              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
+            (currentlyRenderingFiber.lanes |= revertLane),
+            (workInProgressRootSkippedLanes |= revertLane);
+        updateLane = update.action;
+        shouldDoubleInvokeUserFnsInHooksDEV &&
+          reducer(pendingQueue, updateLane);
+        pendingQueue = update.hasEagerState
+          ? update.eagerState
+          : reducer(pendingQueue, updateLane);
+      } else
+        (revertLane = {
+          lane: updateLane,
+          revertLane: update.revertLane,
+          action: update.action,
+          hasEagerState: update.hasEagerState,
+          eagerState: update.eagerState,
+          next: null
+        }),
+          null === newBaseQueueLast
+            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
+              (baseFirst = pendingQueue))
+            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
+          (currentlyRenderingFiber.lanes |= updateLane),
+          (workInProgressRootSkippedLanes |= updateLane);
+      update = update.next;
+    } while (null !== update && update !== current);
+    null === newBaseQueueLast
+      ? (baseFirst = pendingQueue)
+      : (newBaseQueueLast.next = newBaseQueueFirst);
+    if (
+      !objectIs(pendingQueue, hook.memoizedState) &&
+      ((didReceiveUpdate = !0),
+      didReadFromEntangledAsyncAction$33 &&
+        ((reducer = currentEntangledActionThenable), null !== reducer))
+    )
+      throw reducer;
+    hook.memoizedState = pendingQueue;
+    hook.baseState = baseFirst;
+    hook.baseQueue = newBaseQueueLast;
+    queue.lastRenderedState = pendingQueue;
+  }
+  null === baseQueue && (queue.lanes = 0);
+  return [hook.memoizedState, queue.dispatch];
+}
+function rerenderReducer(reducer) {
+  var hook = updateWorkInProgressHook(),
+    queue = hook.queue;
+  if (null === queue) throw Error(formatProdErrorMessage(311));
+  queue.lastRenderedReducer = reducer;
+  var dispatch = queue.dispatch,
+    lastRenderPhaseUpdate = queue.pending,
+    newState = hook.memoizedState;
+  if (null !== lastRenderPhaseUpdate) {
+    queue.pending = null;
+    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
+    do (newState = reducer(newState, update.action)), (update = update.next);
+    while (update !== lastRenderPhaseUpdate);
+    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
+    hook.memoizedState = newState;
+    null === hook.baseQueue && (hook.baseState = newState);
+    queue.lastRenderedState = newState;
+  }
+  return [newState, dispatch];
+}
+function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
+  var fiber = currentlyRenderingFiber,
+    hook = updateWorkInProgressHook(),
+    isHydrating$jscomp$0 = isHydrating;
+  if (isHydrating$jscomp$0) {
+    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
+    getServerSnapshot = getServerSnapshot();
+  } else getServerSnapshot = getSnapshot();
+  var snapshotChanged = !objectIs(
+    (currentHook || hook).memoizedState,
+    getServerSnapshot
+  );
+  snapshotChanged &&
+    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));
+  hook = hook.queue;
+  updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
+    subscribe
+  ]);
+  if (
+    hook.getSnapshot !== getSnapshot ||
+    snapshotChanged ||
+    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)
+  ) {
+    fiber.flags |= 2048;
+    pushSimpleEffect(
+      9,
+      createEffectInstance(),
+      updateStoreInstance.bind(
+        null,
+        fiber,
+        hook,
+        getServerSnapshot,
+        getSnapshot
+      ),
+      null
+    );
+    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
+    isHydrating$jscomp$0 ||
+      0 !== (renderLanes & 60) ||
+      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
+  }
+  return getServerSnapshot;
+}
+function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
+  fiber.flags |= 16384;
+  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
+  getSnapshot = currentlyRenderingFiber.updateQueue;
+  null === getSnapshot
+    ? ((getSnapshot = createFunctionComponentUpdateQueue()),
+      (currentlyRenderingFiber.updateQueue = getSnapshot),
+      (getSnapshot.stores = [fiber]))
+    : ((renderedSnapshot = getSnapshot.stores),
+      null === renderedSnapshot
+        ? (getSnapshot.stores = [fiber])
+        : renderedSnapshot.push(fiber));
+}
+function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
+  inst.value = nextSnapshot;
+  inst.getSnapshot = getSnapshot;
+  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
+}
+function subscribeToStore(fiber, inst, subscribe) {
+  return subscribe(function () {
+    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
+  });
+}
+function checkIfSnapshotChanged(inst) {
+  var latestGetSnapshot = inst.getSnapshot;
+  inst = inst.value;
+  try {
+    var nextValue = latestGetSnapshot();
+    return !objectIs(inst, nextValue);
+  } catch (error) {
+    return !0;
+  }
+}
+function forceStoreRerender(fiber) {
+  var root = enqueueConcurrentRenderForLane(fiber, 2);
+  null !== root && scheduleUpdateOnFiber(root, fiber, 2);
+}
+function mountStateImpl(initialState) {
+  var hook = mountWorkInProgressHook();
+  if ("function" === typeof initialState) {
+    var initialStateInitializer = initialState;
+    initialState = initialStateInitializer();
+    if (shouldDoubleInvokeUserFnsInHooksDEV) {
+      setIsStrictModeForDevtools(!0);
+      try {
+        initialStateInitializer();
+      } finally {
+        setIsStrictModeForDevtools(!1);
+      }
+    }
+  }
+  hook.memoizedState = hook.baseState = initialState;
+  hook.queue = {
+    pending: null,
+    lanes: 0,
+    dispatch: null,
+    lastRenderedReducer: basicStateReducer,
+    lastRenderedState: initialState
+  };
+  return hook;
+}
+function updateOptimisticImpl(hook, current, passthrough, reducer) {
+  hook.baseState = passthrough;
+  return updateReducerImpl(
+    hook,
+    currentHook,
+    "function" === typeof reducer ? reducer : basicStateReducer
+  );
+}
+function dispatchActionState(
+  fiber,
+  actionQueue,
+  setPendingState,
+  setState,
+  payload
+) {
+  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
+  fiber = actionQueue.action;
+  if (null !== fiber) {
+    var actionNode = {
+      payload: payload,
+      action: fiber,
+      next: null,
+      isTransition: !0,
+      status: "pending",
+      value: null,
+      reason: null,
+      listeners: [],
+      then: function (listener) {
+        actionNode.listeners.push(listener);
+      }
+    };
+    null !== ReactSharedInternals.T
+      ? setPendingState(!0)
+      : (actionNode.isTransition = !1);
+    setState(actionNode);
+    setPendingState = actionQueue.pending;
+    null === setPendingState
+      ? ((actionNode.next = actionQueue.pending = actionNode),
+        runActionStateAction(actionQueue, actionNode))
+      : ((actionNode.next = setPendingState.next),
+        (actionQueue.pending = setPendingState.next = actionNode));
+  }
+}
+function runActionStateAction(actionQueue, node) {
+  var action = node.action,
+    payload = node.payload,
+    prevState = actionQueue.state;
+  if (node.isTransition) {
+    var prevTransition = ReactSharedInternals.T,
+      currentTransition = {};
+    ReactSharedInternals.T = currentTransition;
+    try {
+      var returnValue = action(prevState, payload),
+        onStartTransitionFinish = ReactSharedInternals.S;
+      null !== onStartTransitionFinish &&
+        onStartTransitionFinish(currentTransition, returnValue);
+      handleActionReturnValue(actionQueue, node, returnValue);
+    } catch (error) {
+      onActionError(actionQueue, node, error);
+    } finally {
+      ReactSharedInternals.T = prevTransition;
+    }
+  } else
+    try {
+      (prevTransition = action(prevState, payload)),
+        handleActionReturnValue(actionQueue, node, prevTransition);
+    } catch (error$39) {
+      onActionError(actionQueue, node, error$39);
+    }
+}
+function handleActionReturnValue(actionQueue, node, returnValue) {
+  null !== returnValue &&
+  "object" === typeof returnValue &&
+  "function" === typeof returnValue.then
+    ? returnValue.then(
+        function (nextState) {
+          onActionSuccess(actionQueue, node, nextState);
+        },
+        function (error) {
+          return onActionError(actionQueue, node, error);
+        }
+      )
+    : onActionSuccess(actionQueue, node, returnValue);
+}
+function onActionSuccess(actionQueue, actionNode, nextState) {
+  actionNode.status = "fulfilled";
+  actionNode.value = nextState;
+  notifyActionListeners(actionNode);
+  actionQueue.state = nextState;
+  actionNode = actionQueue.pending;
+  null !== actionNode &&
+    ((nextState = actionNode.next),
+    nextState === actionNode
+      ? (actionQueue.pending = null)
+      : ((nextState = nextState.next),
+        (actionNode.next = nextState),
+        runActionStateAction(actionQueue, nextState)));
+}
+function onActionError(actionQueue, actionNode, error) {
+  var last = actionQueue.pending;
+  actionQueue.pending = null;
+  if (null !== last) {
+    last = last.next;
+    do
+      (actionNode.status = "rejected"),
+        (actionNode.reason = error),
+        notifyActionListeners(actionNode),
+        (actionNode = actionNode.next);
+    while (actionNode !== last);
+  }
+  actionQueue.action = null;
+}
+function notifyActionListeners(actionNode) {
+  actionNode = actionNode.listeners;
+  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
+}
+function actionStateReducer(oldState, newState) {
+  return newState;
+}
+function mountActionState(action, initialStateProp) {
+  if (isHydrating) {
+    var ssrFormState = workInProgressRoot.formState;
+    if (null !== ssrFormState) {
+      a: {
+        var JSCompiler_inline_result = currentlyRenderingFiber;
+        if (isHydrating) {
+          if (nextHydratableInstance) {
+            b: {
+              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
+              for (
+                var inRootOrSingleton = rootOrSingletonContext;
+                8 !== JSCompiler_inline_result$jscomp$0.nodeType;
+
+              ) {
+                if (!inRootOrSingleton) {
+                  JSCompiler_inline_result$jscomp$0 = null;
+                  break b;
+                }
+                JSCompiler_inline_result$jscomp$0 = getNextHydratable(
+                  JSCompiler_inline_result$jscomp$0.nextSibling
+                );
+                if (null === JSCompiler_inline_result$jscomp$0) {
+                  JSCompiler_inline_result$jscomp$0 = null;
+                  break b;
+                }
+              }
+              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
+              JSCompiler_inline_result$jscomp$0 =
+                "F!" === inRootOrSingleton || "F" === inRootOrSingleton
+                  ? JSCompiler_inline_result$jscomp$0
+                  : null;
+            }
+            if (JSCompiler_inline_result$jscomp$0) {
+              nextHydratableInstance = getNextHydratable(
+                JSCompiler_inline_result$jscomp$0.nextSibling
+              );
+              JSCompiler_inline_result =
+                "F!" === JSCompiler_inline_result$jscomp$0.data;
+              break a;
+            }
+          }
+          throwOnHydrationMismatch(JSCompiler_inline_result);
+        }
+        JSCompiler_inline_result = !1;
+      }
+      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
+    }
+  }
+  ssrFormState = mountWorkInProgressHook();
+  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
+  JSCompiler_inline_result = {
+    pending: null,
+    lanes: 0,
+    dispatch: null,
+    lastRenderedReducer: actionStateReducer,
+    lastRenderedState: initialStateProp
+  };
+  ssrFormState.queue = JSCompiler_inline_result;
+  ssrFormState = dispatchSetState.bind(
+    null,
+    currentlyRenderingFiber,
+    JSCompiler_inline_result
+  );
+  JSCompiler_inline_result.dispatch = ssrFormState;
+  JSCompiler_inline_result = mountStateImpl(!1);
+  inRootOrSingleton = dispatchOptimisticSetState.bind(
+    null,
+    currentlyRenderingFiber,
+    !1,
+    JSCompiler_inline_result.queue
+  );
+  JSCompiler_inline_result = mountWorkInProgressHook();
+  JSCompiler_inline_result$jscomp$0 = {
+    state: initialStateProp,
+    dispatch: null,
+    action: action,
+    pending: null
+  };
+  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
+  ssrFormState = dispatchActionState.bind(
+    null,
+    currentlyRenderingFiber,
+    JSCompiler_inline_result$jscomp$0,
+    inRootOrSingleton,
+    ssrFormState
+  );
+  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
+  JSCompiler_inline_result.memoizedState = action;
+  return [initialStateProp, ssrFormState, !1];
+}
+function updateActionState(action) {
+  var stateHook = updateWorkInProgressHook();
+  return updateActionStateImpl(stateHook, currentHook, action);
+}
+function updateActionStateImpl(stateHook, currentStateHook, action) {
+  currentStateHook = updateReducerImpl(
+    stateHook,
+    currentStateHook,
+    actionStateReducer
+  )[0];
+  stateHook = updateReducer(basicStateReducer)[0];
+  if (
+    "object" === typeof currentStateHook &&
+    null !== currentStateHook &&
+    "function" === typeof currentStateHook.then
+  )
+    try {
+      var state = useThenable(currentStateHook);
+    } catch (x) {
+      if (x === SuspenseException) throw SuspenseActionException;
+      throw x;
+    }
+  else state = currentStateHook;
+  currentStateHook = updateWorkInProgressHook();
+  var actionQueue = currentStateHook.queue,
+    dispatch = actionQueue.dispatch;
+  action !== currentStateHook.memoizedState &&
+    ((currentlyRenderingFiber.flags |= 2048),
+    pushSimpleEffect(
+      9,
+      createEffectInstance(),
+      actionStateActionEffect.bind(null, actionQueue, action),
+      null
+    ));
+  return [state, dispatch, stateHook];
+}
+function actionStateActionEffect(actionQueue, action) {
+  actionQueue.action = action;
+}
+function rerenderActionState(action) {
+  var stateHook = updateWorkInProgressHook(),
+    currentStateHook = currentHook;
+  if (null !== currentStateHook)
+    return updateActionStateImpl(stateHook, currentStateHook, action);
+  updateWorkInProgressHook();
+  stateHook = stateHook.memoizedState;
+  currentStateHook = updateWorkInProgressHook();
+  var dispatch = currentStateHook.queue.dispatch;
+  currentStateHook.memoizedState = action;
+  return [stateHook, dispatch, !1];
+}
+function pushSimpleEffect(tag, inst, create, deps) {
+  tag = { tag: tag, create: create, deps: deps, inst: inst, next: null };
+  inst = currentlyRenderingFiber.updateQueue;
+  null === inst &&
+    ((inst = createFunctionComponentUpdateQueue()),
+    (currentlyRenderingFiber.updateQueue = inst));
+  create = inst.lastEffect;
+  null === create
+    ? (inst.lastEffect = tag.next = tag)
+    : ((deps = create.next),
+      (create.next = tag),
+      (tag.next = deps),
+      (inst.lastEffect = tag));
+  return tag;
+}
+function createEffectInstance() {
+  return { destroy: void 0, resource: void 0 };
+}
+function updateRef() {
+  return updateWorkInProgressHook().memoizedState;
+}
+function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
+  var hook = mountWorkInProgressHook();
+  deps = void 0 === deps ? null : deps;
+  currentlyRenderingFiber.flags |= fiberFlags;
+  hook.memoizedState = pushSimpleEffect(
+    1 | hookFlags,
+    createEffectInstance(),
+    create,
+    deps
+  );
+}
+function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
+  var hook = updateWorkInProgressHook();
+  deps = void 0 === deps ? null : deps;
+  var inst = hook.memoizedState.inst;
+  null !== currentHook &&
+  null !== deps &&
+  areHookInputsEqual(deps, currentHook.memoizedState.deps)
+    ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
+    : ((currentlyRenderingFiber.flags |= fiberFlags),
+      (hook.memoizedState = pushSimpleEffect(
+        1 | hookFlags,
+        inst,
+        create,
+        deps
+      )));
+}
+function mountEffect(create, deps) {
+  mountEffectImpl(8390656, 8, create, deps);
+}
+function updateEffect(create, deps) {
+  updateEffectImpl(2048, 8, create, deps);
+}
+function useEffectEventImpl(payload) {
+  currentlyRenderingFiber.flags |= 4;
+  var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
+  if (null === componentUpdateQueue)
+    (componentUpdateQueue = createFunctionComponentUpdateQueue()),
+      (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
+      (componentUpdateQueue.events = [payload]);
+  else {
+    var events = componentUpdateQueue.events;
+    null === events
+      ? (componentUpdateQueue.events = [payload])
+      : events.push(payload);
+  }
+}
+function updateEvent(callback) {
+  var ref = updateWorkInProgressHook().memoizedState;
+  useEffectEventImpl({ ref: ref, nextImpl: callback });
+  return function () {
+    if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
+    return ref.impl.apply(void 0, arguments);
+  };
+}
+function updateInsertionEffect(create, deps) {
+  return updateEffectImpl(4, 2, create, deps);
+}
+function updateLayoutEffect(create, deps) {
+  return updateEffectImpl(4, 4, create, deps);
+}
+function imperativeHandleEffect(create, ref) {
+  if ("function" === typeof ref) {
+    create = create();
+    var refCleanup = ref(create);
+    return function () {
+      "function" === typeof refCleanup ? refCleanup() : ref(null);
+    };
+  }
+  if (null !== ref && void 0 !== ref)
+    return (
+      (create = create()),
+      (ref.current = create),
+      function () {
+        ref.current = null;
+      }
+    );
+}
+function updateImperativeHandle(ref, create, deps) {
+  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
+  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
+}
+function mountDebugValue() {}
+function updateCallback(callback, deps) {
+  var hook = updateWorkInProgressHook();
+  deps = void 0 === deps ? null : deps;
+  var prevState = hook.memoizedState;
+  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
+    return prevState[0];
+  hook.memoizedState = [callback, deps];
+  return callback;
+}
+function updateMemo(nextCreate, deps) {
+  var hook = updateWorkInProgressHook();
+  deps = void 0 === deps ? null : deps;
+  var prevState = hook.memoizedState;
+  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
+    return prevState[0];
+  prevState = nextCreate();
+  if (shouldDoubleInvokeUserFnsInHooksDEV) {
+    setIsStrictModeForDevtools(!0);
+    try {
+      nextCreate();
+    } finally {
+      setIsStrictModeForDevtools(!1);
+    }
+  }
+  hook.memoizedState = [prevState, deps];
+  return prevState;
+}
+function mountDeferredValueImpl(hook, value, initialValue) {
+  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
+    return (hook.memoizedState = value);
+  hook.memoizedState = initialValue;
+  hook = requestDeferredLane();
+  currentlyRenderingFiber.lanes |= hook;
+  workInProgressRootSkippedLanes |= hook;
+  return initialValue;
+}
+function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
+  if (objectIs(value, prevValue)) return value;
+  if (null !== currentTreeHiddenStackCursor.current)
+    return (
+      (hook = mountDeferredValueImpl(hook, value, initialValue)),
+      objectIs(hook, prevValue) || (didReceiveUpdate = !0),
+      hook
+    );
+  if (0 === (renderLanes & 42))
+    return (didReceiveUpdate = !0), (hook.memoizedState = value);
+  hook = requestDeferredLane();
+  currentlyRenderingFiber.lanes |= hook;
+  workInProgressRootSkippedLanes |= hook;
+  return prevValue;
+}
+function startTransition(fiber, queue, pendingState, finishedState, callback) {
+  var previousPriority = ReactDOMSharedInternals.p;
+  ReactDOMSharedInternals.p =
+    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
+  var prevTransition = ReactSharedInternals.T,
+    currentTransition = {};
+  ReactSharedInternals.T = currentTransition;
+  dispatchOptimisticSetState(fiber, !1, queue, pendingState);
+  try {
+    var returnValue = callback(),
+      onStartTransitionFinish = ReactSharedInternals.S;
+    null !== onStartTransitionFinish &&
+      onStartTransitionFinish(currentTransition, returnValue);
+    if (
+      null !== returnValue &&
+      "object" === typeof returnValue &&
+      "function" === typeof returnValue.then
+    ) {
+      var thenableForFinishedState = chainThenableValue(
+        returnValue,
+        finishedState
+      );
+      dispatchSetStateInternal(
+        fiber,
+        queue,
+        thenableForFinishedState,
+        requestUpdateLane(fiber)
+      );
+    } else
+      dispatchSetStateInternal(
+        fiber,
+        queue,
+        finishedState,
+        requestUpdateLane(fiber)
+      );
+  } catch (error) {
+    dispatchSetStateInternal(
+      fiber,
+      queue,
+      { then: function () {}, status: "rejected", reason: error },
+      requestUpdateLane()
+    );
+  } finally {
+    (ReactDOMSharedInternals.p = previousPriority),
+      (ReactSharedInternals.T = prevTransition);
+  }
+}
+function noop$2() {}
+function startHostTransition(formFiber, pendingState, action, formData) {
+  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
+  var queue = ensureFormComponentIsStateful(formFiber).queue;
+  startTransition(
+    formFiber,
+    queue,
+    pendingState,
+    sharedNotPendingObject,
+    null === action
+      ? noop$2
+      : function () {
+          requestFormReset$1(formFiber);
+          return action(formData);
+        }
+  );
+}
+function ensureFormComponentIsStateful(formFiber) {
+  var existingStateHook = formFiber.memoizedState;
+  if (null !== existingStateHook) return existingStateHook;
+  existingStateHook = {
+    memoizedState: sharedNotPendingObject,
+    baseState: sharedNotPendingObject,
+    baseQueue: null,
+    queue: {
+      pending: null,
+      lanes: 0,
+      dispatch: null,
+      lastRenderedReducer: basicStateReducer,
+      lastRenderedState: sharedNotPendingObject
+    },
+    next: null
+  };
+  var initialResetState = {};
+  existingStateHook.next = {
+    memoizedState: initialResetState,
+    baseState: initialResetState,
+    baseQueue: null,
+    queue: {
+      pending: null,
+      lanes: 0,
+      dispatch: null,
+      lastRenderedReducer: basicStateReducer,
+      lastRenderedState: initialResetState
+    },
+    next: null
+  };
+  formFiber.memoizedState = existingStateHook;
+  formFiber = formFiber.alternate;
+  null !== formFiber && (formFiber.memoizedState = existingStateHook);
+  return existingStateHook;
+}
+function requestFormReset$1(formFiber) {
+  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
+  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
+}
+function useHostTransitionStatus() {
+  return readContext(HostTransitionContext);
+}
+function updateId() {
+  return updateWorkInProgressHook().memoizedState;
+}
+function updateRefresh() {
+  return updateWorkInProgressHook().memoizedState;
+}
+function refreshCache(fiber, seedKey, seedValue) {
+  for (var provider = fiber.return; null !== provider; ) {
+    switch (provider.tag) {
+      case 24:
+      case 3:
+        var lane = requestUpdateLane();
+        fiber = createUpdate(lane);
+        var root$42 = enqueueUpdate(provider, fiber, lane);
+        null !== root$42 &&
+          (scheduleUpdateOnFiber(root$42, provider, lane),
+          entangleTransitions(root$42, provider, lane));
+        provider = createCache();
+        null !== seedKey &&
+          void 0 !== seedKey &&
+          null !== root$42 &&
+          provider.data.set(seedKey, seedValue);
+        fiber.payload = { cache: provider };
+        return;
+    }
+    provider = provider.return;
+  }
+}
+function dispatchReducerAction(fiber, queue, action) {
+  var lane = requestUpdateLane();
+  action = {
+    lane: lane,
+    revertLane: 0,
+    action: action,
+    hasEagerState: !1,
+    eagerState: null,
+    next: null
+  };
+  isRenderPhaseUpdate(fiber)
+    ? enqueueRenderPhaseUpdate(queue, action)
+    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
+      null !== action &&
+        (scheduleUpdateOnFiber(action, fiber, lane),
+        entangleTransitionUpdate(action, queue, lane)));
+}
+function dispatchSetState(fiber, queue, action) {
+  var lane = requestUpdateLane();
+  dispatchSetStateInternal(fiber, queue, action, lane);
+}
+function dispatchSetStateInternal(fiber, queue, action, lane) {
+  var update = {
+    lane: lane,
+    revertLane: 0,
+    action: action,
+    hasEagerState: !1,
+    eagerState: null,
+    next: null
+  };
+  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
+  else {
+    var alternate = fiber.alternate;
+    if (
+      0 === fiber.lanes &&
+      (null === alternate || 0 === alternate.lanes) &&
+      ((alternate = queue.lastRenderedReducer), null !== alternate)
+    )
+      try {
+        var currentState = queue.lastRenderedState,
+          eagerState = alternate(currentState, action);
+        update.hasEagerState = !0;
+        update.eagerState = eagerState;
+        if (objectIs(eagerState, currentState))
+          return (
+            enqueueUpdate$1(fiber, queue, update, 0),
+            null === workInProgressRoot && finishQueueingConcurrentUpdates(),
+            !1
+          );
+      } catch (error) {
+      } finally {
+      }
+    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
+    if (null !== action)
+      return (
+        scheduleUpdateOnFiber(action, fiber, lane),
+        entangleTransitionUpdate(action, queue, lane),
+        !0
+      );
+  }
+  return !1;
+}
+function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
+  action = {
+    lane: 2,
+    revertLane: requestTransitionLane(),
+    action: action,
+    hasEagerState: !1,
+    eagerState: null,
+    next: null
+  };
+  if (isRenderPhaseUpdate(fiber)) {
+    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
+  } else
+    (throwIfDuringRender = enqueueConcurrentHookUpdate(
+      fiber,
+      queue,
+      action,
+      2
+    )),
+      null !== throwIfDuringRender &&
+        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
+}
+function isRenderPhaseUpdate(fiber) {
+  var alternate = fiber.alternate;
+  return (
+    fiber === currentlyRenderingFiber ||
+    (null !== alternate && alternate === currentlyRenderingFiber)
+  );
+}
+function enqueueRenderPhaseUpdate(queue, update) {
+  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =
+    !0;
+  var pending = queue.pending;
+  null === pending
+    ? (update.next = update)
+    : ((update.next = pending.next), (pending.next = update));
+  queue.pending = update;
+}
+function entangleTransitionUpdate(root, queue, lane) {
+  if (0 !== (lane & 4194176)) {
+    var queueLanes = queue.lanes;
+    queueLanes &= root.pendingLanes;
+    lane |= queueLanes;
+    queue.lanes = lane;
+    markRootEntangled(root, lane);
+  }
+}
+var ContextOnlyDispatcher = {
+  readContext: readContext,
+  use: use,
+  useCallback: throwInvalidHookError,
+  useContext: throwInvalidHookError,
+  useEffect: throwInvalidHookError,
+  useImperativeHandle: throwInvalidHookError,
+  useLayoutEffect: throwInvalidHookError,
+  useInsertionEffect: throwInvalidHookError,
+  useMemo: throwInvalidHookError,
+  useReducer: throwInvalidHookError,
+  useRef: throwInvalidHookError,
+  useState: throwInvalidHookError,
+  useDebugValue: throwInvalidHookError,
+  useDeferredValue: throwInvalidHookError,
+  useTransition: throwInvalidHookError,
+  useSyncExternalStore: throwInvalidHookError,
+  useId: throwInvalidHookError,
+  useHostTransitionStatus: throwInvalidHookError,
+  useFormState: throwInvalidHookError,
+  useActionState: throwInvalidHookError,
+  useOptimistic: throwInvalidHookError,
+  useMemoCache: throwInvalidHookError,
+  useCacheRefresh: throwInvalidHookError
+};
+ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
+var HooksDispatcherOnMount = {
+    readContext: readContext,
+    use: use,
+    useCallback: function (callback, deps) {
+      mountWorkInProgressHook().memoizedState = [
+        callback,
+        void 0 === deps ? null : deps
+      ];
+      return callback;
+    },
+    useContext: readContext,
+    useEffect: mountEffect,
+    useImperativeHandle: function (ref, create, deps) {
+      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
+      mountEffectImpl(
+        4194308,
+        4,
+        imperativeHandleEffect.bind(null, create, ref),
+        deps
+      );
+    },
+    useLayoutEffect: function (create, deps) {
+      return mountEffectImpl(4194308, 4, create, deps);
+    },
+    useInsertionEffect: function (create, deps) {
+      mountEffectImpl(4, 2, create, deps);
+    },
+    useMemo: function (nextCreate, deps) {
+      var hook = mountWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var nextValue = nextCreate();
+      if (shouldDoubleInvokeUserFnsInHooksDEV) {
+        setIsStrictModeForDevtools(!0);
+        try {
+          nextCreate();
+        } finally {
+          setIsStrictModeForDevtools(!1);
+        }
+      }
+      hook.memoizedState = [nextValue, deps];
+      return nextValue;
+    },
+    useReducer: function (reducer, initialArg, init) {
+      var hook = mountWorkInProgressHook();
+      if (void 0 !== init) {
+        var initialState = init(initialArg);
+        if (shouldDoubleInvokeUserFnsInHooksDEV) {
+          setIsStrictModeForDevtools(!0);
+          try {
+            init(initialArg);
+          } finally {
+            setIsStrictModeForDevtools(!1);
+          }
+        }
+      } else initialState = initialArg;
+      hook.memoizedState = hook.baseState = initialState;
+      reducer = {
+        pending: null,
+        lanes: 0,
+        dispatch: null,
+        lastRenderedReducer: reducer,
+        lastRenderedState: initialState
+      };
+      hook.queue = reducer;
+      reducer = reducer.dispatch = dispatchReducerAction.bind(
+        null,
+        currentlyRenderingFiber,
+        reducer
+      );
+      return [hook.memoizedState, reducer];
+    },
+    useRef: function (initialValue) {
+      var hook = mountWorkInProgressHook();
+      initialValue = { current: initialValue };
+      return (hook.memoizedState = initialValue);
+    },
+    useState: function (initialState) {
+      initialState = mountStateImpl(initialState);
+      var queue = initialState.queue,
+        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
+      queue.dispatch = dispatch;
+      return [initialState.memoizedState, dispatch];
+    },
+    useDebugValue: mountDebugValue,
+    useDeferredValue: function (value, initialValue) {
+      var hook = mountWorkInProgressHook();
+      return mountDeferredValueImpl(hook, value, initialValue);
+    },
+    useTransition: function () {
+      var stateHook = mountStateImpl(!1);
+      stateHook = startTransition.bind(
+        null,
+        currentlyRenderingFiber,
+        stateHook.queue,
+        !0,
+        !1
+      );
+      mountWorkInProgressHook().memoizedState = stateHook;
+      return [!1, stateHook];
+    },
+    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
+      var fiber = currentlyRenderingFiber,
+        hook = mountWorkInProgressHook();
+      if (isHydrating) {
+        if (void 0 === getServerSnapshot)
+          throw Error(formatProdErrorMessage(407));
+        getServerSnapshot = getServerSnapshot();
+      } else {
+        getServerSnapshot = getSnapshot();
+        if (null === workInProgressRoot)
+          throw Error(formatProdErrorMessage(349));
+        0 !== (workInProgressRootRenderLanes & 60) ||
+          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
+      }
+      hook.memoizedState = getServerSnapshot;
+      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
+      hook.queue = inst;
+      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
+        subscribe
+      ]);
+      fiber.flags |= 2048;
+      pushSimpleEffect(
+        9,
+        createEffectInstance(),
+        updateStoreInstance.bind(
+          null,
+          fiber,
+          inst,
+          getServerSnapshot,
+          getSnapshot
+        ),
+        null
+      );
+      return getServerSnapshot;
+    },
+    useId: function () {
+      var hook = mountWorkInProgressHook(),
+        identifierPrefix = workInProgressRoot.identifierPrefix;
+      if (isHydrating) {
+        var treeId = getTreeId();
+        identifierPrefix = ":" + identifierPrefix + "R" + treeId;
+        treeId = localIdCounter++;
+        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
+        identifierPrefix += ":";
+      } else
+        (treeId = globalClientIdCounter$1++),
+          (identifierPrefix =
+            ":" + identifierPrefix + "r" + treeId.toString(32) + ":");
+      return (hook.memoizedState = identifierPrefix);
+    },
+    useHostTransitionStatus: useHostTransitionStatus,
+    useFormState: mountActionState,
+    useActionState: mountActionState,
+    useOptimistic: function (passthrough) {
+      var hook = mountWorkInProgressHook();
+      hook.memoizedState = hook.baseState = passthrough;
+      var queue = {
+        pending: null,
+        lanes: 0,
+        dispatch: null,
+        lastRenderedReducer: null,
+        lastRenderedState: null
+      };
+      hook.queue = queue;
+      hook = dispatchOptimisticSetState.bind(
+        null,
+        currentlyRenderingFiber,
+        !0,
+        queue
+      );
+      queue.dispatch = hook;
+      return [passthrough, hook];
+    },
+    useMemoCache: useMemoCache,
+    useCacheRefresh: function () {
+      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
+        null,
+        currentlyRenderingFiber
+      ));
+    },
+    useEffectEvent: function (callback) {
+      var hook = mountWorkInProgressHook(),
+        ref = { impl: callback };
+      hook.memoizedState = ref;
+      return function () {
+        if (0 !== (executionContext & 2))
+          throw Error(formatProdErrorMessage(440));
+        return ref.impl.apply(void 0, arguments);
+      };
+    }
+  },
+  HooksDispatcherOnUpdate = {
+    readContext: readContext,
+    use: use,
+    useCallback: updateCallback,
+    useContext: readContext,
+    useEffect: updateEffect,
+    useImperativeHandle: updateImperativeHandle,
+    useInsertionEffect: updateInsertionEffect,
+    useLayoutEffect: updateLayoutEffect,
+    useMemo: updateMemo,
+    useReducer: updateReducer,
+    useRef: updateRef,
+    useState: function () {
+      return updateReducer(basicStateReducer);
+    },
+    useDebugValue: mountDebugValue,
+    useDeferredValue: function (value, initialValue) {
+      var hook = updateWorkInProgressHook();
+      return updateDeferredValueImpl(
+        hook,
+        currentHook.memoizedState,
+        value,
+        initialValue
+      );
+    },
+    useTransition: function () {
+      var booleanOrThenable = updateReducer(basicStateReducer)[0],
+        start = updateWorkInProgressHook().memoizedState;
+      return [
+        "boolean" === typeof booleanOrThenable
+          ? booleanOrThenable
+          : useThenable(booleanOrThenable),
+        start
+      ];
+    },
+    useSyncExternalStore: updateSyncExternalStore,
+    useId: updateId,
+    useHostTransitionStatus: useHostTransitionStatus,
+    useFormState: updateActionState,
+    useActionState: updateActionState,
+    useOptimistic: function (passthrough, reducer) {
+      var hook = updateWorkInProgressHook();
+      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
+    },
+    useMemoCache: useMemoCache,
+    useCacheRefresh: updateRefresh
+  };
+HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
+var HooksDispatcherOnRerender = {
+  readContext: readContext,
+  use: use,
+  useCallback: updateCallback,
+  useContext: readContext,
+  useEffect: updateEffect,
+  useImperativeHandle: updateImperativeHandle,
+  useInsertionEffect: updateInsertionEffect,
+  useLayoutEffect: updateLayoutEffect,
+  useMemo: updateMemo,
+  useReducer: rerenderReducer,
+  useRef: updateRef,
+  useState: function () {
+    return rerenderReducer(basicStateReducer);
+  },
+  useDebugValue: mountDebugValue,
+  useDeferredValue: function (value, initialValue) {
+    var hook = updateWorkInProgressHook();
+    return null === currentHook
+      ? mountDeferredValueImpl(hook, value, initialValue)
+      : updateDeferredValueImpl(
+          hook,
+          currentHook.memoizedState,
+          value,
+          initialValue
+        );
+  },
+  useTransition: function () {
+    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
+      start = updateWorkInProgressHook().memoizedState;
+    return [
+      "boolean" === typeof booleanOrThenable
+        ? booleanOrThenable
+        : useThenable(booleanOrThenable),
+      start
+    ];
+  },
+  useSyncExternalStore: updateSyncExternalStore,
+  useId: updateId,
+  useHostTransitionStatus: useHostTransitionStatus,
+  useFormState: rerenderActionState,
+  useActionState: rerenderActionState,
+  useOptimistic: function (passthrough, reducer) {
+    var hook = updateWorkInProgressHook();
+    if (null !== currentHook)
+      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
+    hook.baseState = passthrough;
+    return [passthrough, hook.queue.dispatch];
+  },
+  useMemoCache: useMemoCache,
+  useCacheRefresh: updateRefresh
+};
+HooksDispatcherOnRerender.useEffectEvent = updateEvent;
+var thenableState = null,
+  thenableIndexCounter = 0;
+function unwrapThenable(thenable) {
+  var index = thenableIndexCounter;
+  thenableIndexCounter += 1;
+  null === thenableState && (thenableState = []);
+  return trackUsedThenable(thenableState, thenable, index);
+}
+function coerceRef(workInProgress, element) {
+  element = element.props.ref;
+  workInProgress.ref = void 0 !== element ? element : null;
+}
+function throwOnInvalidObjectType(returnFiber, newChild) {
+  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
+    throw Error(formatProdErrorMessage(525));
+  returnFiber = Object.prototype.toString.call(newChild);
+  throw Error(
+    formatProdErrorMessage(
+      31,
+      "[object Object]" === returnFiber
+        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
+        : returnFiber
+    )
+  );
+}
+function resolveLazy(lazyType) {
+  var init = lazyType._init;
+  return init(lazyType._payload);
+}
+function createChildReconciler(shouldTrackSideEffects) {
+  function deleteChild(returnFiber, childToDelete) {
+    if (shouldTrackSideEffects) {
+      var deletions = returnFiber.deletions;
+      null === deletions
+        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))
+        : deletions.push(childToDelete);
+    }
+  }
+  function deleteRemainingChildren(returnFiber, currentFirstChild) {
+    if (!shouldTrackSideEffects) return null;
+    for (; null !== currentFirstChild; )
+      deleteChild(returnFiber, currentFirstChild),
+        (currentFirstChild = currentFirstChild.sibling);
+    return null;
+  }
+  function mapRemainingChildren(currentFirstChild) {
+    for (var existingChildren = new Map(); null !== currentFirstChild; )
+      null !== currentFirstChild.key
+        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
+        : existingChildren.set(currentFirstChild.index, currentFirstChild),
+        (currentFirstChild = currentFirstChild.sibling);
+    return existingChildren;
+  }
+  function useFiber(fiber, pendingProps) {
+    fiber = createWorkInProgress(fiber, pendingProps);
+    fiber.index = 0;
+    fiber.sibling = null;
+    return fiber;
+  }
+  function placeChild(newFiber, lastPlacedIndex, newIndex) {
+    newFiber.index = newIndex;
+    if (!shouldTrackSideEffects)
+      return (newFiber.flags |= 1048576), lastPlacedIndex;
+    newIndex = newFiber.alternate;
+    if (null !== newIndex)
+      return (
+        (newIndex = newIndex.index),
+        newIndex < lastPlacedIndex
+          ? ((newFiber.flags |= 67108866), lastPlacedIndex)
+          : newIndex
+      );
+    newFiber.flags |= 67108866;
+    return lastPlacedIndex;
+  }
+  function placeSingleChild(newFiber) {
+    shouldTrackSideEffects &&
+      null === newFiber.alternate &&
+      (newFiber.flags |= 67108866);
+    return newFiber;
+  }
+  function updateTextNode(returnFiber, current, textContent, lanes) {
+    if (null === current || 6 !== current.tag)
+      return (
+        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
+        (current.return = returnFiber),
+        current
+      );
+    current = useFiber(current, textContent);
+    current.return = returnFiber;
+    return current;
+  }
+  function updateElement(returnFiber, current, element, lanes) {
+    var elementType = element.type;
+    if (elementType === REACT_FRAGMENT_TYPE)
+      return updateFragment(
+        returnFiber,
+        current,
+        element.props.children,
+        lanes,
+        element.key
+      );
+    if (
+      null !== current &&
+      (current.elementType === elementType ||
+        ("object" === typeof elementType &&
+          null !== elementType &&
+          elementType.$$typeof === REACT_LAZY_TYPE &&
+          resolveLazy(elementType) === current.type))
+    )
+      return (
+        (current = useFiber(current, element.props)),
+        coerceRef(current, element),
+        (current.return = returnFiber),
+        current
+      );
+    current = createFiberFromTypeAndProps(
+      element.type,
+      element.key,
+      element.props,
+      null,
+      returnFiber.mode,
+      lanes
+    );
+    coerceRef(current, element);
+    current.return = returnFiber;
+    return current;
+  }
+  function updatePortal(returnFiber, current, portal, lanes) {
+    if (
+      null === current ||
+      4 !== current.tag ||
+      current.stateNode.containerInfo !== portal.containerInfo ||
+      current.stateNode.implementation !== portal.implementation
+    )
+      return (
+        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
+        (current.return = returnFiber),
+        current
+      );
+    current = useFiber(current, portal.children || []);
+    current.return = returnFiber;
+    return current;
+  }
+  function updateFragment(returnFiber, current, fragment, lanes, key) {
+    if (null === current || 7 !== current.tag)
+      return (
+        (current = createFiberFromFragment(
+          fragment,
+          returnFiber.mode,
+          lanes,
+          key
+        )),
+        (current.return = returnFiber),
+        current
+      );
+    current = useFiber(current, fragment);
+    current.return = returnFiber;
+    return current;
+  }
+  function createChild(returnFiber, newChild, lanes) {
+    if (
+      ("string" === typeof newChild && "" !== newChild) ||
+      "number" === typeof newChild ||
+      "bigint" === typeof newChild
+    )
+      return (
+        (newChild = createFiberFromText(
+          "" + newChild,
+          returnFiber.mode,
+          lanes
+        )),
+        (newChild.return = returnFiber),
+        newChild
+      );
+    if ("object" === typeof newChild && null !== newChild) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          return (
+            (lanes = createFiberFromTypeAndProps(
+              newChild.type,
+              newChild.key,
+              newChild.props,
+              null,
+              returnFiber.mode,
+              lanes
+            )),
+            coerceRef(lanes, newChild),
+            (lanes.return = returnFiber),
+            lanes
+          );
+        case REACT_PORTAL_TYPE:
+          return (
+            (newChild = createFiberFromPortal(
+              newChild,
+              returnFiber.mode,
+              lanes
+            )),
+            (newChild.return = returnFiber),
+            newChild
+          );
+        case REACT_LAZY_TYPE:
+          var init = newChild._init;
+          newChild = init(newChild._payload);
+          return createChild(returnFiber, newChild, lanes);
+      }
+      if (
+        isArrayImpl(newChild) ||
+        getIteratorFn(newChild) ||
+        "function" === typeof newChild[ASYNC_ITERATOR]
+      )
+        return (
+          (newChild = createFiberFromFragment(
+            newChild,
+            returnFiber.mode,
+            lanes,
+            null
+          )),
+          (newChild.return = returnFiber),
+          newChild
+        );
+      if ("function" === typeof newChild.then)
+        return createChild(returnFiber, unwrapThenable(newChild), lanes);
+      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
+        return createChild(
+          returnFiber,
+          readContextDuringReconciliation(returnFiber, newChild),
+          lanes
+        );
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
+    return null;
+  }
+  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
+    var key = null !== oldFiber ? oldFiber.key : null;
+    if (
+      ("string" === typeof newChild && "" !== newChild) ||
+      "number" === typeof newChild ||
+      "bigint" === typeof newChild
+    )
+      return null !== key
+        ? null
+        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
+    if ("object" === typeof newChild && null !== newChild) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          return newChild.key === key
+            ? updateElement(returnFiber, oldFiber, newChild, lanes)
+            : null;
+        case REACT_PORTAL_TYPE:
+          return newChild.key === key
+            ? updatePortal(returnFiber, oldFiber, newChild, lanes)
+            : null;
+        case REACT_LAZY_TYPE:
+          return (
+            (key = newChild._init),
+            (newChild = key(newChild._payload)),
+            updateSlot(returnFiber, oldFiber, newChild, lanes)
+          );
+      }
+      if (
+        isArrayImpl(newChild) ||
+        getIteratorFn(newChild) ||
+        "function" === typeof newChild[ASYNC_ITERATOR]
+      )
+        return null !== key
+          ? null
+          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
+      if ("function" === typeof newChild.then)
+        return updateSlot(
+          returnFiber,
+          oldFiber,
+          unwrapThenable(newChild),
+          lanes
+        );
+      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
+        return updateSlot(
+          returnFiber,
+          oldFiber,
+          readContextDuringReconciliation(returnFiber, newChild),
+          lanes
+        );
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
+    return null;
+  }
+  function updateFromMap(
+    existingChildren,
+    returnFiber,
+    newIdx,
+    newChild,
+    lanes
+  ) {
+    if (
+      ("string" === typeof newChild && "" !== newChild) ||
+      "number" === typeof newChild ||
+      "bigint" === typeof newChild
+    )
+      return (
+        (existingChildren = existingChildren.get(newIdx) || null),
+        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
+      );
+    if ("object" === typeof newChild && null !== newChild) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          return (
+            (existingChildren =
+              existingChildren.get(
+                null === newChild.key ? newIdx : newChild.key
+              ) || null),
+            updateElement(returnFiber, existingChildren, newChild, lanes)
+          );
+        case REACT_PORTAL_TYPE:
+          return (
+            (existingChildren =
+              existingChildren.get(
+                null === newChild.key ? newIdx : newChild.key
+              ) || null),
+            updatePortal(returnFiber, existingChildren, newChild, lanes)
+          );
+        case REACT_LAZY_TYPE:
+          var init = newChild._init;
+          newChild = init(newChild._payload);
+          return updateFromMap(
+            existingChildren,
+            returnFiber,
+            newIdx,
+            newChild,
+            lanes
+          );
+      }
+      if (
+        isArrayImpl(newChild) ||
+        getIteratorFn(newChild) ||
+        "function" === typeof newChild[ASYNC_ITERATOR]
+      )
+        return (
+          (existingChildren = existingChildren.get(newIdx) || null),
+          updateFragment(returnFiber, existingChildren, newChild, lanes, null)
+        );
+      if ("function" === typeof newChild.then)
+        return updateFromMap(
+          existingChildren,
+          returnFiber,
+          newIdx,
+          unwrapThenable(newChild),
+          lanes
+        );
+      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
+        return updateFromMap(
+          existingChildren,
+          returnFiber,
+          newIdx,
+          readContextDuringReconciliation(returnFiber, newChild),
+          lanes
+        );
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
+    return null;
+  }
+  function reconcileChildrenArray(
+    returnFiber,
+    currentFirstChild,
+    newChildren,
+    lanes
+  ) {
+    for (
+      var resultingFirstChild = null,
+        previousNewFiber = null,
+        oldFiber = currentFirstChild,
+        newIdx = (currentFirstChild = 0),
+        nextOldFiber = null;
+      null !== oldFiber && newIdx < newChildren.length;
+      newIdx++
+    ) {
+      oldFiber.index > newIdx
+        ? ((nextOldFiber = oldFiber), (oldFiber = null))
+        : (nextOldFiber = oldFiber.sibling);
+      var newFiber = updateSlot(
+        returnFiber,
+        oldFiber,
+        newChildren[newIdx],
+        lanes
+      );
+      if (null === newFiber) {
+        null === oldFiber && (oldFiber = nextOldFiber);
+        break;
+      }
+      shouldTrackSideEffects &&
+        oldFiber &&
+        null === newFiber.alternate &&
+        deleteChild(returnFiber, oldFiber);
+      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
+      null === previousNewFiber
+        ? (resultingFirstChild = newFiber)
+        : (previousNewFiber.sibling = newFiber);
+      previousNewFiber = newFiber;
+      oldFiber = nextOldFiber;
+    }
+    if (newIdx === newChildren.length)
+      return (
+        deleteRemainingChildren(returnFiber, oldFiber),
+        isHydrating && pushTreeFork(returnFiber, newIdx),
+        resultingFirstChild
+      );
+    if (null === oldFiber) {
+      for (; newIdx < newChildren.length; newIdx++)
+        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
+          null !== oldFiber &&
+            ((currentFirstChild = placeChild(
+              oldFiber,
+              currentFirstChild,
+              newIdx
+            )),
+            null === previousNewFiber
+              ? (resultingFirstChild = oldFiber)
+              : (previousNewFiber.sibling = oldFiber),
+            (previousNewFiber = oldFiber));
+      isHydrating && pushTreeFork(returnFiber, newIdx);
+      return resultingFirstChild;
+    }
+    for (
+      oldFiber = mapRemainingChildren(oldFiber);
+      newIdx < newChildren.length;
+      newIdx++
+    )
+      (nextOldFiber = updateFromMap(
+        oldFiber,
+        returnFiber,
+        newIdx,
+        newChildren[newIdx],
+        lanes
+      )),
+        null !== nextOldFiber &&
+          (shouldTrackSideEffects &&
+            null !== nextOldFiber.alternate &&
+            oldFiber.delete(
+              null === nextOldFiber.key ? newIdx : nextOldFiber.key
+            ),
+          (currentFirstChild = placeChild(
+            nextOldFiber,
+            currentFirstChild,
+            newIdx
+          )),
+          null === previousNewFiber
+            ? (resultingFirstChild = nextOldFiber)
+            : (previousNewFiber.sibling = nextOldFiber),
+          (previousNewFiber = nextOldFiber));
+    shouldTrackSideEffects &&
+      oldFiber.forEach(function (child) {
+        return deleteChild(returnFiber, child);
+      });
+    isHydrating && pushTreeFork(returnFiber, newIdx);
+    return resultingFirstChild;
+  }
+  function reconcileChildrenAsyncIteratable(
+    returnFiber,
+    currentFirstChild,
+    newChildrenIterable,
+    lanes
+  ) {
+    var newChildren = newChildrenIterable[ASYNC_ITERATOR]();
+    if (null == newChildren) throw Error(formatProdErrorMessage(151));
+    return reconcileChildrenIterator(
+      returnFiber,
+      currentFirstChild,
+      {
+        next: function () {
+          return unwrapThenable(newChildren.next());
+        }
+      },
+      lanes
+    );
+  }
+  function reconcileChildrenIterator(
+    returnFiber,
+    currentFirstChild,
+    newChildren,
+    lanes
+  ) {
+    if (null == newChildren) throw Error(formatProdErrorMessage(151));
+    for (
+      var resultingFirstChild = null,
+        previousNewFiber = null,
+        oldFiber = currentFirstChild,
+        newIdx = (currentFirstChild = 0),
+        nextOldFiber = null,
+        step = newChildren.next();
+      null !== oldFiber && !step.done;
+      newIdx++, step = newChildren.next()
+    ) {
+      oldFiber.index > newIdx
+        ? ((nextOldFiber = oldFiber), (oldFiber = null))
+        : (nextOldFiber = oldFiber.sibling);
+      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
+      if (null === newFiber) {
+        null === oldFiber && (oldFiber = nextOldFiber);
+        break;
+      }
+      shouldTrackSideEffects &&
+        oldFiber &&
+        null === newFiber.alternate &&
+        deleteChild(returnFiber, oldFiber);
+      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
+      null === previousNewFiber
+        ? (resultingFirstChild = newFiber)
+        : (previousNewFiber.sibling = newFiber);
+      previousNewFiber = newFiber;
+      oldFiber = nextOldFiber;
+    }
+    if (step.done)
+      return (
+        deleteRemainingChildren(returnFiber, oldFiber),
+        isHydrating && pushTreeFork(returnFiber, newIdx),
+        resultingFirstChild
+      );
+    if (null === oldFiber) {
+      for (; !step.done; newIdx++, step = newChildren.next())
+        (step = createChild(returnFiber, step.value, lanes)),
+          null !== step &&
+            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
+            null === previousNewFiber
+              ? (resultingFirstChild = step)
+              : (previousNewFiber.sibling = step),
+            (previousNewFiber = step));
+      isHydrating && pushTreeFork(returnFiber, newIdx);
+      return resultingFirstChild;
+    }
+    for (
+      oldFiber = mapRemainingChildren(oldFiber);
+      !step.done;
+      newIdx++, step = newChildren.next()
+    )
+      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
+        null !== step &&
+          (shouldTrackSideEffects &&
+            null !== step.alternate &&
+            oldFiber.delete(null === step.key ? newIdx : step.key),
+          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
+          null === previousNewFiber
+            ? (resultingFirstChild = step)
+            : (previousNewFiber.sibling = step),
+          (previousNewFiber = step));
+    shouldTrackSideEffects &&
+      oldFiber.forEach(function (child) {
+        return deleteChild(returnFiber, child);
+      });
+    isHydrating && pushTreeFork(returnFiber, newIdx);
+    return resultingFirstChild;
+  }
+  function reconcileChildFibersImpl(
+    returnFiber,
+    currentFirstChild,
+    newChild,
+    lanes
+  ) {
+    "object" === typeof newChild &&
+      null !== newChild &&
+      newChild.type === REACT_FRAGMENT_TYPE &&
+      null === newChild.key &&
+      (newChild = newChild.props.children);
+    if ("object" === typeof newChild && null !== newChild) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          a: {
+            for (var key = newChild.key; null !== currentFirstChild; ) {
+              if (currentFirstChild.key === key) {
+                key = newChild.type;
+                if (key === REACT_FRAGMENT_TYPE) {
+                  if (7 === currentFirstChild.tag) {
+                    deleteRemainingChildren(
+                      returnFiber,
+                      currentFirstChild.sibling
+                    );
+                    lanes = useFiber(
+                      currentFirstChild,
+                      newChild.props.children
+                    );
+                    lanes.return = returnFiber;
+                    returnFiber = lanes;
+                    break a;
+                  }
+                } else if (
+                  currentFirstChild.elementType === key ||
+                  ("object" === typeof key &&
+                    null !== key &&
+                    key.$$typeof === REACT_LAZY_TYPE &&
+                    resolveLazy(key) === currentFirstChild.type)
+                ) {
+                  deleteRemainingChildren(
+                    returnFiber,
+                    currentFirstChild.sibling
+                  );
+                  lanes = useFiber(currentFirstChild, newChild.props);
+                  coerceRef(lanes, newChild);
+                  lanes.return = returnFiber;
+                  returnFiber = lanes;
+                  break a;
+                }
+                deleteRemainingChildren(returnFiber, currentFirstChild);
+                break;
+              } else deleteChild(returnFiber, currentFirstChild);
+              currentFirstChild = currentFirstChild.sibling;
+            }
+            newChild.type === REACT_FRAGMENT_TYPE
+              ? ((lanes = createFiberFromFragment(
+                  newChild.props.children,
+                  returnFiber.mode,
+                  lanes,
+                  newChild.key
+                )),
+                (lanes.return = returnFiber),
+                (returnFiber = lanes))
+              : ((lanes = createFiberFromTypeAndProps(
+                  newChild.type,
+                  newChild.key,
+                  newChild.props,
+                  null,
+                  returnFiber.mode,
+                  lanes
+                )),
+                coerceRef(lanes, newChild),
+                (lanes.return = returnFiber),
+                (returnFiber = lanes));
+          }
+          return placeSingleChild(returnFiber);
+        case REACT_PORTAL_TYPE:
+          a: {
+            for (key = newChild.key; null !== currentFirstChild; ) {
+              if (currentFirstChild.key === key)
+                if (
+                  4 === currentFirstChild.tag &&
+                  currentFirstChild.stateNode.containerInfo ===
+                    newChild.containerInfo &&
+                  currentFirstChild.stateNode.implementation ===
+                    newChild.implementation
+                ) {
+                  deleteRemainingChildren(
+                    returnFiber,
+                    currentFirstChild.sibling
+                  );
+                  lanes = useFiber(currentFirstChild, newChild.children || []);
+                  lanes.return = returnFiber;
+                  returnFiber = lanes;
+                  break a;
+                } else {
+                  deleteRemainingChildren(returnFiber, currentFirstChild);
+                  break;
+                }
+              else deleteChild(returnFiber, currentFirstChild);
+              currentFirstChild = currentFirstChild.sibling;
+            }
+            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
+            lanes.return = returnFiber;
+            returnFiber = lanes;
+          }
+          return placeSingleChild(returnFiber);
+        case REACT_LAZY_TYPE:
+          return (
+            (key = newChild._init),
+            (newChild = key(newChild._payload)),
+            reconcileChildFibersImpl(
+              returnFiber,
+              currentFirstChild,
+              newChild,
+              lanes
+            )
+          );
+      }
+      if (isArrayImpl(newChild))
+        return reconcileChildrenArray(
+          returnFiber,
+          currentFirstChild,
+          newChild,
+          lanes
+        );
+      if (getIteratorFn(newChild)) {
+        key = getIteratorFn(newChild);
+        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
+        newChild = key.call(newChild);
+        return reconcileChildrenIterator(
+          returnFiber,
+          currentFirstChild,
+          newChild,
+          lanes
+        );
+      }
+      if ("function" === typeof newChild[ASYNC_ITERATOR])
+        return reconcileChildrenAsyncIteratable(
+          returnFiber,
+          currentFirstChild,
+          newChild,
+          lanes
+        );
+      if ("function" === typeof newChild.then)
+        return reconcileChildFibersImpl(
+          returnFiber,
+          currentFirstChild,
+          unwrapThenable(newChild),
+          lanes
+        );
+      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
+        return reconcileChildFibersImpl(
+          returnFiber,
+          currentFirstChild,
+          readContextDuringReconciliation(returnFiber, newChild),
+          lanes
+        );
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
+    return ("string" === typeof newChild && "" !== newChild) ||
+      "number" === typeof newChild ||
+      "bigint" === typeof newChild
+      ? ((newChild = "" + newChild),
+        null !== currentFirstChild && 6 === currentFirstChild.tag
+          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
+            (lanes = useFiber(currentFirstChild, newChild)),
+            (lanes.return = returnFiber),
+            (returnFiber = lanes))
+          : (deleteRemainingChildren(returnFiber, currentFirstChild),
+            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),
+            (lanes.return = returnFiber),
+            (returnFiber = lanes)),
+        placeSingleChild(returnFiber))
+      : deleteRemainingChildren(returnFiber, currentFirstChild);
+  }
+  return function (returnFiber, currentFirstChild, newChild, lanes) {
+    try {
+      thenableIndexCounter = 0;
+      var firstChildFiber = reconcileChildFibersImpl(
+        returnFiber,
+        currentFirstChild,
+        newChild,
+        lanes
+      );
+      thenableState = null;
+      return firstChildFiber;
+    } catch (x) {
+      if (x === SuspenseException || x === SuspenseActionException) throw x;
+      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
+      fiber.lanes = lanes;
+      fiber.return = returnFiber;
+      return fiber;
+    } finally {
+    }
+  };
+}
+var reconcileChildFibers = createChildReconciler(!0),
+  mountChildFibers = createChildReconciler(!1),
+  suspenseHandlerStackCursor = createCursor(null),
+  shellBoundary = null;
+function pushPrimaryTreeSuspenseHandler(handler) {
+  var current = handler.alternate;
+  push(suspenseStackCursor, suspenseStackCursor.current & 1);
+  push(suspenseHandlerStackCursor, handler);
+  null === shellBoundary &&
+    (null === current || null !== currentTreeHiddenStackCursor.current
+      ? (shellBoundary = handler)
+      : null !== current.memoizedState && (shellBoundary = handler));
+}
+function pushOffscreenSuspenseHandler(fiber) {
+  if (22 === fiber.tag) {
+    if (
+      (push(suspenseStackCursor, suspenseStackCursor.current),
+      push(suspenseHandlerStackCursor, fiber),
+      null === shellBoundary)
+    ) {
+      var current = fiber.alternate;
+      null !== current &&
+        null !== current.memoizedState &&
+        (shellBoundary = fiber);
+    }
+  } else reuseSuspenseHandlerOnStack(fiber);
+}
+function reuseSuspenseHandlerOnStack() {
+  push(suspenseStackCursor, suspenseStackCursor.current);
+  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
+}
+function popSuspenseHandler(fiber) {
+  pop(suspenseHandlerStackCursor);
+  shellBoundary === fiber && (shellBoundary = null);
+  pop(suspenseStackCursor);
+}
+var suspenseStackCursor = createCursor(0);
+function findFirstSuspended(row) {
+  for (var node = row; null !== node; ) {
+    if (13 === node.tag) {
+      var state = node.memoizedState;
+      if (
+        null !== state &&
+        ((state = state.dehydrated),
+        null === state ||
+          "$?" === state.data ||
+          isSuspenseInstanceFallback(state))
+      )
+        return node;
+    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
+      if (0 !== (node.flags & 128)) return node;
+    } else if (null !== node.child) {
+      node.child.return = node;
+      node = node.child;
+      continue;
+    }
+    if (node === row) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === row) return null;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
+  }
+  return null;
+}
+var reportGlobalError =
+  "function" === typeof reportError
+    ? reportError
+    : function (error) {
+        if (
+          "object" === typeof window &&
+          "function" === typeof window.ErrorEvent
+        ) {
+          var event = new window.ErrorEvent("error", {
+            bubbles: !0,
+            cancelable: !0,
+            message:
+              "object" === typeof error &&
+              null !== error &&
+              "string" === typeof error.message
+                ? String(error.message)
+                : String(error),
+            error: error
+          });
+          if (!window.dispatchEvent(event)) return;
+        } else if (
+          "object" === typeof process &&
+          "function" === typeof process.emit
+        ) {
+          process.emit("uncaughtException", error);
+          return;
+        }
+        console.error(error);
+      };
+function defaultOnUncaughtError(error) {
+  reportGlobalError(error);
+}
+function defaultOnCaughtError(error) {
+  console.error(error);
+}
+function defaultOnRecoverableError(error) {
+  reportGlobalError(error);
+}
+function logUncaughtError(root, errorInfo) {
+  try {
+    var onUncaughtError = root.onUncaughtError;
+    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
+  } catch (e$75) {
+    setTimeout(function () {
+      throw e$75;
+    });
+  }
+}
+function logCaughtError(root, boundary, errorInfo) {
+  try {
+    var onCaughtError = root.onCaughtError;
+    onCaughtError(errorInfo.value, {
+      componentStack: errorInfo.stack,
+      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
+    });
+  } catch (e$76) {
+    setTimeout(function () {
+      throw e$76;
+    });
+  }
+}
+function createRootErrorUpdate(root, errorInfo, lane) {
+  lane = createUpdate(lane);
+  lane.tag = 3;
+  lane.payload = { element: null };
+  lane.callback = function () {
+    logUncaughtError(root, errorInfo);
+  };
+  return lane;
+}
+function createClassErrorUpdate(lane) {
+  lane = createUpdate(lane);
+  lane.tag = 3;
+  return lane;
+}
+function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
+  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
+  if ("function" === typeof getDerivedStateFromError) {
+    var error = errorInfo.value;
+    update.payload = function () {
+      return getDerivedStateFromError(error);
+    };
+    update.callback = function () {
+      logCaughtError(root, fiber, errorInfo);
+    };
+  }
+  var inst = fiber.stateNode;
+  null !== inst &&
+    "function" === typeof inst.componentDidCatch &&
+    (update.callback = function () {
+      logCaughtError(root, fiber, errorInfo);
+      "function" !== typeof getDerivedStateFromError &&
+        (null === legacyErrorBoundariesThatAlreadyFailed
+          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
+          : legacyErrorBoundariesThatAlreadyFailed.add(this));
+      var stack = errorInfo.stack;
+      this.componentDidCatch(errorInfo.value, {
+        componentStack: null !== stack ? stack : ""
+      });
+    });
+}
+function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
+  var currentSourceFiber = sourceFiber.alternate;
+  null !== currentSourceFiber &&
+    propagateParentContextChanges(
+      currentSourceFiber,
+      sourceFiber,
+      rootRenderLanes,
+      !0
+    );
+}
+function markSuspenseBoundaryShouldCapture(
+  suspenseBoundary,
+  returnFiber,
+  sourceFiber,
+  root,
+  rootRenderLanes
+) {
+  suspenseBoundary.flags |= 65536;
+  suspenseBoundary.lanes = rootRenderLanes;
+  return suspenseBoundary;
+}
+function throwException(
+  root,
+  returnFiber,
+  sourceFiber,
+  value,
+  rootRenderLanes
+) {
+  sourceFiber.flags |= 32768;
+  if (
+    null !== value &&
+    "object" === typeof value &&
+    (value.$$typeof === REACT_POSTPONE_TYPE &&
+      (value = { then: function () {} }),
+    "function" === typeof value.then)
+  ) {
+    resetSuspendedComponent(sourceFiber, rootRenderLanes);
+    var suspenseBoundary = suspenseHandlerStackCursor.current;
+    if (null !== suspenseBoundary) {
+      switch (suspenseBoundary.tag) {
+        case 13:
+          return (
+            null === shellBoundary
+              ? renderDidSuspendDelayIfPossible()
+              : null === suspenseBoundary.alternate &&
+                0 === workInProgressRootExitStatus &&
+                (workInProgressRootExitStatus = 3),
+            (suspenseBoundary.flags &= -257),
+            markSuspenseBoundaryShouldCapture(
+              suspenseBoundary,
+              returnFiber,
+              sourceFiber,
+              root,
+              rootRenderLanes
+            ),
+            value === noopSuspenseyCommitThenable
+              ? (suspenseBoundary.flags |= 16384)
+              : ((sourceFiber = suspenseBoundary.updateQueue),
+                null === sourceFiber
+                  ? (suspenseBoundary.updateQueue = new Set([value]))
+                  : sourceFiber.add(value),
+                attachPingListener(root, value, rootRenderLanes)),
+            !1
+          );
+        case 22:
+          return (
+            (suspenseBoundary.flags |= 65536),
+            value === noopSuspenseyCommitThenable
+              ? (suspenseBoundary.flags |= 16384)
+              : ((sourceFiber = suspenseBoundary.updateQueue),
+                null === sourceFiber
+                  ? ((sourceFiber = {
+                      transitions: null,
+                      markerInstances: null,
+                      retryQueue: new Set([value])
+                    }),
+                    (suspenseBoundary.updateQueue = sourceFiber))
+                  : ((returnFiber = sourceFiber.retryQueue),
+                    null === returnFiber
+                      ? (sourceFiber.retryQueue = new Set([value]))
+                      : returnFiber.add(value)),
+                attachPingListener(root, value, rootRenderLanes)),
+            !1
+          );
+      }
+      throw Error(formatProdErrorMessage(435, suspenseBoundary.tag));
+    }
+    attachPingListener(root, value, rootRenderLanes);
+    renderDidSuspendDelayIfPossible();
+    return !1;
+  }
+  if (isHydrating)
+    return (
+      (suspenseBoundary = suspenseHandlerStackCursor.current),
+      null !== suspenseBoundary
+        ? (0 === (suspenseBoundary.flags & 65536) &&
+            (suspenseBoundary.flags |= 256),
+          markSuspenseBoundaryShouldCapture(
+            suspenseBoundary,
+            returnFiber,
+            sourceFiber,
+            root,
+            rootRenderLanes
+          ),
+          value !== HydrationMismatchException &&
+            ((root = Error(formatProdErrorMessage(422), { cause: value })),
+            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
+        : (value !== HydrationMismatchException &&
+            ((returnFiber = Error(formatProdErrorMessage(423), {
+              cause: value
+            })),
+            queueHydrationError(
+              createCapturedValueAtFiber(returnFiber, sourceFiber)
+            )),
+          (root = root.current.alternate),
+          (root.flags |= 65536),
+          (rootRenderLanes &= -rootRenderLanes),
+          (root.lanes |= rootRenderLanes),
+          (sourceFiber = createCapturedValueAtFiber(value, sourceFiber)),
+          (rootRenderLanes = createRootErrorUpdate(
+            root.stateNode,
+            sourceFiber,
+            rootRenderLanes
+          )),
+          enqueueCapturedUpdate(root, rootRenderLanes),
+          4 !== workInProgressRootExitStatus &&
+            (workInProgressRootExitStatus = 2)),
+      !1
+    );
+  suspenseBoundary = Error(formatProdErrorMessage(520), { cause: value });
+  queueConcurrentError(
+    createCapturedValueAtFiber(suspenseBoundary, sourceFiber)
+  );
+  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
+  if (null === returnFiber) return !0;
+  sourceFiber = createCapturedValueAtFiber(value, sourceFiber);
+  do {
+    switch (returnFiber.tag) {
+      case 3:
+        return (
+          (returnFiber.flags |= 65536),
+          (root = rootRenderLanes & -rootRenderLanes),
+          (returnFiber.lanes |= root),
+          (root = createRootErrorUpdate(
+            returnFiber.stateNode,
+            sourceFiber,
+            root
+          )),
+          enqueueCapturedUpdate(returnFiber, root),
+          !1
+        );
+      case 1:
+        if (
+          ((value = returnFiber.type),
+          (suspenseBoundary = returnFiber.stateNode),
+          0 === (returnFiber.flags & 128) &&
+            ("function" === typeof value.getDerivedStateFromError ||
+              (null !== suspenseBoundary &&
+                "function" === typeof suspenseBoundary.componentDidCatch &&
+                (null === legacyErrorBoundariesThatAlreadyFailed ||
+                  !legacyErrorBoundariesThatAlreadyFailed.has(
+                    suspenseBoundary
+                  )))))
+        )
+          return (
+            (returnFiber.flags |= 65536),
+            (rootRenderLanes &= -rootRenderLanes),
+            (returnFiber.lanes |= rootRenderLanes),
+            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
+            initializeClassErrorUpdate(
+              rootRenderLanes,
+              root,
+              returnFiber,
+              sourceFiber
+            ),
+            enqueueCapturedUpdate(returnFiber, rootRenderLanes),
+            !1
+          );
+    }
+    returnFiber = returnFiber.return;
+  } while (null !== returnFiber);
+  return !1;
+}
+var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
+  didReceiveUpdate = !1;
+function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
+  workInProgress.child =
+    null === current
+      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
+      : reconcileChildFibers(
+          workInProgress,
+          current.child,
+          nextChildren,
+          renderLanes
+        );
+}
+function updateForwardRef(
+  current,
+  workInProgress,
+  Component,
+  nextProps,
+  renderLanes
+) {
+  Component = Component.render;
+  var ref = workInProgress.ref;
+  if ("ref" in nextProps) {
+    var propsWithoutRef = {};
+    for (var key in nextProps)
+      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
+  } else propsWithoutRef = nextProps;
+  prepareToReadContext(workInProgress);
+  nextProps = renderWithHooks(
+    current,
+    workInProgress,
+    Component,
+    propsWithoutRef,
+    ref,
+    renderLanes
+  );
+  key = checkDidRenderIdHook();
+  if (null !== current && !didReceiveUpdate)
+    return (
+      bailoutHooks(current, workInProgress, renderLanes),
+      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
+    );
+  isHydrating && key && pushMaterializedTreeId(workInProgress);
+  workInProgress.flags |= 1;
+  reconcileChildren(current, workInProgress, nextProps, renderLanes);
+  return workInProgress.child;
+}
+function updateMemoComponent(
+  current,
+  workInProgress,
+  Component,
+  nextProps,
+  renderLanes
+) {
+  if (null === current) {
+    var type = Component.type;
+    if (
+      "function" === typeof type &&
+      !shouldConstruct(type) &&
+      void 0 === type.defaultProps &&
+      null === Component.compare
+    )
+      return (
+        (workInProgress.tag = 15),
+        (workInProgress.type = type),
+        updateSimpleMemoComponent(
+          current,
+          workInProgress,
+          type,
+          nextProps,
+          renderLanes
+        )
+      );
+    current = createFiberFromTypeAndProps(
+      Component.type,
+      null,
+      nextProps,
+      workInProgress,
+      workInProgress.mode,
+      renderLanes
+    );
+    current.ref = workInProgress.ref;
+    current.return = workInProgress;
+    return (workInProgress.child = current);
+  }
+  type = current.child;
+  if (!checkScheduledUpdateOrContext(current, renderLanes)) {
+    var prevProps = type.memoizedProps;
+    Component = Component.compare;
+    Component = null !== Component ? Component : shallowEqual;
+    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)
+      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
+  }
+  workInProgress.flags |= 1;
+  current = createWorkInProgress(type, nextProps);
+  current.ref = workInProgress.ref;
+  current.return = workInProgress;
+  return (workInProgress.child = current);
+}
+function updateSimpleMemoComponent(
+  current,
+  workInProgress,
+  Component,
+  nextProps,
+  renderLanes
+) {
+  if (null !== current) {
+    var prevProps = current.memoizedProps;
+    if (
+      shallowEqual(prevProps, nextProps) &&
+      current.ref === workInProgress.ref
+    )
+      if (
+        ((didReceiveUpdate = !1),
+        (workInProgress.pendingProps = nextProps = prevProps),
+        checkScheduledUpdateOrContext(current, renderLanes))
+      )
+        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
+      else
+        return (
+          (workInProgress.lanes = current.lanes),
+          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
+        );
+  }
+  return updateFunctionComponent(
+    current,
+    workInProgress,
+    Component,
+    nextProps,
+    renderLanes
+  );
+}
+function updateOffscreenComponent(current, workInProgress, renderLanes) {
+  var nextProps = workInProgress.pendingProps,
+    nextChildren = nextProps.children,
+    nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2),
+    prevState = null !== current ? current.memoizedState : null;
+  markRef(current, workInProgress);
+  if ("hidden" === nextProps.mode || nextIsDetached) {
+    if (0 !== (workInProgress.flags & 128)) {
+      nextProps =
+        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
+      if (null !== current) {
+        nextChildren = workInProgress.child = current.child;
+        for (nextIsDetached = 0; null !== nextChildren; )
+          (nextIsDetached =
+            nextIsDetached | nextChildren.lanes | nextChildren.childLanes),
+            (nextChildren = nextChildren.sibling);
+        workInProgress.childLanes = nextIsDetached & ~nextProps;
+      } else (workInProgress.childLanes = 0), (workInProgress.child = null);
+      return deferHiddenOffscreenComponent(
+        current,
+        workInProgress,
+        nextProps,
+        renderLanes
+      );
+    }
+    if (0 !== (renderLanes & 536870912))
+      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
+        null !== current &&
+          pushTransition(
+            workInProgress,
+            null !== prevState ? prevState.cachePool : null
+          ),
+        null !== prevState
+          ? pushHiddenContext(workInProgress, prevState)
+          : reuseHiddenContextOnStack(),
+        pushOffscreenSuspenseHandler(workInProgress);
+    else
+      return (
+        (workInProgress.lanes = workInProgress.childLanes = 536870912),
+        deferHiddenOffscreenComponent(
+          current,
+          workInProgress,
+          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,
+          renderLanes
+        )
+      );
+  } else
+    null !== prevState
+      ? (pushTransition(workInProgress, prevState.cachePool),
+        pushHiddenContext(workInProgress, prevState),
+        reuseSuspenseHandlerOnStack(workInProgress),
+        (workInProgress.memoizedState = null))
+      : (null !== current && pushTransition(workInProgress, null),
+        reuseHiddenContextOnStack(),
+        reuseSuspenseHandlerOnStack(workInProgress));
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+  return workInProgress.child;
+}
+function deferHiddenOffscreenComponent(
+  current,
+  workInProgress,
+  nextBaseLanes,
+  renderLanes
+) {
+  var JSCompiler_inline_result = peekCacheFromPool();
+  JSCompiler_inline_result =
+    null === JSCompiler_inline_result
+      ? null
+      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
+  workInProgress.memoizedState = {
+    baseLanes: nextBaseLanes,
+    cachePool: JSCompiler_inline_result
+  };
+  null !== current && pushTransition(workInProgress, null);
+  reuseHiddenContextOnStack();
+  pushOffscreenSuspenseHandler(workInProgress);
+  null !== current &&
+    propagateParentContextChanges(current, workInProgress, renderLanes, !0);
+  return null;
+}
+function markRef(current, workInProgress) {
+  var ref = workInProgress.ref;
+  if (null === ref)
+    null !== current &&
+      null !== current.ref &&
+      (workInProgress.flags |= 4194816);
+  else {
+    if ("function" !== typeof ref && "object" !== typeof ref)
+      throw Error(formatProdErrorMessage(284));
+    if (null === current || current.ref !== ref)
+      workInProgress.flags |= 4194816;
+  }
+}
+function updateFunctionComponent(
+  current,
+  workInProgress,
+  Component,
+  nextProps,
+  renderLanes
+) {
+  prepareToReadContext(workInProgress);
+  Component = renderWithHooks(
+    current,
+    workInProgress,
+    Component,
+    nextProps,
+    void 0,
+    renderLanes
+  );
+  nextProps = checkDidRenderIdHook();
+  if (null !== current && !didReceiveUpdate)
+    return (
+      bailoutHooks(current, workInProgress, renderLanes),
+      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
+    );
+  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
+  workInProgress.flags |= 1;
+  reconcileChildren(current, workInProgress, Component, renderLanes);
+  return workInProgress.child;
+}
+function replayFunctionComponent(
+  current,
+  workInProgress,
+  nextProps,
+  Component,
+  secondArg,
+  renderLanes
+) {
+  prepareToReadContext(workInProgress);
+  workInProgress.updateQueue = null;
+  nextProps = renderWithHooksAgain(
+    workInProgress,
+    Component,
+    nextProps,
+    secondArg
+  );
+  finishRenderingHooks(current);
+  Component = checkDidRenderIdHook();
+  if (null !== current && !didReceiveUpdate)
+    return (
+      bailoutHooks(current, workInProgress, renderLanes),
+      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
+    );
+  isHydrating && Component && pushMaterializedTreeId(workInProgress);
+  workInProgress.flags |= 1;
+  reconcileChildren(current, workInProgress, nextProps, renderLanes);
+  return workInProgress.child;
+}
+function updateClassComponent(
+  current,
+  workInProgress,
+  Component,
+  nextProps,
+  renderLanes
+) {
+  prepareToReadContext(workInProgress);
+  if (null === workInProgress.stateNode) {
+    var context = emptyContextObject,
+      contextType = Component.contextType;
+    "object" === typeof contextType &&
+      null !== contextType &&
+      (context = readContext(contextType));
+    context = new Component(nextProps, context);
+    workInProgress.memoizedState =
+      null !== context.state && void 0 !== context.state ? context.state : null;
+    context.updater = classComponentUpdater;
+    workInProgress.stateNode = context;
+    context._reactInternals = workInProgress;
+    context = workInProgress.stateNode;
+    context.props = nextProps;
+    context.state = workInProgress.memoizedState;
+    context.refs = {};
+    initializeUpdateQueue(workInProgress);
+    contextType = Component.contextType;
+    context.context =
+      "object" === typeof contextType && null !== contextType
+        ? readContext(contextType)
+        : emptyContextObject;
+    context.state = workInProgress.memoizedState;
+    contextType = Component.getDerivedStateFromProps;
+    "function" === typeof contextType &&
+      (applyDerivedStateFromProps(
+        workInProgress,
+        Component,
+        contextType,
+        nextProps
+      ),
+      (context.state = workInProgress.memoizedState));
+    "function" === typeof Component.getDerivedStateFromProps ||
+      "function" === typeof context.getSnapshotBeforeUpdate ||
+      ("function" !== typeof context.UNSAFE_componentWillMount &&
+        "function" !== typeof context.componentWillMount) ||
+      ((contextType = context.state),
+      "function" === typeof context.componentWillMount &&
+        context.componentWillMount(),
+      "function" === typeof context.UNSAFE_componentWillMount &&
+        context.UNSAFE_componentWillMount(),
+      contextType !== context.state &&
+        classComponentUpdater.enqueueReplaceState(context, context.state, null),
+      processUpdateQueue(workInProgress, nextProps, context, renderLanes),
+      suspendIfUpdateReadFromEntangledAsyncAction(),
+      (context.state = workInProgress.memoizedState));
+    "function" === typeof context.componentDidMount &&
+      (workInProgress.flags |= 4194308);
+    nextProps = !0;
+  } else if (null === current) {
+    context = workInProgress.stateNode;
+    var unresolvedOldProps = workInProgress.memoizedProps,
+      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
+    context.props = oldProps;
+    var oldContext = context.context,
+      contextType$jscomp$0 = Component.contextType;
+    contextType = emptyContextObject;
+    "object" === typeof contextType$jscomp$0 &&
+      null !== contextType$jscomp$0 &&
+      (contextType = readContext(contextType$jscomp$0));
+    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
+    contextType$jscomp$0 =
+      "function" === typeof getDerivedStateFromProps ||
+      "function" === typeof context.getSnapshotBeforeUpdate;
+    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
+    contextType$jscomp$0 ||
+      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
+        "function" !== typeof context.componentWillReceiveProps) ||
+      ((unresolvedOldProps || oldContext !== contextType) &&
+        callComponentWillReceiveProps(
+          workInProgress,
+          context,
+          nextProps,
+          contextType
+        ));
+    hasForceUpdate = !1;
+    var oldState = workInProgress.memoizedState;
+    context.state = oldState;
+    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
+    suspendIfUpdateReadFromEntangledAsyncAction();
+    oldContext = workInProgress.memoizedState;
+    unresolvedOldProps || oldState !== oldContext || hasForceUpdate
+      ? ("function" === typeof getDerivedStateFromProps &&
+          (applyDerivedStateFromProps(
+            workInProgress,
+            Component,
+            getDerivedStateFromProps,
+            nextProps
+          ),
+          (oldContext = workInProgress.memoizedState)),
+        (oldProps =
+          hasForceUpdate ||
+          checkShouldComponentUpdate(
+            workInProgress,
+            Component,
+            oldProps,
+            nextProps,
+            oldState,
+            oldContext,
+            contextType
+          ))
+          ? (contextType$jscomp$0 ||
+              ("function" !== typeof context.UNSAFE_componentWillMount &&
+                "function" !== typeof context.componentWillMount) ||
+              ("function" === typeof context.componentWillMount &&
+                context.componentWillMount(),
+              "function" === typeof context.UNSAFE_componentWillMount &&
+                context.UNSAFE_componentWillMount()),
+            "function" === typeof context.componentDidMount &&
+              (workInProgress.flags |= 4194308))
+          : ("function" === typeof context.componentDidMount &&
+              (workInProgress.flags |= 4194308),
+            (workInProgress.memoizedProps = nextProps),
+            (workInProgress.memoizedState = oldContext)),
+        (context.props = nextProps),
+        (context.state = oldContext),
+        (context.context = contextType),
+        (nextProps = oldProps))
+      : ("function" === typeof context.componentDidMount &&
+          (workInProgress.flags |= 4194308),
+        (nextProps = !1));
+  } else {
+    context = workInProgress.stateNode;
+    cloneUpdateQueue(current, workInProgress);
+    contextType = workInProgress.memoizedProps;
+    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
+    context.props = contextType$jscomp$0;
+    getDerivedStateFromProps = workInProgress.pendingProps;
+    oldState = context.context;
+    oldContext = Component.contextType;
+    oldProps = emptyContextObject;
+    "object" === typeof oldContext &&
+      null !== oldContext &&
+      (oldProps = readContext(oldContext));
+    unresolvedOldProps = Component.getDerivedStateFromProps;
+    (oldContext =
+      "function" === typeof unresolvedOldProps ||
+      "function" === typeof context.getSnapshotBeforeUpdate) ||
+      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
+        "function" !== typeof context.componentWillReceiveProps) ||
+      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&
+        callComponentWillReceiveProps(
+          workInProgress,
+          context,
+          nextProps,
+          oldProps
+        ));
+    hasForceUpdate = !1;
+    oldState = workInProgress.memoizedState;
+    context.state = oldState;
+    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
+    suspendIfUpdateReadFromEntangledAsyncAction();
+    var newState = workInProgress.memoizedState;
+    contextType !== getDerivedStateFromProps ||
+    oldState !== newState ||
+    hasForceUpdate ||
+    (null !== current &&
+      null !== current.dependencies &&
+      checkIfContextChanged(current.dependencies))
+      ? ("function" === typeof unresolvedOldProps &&
+          (applyDerivedStateFromProps(
+            workInProgress,
+            Component,
+            unresolvedOldProps,
+            nextProps
+          ),
+          (newState = workInProgress.memoizedState)),
+        (contextType$jscomp$0 =
+          hasForceUpdate ||
+          checkShouldComponentUpdate(
+            workInProgress,
+            Component,
+            contextType$jscomp$0,
+            nextProps,
+            oldState,
+            newState,
+            oldProps
+          ) ||
+          (null !== current &&
+            null !== current.dependencies &&
+            checkIfContextChanged(current.dependencies)))
+          ? (oldContext ||
+              ("function" !== typeof context.UNSAFE_componentWillUpdate &&
+                "function" !== typeof context.componentWillUpdate) ||
+              ("function" === typeof context.componentWillUpdate &&
+                context.componentWillUpdate(nextProps, newState, oldProps),
+              "function" === typeof context.UNSAFE_componentWillUpdate &&
+                context.UNSAFE_componentWillUpdate(
+                  nextProps,
+                  newState,
+                  oldProps
+                )),
+            "function" === typeof context.componentDidUpdate &&
+              (workInProgress.flags |= 4),
+            "function" === typeof context.getSnapshotBeforeUpdate &&
+              (workInProgress.flags |= 1024))
+          : ("function" !== typeof context.componentDidUpdate ||
+              (contextType === current.memoizedProps &&
+                oldState === current.memoizedState) ||
+              (workInProgress.flags |= 4),
+            "function" !== typeof context.getSnapshotBeforeUpdate ||
+              (contextType === current.memoizedProps &&
+                oldState === current.memoizedState) ||
+              (workInProgress.flags |= 1024),
+            (workInProgress.memoizedProps = nextProps),
+            (workInProgress.memoizedState = newState)),
+        (context.props = nextProps),
+        (context.state = newState),
+        (context.context = oldProps),
+        (nextProps = contextType$jscomp$0))
+      : ("function" !== typeof context.componentDidUpdate ||
+          (contextType === current.memoizedProps &&
+            oldState === current.memoizedState) ||
+          (workInProgress.flags |= 4),
+        "function" !== typeof context.getSnapshotBeforeUpdate ||
+          (contextType === current.memoizedProps &&
+            oldState === current.memoizedState) ||
+          (workInProgress.flags |= 1024),
+        (nextProps = !1));
+  }
+  context = nextProps;
+  markRef(current, workInProgress);
+  nextProps = 0 !== (workInProgress.flags & 128);
+  context || nextProps
+    ? ((context = workInProgress.stateNode),
+      (Component =
+        nextProps && "function" !== typeof Component.getDerivedStateFromError
+          ? null
+          : context.render()),
+      (workInProgress.flags |= 1),
+      null !== current && nextProps
+        ? ((workInProgress.child = reconcileChildFibers(
+            workInProgress,
+            current.child,
+            null,
+            renderLanes
+          )),
+          (workInProgress.child = reconcileChildFibers(
+            workInProgress,
+            null,
+            Component,
+            renderLanes
+          )))
+        : reconcileChildren(current, workInProgress, Component, renderLanes),
+      (workInProgress.memoizedState = context.state),
+      (current = workInProgress.child))
+    : (current = bailoutOnAlreadyFinishedWork(
+        current,
+        workInProgress,
+        renderLanes
+      ));
+  return current;
+}
+function mountHostRootWithoutHydrating(
+  current,
+  workInProgress,
+  nextChildren,
+  renderLanes
+) {
+  resetHydrationState();
+  workInProgress.flags |= 256;
+  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+  return workInProgress.child;
+}
+var SUSPENDED_MARKER = {
+  dehydrated: null,
+  treeContext: null,
+  retryLane: 0,
+  hydrationErrors: null
+};
+function mountSuspenseOffscreenState(renderLanes) {
+  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
+}
+function getRemainingWorkInPrimaryTree(
+  current,
+  primaryTreeDidDefer,
+  renderLanes
+) {
+  current = null !== current ? current.childLanes & ~renderLanes : 0;
+  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
+  return current;
+}
+function updateSuspenseComponent(current, workInProgress, renderLanes) {
+  var nextProps = workInProgress.pendingProps,
+    showFallback = !1,
+    didSuspend = 0 !== (workInProgress.flags & 128),
+    JSCompiler_temp;
+  (JSCompiler_temp = didSuspend) ||
+    (JSCompiler_temp =
+      null !== current && null === current.memoizedState
+        ? !1
+        : 0 !== (suspenseStackCursor.current & 2));
+  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));
+  JSCompiler_temp = 0 !== (workInProgress.flags & 32);
+  workInProgress.flags &= -33;
+  if (null === current) {
+    if (isHydrating) {
+      showFallback
+        ? pushPrimaryTreeSuspenseHandler(workInProgress)
+        : reuseSuspenseHandlerOnStack(workInProgress);
+      if (isHydrating) {
+        var nextInstance = nextHydratableInstance,
+          JSCompiler_temp$jscomp$0;
+        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {
+          c: {
+            JSCompiler_temp$jscomp$0 = nextInstance;
+            for (
+              nextInstance = rootOrSingletonContext;
+              8 !== JSCompiler_temp$jscomp$0.nodeType;
+
+            ) {
+              if (!nextInstance) {
+                nextInstance = null;
+                break c;
+              }
+              JSCompiler_temp$jscomp$0 = getNextHydratable(
+                JSCompiler_temp$jscomp$0.nextSibling
+              );
+              if (null === JSCompiler_temp$jscomp$0) {
+                nextInstance = null;
+                break c;
+              }
+            }
+            nextInstance = JSCompiler_temp$jscomp$0;
+          }
+          null !== nextInstance
+            ? ((workInProgress.memoizedState = {
+                dehydrated: nextInstance,
+                treeContext:
+                  null !== treeContextProvider
+                    ? { id: treeContextId, overflow: treeContextOverflow }
+                    : null,
+                retryLane: 536870912,
+                hydrationErrors: null
+              }),
+              (JSCompiler_temp$jscomp$0 = createFiberImplClass(
+                18,
+                null,
+                null,
+                0
+              )),
+              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),
+              (JSCompiler_temp$jscomp$0.return = workInProgress),
+              (workInProgress.child = JSCompiler_temp$jscomp$0),
+              (hydrationParentFiber = workInProgress),
+              (nextHydratableInstance = null),
+              (JSCompiler_temp$jscomp$0 = !0))
+            : (JSCompiler_temp$jscomp$0 = !1);
+        }
+        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
+      }
+      nextInstance = workInProgress.memoizedState;
+      if (
+        null !== nextInstance &&
+        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)
+      )
+        return (
+          isSuspenseInstanceFallback(nextInstance)
+            ? (workInProgress.lanes = 32)
+            : (workInProgress.lanes = 536870912),
+          null
+        );
+      popSuspenseHandler(workInProgress);
+    }
+    nextInstance = nextProps.children;
+    JSCompiler_temp$jscomp$0 = nextProps.fallback;
+    if (showFallback)
+      return (
+        reuseSuspenseHandlerOnStack(workInProgress),
+        (nextProps = mountSuspenseFallbackChildren(
+          workInProgress,
+          nextInstance,
+          JSCompiler_temp$jscomp$0,
+          renderLanes
+        )),
+        (showFallback = workInProgress.child),
+        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
+        (showFallback.childLanes = getRemainingWorkInPrimaryTree(
+          current,
+          JSCompiler_temp,
+          renderLanes
+        )),
+        (workInProgress.memoizedState = SUSPENDED_MARKER),
+        nextProps
+      );
+    if ("number" === typeof nextProps.unstable_expectedLoadTime)
+      return (
+        reuseSuspenseHandlerOnStack(workInProgress),
+        (nextProps = mountSuspenseFallbackChildren(
+          workInProgress,
+          nextInstance,
+          JSCompiler_temp$jscomp$0,
+          renderLanes
+        )),
+        (showFallback = workInProgress.child),
+        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
+        (showFallback.childLanes = getRemainingWorkInPrimaryTree(
+          current,
+          JSCompiler_temp,
+          renderLanes
+        )),
+        (workInProgress.memoizedState = SUSPENDED_MARKER),
+        (workInProgress.lanes = 4194304),
+        nextProps
+      );
+    pushPrimaryTreeSuspenseHandler(workInProgress);
+    return mountSuspensePrimaryChildren(workInProgress, nextInstance);
+  }
+  JSCompiler_temp$jscomp$0 = current.memoizedState;
+  if (
+    null !== JSCompiler_temp$jscomp$0 &&
+    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),
+    null !== nextInstance)
+  ) {
+    if (didSuspend)
+      workInProgress.flags & 256
+        ? (pushPrimaryTreeSuspenseHandler(workInProgress),
+          (workInProgress.flags &= -257),
+          (workInProgress = retrySuspenseComponentWithoutHydrating(
+            current,
+            workInProgress,
+            renderLanes
+          )))
+        : null !== workInProgress.memoizedState
+          ? (reuseSuspenseHandlerOnStack(workInProgress),
+            (workInProgress.child = current.child),
+            (workInProgress.flags |= 128),
+            (workInProgress = null))
+          : (reuseSuspenseHandlerOnStack(workInProgress),
+            (showFallback = nextProps.fallback),
+            (nextInstance = workInProgress.mode),
+            (nextProps = mountWorkInProgressOffscreenFiber(
+              { mode: "visible", children: nextProps.children },
+              nextInstance
+            )),
+            (showFallback = createFiberFromFragment(
+              showFallback,
+              nextInstance,
+              renderLanes,
+              null
+            )),
+            (showFallback.flags |= 2),
+            (nextProps.return = workInProgress),
+            (showFallback.return = workInProgress),
+            (nextProps.sibling = showFallback),
+            (workInProgress.child = nextProps),
+            reconcileChildFibers(
+              workInProgress,
+              current.child,
+              null,
+              renderLanes
+            ),
+            (nextProps = workInProgress.child),
+            (nextProps.memoizedState =
+              mountSuspenseOffscreenState(renderLanes)),
+            (nextProps.childLanes = getRemainingWorkInPrimaryTree(
+              current,
+              JSCompiler_temp,
+              renderLanes
+            )),
+            (workInProgress.memoizedState = SUSPENDED_MARKER),
+            (workInProgress = showFallback));
+    else if (
+      (pushPrimaryTreeSuspenseHandler(workInProgress),
+      isSuspenseInstanceFallback(nextInstance))
+    ) {
+      JSCompiler_temp =
+        nextInstance.nextSibling && nextInstance.nextSibling.dataset;
+      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
+      JSCompiler_temp = digest;
+      "POSTPONE" !== JSCompiler_temp &&
+        ((nextProps = Error(formatProdErrorMessage(419))),
+        (nextProps.stack = ""),
+        (nextProps.digest = JSCompiler_temp),
+        queueHydrationError({ value: nextProps, source: null, stack: null }));
+      workInProgress = retrySuspenseComponentWithoutHydrating(
+        current,
+        workInProgress,
+        renderLanes
+      );
+    } else if (
+      (didReceiveUpdate ||
+        propagateParentContextChanges(current, workInProgress, renderLanes, !1),
+      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
+      didReceiveUpdate || JSCompiler_temp)
+    ) {
+      JSCompiler_temp = workInProgressRoot;
+      if (
+        null !== JSCompiler_temp &&
+        ((nextProps = renderLanes & -renderLanes),
+        (nextProps =
+          0 !== (nextProps & 42)
+            ? 1
+            : getBumpedLaneForHydrationByLane(nextProps)),
+        (nextProps =
+          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))
+            ? 0
+            : nextProps),
+        0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)
+      )
+        throw (
+          ((JSCompiler_temp$jscomp$0.retryLane = nextProps),
+          enqueueConcurrentRenderForLane(current, nextProps),
+          scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
+          SelectiveHydrationException)
+        );
+      "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
+      workInProgress = retrySuspenseComponentWithoutHydrating(
+        current,
+        workInProgress,
+        renderLanes
+      );
+    } else
+      "$?" === nextInstance.data
+        ? ((workInProgress.flags |= 192),
+          (workInProgress.child = current.child),
+          (workInProgress = null))
+        : ((current = JSCompiler_temp$jscomp$0.treeContext),
+          (nextHydratableInstance = getNextHydratable(
+            nextInstance.nextSibling
+          )),
+          (hydrationParentFiber = workInProgress),
+          (isHydrating = !0),
+          (hydrationErrors = null),
+          (rootOrSingletonContext = !1),
+          null !== current &&
+            ((idStack[idStackIndex++] = treeContextId),
+            (idStack[idStackIndex++] = treeContextOverflow),
+            (idStack[idStackIndex++] = treeContextProvider),
+            (treeContextId = current.id),
+            (treeContextOverflow = current.overflow),
+            (treeContextProvider = workInProgress)),
+          (workInProgress = mountSuspensePrimaryChildren(
+            workInProgress,
+            nextProps.children
+          )),
+          (workInProgress.flags |= 4096));
+    return workInProgress;
+  }
+  if (showFallback)
+    return (
+      reuseSuspenseHandlerOnStack(workInProgress),
+      (showFallback = nextProps.fallback),
+      (nextInstance = workInProgress.mode),
+      (JSCompiler_temp$jscomp$0 = current.child),
+      (digest = JSCompiler_temp$jscomp$0.sibling),
+      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
+        mode: "hidden",
+        children: nextProps.children
+      })),
+      (nextProps.subtreeFlags =
+        JSCompiler_temp$jscomp$0.subtreeFlags & 65011712),
+      null !== digest
+        ? (showFallback = createWorkInProgress(digest, showFallback))
+        : ((showFallback = createFiberFromFragment(
+            showFallback,
+            nextInstance,
+            renderLanes,
+            null
+          )),
+          (showFallback.flags |= 2)),
+      (showFallback.return = workInProgress),
+      (nextProps.return = workInProgress),
+      (nextProps.sibling = showFallback),
+      (workInProgress.child = nextProps),
+      (nextProps = showFallback),
+      (showFallback = workInProgress.child),
+      (nextInstance = current.child.memoizedState),
+      null === nextInstance
+        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))
+        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),
+          null !== JSCompiler_temp$jscomp$0
+            ? ((digest = CacheContext._currentValue),
+              (JSCompiler_temp$jscomp$0 =
+                JSCompiler_temp$jscomp$0.parent !== digest
+                  ? { parent: digest, pool: digest }
+                  : JSCompiler_temp$jscomp$0))
+            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),
+          (nextInstance = {
+            baseLanes: nextInstance.baseLanes | renderLanes,
+            cachePool: JSCompiler_temp$jscomp$0
+          })),
+      (showFallback.memoizedState = nextInstance),
+      (showFallback.childLanes = getRemainingWorkInPrimaryTree(
+        current,
+        JSCompiler_temp,
+        renderLanes
+      )),
+      (workInProgress.memoizedState = SUSPENDED_MARKER),
+      nextProps
+    );
+  pushPrimaryTreeSuspenseHandler(workInProgress);
+  renderLanes = current.child;
+  current = renderLanes.sibling;
+  renderLanes = createWorkInProgress(renderLanes, {
+    mode: "visible",
+    children: nextProps.children
+  });
+  renderLanes.return = workInProgress;
+  renderLanes.sibling = null;
+  null !== current &&
+    ((JSCompiler_temp = workInProgress.deletions),
+    null === JSCompiler_temp
+      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))
+      : JSCompiler_temp.push(current));
+  workInProgress.child = renderLanes;
+  workInProgress.memoizedState = null;
+  return renderLanes;
+}
+function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
+  primaryChildren = mountWorkInProgressOffscreenFiber(
+    { mode: "visible", children: primaryChildren },
+    workInProgress.mode
+  );
+  primaryChildren.return = workInProgress;
+  return (workInProgress.child = primaryChildren);
+}
+function mountSuspenseFallbackChildren(
+  workInProgress,
+  primaryChildren,
+  fallbackChildren,
+  renderLanes
+) {
+  var mode = workInProgress.mode;
+  primaryChildren = mountWorkInProgressOffscreenFiber(
+    { mode: "hidden", children: primaryChildren },
+    mode
+  );
+  fallbackChildren = createFiberFromFragment(
+    fallbackChildren,
+    mode,
+    renderLanes,
+    null
+  );
+  primaryChildren.return = workInProgress;
+  fallbackChildren.return = workInProgress;
+  primaryChildren.sibling = fallbackChildren;
+  workInProgress.child = primaryChildren;
+  return fallbackChildren;
+}
+function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
+  return createFiberFromOffscreen(offscreenProps, mode, 0, null);
+}
+function retrySuspenseComponentWithoutHydrating(
+  current,
+  workInProgress,
+  renderLanes
+) {
+  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
+  current = mountSuspensePrimaryChildren(
+    workInProgress,
+    workInProgress.pendingProps.children
+  );
+  current.flags |= 2;
+  workInProgress.memoizedState = null;
+  return current;
+}
+function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
+  fiber.lanes |= renderLanes;
+  var alternate = fiber.alternate;
+  null !== alternate && (alternate.lanes |= renderLanes);
+  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
+}
+function initSuspenseListRenderState(
+  workInProgress,
+  isBackwards,
+  tail,
+  lastContentRow,
+  tailMode
+) {
+  var renderState = workInProgress.memoizedState;
+  null === renderState
+    ? (workInProgress.memoizedState = {
+        isBackwards: isBackwards,
+        rendering: null,
+        renderingStartTime: 0,
+        last: lastContentRow,
+        tail: tail,
+        tailMode: tailMode
+      })
+    : ((renderState.isBackwards = isBackwards),
+      (renderState.rendering = null),
+      (renderState.renderingStartTime = 0),
+      (renderState.last = lastContentRow),
+      (renderState.tail = tail),
+      (renderState.tailMode = tailMode));
+}
+function updateSuspenseListComponent(current, workInProgress, renderLanes) {
+  var nextProps = workInProgress.pendingProps,
+    revealOrder = nextProps.revealOrder,
+    tailMode = nextProps.tail;
+  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
+  nextProps = suspenseStackCursor.current;
+  if (0 !== (nextProps & 2))
+    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);
+  else {
+    if (null !== current && 0 !== (current.flags & 128))
+      a: for (current = workInProgress.child; null !== current; ) {
+        if (13 === current.tag)
+          null !== current.memoizedState &&
+            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
+        else if (19 === current.tag)
+          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
+        else if (null !== current.child) {
+          current.child.return = current;
+          current = current.child;
+          continue;
+        }
+        if (current === workInProgress) break a;
+        for (; null === current.sibling; ) {
+          if (null === current.return || current.return === workInProgress)
+            break a;
+          current = current.return;
+        }
+        current.sibling.return = current.return;
+        current = current.sibling;
+      }
+    nextProps &= 1;
+  }
+  push(suspenseStackCursor, nextProps);
+  switch (revealOrder) {
+    case "forwards":
+      renderLanes = workInProgress.child;
+      for (revealOrder = null; null !== renderLanes; )
+        (current = renderLanes.alternate),
+          null !== current &&
+            null === findFirstSuspended(current) &&
+            (revealOrder = renderLanes),
+          (renderLanes = renderLanes.sibling);
+      renderLanes = revealOrder;
+      null === renderLanes
+        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))
+        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
+      initSuspenseListRenderState(
+        workInProgress,
+        !1,
+        revealOrder,
+        renderLanes,
+        tailMode
+      );
+      break;
+    case "backwards":
+      renderLanes = null;
+      revealOrder = workInProgress.child;
+      for (workInProgress.child = null; null !== revealOrder; ) {
+        current = revealOrder.alternate;
+        if (null !== current && null === findFirstSuspended(current)) {
+          workInProgress.child = revealOrder;
+          break;
+        }
+        current = revealOrder.sibling;
+        revealOrder.sibling = renderLanes;
+        renderLanes = revealOrder;
+        revealOrder = current;
+      }
+      initSuspenseListRenderState(
+        workInProgress,
+        !0,
+        renderLanes,
+        null,
+        tailMode
+      );
+      break;
+    case "together":
+      initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
+      break;
+    default:
+      workInProgress.memoizedState = null;
+  }
+  return workInProgress.child;
+}
+function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
+  null !== current && (workInProgress.dependencies = current.dependencies);
+  workInProgressRootSkippedLanes |= workInProgress.lanes;
+  if (0 === (renderLanes & workInProgress.childLanes))
+    if (null !== current) {
+      if (
+        (propagateParentContextChanges(
+          current,
+          workInProgress,
+          renderLanes,
+          !1
+        ),
+        0 === (renderLanes & workInProgress.childLanes))
+      )
+        return null;
+    } else return null;
+  if (null !== current && workInProgress.child !== current.child)
+    throw Error(formatProdErrorMessage(153));
+  if (null !== workInProgress.child) {
+    current = workInProgress.child;
+    renderLanes = createWorkInProgress(current, current.pendingProps);
+    workInProgress.child = renderLanes;
+    for (renderLanes.return = workInProgress; null !== current.sibling; )
+      (current = current.sibling),
+        (renderLanes = renderLanes.sibling =
+          createWorkInProgress(current, current.pendingProps)),
+        (renderLanes.return = workInProgress);
+    renderLanes.sibling = null;
+  }
+  return workInProgress.child;
+}
+function checkScheduledUpdateOrContext(current, renderLanes) {
+  if (0 !== (current.lanes & renderLanes)) return !0;
+  current = current.dependencies;
+  return null !== current && checkIfContextChanged(current) ? !0 : !1;
+}
+function attemptEarlyBailoutIfNoScheduledUpdate(
+  current,
+  workInProgress,
+  renderLanes
+) {
+  switch (workInProgress.tag) {
+    case 3:
+      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
+      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
+      resetHydrationState();
+      break;
+    case 27:
+    case 5:
+      pushHostContext(workInProgress);
+      break;
+    case 4:
+      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
+      break;
+    case 10:
+      pushProvider(
+        workInProgress,
+        workInProgress.type,
+        workInProgress.memoizedProps.value
+      );
+      break;
+    case 13:
+      var state = workInProgress.memoizedState;
+      if (null !== state) {
+        if (null !== state.dehydrated)
+          return (
+            pushPrimaryTreeSuspenseHandler(workInProgress),
+            (workInProgress.flags |= 128),
+            null
+          );
+        if (0 !== (renderLanes & workInProgress.child.childLanes))
+          return updateSuspenseComponent(current, workInProgress, renderLanes);
+        pushPrimaryTreeSuspenseHandler(workInProgress);
+        current = bailoutOnAlreadyFinishedWork(
+          current,
+          workInProgress,
+          renderLanes
+        );
+        return null !== current ? current.sibling : null;
+      }
+      pushPrimaryTreeSuspenseHandler(workInProgress);
+      break;
+    case 19:
+      var didSuspendBefore = 0 !== (current.flags & 128);
+      state = 0 !== (renderLanes & workInProgress.childLanes);
+      state ||
+        (propagateParentContextChanges(
+          current,
+          workInProgress,
+          renderLanes,
+          !1
+        ),
+        (state = 0 !== (renderLanes & workInProgress.childLanes)));
+      if (didSuspendBefore) {
+        if (state)
+          return updateSuspenseListComponent(
+            current,
+            workInProgress,
+            renderLanes
+          );
+        workInProgress.flags |= 128;
+      }
+      didSuspendBefore = workInProgress.memoizedState;
+      null !== didSuspendBefore &&
+        ((didSuspendBefore.rendering = null),
+        (didSuspendBefore.tail = null),
+        (didSuspendBefore.lastEffect = null));
+      push(suspenseStackCursor, suspenseStackCursor.current);
+      if (state) break;
+      else return null;
+    case 22:
+    case 23:
+      return (
+        (workInProgress.lanes = 0),
+        updateOffscreenComponent(current, workInProgress, renderLanes)
+      );
+    case 24:
+      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
+  }
+  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
+}
+function beginWork(current, workInProgress, renderLanes) {
+  if (null !== current)
+    if (current.memoizedProps !== workInProgress.pendingProps)
+      didReceiveUpdate = !0;
+    else {
+      if (
+        !checkScheduledUpdateOrContext(current, renderLanes) &&
+        0 === (workInProgress.flags & 128)
+      )
+        return (
+          (didReceiveUpdate = !1),
+          attemptEarlyBailoutIfNoScheduledUpdate(
+            current,
+            workInProgress,
+            renderLanes
+          )
+        );
+      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
+    }
+  else
+    (didReceiveUpdate = !1),
+      isHydrating &&
+        0 !== (workInProgress.flags & 1048576) &&
+        pushTreeId(workInProgress, treeForkCount, workInProgress.index);
+  workInProgress.lanes = 0;
+  switch (workInProgress.tag) {
+    case 16:
+      a: {
+        current = workInProgress.pendingProps;
+        var lazyComponent = workInProgress.elementType,
+          init = lazyComponent._init;
+        lazyComponent = init(lazyComponent._payload);
+        workInProgress.type = lazyComponent;
+        if ("function" === typeof lazyComponent)
+          shouldConstruct(lazyComponent)
+            ? ((current = resolveClassComponentProps(lazyComponent, current)),
+              (workInProgress.tag = 1),
+              (workInProgress = updateClassComponent(
+                null,
+                workInProgress,
+                lazyComponent,
+                current,
+                renderLanes
+              )))
+            : ((workInProgress.tag = 0),
+              (workInProgress = updateFunctionComponent(
+                null,
+                workInProgress,
+                lazyComponent,
+                current,
+                renderLanes
+              )));
+        else {
+          if (void 0 !== lazyComponent && null !== lazyComponent)
+            if (
+              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)
+            ) {
+              workInProgress.tag = 11;
+              workInProgress = updateForwardRef(
+                null,
+                workInProgress,
+                lazyComponent,
+                current,
+                renderLanes
+              );
+              break a;
+            } else if (init === REACT_MEMO_TYPE) {
+              workInProgress.tag = 14;
+              workInProgress = updateMemoComponent(
+                null,
+                workInProgress,
+                lazyComponent,
+                current,
+                renderLanes
+              );
+              break a;
+            }
+          workInProgress =
+            getComponentNameFromType(lazyComponent) || lazyComponent;
+          throw Error(formatProdErrorMessage(306, workInProgress, ""));
+        }
+      }
+      return workInProgress;
+    case 0:
+      return updateFunctionComponent(
+        current,
+        workInProgress,
+        workInProgress.type,
+        workInProgress.pendingProps,
+        renderLanes
+      );
+    case 1:
+      return (
+        (lazyComponent = workInProgress.type),
+        (init = resolveClassComponentProps(
+          lazyComponent,
+          workInProgress.pendingProps
+        )),
+        updateClassComponent(
+          current,
+          workInProgress,
+          lazyComponent,
+          init,
+          renderLanes
+        )
+      );
+    case 3:
+      a: {
+        pushHostContainer(
+          workInProgress,
+          workInProgress.stateNode.containerInfo
+        );
+        if (null === current) throw Error(formatProdErrorMessage(387));
+        var nextProps = workInProgress.pendingProps;
+        init = workInProgress.memoizedState;
+        lazyComponent = init.element;
+        cloneUpdateQueue(current, workInProgress);
+        processUpdateQueue(workInProgress, nextProps, null, renderLanes);
+        var nextState = workInProgress.memoizedState;
+        nextProps = nextState.cache;
+        pushProvider(workInProgress, CacheContext, nextProps);
+        nextProps !== init.cache &&
+          propagateContextChanges(
+            workInProgress,
+            [CacheContext],
+            renderLanes,
+            !0
+          );
+        suspendIfUpdateReadFromEntangledAsyncAction();
+        nextProps = nextState.element;
+        if (init.isDehydrated)
+          if (
+            ((init = {
+              element: nextProps,
+              isDehydrated: !1,
+              cache: nextState.cache
+            }),
+            (workInProgress.updateQueue.baseState = init),
+            (workInProgress.memoizedState = init),
+            workInProgress.flags & 256)
+          ) {
+            workInProgress = mountHostRootWithoutHydrating(
+              current,
+              workInProgress,
+              nextProps,
+              renderLanes
+            );
+            break a;
+          } else if (nextProps !== lazyComponent) {
+            lazyComponent = createCapturedValueAtFiber(
+              Error(formatProdErrorMessage(424)),
+              workInProgress
+            );
+            queueHydrationError(lazyComponent);
+            workInProgress = mountHostRootWithoutHydrating(
+              current,
+              workInProgress,
+              nextProps,
+              renderLanes
+            );
+            break a;
+          } else
+            for (
+              nextHydratableInstance = getNextHydratable(
+                workInProgress.stateNode.containerInfo.firstChild
+              ),
+                hydrationParentFiber = workInProgress,
+                isHydrating = !0,
+                hydrationErrors = null,
+                rootOrSingletonContext = !0,
+                renderLanes = mountChildFibers(
+                  workInProgress,
+                  null,
+                  nextProps,
+                  renderLanes
+                ),
+                workInProgress.child = renderLanes;
+              renderLanes;
+
+            )
+              (renderLanes.flags = (renderLanes.flags & -3) | 4096),
+                (renderLanes = renderLanes.sibling);
+        else {
+          resetHydrationState();
+          if (nextProps === lazyComponent) {
+            workInProgress = bailoutOnAlreadyFinishedWork(
+              current,
+              workInProgress,
+              renderLanes
+            );
+            break a;
+          }
+          reconcileChildren(current, workInProgress, nextProps, renderLanes);
+        }
+        workInProgress = workInProgress.child;
+      }
+      return workInProgress;
+    case 26:
+      return (
+        markRef(current, workInProgress),
+        null === current
+          ? (renderLanes = getResource(
+              workInProgress.type,
+              null,
+              workInProgress.pendingProps,
+              null
+            ))
+            ? (workInProgress.memoizedState = renderLanes)
+            : isHydrating ||
+              ((renderLanes = workInProgress.type),
+              (current = workInProgress.pendingProps),
+              (lazyComponent = getOwnerDocumentFromRootContainer(
+                rootInstanceStackCursor.current
+              ).createElement(renderLanes)),
+              (lazyComponent[internalInstanceKey] = workInProgress),
+              (lazyComponent[internalPropsKey] = current),
+              setInitialProperties(lazyComponent, renderLanes, current),
+              markNodeAsHoistable(lazyComponent),
+              (workInProgress.stateNode = lazyComponent))
+          : (workInProgress.memoizedState = getResource(
+              workInProgress.type,
+              current.memoizedProps,
+              workInProgress.pendingProps,
+              current.memoizedState
+            )),
+        null
+      );
+    case 27:
+      return (
+        pushHostContext(workInProgress),
+        null === current &&
+          isHydrating &&
+          ((lazyComponent = workInProgress.stateNode =
+            resolveSingletonInstance(
+              workInProgress.type,
+              workInProgress.pendingProps,
+              rootInstanceStackCursor.current
+            )),
+          (hydrationParentFiber = workInProgress),
+          (rootOrSingletonContext = !0),
+          (nextHydratableInstance = getNextHydratable(
+            lazyComponent.firstChild
+          ))),
+        (lazyComponent = workInProgress.pendingProps.children),
+        null !== current || isHydrating
+          ? reconcileChildren(
+              current,
+              workInProgress,
+              lazyComponent,
+              renderLanes
+            )
+          : (workInProgress.child = reconcileChildFibers(
+              workInProgress,
+              null,
+              lazyComponent,
+              renderLanes
+            )),
+        markRef(current, workInProgress),
+        workInProgress.child
+      );
+    case 5:
+      return (
+        null === current &&
+          isHydrating &&
+          ((lazyComponent = nextHydratableInstance),
+          (init = !lazyComponent) ||
+            ((lazyComponent = canHydrateInstance(
+              lazyComponent,
+              workInProgress.type,
+              workInProgress.pendingProps,
+              rootOrSingletonContext
+            )),
+            null !== lazyComponent
+              ? ((workInProgress.stateNode = lazyComponent),
+                (hydrationParentFiber = workInProgress),
+                (nextHydratableInstance = getNextHydratable(
+                  lazyComponent.firstChild
+                )),
+                (rootOrSingletonContext = !1),
+                (lazyComponent = !0))
+              : (lazyComponent = !1),
+            (init = !lazyComponent)),
+          init && throwOnHydrationMismatch(workInProgress)),
+        pushHostContext(workInProgress),
+        (init = workInProgress.type),
+        (nextProps = workInProgress.pendingProps),
+        (nextState = null !== current ? current.memoizedProps : null),
+        (lazyComponent = nextProps.children),
+        shouldSetTextContent(init, nextProps)
+          ? (lazyComponent = null)
+          : null !== nextState &&
+            shouldSetTextContent(init, nextState) &&
+            (workInProgress.flags |= 32),
+        null !== workInProgress.memoizedState &&
+          ((init = renderWithHooks(
+            current,
+            workInProgress,
+            TransitionAwareHostComponent,
+            null,
+            null,
+            renderLanes
+          )),
+          (HostTransitionContext._currentValue = init)),
+        markRef(current, workInProgress),
+        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),
+        workInProgress.child
+      );
+    case 6:
+      return (
+        null === current &&
+          isHydrating &&
+          ((renderLanes = nextHydratableInstance),
+          (current = !renderLanes) ||
+            ((renderLanes = canHydrateTextInstance(
+              renderLanes,
+              workInProgress.pendingProps,
+              rootOrSingletonContext
+            )),
+            null !== renderLanes
+              ? ((workInProgress.stateNode = renderLanes),
+                (hydrationParentFiber = workInProgress),
+                (nextHydratableInstance = null),
+                (renderLanes = !0))
+              : (renderLanes = !1),
+            (current = !renderLanes)),
+          current && throwOnHydrationMismatch(workInProgress)),
+        null
+      );
+    case 13:
+      return updateSuspenseComponent(current, workInProgress, renderLanes);
+    case 4:
+      return (
+        pushHostContainer(
+          workInProgress,
+          workInProgress.stateNode.containerInfo
+        ),
+        (lazyComponent = workInProgress.pendingProps),
+        null === current
+          ? (workInProgress.child = reconcileChildFibers(
+              workInProgress,
+              null,
+              lazyComponent,
+              renderLanes
+            ))
+          : reconcileChildren(
+              current,
+              workInProgress,
+              lazyComponent,
+              renderLanes
+            ),
+        workInProgress.child
+      );
+    case 11:
+      return updateForwardRef(
+        current,
+        workInProgress,
+        workInProgress.type,
+        workInProgress.pendingProps,
+        renderLanes
+      );
+    case 7:
+      return (
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps,
+          renderLanes
+        ),
+        workInProgress.child
+      );
+    case 8:
+      return (
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps.children,
+          renderLanes
+        ),
+        workInProgress.child
+      );
+    case 12:
+      return (
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps.children,
+          renderLanes
+        ),
+        workInProgress.child
+      );
+    case 10:
+      return (
+        (lazyComponent = workInProgress.pendingProps),
+        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),
+        reconcileChildren(
+          current,
+          workInProgress,
+          lazyComponent.children,
+          renderLanes
+        ),
+        workInProgress.child
+      );
+    case 9:
+      return (
+        (init = workInProgress.type._context),
+        (lazyComponent = workInProgress.pendingProps.children),
+        prepareToReadContext(workInProgress),
+        (init = readContext(init)),
+        (lazyComponent = lazyComponent(init)),
+        (workInProgress.flags |= 1),
+        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),
+        workInProgress.child
+      );
+    case 14:
+      return updateMemoComponent(
+        current,
+        workInProgress,
+        workInProgress.type,
+        workInProgress.pendingProps,
+        renderLanes
+      );
+    case 15:
+      return updateSimpleMemoComponent(
+        current,
+        workInProgress,
+        workInProgress.type,
+        workInProgress.pendingProps,
+        renderLanes
+      );
+    case 19:
+      return updateSuspenseListComponent(current, workInProgress, renderLanes);
+    case 22:
+      return updateOffscreenComponent(current, workInProgress, renderLanes);
+    case 24:
+      return (
+        prepareToReadContext(workInProgress),
+        (lazyComponent = readContext(CacheContext)),
+        null === current
+          ? ((init = peekCacheFromPool()),
+            null === init &&
+              ((init = workInProgressRoot),
+              (nextProps = createCache()),
+              (init.pooledCache = nextProps),
+              nextProps.refCount++,
+              null !== nextProps && (init.pooledCacheLanes |= renderLanes),
+              (init = nextProps)),
+            (workInProgress.memoizedState = {
+              parent: lazyComponent,
+              cache: init
+            }),
+            initializeUpdateQueue(workInProgress),
+            pushProvider(workInProgress, CacheContext, init))
+          : (0 !== (current.lanes & renderLanes) &&
+              (cloneUpdateQueue(current, workInProgress),
+              processUpdateQueue(workInProgress, null, null, renderLanes),
+              suspendIfUpdateReadFromEntangledAsyncAction()),
+            (init = current.memoizedState),
+            (nextProps = workInProgress.memoizedState),
+            init.parent !== lazyComponent
+              ? ((init = { parent: lazyComponent, cache: lazyComponent }),
+                (workInProgress.memoizedState = init),
+                0 === workInProgress.lanes &&
+                  (workInProgress.memoizedState =
+                    workInProgress.updateQueue.baseState =
+                      init),
+                pushProvider(workInProgress, CacheContext, lazyComponent))
+              : ((lazyComponent = nextProps.cache),
+                pushProvider(workInProgress, CacheContext, lazyComponent),
+                lazyComponent !== init.cache &&
+                  propagateContextChanges(
+                    workInProgress,
+                    [CacheContext],
+                    renderLanes,
+                    !0
+                  ))),
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps.children,
+          renderLanes
+        ),
+        workInProgress.child
+      );
+    case 30:
+      return (
+        (lazyComponent = workInProgress.pendingProps),
+        (init = workInProgress.stateNode),
+        null != lazyComponent.name && "auto" !== lazyComponent.name
+          ? ((workInProgress.flags |= 2097152),
+            null === current &&
+              trackAppearingViewTransition(init, lazyComponent.name))
+          : null === init.autoName &&
+            ((nextProps = workInProgressRoot.identifierPrefix),
+            isHydrating
+              ? ((nextState = getTreeId()),
+                (nextProps = "\u00ab" + nextProps + "T" + nextState + "\u00bb"))
+              : ((nextState = globalClientIdCounter++),
+                (nextProps =
+                  "\u00ab" +
+                  nextProps +
+                  "t" +
+                  nextState.toString(32) +
+                  "\u00bb")),
+            (init.autoName = nextProps)),
+        null !== current && current.memoizedProps.name !== lazyComponent.name
+          ? (workInProgress.flags |= 4194816)
+          : markRef(current, workInProgress),
+        reconcileChildren(
+          current,
+          workInProgress,
+          lazyComponent.children,
+          renderLanes
+        ),
+        workInProgress.child
+      );
+    case 29:
+      throw workInProgress.pendingProps;
+  }
+  throw Error(formatProdErrorMessage(156, workInProgress.tag));
+}
+function commitHookEffectListMount(flags, finishedWork) {
+  try {
+    var updateQueue = finishedWork.updateQueue,
+      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
+    if (null !== lastEffect) {
+      var firstEffect = lastEffect.next;
+      updateQueue = firstEffect;
+      do {
+        if ((updateQueue.tag & flags) === flags) {
+          lastEffect = void 0;
+          var create = updateQueue.create,
+            inst = updateQueue.inst;
+          lastEffect = create();
+          inst.destroy = lastEffect;
+        }
+        updateQueue = updateQueue.next;
+      } while (updateQueue !== firstEffect);
+    }
+  } catch (error) {
+    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+  }
+}
+function commitHookEffectListUnmount(
+  flags,
+  finishedWork,
+  nearestMountedAncestor$jscomp$0
+) {
+  try {
+    var updateQueue = finishedWork.updateQueue,
+      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
+    if (null !== lastEffect) {
+      var firstEffect = lastEffect.next;
+      updateQueue = firstEffect;
+      do {
+        if ((updateQueue.tag & flags) === flags) {
+          var inst = updateQueue.inst,
+            destroy = inst.destroy;
+          if (void 0 !== destroy) {
+            inst.destroy = void 0;
+            lastEffect = finishedWork;
+            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0;
+            try {
+              destroy();
+            } catch (error) {
+              captureCommitPhaseError(
+                lastEffect,
+                nearestMountedAncestor,
+                error
+              );
+            }
+          }
+        }
+        updateQueue = updateQueue.next;
+      } while (updateQueue !== firstEffect);
+    }
+  } catch (error) {
+    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+  }
+}
+function commitClassCallbacks(finishedWork) {
+  var updateQueue = finishedWork.updateQueue;
+  if (null !== updateQueue) {
+    var instance = finishedWork.stateNode;
+    try {
+      commitCallbacks(updateQueue, instance);
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+  }
+}
+function safelyCallComponentWillUnmount(
+  current,
+  nearestMountedAncestor,
+  instance
+) {
+  instance.props = resolveClassComponentProps(
+    current.type,
+    current.memoizedProps
+  );
+  instance.state = current.memoizedState;
+  try {
+    instance.componentWillUnmount();
+  } catch (error) {
+    captureCommitPhaseError(current, nearestMountedAncestor, error);
+  }
+}
+function safelyAttachRef(current, nearestMountedAncestor) {
+  try {
+    var ref = current.ref;
+    if (null !== ref) {
+      switch (current.tag) {
+        case 26:
+        case 27:
+        case 5:
+          var instanceToUse = current.stateNode;
+          break;
+        case 30:
+          var instance = current.stateNode,
+            name = getViewTransitionName(current.memoizedProps, instance);
+          if (null === instance.ref || instance.ref.name !== name)
+            instance.ref = createViewTransitionInstance(name);
+          instanceToUse = instance.ref;
+          break;
+        default:
+          instanceToUse = current.stateNode;
+      }
+      "function" === typeof ref
+        ? (current.refCleanup = ref(instanceToUse))
+        : (ref.current = instanceToUse);
+    }
+  } catch (error) {
+    captureCommitPhaseError(current, nearestMountedAncestor, error);
+  }
+}
+function safelyDetachRef(current, nearestMountedAncestor) {
+  var ref = current.ref,
+    refCleanup = current.refCleanup;
+  if (null !== ref)
+    if ("function" === typeof refCleanup)
+      try {
+        refCleanup();
+      } catch (error) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error);
+      } finally {
+        (current.refCleanup = null),
+          (current = current.alternate),
+          null != current && (current.refCleanup = null);
+      }
+    else if ("function" === typeof ref)
+      try {
+        ref(null);
+      } catch (error$115) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error$115);
+      }
+    else ref.current = null;
+}
+function commitHostMount(finishedWork) {
+  var type = finishedWork.type,
+    props = finishedWork.memoizedProps,
+    instance = finishedWork.stateNode;
+  try {
+    a: switch (type) {
+      case "button":
+      case "input":
+      case "select":
+      case "textarea":
+        props.autoFocus && instance.focus();
+        break a;
+      case "img":
+        props.src
+          ? (instance.src = props.src)
+          : props.srcSet && (instance.srcset = props.srcSet);
+    }
+  } catch (error) {
+    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+  }
+}
+function commitHostUpdate(finishedWork, newProps, oldProps) {
+  try {
+    var domElement = finishedWork.stateNode;
+    updateProperties(domElement, finishedWork.type, oldProps, newProps);
+    domElement[internalPropsKey] = newProps;
+  } catch (error) {
+    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+  }
+}
+function isHostParent(fiber) {
+  return (
+    5 === fiber.tag ||
+    3 === fiber.tag ||
+    26 === fiber.tag ||
+    27 === fiber.tag ||
+    4 === fiber.tag
+  );
+}
+function getHostSibling(fiber) {
+  a: for (;;) {
+    for (; null === fiber.sibling; ) {
+      if (null === fiber.return || isHostParent(fiber.return)) return null;
+      fiber = fiber.return;
+    }
+    fiber.sibling.return = fiber.return;
+    for (
+      fiber = fiber.sibling;
+      5 !== fiber.tag &&
+      6 !== fiber.tag &&
+      27 !== fiber.tag &&
+      18 !== fiber.tag;
+
+    ) {
+      if (fiber.flags & 2) continue a;
+      if (null === fiber.child || 4 === fiber.tag) continue a;
+      else (fiber.child.return = fiber), (fiber = fiber.child);
+    }
+    if (!(fiber.flags & 2)) return fiber.stateNode;
+  }
+}
+function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
+  var tag = node.tag;
+  if (5 === tag || 6 === tag)
+    (node = node.stateNode),
+      before
+        ? 8 === parent.nodeType
+          ? parent.parentNode.insertBefore(node, before)
+          : parent.insertBefore(node, before)
+        : (8 === parent.nodeType
+            ? ((before = parent.parentNode), before.insertBefore(node, parent))
+            : ((before = parent), before.appendChild(node)),
+          (parent = parent._reactRootContainer),
+          (null !== parent && void 0 !== parent) ||
+            null !== before.onclick ||
+            (before.onclick = noop$1)),
+      (viewTransitionMutationContext = !0);
+  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
+    for (
+      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
+        node = node.sibling;
+      null !== node;
+
+    )
+      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
+        (node = node.sibling);
+}
+function insertOrAppendPlacementNode(node, before, parent) {
+  var tag = node.tag;
+  if (5 === tag || 6 === tag)
+    (node = node.stateNode),
+      before ? parent.insertBefore(node, before) : parent.appendChild(node),
+      (viewTransitionMutationContext = !0);
+  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))
+    for (
+      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
+      null !== node;
+
+    )
+      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
+}
+var offscreenSubtreeIsHidden = !1,
+  offscreenSubtreeWasHidden = !1,
+  needsFormReset = !1,
+  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
+  nextEffect = null,
+  shouldStartViewTransition = !1,
+  viewTransitionContextChanged = !1,
+  viewTransitionCancelableChildren = null;
+function commitBeforeMutationEffects(
+  root,
+  firstChild,
+  committedLanes,
+  appearingViewTransitions
+) {
+  root = root.containerInfo;
+  eventsEnabled = _enabled;
+  root = getActiveElementDeep(root);
+  if (hasSelectionCapabilities(root)) {
+    if ("selectionStart" in root)
+      var JSCompiler_temp = {
+        start: root.selectionStart,
+        end: root.selectionEnd
+      };
+    else
+      a: {
+        JSCompiler_temp =
+          ((JSCompiler_temp = root.ownerDocument) &&
+            JSCompiler_temp.defaultView) ||
+          window;
+        var selection =
+          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
+        if (selection && 0 !== selection.rangeCount) {
+          JSCompiler_temp = selection.anchorNode;
+          var anchorOffset = selection.anchorOffset,
+            focusNode = selection.focusNode;
+          selection = selection.focusOffset;
+          try {
+            JSCompiler_temp.nodeType, focusNode.nodeType;
+          } catch (e$20) {
+            JSCompiler_temp = null;
+            break a;
+          }
+          var length = 0,
+            start = -1,
+            end = -1,
+            indexWithinAnchor = 0,
+            indexWithinFocus = 0,
+            node = root,
+            parentNode = null;
+          b: for (;;) {
+            for (var next; ; ) {
+              node !== JSCompiler_temp ||
+                (0 !== anchorOffset && 3 !== node.nodeType) ||
+                (start = length + anchorOffset);
+              node !== focusNode ||
+                (0 !== selection && 3 !== node.nodeType) ||
+                (end = length + selection);
+              3 === node.nodeType && (length += node.nodeValue.length);
+              if (null === (next = node.firstChild)) break;
+              parentNode = node;
+              node = next;
+            }
+            for (;;) {
+              if (node === root) break b;
+              parentNode === JSCompiler_temp &&
+                ++indexWithinAnchor === anchorOffset &&
+                (start = length);
+              parentNode === focusNode &&
+                ++indexWithinFocus === selection &&
+                (end = length);
+              if (null !== (next = node.nextSibling)) break;
+              node = parentNode;
+              parentNode = node.parentNode;
+            }
+            node = next;
+          }
+          JSCompiler_temp =
+            -1 === start || -1 === end ? null : { start: start, end: end };
+        } else JSCompiler_temp = null;
+      }
+    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
+  } else JSCompiler_temp = null;
+  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
+  shouldStartViewTransition = _enabled = !1;
+  committedLanes = (committedLanes & 335544192) === committedLanes;
+  nextEffect = firstChild;
+  for (firstChild = committedLanes ? 9238 : 1028; null !== nextEffect; ) {
+    root = nextEffect;
+    if (
+      committedLanes &&
+      ((JSCompiler_temp = root.deletions), null !== JSCompiler_temp)
+    )
+      for (
+        anchorOffset = 0;
+        anchorOffset < JSCompiler_temp.length;
+        anchorOffset++
+      )
+        committedLanes &&
+          commitExitViewTransitions(
+            JSCompiler_temp[anchorOffset],
+            appearingViewTransitions
+          );
+    if (null === root.alternate && 0 !== (root.flags & 2))
+      commitBeforeMutationEffects_complete(committedLanes);
+    else {
+      if (22 === root.tag)
+        if (((JSCompiler_temp = root.alternate), null !== root.memoizedState)) {
+          null !== JSCompiler_temp &&
+            null === JSCompiler_temp.memoizedState &&
+            committedLanes &&
+            commitExitViewTransitions(
+              JSCompiler_temp,
+              appearingViewTransitions
+            );
+          commitBeforeMutationEffects_complete(committedLanes);
+          continue;
+        } else if (
+          null !== JSCompiler_temp &&
+          null !== JSCompiler_temp.memoizedState
+        ) {
+          commitBeforeMutationEffects_complete(committedLanes);
+          continue;
+        }
+      JSCompiler_temp = root.child;
+      0 !== (root.subtreeFlags & firstChild) && null !== JSCompiler_temp
+        ? ((JSCompiler_temp.return = root), (nextEffect = JSCompiler_temp))
+        : (committedLanes && commitNestedViewTransitions(root),
+          commitBeforeMutationEffects_complete(committedLanes));
+    }
+  }
+}
+function commitBeforeMutationEffects_complete(
+  isViewTransitionEligible$jscomp$0
+) {
+  for (; null !== nextEffect; ) {
+    var fiber = nextEffect,
+      isViewTransitionEligible = isViewTransitionEligible$jscomp$0,
+      current = fiber.alternate,
+      flags = fiber.flags;
+    switch (fiber.tag) {
+      case 0:
+        if (
+          0 !== (flags & 4) &&
+          ((current = fiber.updateQueue),
+          (current = null !== current ? current.events : null),
+          null !== current)
+        )
+          for (
+            isViewTransitionEligible = 0;
+            isViewTransitionEligible < current.length;
+            isViewTransitionEligible++
+          )
+            (flags = current[isViewTransitionEligible]),
+              (flags.ref.impl = flags.nextImpl);
+        break;
+      case 11:
+      case 15:
+        break;
+      case 1:
+        if (0 !== (flags & 1024) && null !== current) {
+          isViewTransitionEligible = void 0;
+          flags = current.memoizedProps;
+          current = current.memoizedState;
+          var instance = fiber.stateNode;
+          try {
+            var resolvedPrevProps = resolveClassComponentProps(
+              fiber.type,
+              flags,
+              fiber.elementType === fiber.type
+            );
+            isViewTransitionEligible = instance.getSnapshotBeforeUpdate(
+              resolvedPrevProps,
+              current
+            );
+            instance.__reactInternalSnapshotBeforeUpdate =
+              isViewTransitionEligible;
+          } catch (error) {
+            captureCommitPhaseError(fiber, fiber.return, error);
+          }
+        }
+        break;
+      case 3:
+        if (0 !== (flags & 1024))
+          if (
+            ((current = fiber.stateNode.containerInfo),
+            (isViewTransitionEligible = current.nodeType),
+            9 === isViewTransitionEligible)
+          )
+            clearContainerSparingly(current);
+          else if (1 === isViewTransitionEligible)
+            switch (current.nodeName) {
+              case "HEAD":
+              case "HTML":
+              case "BODY":
+                clearContainerSparingly(current);
+                break;
+              default:
+                current.textContent = "";
+            }
+        break;
+      case 5:
+      case 26:
+      case 27:
+      case 6:
+      case 4:
+      case 17:
+        break;
+      case 30:
+        if (
+          isViewTransitionEligible &&
+          null !== current &&
+          0 !== (fiber.subtreeFlags & 8246)
+        )
+          a: {
+            isViewTransitionEligible = getViewTransitionName(
+              current.memoizedProps,
+              current.stateNode
+            );
+            flags = fiber.memoizedProps;
+            instance = getViewTransitionClassName(
+              flags.className,
+              flags.update
+            );
+            if (
+              "none" === instance &&
+              ((instance = getViewTransitionClassName(
+                flags.className,
+                flags.layout
+              )),
+              "none" === instance)
+            )
+              break a;
+            viewTransitionHostInstanceIdx = 0;
+            applyViewTransitionToHostInstances(
+              current.child,
+              isViewTransitionEligible,
+              instance,
+              (current.memoizedState = []),
+              !0
+            );
+          }
+        break;
+      default:
+        if (0 !== (flags & 1024)) throw Error(formatProdErrorMessage(163));
+    }
+    current = fiber.sibling;
+    if (null !== current) {
+      current.return = fiber.return;
+      nextEffect = current;
+      break;
+    }
+    nextEffect = fiber.return;
+  }
+}
+var viewTransitionHostInstanceIdx = 0;
+function applyViewTransitionToHostInstances(
+  child,
+  name,
+  className,
+  collectMeasurements,
+  stopAtNestedViewTransitions
+) {
+  for (var inViewport = !1; null !== child; ) {
+    if (5 === child.tag) {
+      shouldStartViewTransition = !0;
+      var instance = child.stateNode;
+      if (null !== collectMeasurements) {
+        var measurement = measureInstance(instance);
+        collectMeasurements.push(measurement);
+        measurement.view && (inViewport = !0);
+      } else
+        inViewport || (measureInstance(instance).view && (inViewport = !0));
+      measurement = className;
+      instance.style.viewTransitionName =
+        0 === viewTransitionHostInstanceIdx
+          ? name
+          : name + "_" + viewTransitionHostInstanceIdx;
+      null != measurement && (instance.style.viewTransitionClass = measurement);
+      viewTransitionHostInstanceIdx++;
+    } else if (22 !== child.tag || null === child.memoizedState)
+      (30 === child.tag && stopAtNestedViewTransitions) ||
+        (applyViewTransitionToHostInstances(
+          child.child,
+          name,
+          className,
+          collectMeasurements,
+          stopAtNestedViewTransitions
+        ) &&
+          (inViewport = !0));
+    child = child.sibling;
+  }
+  return inViewport;
+}
+function restoreViewTransitionOnHostInstances(
+  child,
+  stopAtNestedViewTransitions
+) {
+  for (; null !== child; ) {
+    if (5 === child.tag)
+      restoreViewTransitionName(child.stateNode, child.memoizedProps);
+    else if (22 !== child.tag || null === child.memoizedState)
+      (30 === child.tag && stopAtNestedViewTransitions) ||
+        restoreViewTransitionOnHostInstances(
+          child.child,
+          stopAtNestedViewTransitions
+        );
+    child = child.sibling;
+  }
+}
+function commitAppearingPairViewTransitions(placement) {
+  if (0 !== (placement.subtreeFlags & 2097152))
+    for (placement = placement.child; null !== placement; ) {
+      if (22 !== placement.tag || null !== placement.memoizedState)
+        if (
+          (commitAppearingPairViewTransitions(placement),
+          30 === placement.tag &&
+            0 !== (placement.flags & 2097152) &&
+            placement.stateNode.paired)
+        ) {
+          var props = placement.memoizedProps;
+          if (null == props.name || "auto" === props.name)
+            throw Error(formatProdErrorMessage(544));
+          var name = props.name;
+          props = getViewTransitionClassName(props.className, props.share);
+          "none" !== props &&
+            ((viewTransitionHostInstanceIdx = 0),
+            applyViewTransitionToHostInstances(
+              placement.child,
+              name,
+              props,
+              null,
+              !1
+            ) || restoreViewTransitionOnHostInstances(placement.child, !1));
+        }
+      placement = placement.sibling;
+    }
+}
+function commitEnterViewTransitions(placement) {
+  if (30 === placement.tag) {
+    var state = placement.stateNode,
+      props = placement.memoizedProps,
+      name = getViewTransitionName(props, state),
+      className = getViewTransitionClassName(
+        props.className,
+        state.paired ? props.share : props.enter
+      );
+    "none" !== className
+      ? ((viewTransitionHostInstanceIdx = 0),
+        applyViewTransitionToHostInstances(
+          placement.child,
+          name,
+          className,
+          null,
+          !1
+        )
+          ? (commitAppearingPairViewTransitions(placement),
+            state.paired ||
+              scheduleViewTransitionEvent(placement, props.onEnter))
+          : restoreViewTransitionOnHostInstances(placement.child, !1))
+      : commitAppearingPairViewTransitions(placement);
+  } else if (0 !== (placement.subtreeFlags & 33554432))
+    for (placement = placement.child; null !== placement; )
+      commitEnterViewTransitions(placement), (placement = placement.sibling);
+  else commitAppearingPairViewTransitions(placement);
+}
+function commitDeletedPairViewTransitions(deletion, appearingViewTransitions) {
+  if (
+    0 !== appearingViewTransitions.size &&
+    0 !== (deletion.subtreeFlags & 2097152)
+  )
+    for (deletion = deletion.child; null !== deletion; ) {
+      if (22 !== deletion.tag || null !== deletion.memoizedState) {
+        if (30 === deletion.tag && 0 !== (deletion.flags & 2097152)) {
+          var props = deletion.memoizedProps,
+            name = props.name;
+          if (null != name && "auto" !== name) {
+            var pair = appearingViewTransitions.get(name);
+            if (void 0 !== pair) {
+              var className = getViewTransitionClassName(
+                props.className,
+                props.share
+              );
+              "none" !== className &&
+                ((viewTransitionHostInstanceIdx = 0),
+                applyViewTransitionToHostInstances(
+                  deletion.child,
+                  name,
+                  className,
+                  null,
+                  !1
+                )
+                  ? ((pair.paired = deletion.stateNode),
+                    scheduleViewTransitionEvent(deletion, props.onShare))
+                  : restoreViewTransitionOnHostInstances(deletion.child, !1));
+              appearingViewTransitions.delete(name);
+              if (0 === appearingViewTransitions.size) break;
+            }
+          }
+        }
+        commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+      }
+      deletion = deletion.sibling;
+    }
+}
+function commitExitViewTransitions(deletion, appearingViewTransitions) {
+  if (30 === deletion.tag) {
+    var props = deletion.memoizedProps,
+      name = getViewTransitionName(props, deletion.stateNode),
+      pair =
+        null !== appearingViewTransitions
+          ? appearingViewTransitions.get(name)
+          : void 0,
+      className = getViewTransitionClassName(
+        props.className,
+        void 0 !== pair ? props.share : props.exit
+      );
+    "none" !== className &&
+      ((viewTransitionHostInstanceIdx = 0),
+      applyViewTransitionToHostInstances(
+        deletion.child,
+        name,
+        className,
+        null,
+        !1
+      )
+        ? void 0 !== pair
+          ? ((pair.paired = deletion.stateNode),
+            appearingViewTransitions.delete(name),
+            scheduleViewTransitionEvent(deletion, props.onShare))
+          : scheduleViewTransitionEvent(deletion, props.onExit)
+        : restoreViewTransitionOnHostInstances(deletion.child, !1));
+    null !== appearingViewTransitions &&
+      commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+  } else if (0 !== (deletion.subtreeFlags & 33554432))
+    for (deletion = deletion.child; null !== deletion; )
+      commitExitViewTransitions(deletion, appearingViewTransitions),
+        (deletion = deletion.sibling);
+  else
+    null !== appearingViewTransitions &&
+      commitDeletedPairViewTransitions(deletion, appearingViewTransitions);
+}
+function commitNestedViewTransitions(changedParent) {
+  for (changedParent = changedParent.child; null !== changedParent; ) {
+    if (30 === changedParent.tag) {
+      var props = changedParent.memoizedProps,
+        name = getViewTransitionName(props, changedParent.stateNode);
+      props = getViewTransitionClassName(props.className, props.layout);
+      "none" !== props &&
+        ((viewTransitionHostInstanceIdx = 0),
+        applyViewTransitionToHostInstances(
+          changedParent.child,
+          name,
+          props,
+          (changedParent.memoizedState = []),
+          !1
+        ));
+    } else
+      0 !== (changedParent.subtreeFlags & 33554432) &&
+        commitNestedViewTransitions(changedParent);
+    changedParent = changedParent.sibling;
+  }
+}
+function restorePairedViewTransitions(parent) {
+  if (0 !== (parent.subtreeFlags & 2097152))
+    for (parent = parent.child; null !== parent; ) {
+      if (22 !== parent.tag || null !== parent.memoizedState) {
+        if (30 === parent.tag && 0 !== (parent.flags & 2097152)) {
+          var instance = parent.stateNode;
+          null !== instance.paired &&
+            ((instance.paired = null),
+            restoreViewTransitionOnHostInstances(parent.child, !1));
+        }
+        restorePairedViewTransitions(parent);
+      }
+      parent = parent.sibling;
+    }
+}
+function restoreEnterViewTransitions(placement) {
+  if (30 === placement.tag)
+    (placement.stateNode.paired = null),
+      restoreViewTransitionOnHostInstances(placement.child, !1),
+      restorePairedViewTransitions(placement);
+  else if (0 !== (placement.subtreeFlags & 33554432))
+    for (placement = placement.child; null !== placement; )
+      restoreEnterViewTransitions(placement), (placement = placement.sibling);
+  else restorePairedViewTransitions(placement);
+}
+function restoreExitViewTransitions(deletion) {
+  if (30 === deletion.tag)
+    (deletion.stateNode.paired = null),
+      restoreViewTransitionOnHostInstances(deletion.child, !1),
+      restorePairedViewTransitions(deletion);
+  else if (0 !== (deletion.subtreeFlags & 33554432))
+    for (deletion = deletion.child; null !== deletion; )
+      restoreExitViewTransitions(deletion), (deletion = deletion.sibling);
+  else restorePairedViewTransitions(deletion);
+}
+function restoreNestedViewTransitions(changedParent) {
+  for (changedParent = changedParent.child; null !== changedParent; )
+    30 === changedParent.tag
+      ? ((changedParent.memoizedState = null),
+        restoreViewTransitionOnHostInstances(changedParent.child, !1))
+      : 0 !== (changedParent.subtreeFlags & 33554432) &&
+        restoreNestedViewTransitions(changedParent),
+      (changedParent = changedParent.sibling);
+}
+function cancelViewTransitionHostInstances(
+  currentViewTransition,
+  child,
+  stopAtNestedViewTransitions
+) {
+  for (; null !== child; ) {
+    if (5 === child.tag) {
+      var instance = child.stateNode,
+        oldName = getViewTransitionName(
+          currentViewTransition.memoizedProps,
+          currentViewTransition.stateNode
+        );
+      null === viewTransitionCancelableChildren &&
+        (viewTransitionCancelableChildren = []);
+      viewTransitionCancelableChildren.push(
+        instance,
+        oldName,
+        child.memoizedProps
+      );
+      viewTransitionHostInstanceIdx++;
+    } else if (22 !== child.tag || null === child.memoizedState)
+      (30 === child.tag && stopAtNestedViewTransitions) ||
+        cancelViewTransitionHostInstances(
+          currentViewTransition,
+          child.child,
+          stopAtNestedViewTransitions
+        );
+    child = child.sibling;
+  }
+}
+function measureViewTransitionHostInstances(
+  currentViewTransition,
+  parentViewTransition,
+  child,
+  name,
+  className,
+  previousMeasurements,
+  stopAtNestedViewTransitions
+) {
+  for (var inViewport = !1; null !== child; ) {
+    if (5 === child.tag) {
+      var instance = child.stateNode;
+      if (
+        null !== previousMeasurements &&
+        viewTransitionHostInstanceIdx < previousMeasurements.length
+      ) {
+        var previousMeasurement =
+            previousMeasurements[viewTransitionHostInstanceIdx],
+          nextMeasurement = measureInstance(instance);
+        if (previousMeasurement.view || nextMeasurement.view) inViewport = !0;
+        var JSCompiler_temp;
+        if ((JSCompiler_temp = 0 === (parentViewTransition.flags & 4)))
+          if (nextMeasurement.clip) JSCompiler_temp = !0;
+          else {
+            JSCompiler_temp = previousMeasurement.rect;
+            var newRect = nextMeasurement.rect;
+            JSCompiler_temp =
+              JSCompiler_temp.y !== newRect.y ||
+              JSCompiler_temp.x !== newRect.x ||
+              JSCompiler_temp.height !== newRect.height ||
+              JSCompiler_temp.width !== newRect.width;
+          }
+        JSCompiler_temp && (parentViewTransition.flags |= 4);
+        nextMeasurement.abs
+          ? (nextMeasurement = !previousMeasurement.abs)
+          : ((previousMeasurement = previousMeasurement.rect),
+            (nextMeasurement = nextMeasurement.rect),
+            (nextMeasurement =
+              previousMeasurement.height !== nextMeasurement.height ||
+              previousMeasurement.width !== nextMeasurement.width));
+        nextMeasurement && (parentViewTransition.flags |= 32);
+      } else parentViewTransition.flags |= 32;
+      0 !== (parentViewTransition.flags & 4) &&
+        ((nextMeasurement = instance),
+        (previousMeasurement = className),
+        (nextMeasurement.style.viewTransitionName =
+          0 === viewTransitionHostInstanceIdx
+            ? name
+            : name + "_" + viewTransitionHostInstanceIdx),
+        null != previousMeasurement &&
+          (nextMeasurement.style.viewTransitionClass = previousMeasurement));
+      (inViewport && 0 !== (parentViewTransition.flags & 4)) ||
+        ((nextMeasurement = getViewTransitionName(
+          currentViewTransition.memoizedProps,
+          currentViewTransition.stateNode
+        )),
+        null === viewTransitionCancelableChildren &&
+          (viewTransitionCancelableChildren = []),
+        viewTransitionCancelableChildren.push(
+          instance,
+          nextMeasurement,
+          child.memoizedProps
+        ));
+      viewTransitionHostInstanceIdx++;
+    } else if (22 !== child.tag || null === child.memoizedState)
+      30 === child.tag && stopAtNestedViewTransitions
+        ? (parentViewTransition.flags |= child.flags & 32)
+        : measureViewTransitionHostInstances(
+            currentViewTransition,
+            parentViewTransition,
+            child.child,
+            name,
+            className,
+            previousMeasurements,
+            stopAtNestedViewTransitions
+          ) && (inViewport = !0);
+    child = child.sibling;
+  }
+  return inViewport;
+}
+function measureNestedViewTransitions(changedParent) {
+  for (changedParent = changedParent.child; null !== changedParent; ) {
+    if (30 === changedParent.tag) {
+      var current = changedParent.alternate;
+      if (null !== current) {
+        var props = changedParent.memoizedProps,
+          name = getViewTransitionName(props, changedParent.stateNode),
+          className = getViewTransitionClassName(props.className, props.layout);
+        viewTransitionHostInstanceIdx = 0;
+        current = measureViewTransitionHostInstances(
+          current,
+          changedParent,
+          changedParent.child,
+          name,
+          className,
+          changedParent.memoizedState,
+          !1
+        );
+        0 !== (changedParent.flags & 4) &&
+          current &&
+          scheduleViewTransitionEvent(changedParent, props.onLayout);
+      }
+    } else
+      0 !== (changedParent.subtreeFlags & 33554432) &&
+        measureNestedViewTransitions(changedParent);
+    changedParent = changedParent.sibling;
+  }
+}
+function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
+  var flags = finishedWork.flags;
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 15:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 4 && commitHookEffectListMount(5, finishedWork);
+      break;
+    case 1:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      if (flags & 4)
+        if (((finishedRoot = finishedWork.stateNode), null === current))
+          try {
+            finishedRoot.componentDidMount();
+          } catch (error) {
+            captureCommitPhaseError(finishedWork, finishedWork.return, error);
+          }
+        else {
+          var prevProps = resolveClassComponentProps(
+            finishedWork.type,
+            current.memoizedProps
+          );
+          current = current.memoizedState;
+          try {
+            finishedRoot.componentDidUpdate(
+              prevProps,
+              current,
+              finishedRoot.__reactInternalSnapshotBeforeUpdate
+            );
+          } catch (error$114) {
+            captureCommitPhaseError(
+              finishedWork,
+              finishedWork.return,
+              error$114
+            );
+          }
+        }
+      flags & 64 && commitClassCallbacks(finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+      break;
+    case 3:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {
+        finishedRoot = null;
+        if (null !== finishedWork.child)
+          switch (finishedWork.child.tag) {
+            case 27:
+            case 5:
+              finishedRoot = finishedWork.child.stateNode;
+              break;
+            case 1:
+              finishedRoot = finishedWork.child.stateNode;
+          }
+        try {
+          commitCallbacks(flags, finishedRoot);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      }
+      break;
+    case 26:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+      break;
+    case 27:
+    case 5:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      null === current && flags & 4 && commitHostMount(finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+      break;
+    case 12:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      break;
+    case 13:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
+      flags & 64 &&
+        ((flags = finishedWork.memoizedState),
+        null !== flags &&
+          ((flags = flags.dehydrated),
+          null !== flags &&
+            ((finishedWork = retryDehydratedSuspenseBoundary.bind(
+              null,
+              finishedWork
+            )),
+            registerSuspenseInstanceRetry(flags, finishedWork))));
+      break;
+    case 22:
+      prevProps =
+        null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
+      if (!prevProps) {
+        current =
+          (null !== current && null !== current.memoizedState) ||
+          offscreenSubtreeWasHidden;
+        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
+          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+        offscreenSubtreeIsHidden = prevProps;
+        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden
+          ? recursivelyTraverseReappearLayoutEffects(
+              finishedRoot,
+              finishedWork,
+              0 !== (finishedWork.subtreeFlags & 8772)
+            )
+          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+      }
+      flags & 512 &&
+        ("manual" === finishedWork.memoizedProps.mode
+          ? safelyAttachRef(finishedWork, finishedWork.return)
+          : safelyDetachRef(finishedWork, finishedWork.return));
+      break;
+    case 30:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+      break;
+    default:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+  }
+}
+function detachFiberAfterEffects(fiber) {
+  var alternate = fiber.alternate;
+  null !== alternate &&
+    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
+  fiber.child = null;
+  fiber.deletions = null;
+  fiber.sibling = null;
+  5 === fiber.tag &&
+    ((alternate = fiber.stateNode),
+    null !== alternate && detachDeletedInstance(alternate));
+  fiber.stateNode = null;
+  fiber.return = null;
+  fiber.dependencies = null;
+  fiber.memoizedProps = null;
+  fiber.memoizedState = null;
+  fiber.pendingProps = null;
+  fiber.stateNode = null;
+  fiber.updateQueue = null;
+}
+var hostParent = null,
+  hostParentIsContainer = !1;
+function recursivelyTraverseDeletionEffects(
+  finishedRoot,
+  nearestMountedAncestor,
+  parent
+) {
+  for (parent = parent.child; null !== parent; )
+    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
+      (parent = parent.sibling);
+}
+function commitDeletionEffectsOnFiber(
+  finishedRoot,
+  nearestMountedAncestor,
+  deletedFiber
+) {
+  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
+    try {
+      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
+    } catch (err) {}
+  switch (deletedFiber.tag) {
+    case 26:
+      offscreenSubtreeWasHidden ||
+        safelyDetachRef(deletedFiber, nearestMountedAncestor);
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      deletedFiber.memoizedState
+        ? deletedFiber.memoizedState.count--
+        : deletedFiber.stateNode &&
+          ((deletedFiber = deletedFiber.stateNode),
+          deletedFiber.parentNode.removeChild(deletedFiber));
+      break;
+    case 27:
+      offscreenSubtreeWasHidden ||
+        safelyDetachRef(deletedFiber, nearestMountedAncestor);
+      var prevHostParent = hostParent,
+        prevHostParentIsContainer = hostParentIsContainer;
+      hostParent = deletedFiber.stateNode;
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      deletedFiber = deletedFiber.stateNode;
+      for (
+        nearestMountedAncestor = deletedFiber.attributes;
+        nearestMountedAncestor.length;
+
+      )
+        deletedFiber.removeAttributeNode(nearestMountedAncestor[0]);
+      detachDeletedInstance(deletedFiber);
+      hostParent = prevHostParent;
+      hostParentIsContainer = prevHostParentIsContainer;
+      break;
+    case 5:
+      offscreenSubtreeWasHidden ||
+        safelyDetachRef(deletedFiber, nearestMountedAncestor);
+    case 6:
+      prevHostParentIsContainer = hostParent;
+      var prevHostParentIsContainer$122 = hostParentIsContainer;
+      hostParent = null;
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      hostParent = prevHostParentIsContainer;
+      hostParentIsContainer = prevHostParentIsContainer$122;
+      if (null !== hostParent)
+        if (hostParentIsContainer)
+          try {
+            (finishedRoot = hostParent),
+              (prevHostParent = deletedFiber.stateNode),
+              8 === finishedRoot.nodeType
+                ? finishedRoot.parentNode.removeChild(prevHostParent)
+                : finishedRoot.removeChild(prevHostParent),
+              (viewTransitionMutationContext = !0);
+          } catch (error) {
+            captureCommitPhaseError(
+              deletedFiber,
+              nearestMountedAncestor,
+              error
+            );
+          }
+        else
+          try {
+            hostParent.removeChild(deletedFiber.stateNode),
+              (viewTransitionMutationContext = !0);
+          } catch (error) {
+            captureCommitPhaseError(
+              deletedFiber,
+              nearestMountedAncestor,
+              error
+            );
+          }
+      break;
+    case 18:
+      null !== hostParent &&
+        (hostParentIsContainer
+          ? ((nearestMountedAncestor = hostParent),
+            (deletedFiber = deletedFiber.stateNode),
+            8 === nearestMountedAncestor.nodeType
+              ? clearSuspenseBoundary(
+                  nearestMountedAncestor.parentNode,
+                  deletedFiber
+                )
+              : 1 === nearestMountedAncestor.nodeType &&
+                clearSuspenseBoundary(nearestMountedAncestor, deletedFiber),
+            retryIfBlockedOn(nearestMountedAncestor))
+          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
+      break;
+    case 4:
+      prevHostParent = hostParent;
+      prevHostParentIsContainer = hostParentIsContainer;
+      hostParent = deletedFiber.stateNode.containerInfo;
+      hostParentIsContainer = !0;
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      hostParent = prevHostParent;
+      hostParentIsContainer = prevHostParentIsContainer;
+      break;
+    case 0:
+    case 11:
+    case 14:
+    case 15:
+      offscreenSubtreeWasHidden ||
+        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
+      offscreenSubtreeWasHidden ||
+        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      break;
+    case 1:
+      offscreenSubtreeWasHidden ||
+        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
+        (prevHostParent = deletedFiber.stateNode),
+        "function" === typeof prevHostParent.componentWillUnmount &&
+          safelyCallComponentWillUnmount(
+            deletedFiber,
+            nearestMountedAncestor,
+            prevHostParent
+          ));
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      break;
+    case 21:
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      break;
+    case 22:
+      offscreenSubtreeWasHidden ||
+        safelyDetachRef(deletedFiber, nearestMountedAncestor);
+      offscreenSubtreeWasHidden =
+        (prevHostParent = offscreenSubtreeWasHidden) ||
+        null !== deletedFiber.memoizedState;
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      offscreenSubtreeWasHidden = prevHostParent;
+      break;
+    default:
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+  }
+}
+function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
+  if (
+    null === finishedWork.memoizedState &&
+    ((finishedRoot = finishedWork.alternate),
+    null !== finishedRoot &&
+      ((finishedRoot = finishedRoot.memoizedState),
+      null !== finishedRoot &&
+        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
+  )
+    try {
+      retryIfBlockedOn(finishedRoot);
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+}
+function getRetryCache(finishedWork) {
+  switch (finishedWork.tag) {
+    case 13:
+    case 19:
+      var retryCache = finishedWork.stateNode;
+      null === retryCache &&
+        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
+      return retryCache;
+    case 22:
+      return (
+        (finishedWork = finishedWork.stateNode),
+        (retryCache = finishedWork._retryCache),
+        null === retryCache &&
+          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
+        retryCache
+      );
+    default:
+      throw Error(formatProdErrorMessage(435, finishedWork.tag));
+  }
+}
+function attachSuspenseRetryListeners(finishedWork, wakeables) {
+  var retryCache = getRetryCache(finishedWork);
+  wakeables.forEach(function (wakeable) {
+    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
+    retryCache.has(wakeable) ||
+      (retryCache.add(wakeable), wakeable.then(retry, retry));
+  });
+}
+function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber, lanes) {
+  var deletions = parentFiber.deletions;
+  if (null !== deletions)
+    for (var i = 0; i < deletions.length; i++) {
+      var childToDelete = deletions[i],
+        root = root$jscomp$0,
+        returnFiber = parentFiber,
+        parent = returnFiber;
+      a: for (; null !== parent; ) {
+        switch (parent.tag) {
+          case 27:
+          case 5:
+            hostParent = parent.stateNode;
+            hostParentIsContainer = !1;
+            break a;
+          case 3:
+            hostParent = parent.stateNode.containerInfo;
+            hostParentIsContainer = !0;
+            break a;
+          case 4:
+            hostParent = parent.stateNode.containerInfo;
+            hostParentIsContainer = !0;
+            break a;
+        }
+        parent = parent.return;
+      }
+      if (null === hostParent) throw Error(formatProdErrorMessage(160));
+      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
+      hostParent = null;
+      hostParentIsContainer = !1;
+      root = childToDelete.alternate;
+      null !== root && (root.return = null);
+      childToDelete.return = null;
+    }
+  if (parentFiber.subtreeFlags & 13878)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0, lanes),
+        (parentFiber = parentFiber.sibling);
+}
+var currentHoistableRoot = null;
+function commitMutationEffectsOnFiber(finishedWork, root, lanes) {
+  var current = finishedWork.alternate,
+    flags = finishedWork.flags;
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 14:
+    case 15:
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      flags & 4 &&
+        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
+        commitHookEffectListMount(3, finishedWork),
+        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
+      break;
+    case 1:
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      flags & 512 &&
+        (offscreenSubtreeWasHidden ||
+          null === current ||
+          safelyDetachRef(current, current.return));
+      flags & 64 &&
+        offscreenSubtreeIsHidden &&
+        ((finishedWork = finishedWork.updateQueue),
+        null !== finishedWork &&
+          ((flags = finishedWork.callbacks),
+          null !== flags &&
+            ((current = finishedWork.shared.hiddenCallbacks),
+            (finishedWork.shared.hiddenCallbacks =
+              null === current ? flags : current.concat(flags)))));
+      break;
+    case 26:
+      var hoistableRoot = currentHoistableRoot;
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      flags & 512 &&
+        (offscreenSubtreeWasHidden ||
+          null === current ||
+          safelyDetachRef(current, current.return));
+      if (flags & 4)
+        if (
+          ((root = null !== current ? current.memoizedState : null),
+          (flags = finishedWork.memoizedState),
+          null === current)
+        )
+          if (null === flags)
+            if (null === finishedWork.stateNode) {
+              a: {
+                flags = finishedWork.type;
+                current = finishedWork.memoizedProps;
+                root = hoistableRoot.ownerDocument || hoistableRoot;
+                b: switch (flags) {
+                  case "title":
+                    lanes = root.getElementsByTagName("title")[0];
+                    if (
+                      !lanes ||
+                      lanes[internalHoistableMarker] ||
+                      lanes[internalInstanceKey] ||
+                      "http://www.w3.org/2000/svg" === lanes.namespaceURI ||
+                      lanes.hasAttribute("itemprop")
+                    )
+                      (lanes = root.createElement(flags)),
+                        root.head.insertBefore(
+                          lanes,
+                          root.querySelector("head > title")
+                        );
+                    setInitialProperties(lanes, flags, current);
+                    lanes[internalInstanceKey] = finishedWork;
+                    markNodeAsHoistable(lanes);
+                    flags = lanes;
+                    break a;
+                  case "link":
+                    if (
+                      (hoistableRoot = getHydratableHoistableCache(
+                        "link",
+                        "href",
+                        root
+                      ).get(flags + (current.href || "")))
+                    )
+                      for (var i = 0; i < hoistableRoot.length; i++)
+                        if (
+                          ((lanes = hoistableRoot[i]),
+                          lanes.getAttribute("href") ===
+                            (null == current.href || "" === current.href
+                              ? null
+                              : current.href) &&
+                            lanes.getAttribute("rel") ===
+                              (null == current.rel ? null : current.rel) &&
+                            lanes.getAttribute("title") ===
+                              (null == current.title ? null : current.title) &&
+                            lanes.getAttribute("crossorigin") ===
+                              (null == current.crossOrigin
+                                ? null
+                                : current.crossOrigin))
+                        ) {
+                          hoistableRoot.splice(i, 1);
+                          break b;
+                        }
+                    lanes = root.createElement(flags);
+                    setInitialProperties(lanes, flags, current);
+                    root.head.appendChild(lanes);
+                    break;
+                  case "meta":
+                    if (
+                      (hoistableRoot = getHydratableHoistableCache(
+                        "meta",
+                        "content",
+                        root
+                      ).get(flags + (current.content || "")))
+                    )
+                      for (i = 0; i < hoistableRoot.length; i++)
+                        if (
+                          ((lanes = hoistableRoot[i]),
+                          lanes.getAttribute("content") ===
+                            (null == current.content
+                              ? null
+                              : "" + current.content) &&
+                            lanes.getAttribute("name") ===
+                              (null == current.name ? null : current.name) &&
+                            lanes.getAttribute("property") ===
+                              (null == current.property
+                                ? null
+                                : current.property) &&
+                            lanes.getAttribute("http-equiv") ===
+                              (null == current.httpEquiv
+                                ? null
+                                : current.httpEquiv) &&
+                            lanes.getAttribute("charset") ===
+                              (null == current.charSet
+                                ? null
+                                : current.charSet))
+                        ) {
+                          hoistableRoot.splice(i, 1);
+                          break b;
+                        }
+                    lanes = root.createElement(flags);
+                    setInitialProperties(lanes, flags, current);
+                    root.head.appendChild(lanes);
+                    break;
+                  default:
+                    throw Error(formatProdErrorMessage(468, flags));
+                }
+                lanes[internalInstanceKey] = finishedWork;
+                markNodeAsHoistable(lanes);
+                flags = lanes;
+              }
+              finishedWork.stateNode = flags;
+            } else
+              mountHoistable(
+                hoistableRoot,
+                finishedWork.type,
+                finishedWork.stateNode
+              );
+          else
+            finishedWork.stateNode = acquireResource(
+              hoistableRoot,
+              flags,
+              finishedWork.memoizedProps
+            );
+        else
+          root !== flags
+            ? (null === root
+                ? null !== current.stateNode &&
+                  ((current = current.stateNode),
+                  current.parentNode.removeChild(current))
+                : root.count--,
+              null === flags
+                ? mountHoistable(
+                    hoistableRoot,
+                    finishedWork.type,
+                    finishedWork.stateNode
+                  )
+                : acquireResource(
+                    hoistableRoot,
+                    flags,
+                    finishedWork.memoizedProps
+                  ))
+            : null === flags &&
+              null !== finishedWork.stateNode &&
+              commitHostUpdate(
+                finishedWork,
+                finishedWork.memoizedProps,
+                current.memoizedProps
+              );
+      break;
+    case 27:
+      if (flags & 4 && null === finishedWork.alternate) {
+        hoistableRoot = finishedWork.stateNode;
+        i = finishedWork.memoizedProps;
+        try {
+          for (var node = hoistableRoot.firstChild; node; ) {
+            var nextNode = node.nextSibling,
+              nodeName = node.nodeName;
+            node[internalHoistableMarker] ||
+              "HEAD" === nodeName ||
+              "BODY" === nodeName ||
+              "SCRIPT" === nodeName ||
+              "STYLE" === nodeName ||
+              ("LINK" === nodeName &&
+                "stylesheet" === node.rel.toLowerCase()) ||
+              hoistableRoot.removeChild(node);
+            node = nextNode;
+          }
+          for (
+            var type = finishedWork.type, attributes = hoistableRoot.attributes;
+            attributes.length;
+
+          )
+            hoistableRoot.removeAttributeNode(attributes[0]);
+          setInitialProperties(hoistableRoot, type, i);
+          hoistableRoot[internalInstanceKey] = finishedWork;
+          hoistableRoot[internalPropsKey] = i;
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      }
+    case 5:
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      flags & 512 &&
+        (offscreenSubtreeWasHidden ||
+          null === current ||
+          safelyDetachRef(current, current.return));
+      if (finishedWork.flags & 32) {
+        root = finishedWork.stateNode;
+        try {
+          setTextContent(root, ""), (viewTransitionMutationContext = !0);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      }
+      flags & 4 &&
+        null != finishedWork.stateNode &&
+        ((root = finishedWork.memoizedProps),
+        commitHostUpdate(
+          finishedWork,
+          root,
+          null !== current ? current.memoizedProps : root
+        ));
+      flags & 1024 && (needsFormReset = !0);
+      break;
+    case 6:
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      if (flags & 4) {
+        if (null === finishedWork.stateNode)
+          throw Error(formatProdErrorMessage(162));
+        flags = finishedWork.memoizedProps;
+        current = finishedWork.stateNode;
+        try {
+          (current.nodeValue = flags), (viewTransitionMutationContext = !0);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      }
+      break;
+    case 3:
+      tagCaches = null;
+      hoistableRoot = currentHoistableRoot;
+      currentHoistableRoot = getHoistableRoot(root.containerInfo);
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      currentHoistableRoot = hoistableRoot;
+      commitReconciliationEffects(finishedWork);
+      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
+        try {
+          retryIfBlockedOn(root.containerInfo);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      needsFormReset &&
+        ((needsFormReset = !1), recursivelyResetForms(finishedWork));
+      break;
+    case 4:
+      flags = currentHoistableRoot;
+      currentHoistableRoot = getHoistableRoot(
+        finishedWork.stateNode.containerInfo
+      );
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      currentHoistableRoot = flags;
+      break;
+    case 12:
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      break;
+    case 13:
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      finishedWork.child.flags & 8192 &&
+        (null !== finishedWork.memoizedState) !==
+          (null !== current && null !== current.memoizedState) &&
+        (globalMostRecentFallbackTime = now());
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((finishedWork.updateQueue = null),
+          attachSuspenseRetryListeners(finishedWork, flags)));
+      break;
+    case 22:
+      flags & 512 &&
+        (offscreenSubtreeWasHidden ||
+          null === current ||
+          safelyDetachRef(current, current.return));
+      node = null !== finishedWork.memoizedState;
+      nextNode = null !== current && null !== current.memoizedState;
+      nodeName = offscreenSubtreeIsHidden;
+      type = offscreenSubtreeWasHidden;
+      offscreenSubtreeIsHidden = nodeName || node;
+      offscreenSubtreeWasHidden = type || nextNode;
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      offscreenSubtreeWasHidden = type;
+      offscreenSubtreeIsHidden = nodeName;
+      commitReconciliationEffects(finishedWork);
+      root = finishedWork.stateNode;
+      root._current = finishedWork;
+      root._visibility &= -3;
+      root._visibility |= root._pendingVisibility & 2;
+      if (
+        flags & 8192 &&
+        ((root._visibility = node
+          ? root._visibility & -2
+          : root._visibility | 1),
+        node &&
+          ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
+          null === current ||
+            nextNode ||
+            root ||
+            recursivelyTraverseDisappearLayoutEffects(finishedWork)),
+        null === finishedWork.memoizedProps ||
+          "manual" !== finishedWork.memoizedProps.mode)
+      )
+        a: for (current = null, root = finishedWork; ; ) {
+          if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
+            if (null === current) {
+              lanes = current = root;
+              try {
+                if (((hoistableRoot = lanes.stateNode), node))
+                  (i = hoistableRoot.style),
+                    "function" === typeof i.setProperty
+                      ? i.setProperty("display", "none", "important")
+                      : (i.display = "none");
+                else {
+                  var instance = lanes.stateNode,
+                    styleProp = lanes.memoizedProps.style,
+                    display =
+                      void 0 !== styleProp &&
+                      null !== styleProp &&
+                      styleProp.hasOwnProperty("display")
+                        ? styleProp.display
+                        : null;
+                  instance.style.display =
+                    null == display || "boolean" === typeof display
+                      ? ""
+                      : ("" + display).trim();
+                }
+              } catch (error) {
+                captureCommitPhaseError(lanes, lanes.return, error);
+              }
+            }
+          } else if (6 === root.tag) {
+            if (null === current) {
+              lanes = root;
+              try {
+                lanes.stateNode.nodeValue = node ? "" : lanes.memoizedProps;
+              } catch (error) {
+                captureCommitPhaseError(lanes, lanes.return, error);
+              }
+            }
+          } else if (
+            ((22 !== root.tag && 23 !== root.tag) ||
+              null === root.memoizedState ||
+              root === finishedWork) &&
+            null !== root.child
+          ) {
+            root.child.return = root;
+            root = root.child;
+            continue;
+          }
+          if (root === finishedWork) break a;
+          for (; null === root.sibling; ) {
+            if (null === root.return || root.return === finishedWork) break a;
+            current === root && (current = null);
+            root = root.return;
+          }
+          current === root && (current = null);
+          root.sibling.return = root.return;
+          root = root.sibling;
+        }
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((current = flags.retryQueue),
+          null !== current &&
+            ((flags.retryQueue = null),
+            attachSuspenseRetryListeners(finishedWork, current))));
+      break;
+    case 19:
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((finishedWork.updateQueue = null),
+          attachSuspenseRetryListeners(finishedWork, flags)));
+      break;
+    case 30:
+      flags & 512 &&
+        (offscreenSubtreeWasHidden ||
+          null === current ||
+          safelyDetachRef(current, current.return));
+      flags = viewTransitionMutationContext;
+      viewTransitionMutationContext = !1;
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
+      commitReconciliationEffects(finishedWork);
+      (lanes & 335544192) === lanes &&
+        null !== current &&
+        viewTransitionMutationContext &&
+        (finishedWork.flags |= 4);
+      viewTransitionMutationContext = flags;
+      break;
+    case 21:
+      break;
+    default:
+      recursivelyTraverseMutationEffects(root, finishedWork, lanes),
+        commitReconciliationEffects(finishedWork);
+  }
+}
+function commitReconciliationEffects(finishedWork) {
+  var flags = finishedWork.flags;
+  if (flags & 2) {
+    try {
+      if (27 !== finishedWork.tag) {
+        a: {
+          for (var parent = finishedWork.return; null !== parent; ) {
+            if (isHostParent(parent)) {
+              var JSCompiler_inline_result = parent;
+              break a;
+            }
+            parent = parent.return;
+          }
+          throw Error(formatProdErrorMessage(160));
+        }
+        switch (JSCompiler_inline_result.tag) {
+          case 27:
+            var parent$jscomp$0 = JSCompiler_inline_result.stateNode,
+              before = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
+            break;
+          case 5:
+            var parent$116 = JSCompiler_inline_result.stateNode;
+            JSCompiler_inline_result.flags & 32 &&
+              (setTextContent(parent$116, ""),
+              (JSCompiler_inline_result.flags &= -33));
+            var before$117 = getHostSibling(finishedWork);
+            insertOrAppendPlacementNode(finishedWork, before$117, parent$116);
+            break;
+          case 3:
+          case 4:
+            var parent$118 = JSCompiler_inline_result.stateNode.containerInfo,
+              before$119 = getHostSibling(finishedWork);
+            insertOrAppendPlacementNodeIntoContainer(
+              finishedWork,
+              before$119,
+              parent$118
+            );
+            break;
+          default:
+            throw Error(formatProdErrorMessage(161));
+        }
+      }
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+    finishedWork.flags &= -3;
+  }
+  flags & 4096 && (finishedWork.flags &= -4097);
+}
+function recursivelyResetForms(parentFiber) {
+  if (parentFiber.subtreeFlags & 1024)
+    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+      var fiber = parentFiber;
+      recursivelyResetForms(fiber);
+      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
+      parentFiber = parentFiber.sibling;
+    }
+}
+function recursivelyTraverseAfterMutationEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 9238)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitAfterMutationEffectsOnFiber(parentFiber, root),
+        (parentFiber = parentFiber.sibling);
+  else measureNestedViewTransitions(parentFiber);
+}
+function commitAfterMutationEffectsOnFiber(finishedWork, root) {
+  var current = finishedWork.alternate;
+  if (null === current) commitEnterViewTransitions(finishedWork);
+  else
+    switch (finishedWork.tag) {
+      case 3:
+        viewTransitionContextChanged = !1;
+        viewTransitionCancelableChildren = null;
+        recursivelyTraverseAfterMutationEffects(root, finishedWork);
+        if (!viewTransitionContextChanged) {
+          finishedWork = viewTransitionCancelableChildren;
+          viewTransitionCancelableChildren = null;
+          if (null !== finishedWork)
+            for (var i = 0; i < finishedWork.length; i += 3) {
+              var instance = finishedWork[i],
+                oldName = finishedWork[i + 1];
+              restoreViewTransitionName(instance, finishedWork[i + 2]);
+              instance = instance.ownerDocument.documentElement;
+              null !== instance &&
+                instance.animate(
+                  { opacity: [0, 0], pointerEvents: ["none", "none"] },
+                  {
+                    duration: 0,
+                    fill: "forwards",
+                    pseudoElement: "::view-transition-group(" + oldName + ")"
+                  }
+                );
+            }
+          finishedWork = root.containerInfo;
+          finishedWork =
+            9 === finishedWork.nodeType
+              ? finishedWork.documentElement
+              : finishedWork.ownerDocument.documentElement;
+          null !== finishedWork &&
+            "" === finishedWork.style.viewTransitionName &&
+            ((finishedWork.style.viewTransitionName = "none"),
+            finishedWork.animate(
+              { opacity: [0, 0], pointerEvents: ["none", "none"] },
+              {
+                duration: 0,
+                fill: "forwards",
+                pseudoElement: "::view-transition-group(root)"
+              }
+            ),
+            finishedWork.animate(
+              { width: [0, 0], height: [0, 0] },
+              {
+                duration: 0,
+                fill: "forwards",
+                pseudoElement: "::view-transition"
+              }
+            ));
+        }
+        break;
+      case 5:
+        recursivelyTraverseAfterMutationEffects(root, finishedWork);
+        break;
+      case 22:
+        null === finishedWork.memoizedState &&
+          (null !== current.memoizedState
+            ? commitEnterViewTransitions(finishedWork)
+            : recursivelyTraverseAfterMutationEffects(root, finishedWork));
+        break;
+      case 30:
+        if (0 !== (finishedWork.subtreeFlags & 8246)) {
+          i = 0 !== (finishedWork.flags & 4);
+          oldName = viewTransitionContextChanged;
+          instance = viewTransitionCancelableChildren;
+          viewTransitionContextChanged = !1;
+          viewTransitionCancelableChildren = null;
+          recursivelyTraverseAfterMutationEffects(root, finishedWork);
+          viewTransitionContextChanged && (finishedWork.flags |= 4);
+          a: {
+            root = finishedWork.memoizedProps;
+            var updateClassName = getViewTransitionClassName(
+                root.className,
+                root.update
+              ),
+              layoutClassName = getViewTransitionClassName(
+                root.className,
+                root.update
+              );
+            if ("none" === updateClassName) {
+              if ("none" === layoutClassName) {
+                current = !1;
+                break a;
+              }
+              finishedWork.flags &= -5;
+              updateClassName = layoutClassName;
+            } else if (0 === (finishedWork.flags & 4)) {
+              if ("none" === layoutClassName) {
+                viewTransitionHostInstanceIdx = 0;
+                cancelViewTransitionHostInstances(
+                  current,
+                  finishedWork.child,
+                  !0
+                );
+                current = !1;
+                break a;
+              }
+              updateClassName = layoutClassName;
+            }
+            layoutClassName = getViewTransitionName(
+              root,
+              finishedWork.stateNode
+            );
+            viewTransitionHostInstanceIdx = 0;
+            root = current.memoizedState;
+            current = measureViewTransitionHostInstances(
+              current,
+              finishedWork,
+              finishedWork.child,
+              layoutClassName,
+              updateClassName,
+              root,
+              !0
+            );
+            viewTransitionHostInstanceIdx !==
+              (null === root ? 0 : root.length) && (finishedWork.flags |= 32);
+          }
+          0 !== (finishedWork.flags & 4) && current
+            ? ((current = finishedWork.memoizedProps),
+              scheduleViewTransitionEvent(
+                finishedWork,
+                i || viewTransitionContextChanged
+                  ? current.onUpdate
+                  : current.onLayout
+              ),
+              (viewTransitionCancelableChildren = instance))
+            : null !== instance &&
+              (instance.push.apply(instance, viewTransitionCancelableChildren),
+              (viewTransitionCancelableChildren = instance));
+          viewTransitionContextChanged =
+            0 !== (finishedWork.flags & 32) ? !0 : oldName;
+        }
+        break;
+      default:
+        recursivelyTraverseAfterMutationEffects(root, finishedWork);
+    }
+}
+function recursivelyTraverseLayoutEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 8772)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
+        (parentFiber = parentFiber.sibling);
+}
+function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var finishedWork = parentFiber;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 14:
+      case 15:
+        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 1:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        var instance = finishedWork.stateNode;
+        "function" === typeof instance.componentWillUnmount &&
+          safelyCallComponentWillUnmount(
+            finishedWork,
+            finishedWork.return,
+            instance
+          );
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 26:
+      case 27:
+      case 5:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 22:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        null === finishedWork.memoizedState &&
+          recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 30:
+        safelyDetachRef(finishedWork, finishedWork.return);
+      default:
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+    }
+    parentFiber = parentFiber.sibling;
+  }
+}
+function recursivelyTraverseReappearLayoutEffects(
+  finishedRoot$jscomp$0,
+  parentFiber,
+  includeWorkInProgressEffects
+) {
+  includeWorkInProgressEffects =
+    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var current = parentFiber.alternate,
+      finishedRoot = finishedRoot$jscomp$0,
+      finishedWork = parentFiber,
+      flags = finishedWork.flags;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 15:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        commitHookEffectListMount(4, finishedWork);
+        break;
+      case 1:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        current = finishedWork;
+        finishedRoot = current.stateNode;
+        if ("function" === typeof finishedRoot.componentDidMount)
+          try {
+            finishedRoot.componentDidMount();
+          } catch (error) {
+            captureCommitPhaseError(current, current.return, error);
+          }
+        current = finishedWork;
+        finishedRoot = current.updateQueue;
+        if (null !== finishedRoot) {
+          var instance = current.stateNode;
+          try {
+            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
+            if (null !== hiddenCallbacks)
+              for (
+                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
+                finishedRoot < hiddenCallbacks.length;
+                finishedRoot++
+              )
+                callCallback(hiddenCallbacks[finishedRoot], instance);
+          } catch (error) {
+            captureCommitPhaseError(current, current.return, error);
+          }
+        }
+        includeWorkInProgressEffects &&
+          flags & 64 &&
+          commitClassCallbacks(finishedWork);
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      case 26:
+      case 27:
+      case 5:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        includeWorkInProgressEffects &&
+          null === current &&
+          flags & 4 &&
+          commitHostMount(finishedWork);
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      case 12:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        break;
+      case 13:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        includeWorkInProgressEffects &&
+          flags & 4 &&
+          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
+        break;
+      case 22:
+        null === finishedWork.memoizedState &&
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      case 30:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      default:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+    }
+    parentFiber = parentFiber.sibling;
+  }
+}
+function commitOffscreenPassiveMountEffects(current, finishedWork) {
+  var previousCache = null;
+  null !== current &&
+    null !== current.memoizedState &&
+    null !== current.memoizedState.cachePool &&
+    (previousCache = current.memoizedState.cachePool.pool);
+  current = null;
+  null !== finishedWork.memoizedState &&
+    null !== finishedWork.memoizedState.cachePool &&
+    (current = finishedWork.memoizedState.cachePool.pool);
+  current !== previousCache &&
+    (null != current && current.refCount++,
+    null != previousCache && releaseCache(previousCache));
+}
+function commitCachePassiveMountEffect(current, finishedWork) {
+  current = null;
+  null !== finishedWork.alternate &&
+    (current = finishedWork.alternate.memoizedState.cache);
+  finishedWork = finishedWork.memoizedState.cache;
+  finishedWork !== current &&
+    (finishedWork.refCount++, null != current && releaseCache(current));
+}
+function recursivelyTraversePassiveMountEffects(
+  root,
+  parentFiber,
+  committedLanes,
+  committedTransitions
+) {
+  var isViewTransitionEligible =
+    (committedLanes & 335544192) === committedLanes;
+  if (parentFiber.subtreeFlags & (isViewTransitionEligible ? 10262 : 10256))
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitPassiveMountOnFiber(
+        root,
+        parentFiber,
+        committedLanes,
+        committedTransitions
+      ),
+        (parentFiber = parentFiber.sibling);
+  else isViewTransitionEligible && restoreNestedViewTransitions(parentFiber);
+}
+function commitPassiveMountOnFiber(
+  finishedRoot,
+  finishedWork,
+  committedLanes,
+  committedTransitions
+) {
+  var isViewTransitionEligible =
+    (committedLanes & 335544192) === committedLanes;
+  isViewTransitionEligible &&
+    null === finishedWork.alternate &&
+    null !== finishedWork.return &&
+    null !== finishedWork.return.alternate &&
+    restoreEnterViewTransitions(finishedWork);
+  var flags = finishedWork.flags;
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 15:
+      recursivelyTraversePassiveMountEffects(
+        finishedRoot,
+        finishedWork,
+        committedLanes,
+        committedTransitions
+      );
+      flags & 2048 && commitHookEffectListMount(9, finishedWork);
+      break;
+    case 1:
+      recursivelyTraversePassiveMountEffects(
+        finishedRoot,
+        finishedWork,
+        committedLanes,
+        committedTransitions
+      );
+      break;
+    case 3:
+      recursivelyTraversePassiveMountEffects(
+        finishedRoot,
+        finishedWork,
+        committedLanes,
+        committedTransitions
+      );
+      isViewTransitionEligible &&
+        ((finishedRoot = finishedRoot.containerInfo),
+        (finishedRoot =
+          9 === finishedRoot.nodeType
+            ? finishedRoot.documentElement
+            : finishedRoot.ownerDocument.documentElement),
+        null !== finishedRoot &&
+          "none" === finishedRoot.style.viewTransitionName &&
+          (finishedRoot.style.viewTransitionName = ""));
+      flags & 2048 &&
+        ((flags = null),
+        null !== finishedWork.alternate &&
+          (flags = finishedWork.alternate.memoizedState.cache),
+        (finishedWork = finishedWork.memoizedState.cache),
+        finishedWork !== flags &&
+          (finishedWork.refCount++, null != flags && releaseCache(flags)));
+      break;
+    case 12:
+      if (flags & 2048) {
+        recursivelyTraversePassiveMountEffects(
+          finishedRoot,
+          finishedWork,
+          committedLanes,
+          committedTransitions
+        );
+        flags = finishedWork.stateNode;
+        try {
+          var _finishedWork$memoize2 = finishedWork.memoizedProps,
+            id = _finishedWork$memoize2.id,
+            onPostCommit = _finishedWork$memoize2.onPostCommit;
+          "function" === typeof onPostCommit &&
+            onPostCommit(
+              id,
+              null === finishedWork.alternate ? "mount" : "update",
+              flags.passiveEffectDuration,
+              -0
+            );
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      } else
+        recursivelyTraversePassiveMountEffects(
+          finishedRoot,
+          finishedWork,
+          committedLanes,
+          committedTransitions
+        );
+      break;
+    case 13:
+      recursivelyTraversePassiveMountEffects(
+        finishedRoot,
+        finishedWork,
+        committedLanes,
+        committedTransitions
+      );
+      break;
+    case 23:
+      break;
+    case 22:
+      _finishedWork$memoize2 = finishedWork.stateNode;
+      id = finishedWork.alternate;
+      null !== finishedWork.memoizedState
+        ? (isViewTransitionEligible &&
+            null !== id &&
+            null === id.memoizedState &&
+            restoreExitViewTransitions(id),
+          _finishedWork$memoize2._visibility & 4
+            ? recursivelyTraversePassiveMountEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions
+              )
+            : recursivelyTraverseAtomicPassiveEffects(
+                finishedRoot,
+                finishedWork
+              ))
+        : (isViewTransitionEligible &&
+            null !== id &&
+            null !== id.memoizedState &&
+            restoreEnterViewTransitions(finishedWork),
+          _finishedWork$memoize2._visibility & 4
+            ? recursivelyTraversePassiveMountEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions
+              )
+            : ((_finishedWork$memoize2._visibility |= 4),
+              recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions,
+                0 !== (finishedWork.subtreeFlags & 10256)
+              )));
+      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
+      break;
+    case 24:
+      recursivelyTraversePassiveMountEffects(
+        finishedRoot,
+        finishedWork,
+        committedLanes,
+        committedTransitions
+      );
+      flags & 2048 &&
+        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
+      break;
+    case 30:
+      isViewTransitionEligible &&
+        ((flags = finishedWork.alternate),
+        null !== flags &&
+          0 !== (finishedWork.subtreeFlags & 8246) &&
+          ((finishedWork.memoizedState = null),
+          restoreViewTransitionOnHostInstances(flags.child, !0),
+          restoreViewTransitionOnHostInstances(finishedWork.child, !0)));
+      recursivelyTraversePassiveMountEffects(
+        finishedRoot,
+        finishedWork,
+        committedLanes,
+        committedTransitions
+      );
+      break;
+    default:
+      recursivelyTraversePassiveMountEffects(
+        finishedRoot,
+        finishedWork,
+        committedLanes,
+        committedTransitions
+      );
+  }
+}
+function recursivelyTraverseReconnectPassiveEffects(
+  finishedRoot$jscomp$0,
+  parentFiber,
+  committedLanes$jscomp$0,
+  committedTransitions$jscomp$0,
+  includeWorkInProgressEffects
+) {
+  includeWorkInProgressEffects =
+    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var finishedRoot = finishedRoot$jscomp$0,
+      finishedWork = parentFiber,
+      committedLanes = committedLanes$jscomp$0,
+      committedTransitions = committedTransitions$jscomp$0,
+      flags = finishedWork.flags;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 15:
+        recursivelyTraverseReconnectPassiveEffects(
+          finishedRoot,
+          finishedWork,
+          committedLanes,
+          committedTransitions,
+          includeWorkInProgressEffects
+        );
+        commitHookEffectListMount(8, finishedWork);
+        break;
+      case 23:
+        break;
+      case 22:
+        var instance = finishedWork.stateNode;
+        null !== finishedWork.memoizedState
+          ? instance._visibility & 4
+            ? recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork,
+                committedLanes,
+                committedTransitions,
+                includeWorkInProgressEffects
+              )
+            : recursivelyTraverseAtomicPassiveEffects(
+                finishedRoot,
+                finishedWork
+              )
+          : ((instance._visibility |= 4),
+            recursivelyTraverseReconnectPassiveEffects(
+              finishedRoot,
+              finishedWork,
+              committedLanes,
+              committedTransitions,
+              includeWorkInProgressEffects
+            ));
+        includeWorkInProgressEffects &&
+          flags & 2048 &&
+          commitOffscreenPassiveMountEffects(
+            finishedWork.alternate,
+            finishedWork
+          );
+        break;
+      case 24:
+        recursivelyTraverseReconnectPassiveEffects(
+          finishedRoot,
+          finishedWork,
+          committedLanes,
+          committedTransitions,
+          includeWorkInProgressEffects
+        );
+        includeWorkInProgressEffects &&
+          flags & 2048 &&
+          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
+        break;
+      default:
+        recursivelyTraverseReconnectPassiveEffects(
+          finishedRoot,
+          finishedWork,
+          committedLanes,
+          committedTransitions,
+          includeWorkInProgressEffects
+        );
+    }
+    parentFiber = parentFiber.sibling;
+  }
+}
+function recursivelyTraverseAtomicPassiveEffects(
+  finishedRoot$jscomp$0,
+  parentFiber
+) {
+  if (parentFiber.subtreeFlags & 10256)
+    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+      var finishedRoot = finishedRoot$jscomp$0,
+        finishedWork = parentFiber,
+        flags = finishedWork.flags;
+      switch (finishedWork.tag) {
+        case 22:
+          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
+          flags & 2048 &&
+            commitOffscreenPassiveMountEffects(
+              finishedWork.alternate,
+              finishedWork
+            );
+          break;
+        case 24:
+          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
+          flags & 2048 &&
+            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
+          break;
+        default:
+          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
+      }
+      parentFiber = parentFiber.sibling;
+    }
+}
+var suspenseyCommitFlag = 8192;
+function recursivelyAccumulateSuspenseyCommit(parentFiber) {
+  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      accumulateSuspenseyCommitOnFiber(parentFiber),
+        (parentFiber = parentFiber.sibling);
+}
+function accumulateSuspenseyCommitOnFiber(fiber) {
+  switch (fiber.tag) {
+    case 26:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      fiber.flags & suspenseyCommitFlag &&
+        null !== fiber.memoizedState &&
+        suspendResource(
+          currentHoistableRoot,
+          fiber.memoizedState,
+          fiber.memoizedProps
+        );
+      break;
+    case 5:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      break;
+    case 3:
+    case 4:
+      var previousHoistableRoot = currentHoistableRoot;
+      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      currentHoistableRoot = previousHoistableRoot;
+      break;
+    case 22:
+      null === fiber.memoizedState &&
+        ((previousHoistableRoot = fiber.alternate),
+        null !== previousHoistableRoot &&
+        null !== previousHoistableRoot.memoizedState
+          ? ((previousHoistableRoot = suspenseyCommitFlag),
+            (suspenseyCommitFlag = 16777216),
+            recursivelyAccumulateSuspenseyCommit(fiber),
+            (suspenseyCommitFlag = previousHoistableRoot))
+          : recursivelyAccumulateSuspenseyCommit(fiber));
+      break;
+    default:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+  }
+}
+function detachAlternateSiblings(parentFiber) {
+  var previousFiber = parentFiber.alternate;
+  if (
+    null !== previousFiber &&
+    ((parentFiber = previousFiber.child), null !== parentFiber)
+  ) {
+    previousFiber.child = null;
+    do
+      (previousFiber = parentFiber.sibling),
+        (parentFiber.sibling = null),
+        (parentFiber = previousFiber);
+    while (null !== parentFiber);
+  }
+}
+function recursivelyTraversePassiveUnmountEffects(parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (0 !== (parentFiber.flags & 16)) {
+    if (null !== deletions)
+      for (var i = 0; i < deletions.length; i++) {
+        var childToDelete = deletions[i];
+        nextEffect = childToDelete;
+        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+          childToDelete,
+          parentFiber
+        );
+      }
+    detachAlternateSiblings(parentFiber);
+  }
+  if (parentFiber.subtreeFlags & 10256)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitPassiveUnmountOnFiber(parentFiber),
+        (parentFiber = parentFiber.sibling);
+}
+function commitPassiveUnmountOnFiber(finishedWork) {
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 15:
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
+      finishedWork.flags & 2048 &&
+        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
+      break;
+    case 3:
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
+      break;
+    case 12:
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
+      break;
+    case 22:
+      var instance = finishedWork.stateNode;
+      null !== finishedWork.memoizedState &&
+      instance._visibility & 4 &&
+      (null === finishedWork.return || 13 !== finishedWork.return.tag)
+        ? ((instance._visibility &= -5),
+          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
+        : recursivelyTraversePassiveUnmountEffects(finishedWork);
+      break;
+    default:
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
+  }
+}
+function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (0 !== (parentFiber.flags & 16)) {
+    if (null !== deletions)
+      for (var i = 0; i < deletions.length; i++) {
+        var childToDelete = deletions[i];
+        nextEffect = childToDelete;
+        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+          childToDelete,
+          parentFiber
+        );
+      }
+    detachAlternateSiblings(parentFiber);
+  }
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    deletions = parentFiber;
+    switch (deletions.tag) {
+      case 0:
+      case 11:
+      case 15:
+        commitHookEffectListUnmount(8, deletions, deletions.return);
+        recursivelyTraverseDisconnectPassiveEffects(deletions);
+        break;
+      case 22:
+        i = deletions.stateNode;
+        i._visibility & 4 &&
+          ((i._visibility &= -5),
+          recursivelyTraverseDisconnectPassiveEffects(deletions));
+        break;
+      default:
+        recursivelyTraverseDisconnectPassiveEffects(deletions);
+    }
+    parentFiber = parentFiber.sibling;
+  }
+}
+function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+  deletedSubtreeRoot,
+  nearestMountedAncestor
+) {
+  for (; null !== nextEffect; ) {
+    var fiber = nextEffect;
+    switch (fiber.tag) {
+      case 0:
+      case 11:
+      case 15:
+        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
+        break;
+      case 23:
+      case 22:
+        if (
+          null !== fiber.memoizedState &&
+          null !== fiber.memoizedState.cachePool
+        ) {
+          var cache = fiber.memoizedState.cachePool.pool;
+          null != cache && cache.refCount++;
+        }
+        break;
+      case 24:
+        releaseCache(fiber.memoizedState.cache);
+    }
+    cache = fiber.child;
+    if (null !== cache) (cache.return = fiber), (nextEffect = cache);
+    else
+      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
+        cache = nextEffect;
+        var sibling = cache.sibling,
+          returnFiber = cache.return;
+        detachFiberAfterEffects(cache);
+        if (cache === fiber) {
+          nextEffect = null;
+          break a;
+        }
+        if (null !== sibling) {
+          sibling.return = returnFiber;
+          nextEffect = sibling;
+          break a;
+        }
+        nextEffect = returnFiber;
+      }
+  }
+}
+function FiberNode(tag, pendingProps, key, mode) {
+  this.tag = tag;
+  this.key = key;
+  this.sibling =
+    this.child =
+    this.return =
+    this.stateNode =
+    this.type =
+    this.elementType =
+      null;
+  this.index = 0;
+  this.refCleanup = this.ref = null;
+  this.pendingProps = pendingProps;
+  this.dependencies =
+    this.memoizedState =
+    this.updateQueue =
+    this.memoizedProps =
+      null;
+  this.mode = mode;
+  this.subtreeFlags = this.flags = 0;
+  this.deletions = null;
+  this.childLanes = this.lanes = 0;
+  this.alternate = null;
+}
+function createFiberImplClass(tag, pendingProps, key, mode) {
+  return new FiberNode(tag, pendingProps, key, mode);
+}
+function shouldConstruct(Component) {
+  Component = Component.prototype;
+  return !(!Component || !Component.isReactComponent);
+}
+function createWorkInProgress(current, pendingProps) {
+  var workInProgress = current.alternate;
+  null === workInProgress
+    ? ((workInProgress = createFiberImplClass(
+        current.tag,
+        pendingProps,
+        current.key,
+        current.mode
+      )),
+      (workInProgress.elementType = current.elementType),
+      (workInProgress.type = current.type),
+      (workInProgress.stateNode = current.stateNode),
+      (workInProgress.alternate = current),
+      (current.alternate = workInProgress))
+    : ((workInProgress.pendingProps = pendingProps),
+      (workInProgress.type = current.type),
+      (workInProgress.flags = 0),
+      (workInProgress.subtreeFlags = 0),
+      (workInProgress.deletions = null));
+  workInProgress.flags = current.flags & 65011712;
+  workInProgress.childLanes = current.childLanes;
+  workInProgress.lanes = current.lanes;
+  workInProgress.child = current.child;
+  workInProgress.memoizedProps = current.memoizedProps;
+  workInProgress.memoizedState = current.memoizedState;
+  workInProgress.updateQueue = current.updateQueue;
+  pendingProps = current.dependencies;
+  workInProgress.dependencies =
+    null === pendingProps
+      ? null
+      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
+  workInProgress.sibling = current.sibling;
+  workInProgress.index = current.index;
+  workInProgress.ref = current.ref;
+  workInProgress.refCleanup = current.refCleanup;
+  return workInProgress;
+}
+function resetWorkInProgress(workInProgress, renderLanes) {
+  workInProgress.flags &= 65011714;
+  var current = workInProgress.alternate;
+  null === current
+    ? ((workInProgress.childLanes = 0),
+      (workInProgress.lanes = renderLanes),
+      (workInProgress.child = null),
+      (workInProgress.subtreeFlags = 0),
+      (workInProgress.memoizedProps = null),
+      (workInProgress.memoizedState = null),
+      (workInProgress.updateQueue = null),
+      (workInProgress.dependencies = null),
+      (workInProgress.stateNode = null))
+    : ((workInProgress.childLanes = current.childLanes),
+      (workInProgress.lanes = current.lanes),
+      (workInProgress.child = current.child),
+      (workInProgress.subtreeFlags = 0),
+      (workInProgress.deletions = null),
+      (workInProgress.memoizedProps = current.memoizedProps),
+      (workInProgress.memoizedState = current.memoizedState),
+      (workInProgress.updateQueue = current.updateQueue),
+      (workInProgress.type = current.type),
+      (renderLanes = current.dependencies),
+      (workInProgress.dependencies =
+        null === renderLanes
+          ? null
+          : {
+              lanes: renderLanes.lanes,
+              firstContext: renderLanes.firstContext
+            }));
+  return workInProgress;
+}
+function createFiberFromTypeAndProps(
+  type,
+  key,
+  pendingProps,
+  owner,
+  mode,
+  lanes
+) {
+  var fiberTag = 0;
+  owner = type;
+  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
+  else if ("string" === typeof type)
+    fiberTag = isHostHoistableType(
+      type,
+      pendingProps,
+      contextStackCursor.current
+    )
+      ? 26
+      : "html" === type || "head" === type || "body" === type
+        ? 27
+        : 5;
+  else
+    a: switch (type) {
+      case REACT_FRAGMENT_TYPE:
+        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
+      case REACT_STRICT_MODE_TYPE:
+        fiberTag = 8;
+        mode |= 24;
+        break;
+      case REACT_PROFILER_TYPE:
+        return (
+          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),
+          (type.elementType = REACT_PROFILER_TYPE),
+          (type.lanes = lanes),
+          type
+        );
+      case REACT_SUSPENSE_TYPE:
+        return (
+          (type = createFiberImplClass(13, pendingProps, key, mode)),
+          (type.elementType = REACT_SUSPENSE_TYPE),
+          (type.lanes = lanes),
+          type
+        );
+      case REACT_SUSPENSE_LIST_TYPE:
+        return (
+          (type = createFiberImplClass(19, pendingProps, key, mode)),
+          (type.elementType = REACT_SUSPENSE_LIST_TYPE),
+          (type.lanes = lanes),
+          type
+        );
+      case REACT_OFFSCREEN_TYPE:
+        return createFiberFromOffscreen(pendingProps, mode, lanes, key);
+      case REACT_LEGACY_HIDDEN_TYPE:
+      case REACT_VIEW_TRANSITION_TYPE:
+        return (
+          (type = createFiberImplClass(30, pendingProps, key, mode)),
+          (type.elementType = REACT_VIEW_TRANSITION_TYPE),
+          (type.lanes = lanes),
+          (type.stateNode = { autoName: null, paired: null, ref: null }),
+          type
+        );
+      default:
+        if ("object" === typeof type && null !== type)
+          switch (type.$$typeof) {
+            case REACT_PROVIDER_TYPE:
+            case REACT_CONTEXT_TYPE:
+              fiberTag = 10;
+              break a;
+            case REACT_CONSUMER_TYPE:
+              fiberTag = 9;
+              break a;
+            case REACT_FORWARD_REF_TYPE:
+              fiberTag = 11;
+              break a;
+            case REACT_MEMO_TYPE:
+              fiberTag = 14;
+              break a;
+            case REACT_LAZY_TYPE:
+              fiberTag = 16;
+              owner = null;
+              break a;
+          }
+        fiberTag = 29;
+        pendingProps = Error(
+          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
+        );
+        owner = null;
+    }
+  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
+  key.elementType = type;
+  key.type = owner;
+  key.lanes = lanes;
+  return key;
+}
+function createFiberFromFragment(elements, mode, lanes, key) {
+  elements = createFiberImplClass(7, elements, key, mode);
+  elements.lanes = lanes;
+  return elements;
+}
+function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
+  pendingProps = createFiberImplClass(22, pendingProps, key, mode);
+  pendingProps.elementType = REACT_OFFSCREEN_TYPE;
+  pendingProps.lanes = lanes;
+  var primaryChildInstance = {
+    _visibility: 1,
+    _pendingVisibility: 1,
+    _pendingMarkers: null,
+    _retryCache: null,
+    _transitions: null,
+    _current: null,
+    detach: function () {
+      var fiber = primaryChildInstance._current;
+      if (null === fiber) throw Error(formatProdErrorMessage(456));
+      if (0 === (primaryChildInstance._pendingVisibility & 2)) {
+        var root = enqueueConcurrentRenderForLane(fiber, 2);
+        null !== root &&
+          ((primaryChildInstance._pendingVisibility |= 2),
+          scheduleUpdateOnFiber(root, fiber, 2));
+      }
+    },
+    attach: function () {
+      var fiber = primaryChildInstance._current;
+      if (null === fiber) throw Error(formatProdErrorMessage(456));
+      if (0 !== (primaryChildInstance._pendingVisibility & 2)) {
+        var root = enqueueConcurrentRenderForLane(fiber, 2);
+        null !== root &&
+          ((primaryChildInstance._pendingVisibility &= -3),
+          scheduleUpdateOnFiber(root, fiber, 2));
+      }
+    }
+  };
+  pendingProps.stateNode = primaryChildInstance;
+  return pendingProps;
+}
+function createFiberFromText(content, mode, lanes) {
+  content = createFiberImplClass(6, content, null, mode);
+  content.lanes = lanes;
+  return content;
+}
+function createFiberFromPortal(portal, mode, lanes) {
+  mode = createFiberImplClass(
+    4,
+    null !== portal.children ? portal.children : [],
+    portal.key,
+    mode
+  );
+  mode.lanes = lanes;
+  mode.stateNode = {
+    containerInfo: portal.containerInfo,
+    pendingChildren: null,
+    implementation: portal.implementation
+  };
+  return mode;
+}
+var hydrationParentFiber = null,
+  nextHydratableInstance = null,
+  isHydrating = !1,
+  hydrationErrors = null,
+  rootOrSingletonContext = !1,
+  HydrationMismatchException = Error(formatProdErrorMessage(519));
+function throwOnHydrationMismatch(fiber) {
+  var error = Error(formatProdErrorMessage(418, ""));
+  queueHydrationError(createCapturedValueAtFiber(error, fiber));
+  throw HydrationMismatchException;
+}
+function prepareToHydrateHostInstance(fiber) {
+  var instance = fiber.stateNode,
+    type = fiber.type,
+    props = fiber.memoizedProps;
+  instance[internalInstanceKey] = fiber;
+  instance[internalPropsKey] = props;
+  switch (type) {
+    case "dialog":
+      listenToNonDelegatedEvent("cancel", instance);
+      listenToNonDelegatedEvent("close", instance);
+      break;
+    case "iframe":
+    case "object":
+    case "embed":
+      listenToNonDelegatedEvent("load", instance);
+      break;
+    case "video":
+    case "audio":
+      for (type = 0; type < mediaEventTypes.length; type++)
+        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
+      break;
+    case "source":
+      listenToNonDelegatedEvent("error", instance);
+      break;
+    case "img":
+    case "image":
+    case "link":
+      listenToNonDelegatedEvent("error", instance);
+      listenToNonDelegatedEvent("load", instance);
+      break;
+    case "details":
+      listenToNonDelegatedEvent("toggle", instance);
+      break;
+    case "input":
+      listenToNonDelegatedEvent("invalid", instance);
+      initInput(
+        instance,
+        props.value,
+        props.defaultValue,
+        props.checked,
+        props.defaultChecked,
+        props.type,
+        props.name,
+        !0
+      );
+      track(instance);
+      break;
+    case "select":
+      listenToNonDelegatedEvent("invalid", instance);
+      break;
+    case "textarea":
+      listenToNonDelegatedEvent("invalid", instance),
+        initTextarea(instance, props.value, props.defaultValue, props.children),
+        track(instance);
+  }
+  type = props.children;
+  ("string" !== typeof type &&
+    "number" !== typeof type &&
+    "bigint" !== typeof type) ||
+  instance.textContent === "" + type ||
+  !0 === props.suppressHydrationWarning ||
+  checkForUnmatchedText(instance.textContent, type)
+    ? (null != props.popover &&
+        (listenToNonDelegatedEvent("beforetoggle", instance),
+        listenToNonDelegatedEvent("toggle", instance)),
+      null != props.onScroll && listenToNonDelegatedEvent("scroll", instance),
+      null != props.onScrollEnd &&
+        listenToNonDelegatedEvent("scrollend", instance),
+      null != props.onClick && (instance.onclick = noop$1),
+      (instance = !0))
+    : (instance = !1);
+  instance || throwOnHydrationMismatch(fiber);
+}
+function popToNextHostParent(fiber) {
+  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
+    switch (hydrationParentFiber.tag) {
+      case 3:
+      case 27:
+        rootOrSingletonContext = !0;
+        return;
+      case 5:
+      case 13:
+        rootOrSingletonContext = !1;
+        return;
+      default:
+        hydrationParentFiber = hydrationParentFiber.return;
+    }
+}
+function popHydrationState(fiber) {
+  if (fiber !== hydrationParentFiber) return !1;
+  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;
+  var shouldClear = !1,
+    JSCompiler_temp;
+  if ((JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag)) {
+    if ((JSCompiler_temp = 5 === fiber.tag))
+      (JSCompiler_temp = fiber.type),
+        (JSCompiler_temp =
+          !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
+          shouldSetTextContent(fiber.type, fiber.memoizedProps));
+    JSCompiler_temp = !JSCompiler_temp;
+  }
+  JSCompiler_temp && (shouldClear = !0);
+  shouldClear && nextHydratableInstance && throwOnHydrationMismatch(fiber);
+  popToNextHostParent(fiber);
+  if (13 === fiber.tag) {
+    fiber = fiber.memoizedState;
+    fiber = null !== fiber ? fiber.dehydrated : null;
+    if (!fiber) throw Error(formatProdErrorMessage(317));
+    a: {
+      fiber = fiber.nextSibling;
+      for (shouldClear = 0; fiber; ) {
+        if (8 === fiber.nodeType)
+          if (((JSCompiler_temp = fiber.data), "/$" === JSCompiler_temp)) {
+            if (0 === shouldClear) {
+              nextHydratableInstance = getNextHydratable(fiber.nextSibling);
+              break a;
+            }
+            shouldClear--;
+          } else
+            ("$" !== JSCompiler_temp &&
+              "$!" !== JSCompiler_temp &&
+              "$?" !== JSCompiler_temp) ||
+              shouldClear++;
+        fiber = fiber.nextSibling;
+      }
+      nextHydratableInstance = null;
+    }
+  } else
+    nextHydratableInstance = hydrationParentFiber
+      ? getNextHydratable(fiber.stateNode.nextSibling)
+      : null;
+  return !0;
+}
+function resetHydrationState() {
+  nextHydratableInstance = hydrationParentFiber = null;
+  isHydrating = !1;
+}
+function upgradeHydrationErrorsToRecoverable() {
+  var queuedErrors = hydrationErrors;
+  null !== queuedErrors &&
+    (null === workInProgressRootRecoverableErrors
+      ? (workInProgressRootRecoverableErrors = queuedErrors)
+      : workInProgressRootRecoverableErrors.push.apply(
+          workInProgressRootRecoverableErrors,
+          queuedErrors
+        ),
+    (hydrationErrors = null));
+  return queuedErrors;
+}
+function queueHydrationError(error) {
+  null === hydrationErrors
+    ? (hydrationErrors = [error])
+    : hydrationErrors.push(error);
+}
+var globalClientIdCounter = 0;
+function getViewTransitionName(props, instance) {
+  return null != props.name && "auto" !== props.name
+    ? props.name
+    : instance.autoName;
+}
+function getViewTransitionClassName(className, eventClassName) {
+  return null == eventClassName
+    ? className
+    : "none" === eventClassName
+      ? eventClassName
+      : null != className
+        ? className + " " + eventClassName
+        : eventClassName;
+}
+function markUpdate(workInProgress) {
+  workInProgress.flags |= 4;
+}
+function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
+  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
+    workInProgress.flags &= -16777217;
+  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {
+    resource = suspenseHandlerStackCursor.current;
+    if (
+      null !== resource &&
+      ((workInProgressRootRenderLanes & 4194176) ===
+      workInProgressRootRenderLanes
+        ? null !== shellBoundary
+        : ((workInProgressRootRenderLanes & 62914560) !==
+            workInProgressRootRenderLanes &&
+            0 === (workInProgressRootRenderLanes & 536870912)) ||
+          resource !== shellBoundary)
+    )
+      throw (
+        ((suspendedThenable = noopSuspenseyCommitThenable),
+        SuspenseyCommitException)
+      );
+    workInProgress.flags |= 8192;
+  }
+}
+function scheduleRetryEffect(workInProgress, retryQueue) {
+  null !== retryQueue && (workInProgress.flags |= 4);
+  workInProgress.flags & 16384 &&
+    ((retryQueue =
+      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
+    (workInProgress.lanes |= retryQueue),
+    (workInProgressSuspendedRetryLanes |= retryQueue));
+}
+function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
+  if (!isHydrating)
+    switch (renderState.tailMode) {
+      case "hidden":
+        hasRenderedATailFallback = renderState.tail;
+        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
+          null !== hasRenderedATailFallback.alternate &&
+            (lastTailNode = hasRenderedATailFallback),
+            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
+        null === lastTailNode
+          ? (renderState.tail = null)
+          : (lastTailNode.sibling = null);
+        break;
+      case "collapsed":
+        lastTailNode = renderState.tail;
+        for (var lastTailNode$135 = null; null !== lastTailNode; )
+          null !== lastTailNode.alternate && (lastTailNode$135 = lastTailNode),
+            (lastTailNode = lastTailNode.sibling);
+        null === lastTailNode$135
+          ? hasRenderedATailFallback || null === renderState.tail
+            ? (renderState.tail = null)
+            : (renderState.tail.sibling = null)
+          : (lastTailNode$135.sibling = null);
+    }
+}
+function bubbleProperties(completedWork) {
+  var didBailout =
+      null !== completedWork.alternate &&
+      completedWork.alternate.child === completedWork.child,
+    newChildLanes = 0,
+    subtreeFlags = 0;
+  if (didBailout)
+    for (var child$136 = completedWork.child; null !== child$136; )
+      (newChildLanes |= child$136.lanes | child$136.childLanes),
+        (subtreeFlags |= child$136.subtreeFlags & 65011712),
+        (subtreeFlags |= child$136.flags & 65011712),
+        (child$136.return = completedWork),
+        (child$136 = child$136.sibling);
+  else
+    for (child$136 = completedWork.child; null !== child$136; )
+      (newChildLanes |= child$136.lanes | child$136.childLanes),
+        (subtreeFlags |= child$136.subtreeFlags),
+        (subtreeFlags |= child$136.flags),
+        (child$136.return = completedWork),
+        (child$136 = child$136.sibling);
+  completedWork.subtreeFlags |= subtreeFlags;
+  completedWork.childLanes = newChildLanes;
+  return didBailout;
+}
+function trackReappearingViewTransitions(workInProgress) {
+  if (0 !== (workInProgress.subtreeFlags & 2097152))
+    for (workInProgress = workInProgress.child; null !== workInProgress; ) {
+      if (22 !== workInProgress.tag || null !== workInProgress.memoizedState) {
+        if (
+          30 === workInProgress.tag &&
+          0 !== (workInProgress.flags & 2097152)
+        ) {
+          var props = workInProgress.memoizedProps;
+          null != props.name &&
+            "auto" !== props.name &&
+            trackAppearingViewTransition(workInProgress.stateNode, props.name);
+        }
+        trackReappearingViewTransitions(workInProgress);
+      }
+      workInProgress = workInProgress.sibling;
+    }
+}
+function completeWork(current, workInProgress, renderLanes) {
+  var newProps = workInProgress.pendingProps;
+  popTreeContext(workInProgress);
+  switch (workInProgress.tag) {
+    case 16:
+    case 15:
+    case 0:
+    case 11:
+    case 7:
+    case 8:
+    case 12:
+    case 9:
+    case 14:
+      return bubbleProperties(workInProgress), null;
+    case 1:
+      return bubbleProperties(workInProgress), null;
+    case 3:
+      renderLanes = workInProgress.stateNode;
+      newProps = null;
+      null !== current && (newProps = current.memoizedState.cache);
+      workInProgress.memoizedState.cache !== newProps &&
+        (workInProgress.flags |= 2048);
+      popProvider(CacheContext);
+      popHostContainer();
+      renderLanes.pendingContext &&
+        ((renderLanes.context = renderLanes.pendingContext),
+        (renderLanes.pendingContext = null));
+      if (null === current || null === current.child)
+        popHydrationState(workInProgress)
+          ? markUpdate(workInProgress)
+          : null === current ||
+            (current.memoizedState.isDehydrated &&
+              0 === (workInProgress.flags & 256)) ||
+            ((workInProgress.flags |= 1024),
+            upgradeHydrationErrorsToRecoverable());
+      bubbleProperties(workInProgress);
+      return null;
+    case 26:
+      return (
+        (renderLanes = workInProgress.memoizedState),
+        null === current
+          ? (markUpdate(workInProgress),
+            null !== renderLanes
+              ? (bubbleProperties(workInProgress),
+                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
+              : (bubbleProperties(workInProgress),
+                (workInProgress.flags &= -16777217)))
+          : renderLanes
+            ? renderLanes !== current.memoizedState
+              ? (markUpdate(workInProgress),
+                bubbleProperties(workInProgress),
+                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
+              : (bubbleProperties(workInProgress),
+                (workInProgress.flags &= -16777217))
+            : (current.memoizedProps !== newProps && markUpdate(workInProgress),
+              bubbleProperties(workInProgress),
+              (workInProgress.flags &= -16777217)),
+        null
+      );
+    case 27:
+      popHostContext(workInProgress);
+      renderLanes = rootInstanceStackCursor.current;
+      var type = workInProgress.type;
+      if (null !== current && null != workInProgress.stateNode)
+        current.memoizedProps !== newProps && markUpdate(workInProgress);
+      else {
+        if (!newProps) {
+          if (null === workInProgress.stateNode)
+            throw Error(formatProdErrorMessage(166));
+          bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
+          return null;
+        }
+        current = contextStackCursor.current;
+        popHydrationState(workInProgress)
+          ? prepareToHydrateHostInstance(workInProgress, current)
+          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),
+            (workInProgress.stateNode = current),
+            markUpdate(workInProgress));
+      }
+      bubbleProperties(workInProgress);
+      workInProgress.subtreeFlags &= -33554433;
+      return null;
+    case 5:
+      popHostContext(workInProgress);
+      renderLanes = workInProgress.type;
+      if (null !== current && null != workInProgress.stateNode)
+        current.memoizedProps !== newProps && markUpdate(workInProgress);
+      else {
+        if (!newProps) {
+          if (null === workInProgress.stateNode)
+            throw Error(formatProdErrorMessage(166));
+          bubbleProperties(workInProgress);
+          workInProgress.subtreeFlags &= -33554433;
+          return null;
+        }
+        current = contextStackCursor.current;
+        if (popHydrationState(workInProgress))
+          prepareToHydrateHostInstance(workInProgress, current);
+        else {
+          type = getOwnerDocumentFromRootContainer(
+            rootInstanceStackCursor.current
+          );
+          switch (current) {
+            case 1:
+              current = type.createElementNS(
+                "http://www.w3.org/2000/svg",
+                renderLanes
+              );
+              break;
+            case 2:
+              current = type.createElementNS(
+                "http://www.w3.org/1998/Math/MathML",
+                renderLanes
+              );
+              break;
+            default:
+              switch (renderLanes) {
+                case "svg":
+                  current = type.createElementNS(
+                    "http://www.w3.org/2000/svg",
+                    renderLanes
+                  );
+                  break;
+                case "math":
+                  current = type.createElementNS(
+                    "http://www.w3.org/1998/Math/MathML",
+                    renderLanes
+                  );
+                  break;
+                case "script":
+                  current = type.createElement("div");
+                  current.innerHTML = "<script>\x3c/script>";
+                  current = current.removeChild(current.firstChild);
+                  break;
+                case "select":
+                  current =
+                    "string" === typeof newProps.is
+                      ? type.createElement("select", { is: newProps.is })
+                      : type.createElement("select");
+                  newProps.multiple
+                    ? (current.multiple = !0)
+                    : newProps.size && (current.size = newProps.size);
+                  break;
+                default:
+                  current =
+                    "string" === typeof newProps.is
+                      ? type.createElement(renderLanes, { is: newProps.is })
+                      : type.createElement(renderLanes);
+              }
+          }
+          current[internalInstanceKey] = workInProgress;
+          current[internalPropsKey] = newProps;
+          a: for (type = workInProgress.child; null !== type; ) {
+            if (5 === type.tag || 6 === type.tag)
+              current.appendChild(type.stateNode);
+            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
+              type.child.return = type;
+              type = type.child;
+              continue;
+            }
+            if (type === workInProgress) break a;
+            for (; null === type.sibling; ) {
+              if (null === type.return || type.return === workInProgress)
+                break a;
+              type = type.return;
+            }
+            type.sibling.return = type.return;
+            type = type.sibling;
+          }
+          workInProgress.stateNode = current;
+          a: switch (
+            (setInitialProperties(current, renderLanes, newProps), renderLanes)
+          ) {
+            case "button":
+            case "input":
+            case "select":
+            case "textarea":
+              current = !!newProps.autoFocus;
+              break a;
+            case "img":
+              current = !0;
+              break a;
+            default:
+              current = !1;
+          }
+          current && markUpdate(workInProgress);
+        }
+      }
+      bubbleProperties(workInProgress);
+      workInProgress.subtreeFlags &= -33554433;
+      workInProgress.flags &= -16777217;
+      return null;
+    case 6:
+      if (current && null != workInProgress.stateNode)
+        current.memoizedProps !== newProps && markUpdate(workInProgress);
+      else {
+        if ("string" !== typeof newProps && null === workInProgress.stateNode)
+          throw Error(formatProdErrorMessage(166));
+        current = rootInstanceStackCursor.current;
+        if (popHydrationState(workInProgress)) {
+          current = workInProgress.stateNode;
+          renderLanes = workInProgress.memoizedProps;
+          newProps = null;
+          type = hydrationParentFiber;
+          if (null !== type)
+            switch (type.tag) {
+              case 27:
+              case 5:
+                newProps = type.memoizedProps;
+            }
+          current[internalInstanceKey] = workInProgress;
+          current =
+            current.nodeValue === renderLanes ||
+            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||
+            checkForUnmatchedText(current.nodeValue, renderLanes)
+              ? !0
+              : !1;
+          current || throwOnHydrationMismatch(workInProgress);
+        } else
+          (current =
+            getOwnerDocumentFromRootContainer(current).createTextNode(
+              newProps
+            )),
+            (current[internalInstanceKey] = workInProgress),
+            (workInProgress.stateNode = current);
+      }
+      bubbleProperties(workInProgress);
+      return null;
+    case 13:
+      newProps = workInProgress.memoizedState;
+      if (
+        null === current ||
+        (null !== current.memoizedState &&
+          null !== current.memoizedState.dehydrated)
+      ) {
+        type = popHydrationState(workInProgress);
+        if (null !== newProps && null !== newProps.dehydrated) {
+          if (null === current) {
+            if (!type) throw Error(formatProdErrorMessage(318));
+            type = workInProgress.memoizedState;
+            type = null !== type ? type.dehydrated : null;
+            if (!type) throw Error(formatProdErrorMessage(317));
+            type[internalInstanceKey] = workInProgress;
+          } else
+            resetHydrationState(),
+              0 === (workInProgress.flags & 128) &&
+                (workInProgress.memoizedState = null),
+              (workInProgress.flags |= 4);
+          bubbleProperties(workInProgress);
+          type = !1;
+        } else
+          (type = upgradeHydrationErrorsToRecoverable()),
+            null !== current &&
+              null !== current.memoizedState &&
+              (current.memoizedState.hydrationErrors = type),
+            (type = !0);
+        if (!type) {
+          if (workInProgress.flags & 256)
+            return popSuspenseHandler(workInProgress), workInProgress;
+          popSuspenseHandler(workInProgress);
+          return null;
+        }
+      }
+      popSuspenseHandler(workInProgress);
+      if (0 !== (workInProgress.flags & 128))
+        return (workInProgress.lanes = renderLanes), workInProgress;
+      renderLanes = null !== newProps;
+      current = null !== current && null !== current.memoizedState;
+      if (renderLanes) {
+        newProps = workInProgress.child;
+        type = null;
+        null !== newProps.alternate &&
+          null !== newProps.alternate.memoizedState &&
+          null !== newProps.alternate.memoizedState.cachePool &&
+          (type = newProps.alternate.memoizedState.cachePool.pool);
+        var cache$149 = null;
+        null !== newProps.memoizedState &&
+          null !== newProps.memoizedState.cachePool &&
+          (cache$149 = newProps.memoizedState.cachePool.pool);
+        cache$149 !== type && (newProps.flags |= 2048);
+      }
+      renderLanes !== current &&
+        renderLanes &&
+        (workInProgress.child.flags |= 8192);
+      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
+      bubbleProperties(workInProgress);
+      return null;
+    case 4:
+      return (
+        popHostContainer(),
+        null === current &&
+          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),
+        bubbleProperties(workInProgress),
+        null
+      );
+    case 10:
+      return (
+        popProvider(workInProgress.type), bubbleProperties(workInProgress), null
+      );
+    case 19:
+      pop(suspenseStackCursor);
+      type = workInProgress.memoizedState;
+      if (null === type) return bubbleProperties(workInProgress), null;
+      newProps = 0 !== (workInProgress.flags & 128);
+      cache$149 = type.rendering;
+      if (null === cache$149)
+        if (newProps) cutOffTailIfNeeded(type, !1);
+        else {
+          if (
+            0 !== workInProgressRootExitStatus ||
+            (null !== current && 0 !== (current.flags & 128))
+          )
+            for (current = workInProgress.child; null !== current; ) {
+              cache$149 = findFirstSuspended(current);
+              if (null !== cache$149) {
+                workInProgress.flags |= 128;
+                cutOffTailIfNeeded(type, !1);
+                current = cache$149.updateQueue;
+                workInProgress.updateQueue = current;
+                scheduleRetryEffect(workInProgress, current);
+                workInProgress.subtreeFlags = 0;
+                current = renderLanes;
+                for (renderLanes = workInProgress.child; null !== renderLanes; )
+                  resetWorkInProgress(renderLanes, current),
+                    (renderLanes = renderLanes.sibling);
+                push(
+                  suspenseStackCursor,
+                  (suspenseStackCursor.current & 1) | 2
+                );
+                return workInProgress.child;
+              }
+              current = current.sibling;
+            }
+          null !== type.tail &&
+            now() > workInProgressRootRenderTargetTime &&
+            ((workInProgress.flags |= 128),
+            (newProps = !0),
+            cutOffTailIfNeeded(type, !1),
+            (workInProgress.lanes = 4194304));
+        }
+      else {
+        if (!newProps)
+          if (((current = findFirstSuspended(cache$149)), null !== current)) {
+            if (
+              ((workInProgress.flags |= 128),
+              (newProps = !0),
+              (current = current.updateQueue),
+              (workInProgress.updateQueue = current),
+              scheduleRetryEffect(workInProgress, current),
+              cutOffTailIfNeeded(type, !0),
+              null === type.tail &&
+                "hidden" === type.tailMode &&
+                !cache$149.alternate &&
+                !isHydrating)
+            )
+              return bubbleProperties(workInProgress), null;
+          } else
+            2 * now() - type.renderingStartTime >
+              workInProgressRootRenderTargetTime &&
+              536870912 !== renderLanes &&
+              ((workInProgress.flags |= 128),
+              (newProps = !0),
+              cutOffTailIfNeeded(type, !1),
+              (workInProgress.lanes = 4194304));
+        type.isBackwards
+          ? ((cache$149.sibling = workInProgress.child),
+            (workInProgress.child = cache$149))
+          : ((current = type.last),
+            null !== current
+              ? (current.sibling = cache$149)
+              : (workInProgress.child = cache$149),
+            (type.last = cache$149));
+      }
+      if (null !== type.tail)
+        return (
+          (workInProgress = type.tail),
+          (type.rendering = workInProgress),
+          (type.tail = workInProgress.sibling),
+          (type.renderingStartTime = now()),
+          (workInProgress.sibling = null),
+          (current = suspenseStackCursor.current),
+          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),
+          workInProgress
+        );
+      bubbleProperties(workInProgress);
+      return null;
+    case 22:
+    case 23:
+      return (
+        popSuspenseHandler(workInProgress),
+        popHiddenContext(),
+        (newProps = null !== workInProgress.memoizedState),
+        null !== current
+          ? (null !== current.memoizedState) !== newProps &&
+            ((workInProgress.flags |= 8192),
+            newProps || trackReappearingViewTransitions(workInProgress))
+          : newProps && (workInProgress.flags |= 8192),
+        newProps
+          ? 0 !== (renderLanes & 536870912) &&
+            0 === (workInProgress.flags & 128) &&
+            (bubbleProperties(workInProgress),
+            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
+          : bubbleProperties(workInProgress),
+        (renderLanes = workInProgress.updateQueue),
+        null !== renderLanes &&
+          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
+        (renderLanes = null),
+        null !== current &&
+          null !== current.memoizedState &&
+          null !== current.memoizedState.cachePool &&
+          (renderLanes = current.memoizedState.cachePool.pool),
+        (newProps = null),
+        null !== workInProgress.memoizedState &&
+          null !== workInProgress.memoizedState.cachePool &&
+          (newProps = workInProgress.memoizedState.cachePool.pool),
+        newProps !== renderLanes && (workInProgress.flags |= 2048),
+        null !== current && pop(resumedCache),
+        null
+      );
+    case 24:
+      return (
+        (renderLanes = null),
+        null !== current && (renderLanes = current.memoizedState.cache),
+        workInProgress.memoizedState.cache !== renderLanes &&
+          (workInProgress.flags |= 2048),
+        popProvider(CacheContext),
+        bubbleProperties(workInProgress),
+        null
+      );
+    case 25:
+      return null;
+    case 30:
+      return (
+        (workInProgress.flags |= 33554432),
+        bubbleProperties(workInProgress),
+        null
+      );
+  }
+  throw Error(formatProdErrorMessage(156, workInProgress.tag));
+}
+function unwindWork(current, workInProgress) {
+  popTreeContext(workInProgress);
+  switch (workInProgress.tag) {
+    case 1:
+      return (
+        (current = workInProgress.flags),
+        current & 65536
+          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+          : null
+      );
+    case 3:
+      return (
+        popProvider(CacheContext),
+        popHostContainer(),
+        (current = workInProgress.flags),
+        0 !== (current & 65536) && 0 === (current & 128)
+          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+          : null
+      );
+    case 26:
+    case 27:
+    case 5:
+      return popHostContext(workInProgress), null;
+    case 13:
+      popSuspenseHandler(workInProgress);
+      current = workInProgress.memoizedState;
+      if (null !== current && null !== current.dehydrated) {
+        if (null === workInProgress.alternate)
+          throw Error(formatProdErrorMessage(340));
+        resetHydrationState();
+      }
+      current = workInProgress.flags;
+      return current & 65536
+        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+        : null;
+    case 19:
+      return pop(suspenseStackCursor), null;
+    case 4:
+      return popHostContainer(), null;
+    case 10:
+      return popProvider(workInProgress.type), null;
+    case 22:
+    case 23:
+      return (
+        popSuspenseHandler(workInProgress),
+        popHiddenContext(),
+        null !== current && pop(resumedCache),
+        (current = workInProgress.flags),
+        current & 65536
+          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+          : null
+      );
+    case 24:
+      return popProvider(CacheContext), null;
+    case 25:
+      return null;
+    default:
+      return null;
+  }
+}
+function unwindInterruptedWork(current, interruptedWork) {
+  popTreeContext(interruptedWork);
+  switch (interruptedWork.tag) {
+    case 3:
+      popProvider(CacheContext);
+      popHostContainer();
+      break;
+    case 26:
+    case 27:
+    case 5:
+      popHostContext(interruptedWork);
+      break;
+    case 4:
+      popHostContainer();
+      break;
+    case 13:
+      popSuspenseHandler(interruptedWork);
+      break;
+    case 19:
+      pop(suspenseStackCursor);
+      break;
+    case 10:
+      popProvider(interruptedWork.type);
+      break;
+    case 22:
+    case 23:
+      popSuspenseHandler(interruptedWork);
+      popHiddenContext();
+      null !== current && pop(resumedCache);
+      break;
+    case 24:
+      popProvider(CacheContext);
+  }
+}
+var DefaultAsyncDispatcher = {
+    getCacheForType: function (resourceType) {
+      var cache = readContext(CacheContext),
+        cacheForType = cache.data.get(resourceType);
+      void 0 === cacheForType &&
+        ((cacheForType = resourceType()),
+        cache.data.set(resourceType, cacheForType));
+      return cacheForType;
+    }
+  },
+  COMPONENT_TYPE = 0,
+  HAS_PSEUDO_CLASS_TYPE = 1,
+  ROLE_TYPE = 2,
+  TEST_NAME_TYPE = 3,
+  TEXT_TYPE = 4;
+if ("function" === typeof Symbol && Symbol.for) {
+  var symbolFor = Symbol.for;
+  COMPONENT_TYPE = symbolFor("selector.component");
+  HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
+  ROLE_TYPE = symbolFor("selector.role");
+  TEST_NAME_TYPE = symbolFor("selector.test_id");
+  TEXT_TYPE = symbolFor("selector.text");
+}
+function findFiberRootForHostRoot(hostRoot) {
+  var maybeFiber = getClosestInstanceFromNode(hostRoot);
+  if (null != maybeFiber) {
+    if ("string" !== typeof maybeFiber.memoizedProps["data-testname"])
+      throw Error(formatProdErrorMessage(364));
+    return maybeFiber;
+  }
+  a: {
+    hostRoot = [hostRoot];
+    for (maybeFiber = 0; maybeFiber < hostRoot.length; ) {
+      var current = hostRoot[maybeFiber++];
+      if (current[internalContainerInstanceKey]) {
+        hostRoot = getInstanceFromNode(current);
+        break a;
+      }
+      hostRoot.push.apply(hostRoot, current.children);
+    }
+    hostRoot = null;
+  }
+  if (null === hostRoot) throw Error(formatProdErrorMessage(362));
+  return hostRoot.stateNode.current;
+}
+function matchSelector(fiber$jscomp$0, selector) {
+  var tag = fiber$jscomp$0.tag;
+  switch (selector.$$typeof) {
+    case COMPONENT_TYPE:
+      if (fiber$jscomp$0.type === selector.value) return !0;
+      break;
+    case HAS_PSEUDO_CLASS_TYPE:
+      a: {
+        selector = selector.value;
+        tag = [fiber$jscomp$0, 0];
+        for (fiber$jscomp$0 = 0; fiber$jscomp$0 < tag.length; ) {
+          var fiber = tag[fiber$jscomp$0++],
+            tag$jscomp$0 = fiber.tag,
+            selectorIndex = tag[fiber$jscomp$0++],
+            selector$jscomp$0 = selector[selectorIndex];
+          if (
+            (5 !== tag$jscomp$0 &&
+              26 !== tag$jscomp$0 &&
+              27 !== tag$jscomp$0) ||
+            !isHiddenSubtree(fiber)
+          ) {
+            for (
+              ;
+              null != selector$jscomp$0 &&
+              matchSelector(fiber, selector$jscomp$0);
+
+            )
+              selectorIndex++, (selector$jscomp$0 = selector[selectorIndex]);
+            if (selectorIndex === selector.length) {
+              selector = !0;
+              break a;
+            } else
+              for (fiber = fiber.child; null !== fiber; )
+                tag.push(fiber, selectorIndex), (fiber = fiber.sibling);
+          }
+        }
+        selector = !1;
+      }
+      return selector;
+    case ROLE_TYPE:
+      if (5 === tag || 26 === tag || 27 === tag)
+        if (
+          ((tag = fiber$jscomp$0.stateNode),
+          (selector = selector.value),
+          (fiber$jscomp$0 = (fiber$jscomp$0 = tag.getAttribute("role"))
+            ? fiber$jscomp$0.trim().split(" ")
+            : null),
+          (selector =
+            (null !== fiber$jscomp$0 &&
+              0 <= fiber$jscomp$0.indexOf(selector)) ||
+            selector === getImplicitRole(tag)
+              ? !0
+              : !1),
+          selector)
+        )
+          return !0;
+      break;
+    case TEXT_TYPE:
+      if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {
+        a: {
+          switch (fiber$jscomp$0.tag) {
+            case 26:
+            case 27:
+            case 5:
+              tag = "";
+              fiber$jscomp$0 = fiber$jscomp$0.stateNode.childNodes;
+              for (
+                selectorIndex = 0;
+                selectorIndex < fiber$jscomp$0.length;
+                selectorIndex++
+              )
+                (fiber = fiber$jscomp$0[selectorIndex]),
+                  fiber.nodeType === Node.TEXT_NODE &&
+                    (tag += fiber.textContent);
+              break a;
+            case 6:
+              tag = fiber$jscomp$0.stateNode.textContent;
+              break a;
+          }
+          tag = null;
+        }
+        if (null !== tag && 0 <= tag.indexOf(selector.value)) return !0;
+      }
+      break;
+    case TEST_NAME_TYPE:
+      if (5 === tag || 26 === tag || 27 === tag)
+        if (
+          ((tag = fiber$jscomp$0.memoizedProps["data-testname"]),
+          "string" === typeof tag &&
+            tag.toLowerCase() === selector.value.toLowerCase())
+        )
+          return !0;
+      break;
+    default:
+      throw Error(formatProdErrorMessage(365));
+  }
+  return !1;
+}
+function selectorToString(selector) {
+  switch (selector.$$typeof) {
+    case COMPONENT_TYPE:
+      return (
+        "<" + (getComponentNameFromType(selector.value) || "Unknown") + ">"
+      );
+    case HAS_PSEUDO_CLASS_TYPE:
+      return ":has(" + (selectorToString(selector) || "") + ")";
+    case ROLE_TYPE:
+      return '[role="' + selector.value + '"]';
+    case TEXT_TYPE:
+      return '"' + selector.value + '"';
+    case TEST_NAME_TYPE:
+      return '[data-testname="' + selector.value + '"]';
+    default:
+      throw Error(formatProdErrorMessage(365));
+  }
+}
+function findPaths(root, selectors) {
+  var matchingFibers = [];
+  root = [root, 0];
+  for (var index = 0; index < root.length; ) {
+    var fiber = root[index++],
+      tag = fiber.tag,
+      selectorIndex = root[index++],
+      selector = selectors[selectorIndex];
+    if ((5 !== tag && 26 !== tag && 27 !== tag) || !isHiddenSubtree(fiber)) {
+      for (; null != selector && matchSelector(fiber, selector); )
+        selectorIndex++, (selector = selectors[selectorIndex]);
+      if (selectorIndex === selectors.length) matchingFibers.push(fiber);
+      else
+        for (fiber = fiber.child; null !== fiber; )
+          root.push(fiber, selectorIndex), (fiber = fiber.sibling);
+    }
+  }
+  return matchingFibers;
+}
+function findAllNodes(hostRoot, selectors) {
+  hostRoot = findFiberRootForHostRoot(hostRoot);
+  hostRoot = findPaths(hostRoot, selectors);
+  selectors = [];
+  hostRoot = Array.from(hostRoot);
+  for (var index = 0; index < hostRoot.length; ) {
+    var node = hostRoot[index++],
+      tag = node.tag;
+    if (5 === tag || 26 === tag || 27 === tag)
+      isHiddenSubtree(node) || selectors.push(node.stateNode);
+    else
+      for (node = node.child; null !== node; )
+        hostRoot.push(node), (node = node.sibling);
+  }
+  return selectors;
+}
+var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
+  executionContext = 0,
+  workInProgressRoot = null,
+  workInProgress = null,
+  workInProgressRootRenderLanes = 0,
+  workInProgressSuspendedReason = 0,
+  workInProgressThrownValue = null,
+  workInProgressRootDidSkipSuspendedSiblings = !1,
+  workInProgressRootIsPrerendering = !1,
+  workInProgressRootDidAttachPingListener = !1,
+  entangledRenderLanes = 0,
+  workInProgressRootExitStatus = 0,
+  workInProgressRootSkippedLanes = 0,
+  workInProgressRootInterleavedUpdatedLanes = 0,
+  workInProgressRootPingedLanes = 0,
+  workInProgressDeferredLane = 0,
+  workInProgressSuspendedRetryLanes = 0,
+  workInProgressRootConcurrentErrors = null,
+  workInProgressRootRecoverableErrors = null,
+  workInProgressAppearingViewTransitions = null,
+  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
+  globalMostRecentFallbackTime = 0,
+  workInProgressRootRenderTargetTime = Infinity,
+  workInProgressTransitions = null,
+  legacyErrorBoundariesThatAlreadyFailed = null,
+  pendingEffectsStatus = 0,
+  pendingEffectsRoot = null,
+  pendingFinishedWork = null,
+  pendingEffectsLanes = 0,
+  pendingEffectsRemainingLanes = 0,
+  pendingPassiveTransitions = null,
+  pendingRecoverableErrors = null,
+  pendingViewTransitionEvents = null,
+  nestedUpdateCount = 0,
+  rootWithNestedUpdates = null;
+function requestUpdateLane() {
+  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
+    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
+  if (null !== ReactSharedInternals.T) {
+    var actionScopeLane = currentEntangledLane;
+    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
+  }
+  return resolveUpdatePriority();
+}
+function requestDeferredLane() {
+  0 === workInProgressDeferredLane &&
+    (workInProgressDeferredLane =
+      0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
+        ? claimNextTransitionLane()
+        : 536870912);
+  var suspenseHandler = suspenseHandlerStackCursor.current;
+  null !== suspenseHandler && (suspenseHandler.flags |= 32);
+  return workInProgressDeferredLane;
+}
+function scheduleViewTransitionEvent(fiber, callback) {
+  if (null != callback) {
+    var state = fiber.stateNode,
+      instance = state.ref;
+    null === instance &&
+      (instance = state.ref =
+        createViewTransitionInstance(
+          getViewTransitionName(fiber.memoizedProps, state)
+        ));
+    null === pendingViewTransitionEvents && (pendingViewTransitionEvents = []);
+    pendingViewTransitionEvents.push(callback.bind(null, instance));
+  }
+}
+function scheduleUpdateOnFiber(root, fiber, lane) {
+  if (
+    (root === workInProgressRoot &&
+      (2 === workInProgressSuspendedReason ||
+        9 === workInProgressSuspendedReason)) ||
+    null !== root.cancelPendingCommit
+  )
+    prepareFreshStack(root, 0),
+      markRootSuspended(
+        root,
+        workInProgressRootRenderLanes,
+        workInProgressDeferredLane,
+        !1
+      );
+  markRootUpdated$1(root, lane);
+  if (0 === (executionContext & 2) || root !== workInProgressRoot)
+    root === workInProgressRoot &&
+      (0 === (executionContext & 2) &&
+        (workInProgressRootInterleavedUpdatedLanes |= lane),
+      4 === workInProgressRootExitStatus &&
+        markRootSuspended(
+          root,
+          workInProgressRootRenderLanes,
+          workInProgressDeferredLane,
+          !1
+        )),
+      ensureRootIsScheduled(root);
+}
+function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
+  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
+  var shouldTimeSlice =
+      (!forceSync &&
+        0 === (lanes & 60) &&
+        0 === (lanes & root$jscomp$0.expiredLanes)) ||
+      checkIfRootIsPrerendering(root$jscomp$0, lanes),
+    exitStatus = shouldTimeSlice
+      ? renderRootConcurrent(root$jscomp$0, lanes)
+      : renderRootSync(root$jscomp$0, lanes, !0),
+    renderWasConcurrent = shouldTimeSlice;
+  do {
+    if (0 === exitStatus) {
+      workInProgressRootIsPrerendering &&
+        !shouldTimeSlice &&
+        markRootSuspended(root$jscomp$0, lanes, 0, !1);
+      break;
+    } else {
+      forceSync = root$jscomp$0.current.alternate;
+      if (
+        renderWasConcurrent &&
+        !isRenderConsistentWithExternalStores(forceSync)
+      ) {
+        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
+        renderWasConcurrent = !1;
+        continue;
+      }
+      if (2 === exitStatus) {
+        renderWasConcurrent = lanes;
+        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
+          var JSCompiler_inline_result = 0;
+        else
+          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),
+            (JSCompiler_inline_result =
+              0 !== JSCompiler_inline_result
+                ? JSCompiler_inline_result
+                : JSCompiler_inline_result & 536870912
+                  ? 536870912
+                  : 0);
+        if (0 !== JSCompiler_inline_result) {
+          lanes = JSCompiler_inline_result;
+          a: {
+            var root = root$jscomp$0;
+            exitStatus = workInProgressRootConcurrentErrors;
+            var wasRootDehydrated = root.current.memoizedState.isDehydrated;
+            wasRootDehydrated &&
+              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
+            JSCompiler_inline_result = renderRootSync(
+              root,
+              JSCompiler_inline_result,
+              !1
+            );
+            if (2 !== JSCompiler_inline_result) {
+              if (
+                workInProgressRootDidAttachPingListener &&
+                !wasRootDehydrated
+              ) {
+                root.errorRecoveryDisabledLanes |= renderWasConcurrent;
+                workInProgressRootInterleavedUpdatedLanes |=
+                  renderWasConcurrent;
+                exitStatus = 4;
+                break a;
+              }
+              renderWasConcurrent = workInProgressRootRecoverableErrors;
+              workInProgressRootRecoverableErrors = exitStatus;
+              null !== renderWasConcurrent &&
+                (null === workInProgressRootRecoverableErrors
+                  ? (workInProgressRootRecoverableErrors = renderWasConcurrent)
+                  : workInProgressRootRecoverableErrors.push.apply(
+                      workInProgressRootRecoverableErrors,
+                      renderWasConcurrent
+                    ));
+            }
+            exitStatus = JSCompiler_inline_result;
+          }
+          renderWasConcurrent = !1;
+          if (2 !== exitStatus) continue;
+        }
+      }
+      if (1 === exitStatus) {
+        prepareFreshStack(root$jscomp$0, 0);
+        markRootSuspended(root$jscomp$0, lanes, 0, !0);
+        break;
+      }
+      a: {
+        shouldTimeSlice = root$jscomp$0;
+        renderWasConcurrent = exitStatus;
+        switch (renderWasConcurrent) {
+          case 0:
+          case 1:
+            throw Error(formatProdErrorMessage(345));
+          case 4:
+            if ((lanes & 4194176) !== lanes) break;
+          case 6:
+            markRootSuspended(
+              shouldTimeSlice,
+              lanes,
+              workInProgressDeferredLane,
+              !workInProgressRootDidSkipSuspendedSiblings
+            );
+            break a;
+          case 2:
+            workInProgressRootRecoverableErrors = null;
+            break;
+          case 3:
+          case 5:
+            break;
+          default:
+            throw Error(formatProdErrorMessage(329));
+        }
+        if (
+          (lanes & 62914560) === lanes &&
+          ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
+          10 < exitStatus)
+        ) {
+          markRootSuspended(
+            shouldTimeSlice,
+            lanes,
+            workInProgressDeferredLane,
+            !workInProgressRootDidSkipSuspendedSiblings
+          );
+          if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
+          shouldTimeSlice.timeoutHandle = scheduleTimeout(
+            commitRootWhenReady.bind(
+              null,
+              shouldTimeSlice,
+              forceSync,
+              workInProgressRootRecoverableErrors,
+              workInProgressTransitions,
+              workInProgressAppearingViewTransitions,
+              workInProgressRootDidIncludeRecursiveRenderUpdate,
+              lanes,
+              workInProgressDeferredLane,
+              workInProgressRootInterleavedUpdatedLanes,
+              workInProgressSuspendedRetryLanes,
+              workInProgressRootDidSkipSuspendedSiblings,
+              renderWasConcurrent,
+              2,
+              -0,
+              0
+            ),
+            exitStatus
+          );
+          break a;
+        }
+        commitRootWhenReady(
+          shouldTimeSlice,
+          forceSync,
+          workInProgressRootRecoverableErrors,
+          workInProgressTransitions,
+          workInProgressAppearingViewTransitions,
+          workInProgressRootDidIncludeRecursiveRenderUpdate,
+          lanes,
+          workInProgressDeferredLane,
+          workInProgressRootInterleavedUpdatedLanes,
+          workInProgressSuspendedRetryLanes,
+          workInProgressRootDidSkipSuspendedSiblings,
+          renderWasConcurrent,
+          0,
+          -0,
+          0
+        );
+      }
+    }
+    break;
+  } while (1);
+  ensureRootIsScheduled(root$jscomp$0);
+}
+function commitRootWhenReady(
+  root,
+  finishedWork,
+  recoverableErrors,
+  transitions,
+  appearingViewTransitions,
+  didIncludeRenderPhaseUpdate,
+  lanes,
+  spawnedLane,
+  updatedLanes,
+  suspendedRetryLanes,
+  didSkipSuspendedSiblings,
+  exitStatus,
+  suspendedCommitReason,
+  completedRenderStartTime,
+  completedRenderEndTime
+) {
+  root.timeoutHandle = -1;
+  var subtreeFlags = finishedWork.subtreeFlags;
+  suspendedCommitReason = (lanes & 335544192) === lanes;
+  subtreeFlags = subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408);
+  if (suspendedCommitReason || subtreeFlags) {
+    suspendedState = { stylesheets: null, count: 0, unsuspend: noop };
+    subtreeFlags && accumulateSuspenseyCommitOnFiber(finishedWork);
+    if (suspendedCommitReason) {
+      subtreeFlags = root.containerInfo;
+      if (null === suspendedState) throw Error(formatProdErrorMessage(475));
+      suspendedCommitReason = suspendedState;
+      subtreeFlags = (
+        9 === subtreeFlags.nodeType ? subtreeFlags : subtreeFlags.ownerDocument
+      ).__reactViewTransition;
+      null != subtreeFlags &&
+        (suspendedCommitReason.count++,
+        (suspendedCommitReason = onUnsuspend.bind(suspendedCommitReason)),
+        subtreeFlags.finished.then(
+          suspendedCommitReason,
+          suspendedCommitReason
+        ));
+    }
+    suspendedCommitReason = waitForCommitToBeReady();
+    if (null !== suspendedCommitReason) {
+      root.cancelPendingCommit = suspendedCommitReason(
+        commitRoot.bind(
+          null,
+          root,
+          finishedWork,
+          lanes,
+          recoverableErrors,
+          transitions,
+          appearingViewTransitions,
+          didIncludeRenderPhaseUpdate,
+          spawnedLane,
+          updatedLanes,
+          suspendedRetryLanes,
+          exitStatus,
+          1,
+          completedRenderStartTime,
+          completedRenderEndTime
+        )
+      );
+      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
+      return;
+    }
+  }
+  commitRoot(
+    root,
+    finishedWork,
+    lanes,
+    recoverableErrors,
+    transitions,
+    appearingViewTransitions,
+    didIncludeRenderPhaseUpdate,
+    spawnedLane,
+    updatedLanes,
+    suspendedRetryLanes
+  );
+}
+function isRenderConsistentWithExternalStores(finishedWork) {
+  for (var node = finishedWork; ; ) {
+    var tag = node.tag;
+    if (
+      (0 === tag || 11 === tag || 15 === tag) &&
+      node.flags & 16384 &&
+      ((tag = node.updateQueue),
+      null !== tag && ((tag = tag.stores), null !== tag))
+    )
+      for (var i = 0; i < tag.length; i++) {
+        var check = tag[i],
+          getSnapshot = check.getSnapshot;
+        check = check.value;
+        try {
+          if (!objectIs(getSnapshot(), check)) return !1;
+        } catch (error) {
+          return !1;
+        }
+      }
+    tag = node.child;
+    if (node.subtreeFlags & 16384 && null !== tag)
+      (tag.return = node), (node = tag);
+    else {
+      if (node === finishedWork) break;
+      for (; null === node.sibling; ) {
+        if (null === node.return || node.return === finishedWork) return !0;
+        node = node.return;
+      }
+      node.sibling.return = node.return;
+      node = node.sibling;
+    }
+  }
+  return !0;
+}
+function markRootSuspended(
+  root,
+  suspendedLanes,
+  spawnedLane,
+  didAttemptEntireTree
+) {
+  suspendedLanes &= ~workInProgressRootPingedLanes;
+  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
+  root.suspendedLanes |= suspendedLanes;
+  root.pingedLanes &= ~suspendedLanes;
+  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
+  didAttemptEntireTree = root.expirationTimes;
+  for (var lanes = suspendedLanes; 0 < lanes; ) {
+    var index$4 = 31 - clz32(lanes),
+      lane = 1 << index$4;
+    didAttemptEntireTree[index$4] = -1;
+    lanes &= ~lane;
+  }
+  0 !== spawnedLane &&
+    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
+}
+function flushSyncWork$1() {
+  return 0 === (executionContext & 6)
+    ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)
+    : !0;
+}
+function resetWorkInProgressStack() {
+  if (null !== workInProgress) {
+    if (0 === workInProgressSuspendedReason)
+      var interruptedWork = workInProgress.return;
+    else
+      (interruptedWork = workInProgress),
+        (lastContextDependency = currentlyRenderingFiber$1 = null),
+        resetHooksOnUnwind(interruptedWork),
+        (thenableState = null),
+        (thenableIndexCounter = 0),
+        (interruptedWork = workInProgress);
+    for (; null !== interruptedWork; )
+      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
+        (interruptedWork = interruptedWork.return);
+    workInProgress = null;
+  }
+}
+function prepareFreshStack(root, lanes) {
+  var timeoutHandle = root.timeoutHandle;
+  -1 !== timeoutHandle &&
+    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
+  timeoutHandle = root.cancelPendingCommit;
+  null !== timeoutHandle &&
+    ((root.cancelPendingCommit = null), timeoutHandle());
+  resetWorkInProgressStack();
+  workInProgressRoot = root;
+  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
+  workInProgressRootRenderLanes = lanes;
+  workInProgressSuspendedReason = 0;
+  workInProgressThrownValue = null;
+  workInProgressRootDidSkipSuspendedSiblings = !1;
+  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
+  workInProgressRootDidAttachPingListener = !1;
+  workInProgressSuspendedRetryLanes =
+    workInProgressDeferredLane =
+    workInProgressRootPingedLanes =
+    workInProgressRootInterleavedUpdatedLanes =
+    workInProgressRootSkippedLanes =
+    workInProgressRootExitStatus =
+      0;
+  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
+    null;
+  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
+  workInProgressAppearingViewTransitions = null;
+  0 !== (lanes & 8) && (lanes |= lanes & 32);
+  var allEntangledLanes = root.entangledLanes;
+  if (0 !== allEntangledLanes)
+    for (
+      root = root.entanglements, allEntangledLanes &= lanes;
+      0 < allEntangledLanes;
+
+    ) {
+      var index$2 = 31 - clz32(allEntangledLanes),
+        lane = 1 << index$2;
+      lanes |= root[index$2];
+      allEntangledLanes &= ~lane;
+    }
+  entangledRenderLanes = lanes;
+  finishQueueingConcurrentUpdates();
+  return timeoutHandle;
+}
+function handleThrow(root, thrownValue) {
+  currentlyRenderingFiber = null;
+  ReactSharedInternals.H = ContextOnlyDispatcher;
+  thrownValue === SuspenseException || thrownValue === SuspenseActionException
+    ? ((thrownValue = getSuspendedThenable()),
+      (workInProgressSuspendedReason = 3))
+    : thrownValue === SuspenseyCommitException
+      ? ((thrownValue = getSuspendedThenable()),
+        (workInProgressSuspendedReason = 4))
+      : (workInProgressSuspendedReason =
+          thrownValue === SelectiveHydrationException
+            ? 8
+            : null !== thrownValue &&
+                "object" === typeof thrownValue &&
+                "function" === typeof thrownValue.then
+              ? 6
+              : 1);
+  workInProgressThrownValue = thrownValue;
+  null === workInProgress &&
+    ((workInProgressRootExitStatus = 1),
+    logUncaughtError(
+      root,
+      createCapturedValueAtFiber(thrownValue, root.current)
+    ));
+}
+function pushDispatcher() {
+  var prevDispatcher = ReactSharedInternals.H;
+  ReactSharedInternals.H = ContextOnlyDispatcher;
+  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
+}
+function pushAsyncDispatcher() {
+  var prevAsyncDispatcher = ReactSharedInternals.A;
+  ReactSharedInternals.A = DefaultAsyncDispatcher;
+  return prevAsyncDispatcher;
+}
+function renderDidSuspendDelayIfPossible() {
+  workInProgressRootExitStatus = 4;
+  workInProgressRootDidSkipSuspendedSiblings ||
+    ((workInProgressRootRenderLanes & 4194176) !==
+      workInProgressRootRenderLanes &&
+      null !== suspenseHandlerStackCursor.current) ||
+    (workInProgressRootIsPrerendering = !0);
+  (0 === (workInProgressRootSkippedLanes & 134217727) &&
+    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
+    null === workInProgressRoot ||
+    markRootSuspended(
+      workInProgressRoot,
+      workInProgressRootRenderLanes,
+      workInProgressDeferredLane,
+      !1
+    );
+}
+function queueConcurrentError(error) {
+  null === workInProgressRootConcurrentErrors
+    ? (workInProgressRootConcurrentErrors = [error])
+    : workInProgressRootConcurrentErrors.push(error);
+}
+function trackAppearingViewTransition(instance, name) {
+  if (null === workInProgressAppearingViewTransitions) {
+    if (
+      (workInProgressRootRenderLanes & 335544192) !==
+      workInProgressRootRenderLanes
+    )
+      return;
+    workInProgressAppearingViewTransitions = new Map();
+  }
+  instance.paired = null;
+  workInProgressAppearingViewTransitions.set(name, instance);
+}
+function renderRootSync(root, lanes, shouldYieldForPrerendering) {
+  var prevExecutionContext = executionContext;
+  executionContext |= 2;
+  var prevDispatcher = pushDispatcher(),
+    prevAsyncDispatcher = pushAsyncDispatcher();
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
+    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
+  lanes = !1;
+  var exitStatus = workInProgressRootExitStatus;
+  a: do
+    try {
+      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
+        var unitOfWork = workInProgress,
+          thrownValue = workInProgressThrownValue;
+        switch (workInProgressSuspendedReason) {
+          case 8:
+            resetWorkInProgressStack();
+            exitStatus = 6;
+            break a;
+          case 3:
+          case 2:
+          case 9:
+          case 6:
+            null === suspenseHandlerStackCursor.current && (lanes = !0);
+            var reason = workInProgressSuspendedReason;
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
+            if (
+              shouldYieldForPrerendering &&
+              workInProgressRootIsPrerendering
+            ) {
+              exitStatus = 0;
+              break a;
+            }
+            break;
+          default:
+            (reason = workInProgressSuspendedReason),
+              (workInProgressSuspendedReason = 0),
+              (workInProgressThrownValue = null),
+              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
+        }
+      }
+      workLoopSync();
+      exitStatus = workInProgressRootExitStatus;
+      break;
+    } catch (thrownValue$169) {
+      handleThrow(root, thrownValue$169);
+    }
+  while (1);
+  lanes && root.shellSuspendCounter++;
+  lastContextDependency = currentlyRenderingFiber$1 = null;
+  executionContext = prevExecutionContext;
+  ReactSharedInternals.H = prevDispatcher;
+  ReactSharedInternals.A = prevAsyncDispatcher;
+  null === workInProgress &&
+    ((workInProgressRoot = null),
+    (workInProgressRootRenderLanes = 0),
+    finishQueueingConcurrentUpdates());
+  return exitStatus;
+}
+function workLoopSync() {
+  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
+}
+function renderRootConcurrent(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= 2;
+  var prevDispatcher = pushDispatcher(),
+    prevAsyncDispatcher = pushAsyncDispatcher();
+  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
+    ? ((workInProgressTransitions = null),
+      (workInProgressRootRenderTargetTime = now() + 500),
+      prepareFreshStack(root, lanes))
+    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
+        root,
+        lanes
+      ));
+  a: do
+    try {
+      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
+        lanes = workInProgress;
+        var thrownValue = workInProgressThrownValue;
+        b: switch (workInProgressSuspendedReason) {
+          case 1:
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
+            break;
+          case 2:
+          case 9:
+            if (isThenableResolved(thrownValue)) {
+              workInProgressSuspendedReason = 0;
+              workInProgressThrownValue = null;
+              replaySuspendedUnitOfWork(lanes);
+              break;
+            }
+            lanes = function () {
+              (2 !== workInProgressSuspendedReason &&
+                9 !== workInProgressSuspendedReason) ||
+                workInProgressRoot !== root ||
+                (workInProgressSuspendedReason = 7);
+              ensureRootIsScheduled(root);
+            };
+            thrownValue.then(lanes, lanes);
+            break a;
+          case 3:
+            workInProgressSuspendedReason = 7;
+            break a;
+          case 4:
+            workInProgressSuspendedReason = 5;
+            break a;
+          case 7:
+            isThenableResolved(thrownValue)
+              ? ((workInProgressSuspendedReason = 0),
+                (workInProgressThrownValue = null),
+                replaySuspendedUnitOfWork(lanes))
+              : ((workInProgressSuspendedReason = 0),
+                (workInProgressThrownValue = null),
+                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
+            break;
+          case 5:
+            var resource = null;
+            switch (workInProgress.tag) {
+              case 26:
+                resource = workInProgress.memoizedState;
+              case 5:
+              case 27:
+                var hostFiber = workInProgress;
+                if (resource ? preloadResource(resource) : 1) {
+                  workInProgressSuspendedReason = 0;
+                  workInProgressThrownValue = null;
+                  var sibling = hostFiber.sibling;
+                  if (null !== sibling) workInProgress = sibling;
+                  else {
+                    var returnFiber = hostFiber.return;
+                    null !== returnFiber
+                      ? ((workInProgress = returnFiber),
+                        completeUnitOfWork(returnFiber))
+                      : (workInProgress = null);
+                  }
+                  break b;
+                }
+            }
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
+            break;
+          case 6:
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
+            break;
+          case 8:
+            resetWorkInProgressStack();
+            workInProgressRootExitStatus = 6;
+            break a;
+          default:
+            throw Error(formatProdErrorMessage(462));
+        }
+      }
+      workLoopConcurrentByScheduler();
+      break;
+    } catch (thrownValue$171) {
+      handleThrow(root, thrownValue$171);
+    }
+  while (1);
+  lastContextDependency = currentlyRenderingFiber$1 = null;
+  ReactSharedInternals.H = prevDispatcher;
+  ReactSharedInternals.A = prevAsyncDispatcher;
+  executionContext = prevExecutionContext;
+  if (null !== workInProgress) return 0;
+  workInProgressRoot = null;
+  workInProgressRootRenderLanes = 0;
+  finishQueueingConcurrentUpdates();
+  return workInProgressRootExitStatus;
+}
+function workLoopConcurrentByScheduler() {
+  for (; null !== workInProgress && !shouldYield(); )
+    performUnitOfWork(workInProgress);
+}
+function performUnitOfWork(unitOfWork) {
+  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
+}
+function replaySuspendedUnitOfWork(unitOfWork) {
+  var next = unitOfWork;
+  var current = next.alternate;
+  switch (next.tag) {
+    case 15:
+    case 0:
+      next = replayFunctionComponent(
+        current,
+        next,
+        next.pendingProps,
+        next.type,
+        void 0,
+        workInProgressRootRenderLanes
+      );
+      break;
+    case 11:
+      next = replayFunctionComponent(
+        current,
+        next,
+        next.pendingProps,
+        next.type.render,
+        next.ref,
+        workInProgressRootRenderLanes
+      );
+      break;
+    case 5:
+      resetHooksOnUnwind(next);
+    default:
+      unwindInterruptedWork(current, next),
+        (next = workInProgress =
+          resetWorkInProgress(next, entangledRenderLanes)),
+        (next = beginWork(current, next, entangledRenderLanes));
+  }
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
+}
+function throwAndUnwindWorkLoop(
+  root,
+  unitOfWork,
+  thrownValue,
+  suspendedReason
+) {
+  lastContextDependency = currentlyRenderingFiber$1 = null;
+  resetHooksOnUnwind(unitOfWork);
+  thenableState = null;
+  thenableIndexCounter = 0;
+  var returnFiber = unitOfWork.return;
+  try {
+    if (
+      throwException(
+        root,
+        returnFiber,
+        unitOfWork,
+        thrownValue,
+        workInProgressRootRenderLanes
+      )
+    ) {
+      workInProgressRootExitStatus = 1;
+      logUncaughtError(
+        root,
+        createCapturedValueAtFiber(thrownValue, root.current)
+      );
+      workInProgress = null;
+      return;
+    }
+  } catch (error) {
+    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
+    workInProgressRootExitStatus = 1;
+    logUncaughtError(
+      root,
+      createCapturedValueAtFiber(thrownValue, root.current)
+    );
+    workInProgress = null;
+    return;
+  }
+  if (unitOfWork.flags & 32768) {
+    if (isHydrating || 1 === suspendedReason) root = !0;
+    else if (
+      workInProgressRootIsPrerendering ||
+      0 !== (workInProgressRootRenderLanes & 536870912)
+    )
+      root = !1;
+    else if (
+      ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
+      2 === suspendedReason ||
+        9 === suspendedReason ||
+        3 === suspendedReason ||
+        6 === suspendedReason)
+    )
+      (suspendedReason = suspenseHandlerStackCursor.current),
+        null !== suspendedReason &&
+          13 === suspendedReason.tag &&
+          (suspendedReason.flags |= 16384);
+    unwindUnitOfWork(unitOfWork, root);
+  } else completeUnitOfWork(unitOfWork);
+}
+function completeUnitOfWork(unitOfWork) {
+  var completedWork = unitOfWork;
+  do {
+    if (0 !== (completedWork.flags & 32768)) {
+      unwindUnitOfWork(
+        completedWork,
+        workInProgressRootDidSkipSuspendedSiblings
+      );
+      return;
+    }
+    unitOfWork = completedWork.return;
+    var next = completeWork(
+      completedWork.alternate,
+      completedWork,
+      entangledRenderLanes
+    );
+    if (null !== next) {
+      workInProgress = next;
+      return;
+    }
+    completedWork = completedWork.sibling;
+    if (null !== completedWork) {
+      workInProgress = completedWork;
+      return;
+    }
+    workInProgress = completedWork = unitOfWork;
+  } while (null !== completedWork);
+  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
+}
+function unwindUnitOfWork(unitOfWork, skipSiblings) {
+  do {
+    var next = unwindWork(unitOfWork.alternate, unitOfWork);
+    if (null !== next) {
+      next.flags &= 32767;
+      workInProgress = next;
+      return;
+    }
+    next = unitOfWork.return;
+    null !== next &&
+      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));
+    if (
+      !skipSiblings &&
+      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
+    ) {
+      workInProgress = unitOfWork;
+      return;
+    }
+    workInProgress = unitOfWork = next;
+  } while (null !== unitOfWork);
+  workInProgressRootExitStatus = 6;
+  workInProgress = null;
+}
+function commitRoot(
+  root,
+  finishedWork,
+  lanes,
+  recoverableErrors,
+  transitions,
+  appearingViewTransitions,
+  didIncludeRenderPhaseUpdate,
+  spawnedLane,
+  updatedLanes,
+  suspendedRetryLanes
+) {
+  root.cancelPendingCommit = null;
+  do flushPendingEffects();
+  while (0 !== pendingEffectsStatus);
+  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
+  if (null !== finishedWork) {
+    if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
+    didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
+    didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
+    markRootFinished(
+      root,
+      lanes,
+      didIncludeRenderPhaseUpdate,
+      spawnedLane,
+      updatedLanes,
+      suspendedRetryLanes
+    );
+    root === workInProgressRoot &&
+      ((workInProgress = workInProgressRoot = null),
+      (workInProgressRootRenderLanes = 0));
+    pendingFinishedWork = finishedWork;
+    pendingEffectsRoot = root;
+    pendingEffectsLanes = lanes;
+    pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
+    pendingPassiveTransitions = transitions;
+    pendingRecoverableErrors = recoverableErrors;
+    pendingViewTransitionEvents = null;
+    recoverableErrors = (lanes & 335544192) === lanes ? 10262 : 10256;
+    0 !== (finishedWork.subtreeFlags & recoverableErrors) ||
+    0 !== (finishedWork.flags & recoverableErrors)
+      ? ((root.callbackNode = null),
+        (root.callbackPriority = 0),
+        scheduleCallback$1(NormalPriority$1, function () {
+          flushPassiveEffects(!0);
+          return null;
+        }))
+      : ((root.callbackNode = null), (root.callbackPriority = 0));
+    recoverableErrors = 0 !== (finishedWork.flags & 13878);
+    if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
+      recoverableErrors = ReactSharedInternals.T;
+      ReactSharedInternals.T = null;
+      transitions = ReactDOMSharedInternals.p;
+      ReactDOMSharedInternals.p = 2;
+      spawnedLane = executionContext;
+      executionContext |= 4;
+      try {
+        commitBeforeMutationEffects(
+          root,
+          finishedWork,
+          lanes,
+          appearingViewTransitions
+        );
+      } finally {
+        (executionContext = spawnedLane),
+          (ReactDOMSharedInternals.p = transitions),
+          (ReactSharedInternals.T = recoverableErrors);
+      }
+    }
+    pendingEffectsStatus = 1;
+    (shouldStartViewTransition &&
+      startViewTransition(
+        root.containerInfo,
+        flushMutationEffects,
+        flushLayoutEffects,
+        flushAfterMutationEffects,
+        flushSpawnedWork,
+        flushPassiveEffects
+      )) ||
+      (flushMutationEffects(), flushLayoutEffects(), flushSpawnedWork());
+  }
+}
+function flushAfterMutationEffects() {
+  3 === pendingEffectsStatus &&
+    ((pendingEffectsStatus = 0),
+    commitAfterMutationEffectsOnFiber(pendingFinishedWork, pendingEffectsRoot),
+    (pendingEffectsStatus = 4));
+}
+function flushMutationEffects() {
+  if (1 === pendingEffectsStatus) {
+    pendingEffectsStatus = 0;
+    var root = pendingEffectsRoot,
+      finishedWork = pendingFinishedWork,
+      lanes = pendingEffectsLanes,
+      rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
+    if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
+      rootMutationHasEffect = ReactSharedInternals.T;
+      ReactSharedInternals.T = null;
+      var previousPriority = ReactDOMSharedInternals.p;
+      ReactDOMSharedInternals.p = 2;
+      var prevExecutionContext = executionContext;
+      executionContext |= 4;
+      try {
+        commitMutationEffectsOnFiber(finishedWork, root, lanes);
+        lanes = selectionInformation;
+        var curFocusedElem = getActiveElementDeep(root.containerInfo),
+          priorFocusedElem = lanes.focusedElem,
+          priorSelectionRange = lanes.selectionRange;
+        if (
+          curFocusedElem !== priorFocusedElem &&
+          priorFocusedElem &&
+          priorFocusedElem.ownerDocument &&
+          containsNode(
+            priorFocusedElem.ownerDocument.documentElement,
+            priorFocusedElem
+          )
+        ) {
+          if (
+            null !== priorSelectionRange &&
+            hasSelectionCapabilities(priorFocusedElem)
+          ) {
+            var start = priorSelectionRange.start,
+              end = priorSelectionRange.end;
+            void 0 === end && (end = start);
+            if ("selectionStart" in priorFocusedElem)
+              (priorFocusedElem.selectionStart = start),
+                (priorFocusedElem.selectionEnd = Math.min(
+                  end,
+                  priorFocusedElem.value.length
+                ));
+            else {
+              var doc = priorFocusedElem.ownerDocument || document,
+                win = (doc && doc.defaultView) || window;
+              if (win.getSelection) {
+                var selection = win.getSelection(),
+                  length = priorFocusedElem.textContent.length,
+                  start$jscomp$0 = Math.min(priorSelectionRange.start, length),
+                  end$jscomp$0 =
+                    void 0 === priorSelectionRange.end
+                      ? start$jscomp$0
+                      : Math.min(priorSelectionRange.end, length);
+                !selection.extend &&
+                  start$jscomp$0 > end$jscomp$0 &&
+                  ((curFocusedElem = end$jscomp$0),
+                  (end$jscomp$0 = start$jscomp$0),
+                  (start$jscomp$0 = curFocusedElem));
+                var startMarker = getNodeForCharacterOffset(
+                    priorFocusedElem,
+                    start$jscomp$0
+                  ),
+                  endMarker = getNodeForCharacterOffset(
+                    priorFocusedElem,
+                    end$jscomp$0
+                  );
+                if (
+                  startMarker &&
+                  endMarker &&
+                  (1 !== selection.rangeCount ||
+                    selection.anchorNode !== startMarker.node ||
+                    selection.anchorOffset !== startMarker.offset ||
+                    selection.focusNode !== endMarker.node ||
+                    selection.focusOffset !== endMarker.offset)
+                ) {
+                  var range = doc.createRange();
+                  range.setStart(startMarker.node, startMarker.offset);
+                  selection.removeAllRanges();
+                  start$jscomp$0 > end$jscomp$0
+                    ? (selection.addRange(range),
+                      selection.extend(endMarker.node, endMarker.offset))
+                    : (range.setEnd(endMarker.node, endMarker.offset),
+                      selection.addRange(range));
+                }
+              }
+            }
+          }
+          doc = [];
+          for (
+            selection = priorFocusedElem;
+            (selection = selection.parentNode);
+
+          )
+            1 === selection.nodeType &&
+              doc.push({
+                element: selection,
+                left: selection.scrollLeft,
+                top: selection.scrollTop
+              });
+          "function" === typeof priorFocusedElem.focus &&
+            priorFocusedElem.focus();
+          for (
+            priorFocusedElem = 0;
+            priorFocusedElem < doc.length;
+            priorFocusedElem++
+          ) {
+            var info = doc[priorFocusedElem];
+            info.element.scrollLeft = info.left;
+            info.element.scrollTop = info.top;
+          }
+        }
+        _enabled = !!eventsEnabled;
+        selectionInformation = eventsEnabled = null;
+      } finally {
+        (executionContext = prevExecutionContext),
+          (ReactDOMSharedInternals.p = previousPriority),
+          (ReactSharedInternals.T = rootMutationHasEffect);
+      }
+    }
+    root.current = finishedWork;
+    pendingEffectsStatus = 2;
+  }
+}
+function flushLayoutEffects() {
+  if (2 === pendingEffectsStatus) {
+    pendingEffectsStatus = 0;
+    var root = pendingEffectsRoot,
+      finishedWork = pendingFinishedWork,
+      rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
+    if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
+      rootHasLayoutEffect = ReactSharedInternals.T;
+      ReactSharedInternals.T = null;
+      var previousPriority = ReactDOMSharedInternals.p;
+      ReactDOMSharedInternals.p = 2;
+      var prevExecutionContext = executionContext;
+      executionContext |= 4;
+      try {
+        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
+      } finally {
+        (executionContext = prevExecutionContext),
+          (ReactDOMSharedInternals.p = previousPriority),
+          (ReactSharedInternals.T = rootHasLayoutEffect);
+      }
+    }
+    pendingEffectsStatus = 3;
+  }
+}
+function flushSpawnedWork() {
+  if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
+    pendingEffectsStatus = 0;
+    requestPaint();
+    var root = pendingEffectsRoot,
+      finishedWork = pendingFinishedWork,
+      lanes = pendingEffectsLanes,
+      recoverableErrors = pendingRecoverableErrors,
+      passiveSubtreeMask = (lanes & 335544192) === lanes ? 10262 : 10256;
+    0 !== (finishedWork.subtreeFlags & passiveSubtreeMask) ||
+    0 !== (finishedWork.flags & passiveSubtreeMask)
+      ? (pendingEffectsStatus = 5)
+      : ((pendingEffectsStatus = 0),
+        (pendingEffectsRoot = null),
+        releaseRootPooledCache(root, root.pendingLanes));
+    passiveSubtreeMask = root.pendingLanes;
+    0 === passiveSubtreeMask && (legacyErrorBoundariesThatAlreadyFailed = null);
+    lanesToEventPriority(lanes);
+    finishedWork = finishedWork.stateNode;
+    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
+      try {
+        injectedHook.onCommitFiberRoot(
+          rendererID,
+          finishedWork,
+          void 0,
+          128 === (finishedWork.current.flags & 128)
+        );
+      } catch (err) {}
+    if (null !== recoverableErrors) {
+      finishedWork = ReactSharedInternals.T;
+      passiveSubtreeMask = ReactDOMSharedInternals.p;
+      ReactDOMSharedInternals.p = 2;
+      ReactSharedInternals.T = null;
+      try {
+        for (
+          var onRecoverableError = root.onRecoverableError, i = 0;
+          i < recoverableErrors.length;
+          i++
+        ) {
+          var recoverableError = recoverableErrors[i];
+          onRecoverableError(recoverableError.value, {
+            componentStack: recoverableError.stack
+          });
+        }
+      } finally {
+        (ReactSharedInternals.T = finishedWork),
+          (ReactDOMSharedInternals.p = passiveSubtreeMask);
+      }
+    }
+    recoverableErrors = pendingViewTransitionEvents;
+    if (null !== recoverableErrors)
+      for (
+        pendingViewTransitionEvents = null, onRecoverableError = 0;
+        onRecoverableError < recoverableErrors.length;
+        onRecoverableError++
+      )
+        (0, recoverableErrors[onRecoverableError])();
+    0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
+    ensureRootIsScheduled(root);
+    passiveSubtreeMask = root.pendingLanes;
+    0 !== (lanes & 4194218) && 0 !== (passiveSubtreeMask & 42)
+      ? root === rootWithNestedUpdates
+        ? nestedUpdateCount++
+        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
+      : (nestedUpdateCount = 0);
+    flushSyncWorkAcrossRoots_impl(0, !1);
+  }
+}
+function releaseRootPooledCache(root, remainingLanes) {
+  0 === (root.pooledCacheLanes &= remainingLanes) &&
+    ((remainingLanes = root.pooledCache),
+    null != remainingLanes &&
+      ((root.pooledCache = null), releaseCache(remainingLanes)));
+}
+function flushPendingEffects(wasDelayedCommit) {
+  flushMutationEffects();
+  flushLayoutEffects();
+  flushSpawnedWork();
+  return flushPassiveEffects(wasDelayedCommit);
+}
+function flushPassiveEffects() {
+  if (5 !== pendingEffectsStatus) return !1;
+  var root = pendingEffectsRoot,
+    remainingLanes = pendingEffectsRemainingLanes;
+  pendingEffectsRemainingLanes = 0;
+  var renderPriority = lanesToEventPriority(pendingEffectsLanes),
+    prevTransition = ReactSharedInternals.T,
+    previousPriority = ReactDOMSharedInternals.p;
+  try {
+    ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
+    ReactSharedInternals.T = null;
+    renderPriority = pendingPassiveTransitions;
+    pendingPassiveTransitions = null;
+    var root$jscomp$0 = pendingEffectsRoot,
+      lanes = pendingEffectsLanes;
+    pendingEffectsStatus = 0;
+    pendingEffectsRoot = null;
+    pendingEffectsLanes = 0;
+    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
+    var prevExecutionContext = executionContext;
+    executionContext |= 4;
+    commitPassiveUnmountOnFiber(root$jscomp$0.current);
+    commitPassiveMountOnFiber(
+      root$jscomp$0,
+      root$jscomp$0.current,
+      lanes,
+      renderPriority
+    );
+    executionContext = prevExecutionContext;
+    flushSyncWorkAcrossRoots_impl(0, !1);
+    if (
+      injectedHook &&
+      "function" === typeof injectedHook.onPostCommitFiberRoot
+    )
+      try {
+        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
+      } catch (err) {}
+    return !0;
+  } finally {
+    (ReactDOMSharedInternals.p = previousPriority),
+      (ReactSharedInternals.T = prevTransition),
+      releaseRootPooledCache(root, remainingLanes);
+  }
+}
+function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
+  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
+  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
+  null !== rootFiber &&
+    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
+}
+function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
+  if (3 === sourceFiber.tag)
+    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
+  else
+    for (; null !== nearestMountedAncestor; ) {
+      if (3 === nearestMountedAncestor.tag) {
+        captureCommitPhaseErrorOnRoot(
+          nearestMountedAncestor,
+          sourceFiber,
+          error
+        );
+        break;
+      } else if (1 === nearestMountedAncestor.tag) {
+        var instance = nearestMountedAncestor.stateNode;
+        if (
+          "function" ===
+            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
+          ("function" === typeof instance.componentDidCatch &&
+            (null === legacyErrorBoundariesThatAlreadyFailed ||
+              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+        ) {
+          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+          error = createClassErrorUpdate(2);
+          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
+          null !== instance &&
+            (initializeClassErrorUpdate(
+              error,
+              instance,
+              nearestMountedAncestor,
+              sourceFiber
+            ),
+            markRootUpdated$1(instance, 2),
+            ensureRootIsScheduled(instance));
+          break;
+        }
+      }
+      nearestMountedAncestor = nearestMountedAncestor.return;
+    }
+}
+function attachPingListener(root, wakeable, lanes) {
+  var pingCache = root.pingCache;
+  if (null === pingCache) {
+    pingCache = root.pingCache = new PossiblyWeakMap();
+    var threadIDs = new Set();
+    pingCache.set(wakeable, threadIDs);
+  } else
+    (threadIDs = pingCache.get(wakeable)),
+      void 0 === threadIDs &&
+        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
+  threadIDs.has(lanes) ||
+    ((workInProgressRootDidAttachPingListener = !0),
+    threadIDs.add(lanes),
+    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
+    wakeable.then(root, root));
+}
+function pingSuspendedRoot(root, wakeable, pingedLanes) {
+  var pingCache = root.pingCache;
+  null !== pingCache && pingCache.delete(wakeable);
+  root.pingedLanes |= root.suspendedLanes & pingedLanes;
+  root.warmLanes &= ~pingedLanes;
+  workInProgressRoot === root &&
+    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
+    (4 === workInProgressRootExitStatus ||
+    (3 === workInProgressRootExitStatus &&
+      (workInProgressRootRenderLanes & 62914560) ===
+        workInProgressRootRenderLanes &&
+      300 > now() - globalMostRecentFallbackTime)
+      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
+      : (workInProgressRootPingedLanes |= pingedLanes),
+    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
+      (workInProgressSuspendedRetryLanes = 0));
+  ensureRootIsScheduled(root);
+}
+function retryTimedOutBoundary(boundaryFiber, retryLane) {
+  0 === retryLane && (retryLane = claimNextRetryLane());
+  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
+  null !== boundaryFiber &&
+    (markRootUpdated$1(boundaryFiber, retryLane),
+    ensureRootIsScheduled(boundaryFiber));
+}
+function retryDehydratedSuspenseBoundary(boundaryFiber) {
+  var suspenseState = boundaryFiber.memoizedState,
+    retryLane = 0;
+  null !== suspenseState && (retryLane = suspenseState.retryLane);
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+}
+function resolveRetryWakeable(boundaryFiber, wakeable) {
+  var retryLane = 0;
+  switch (boundaryFiber.tag) {
+    case 13:
+      var retryCache = boundaryFiber.stateNode;
+      var suspenseState = boundaryFiber.memoizedState;
+      null !== suspenseState && (retryLane = suspenseState.retryLane);
+      break;
+    case 19:
+      retryCache = boundaryFiber.stateNode;
+      break;
+    case 22:
+      retryCache = boundaryFiber.stateNode._retryCache;
+      break;
+    default:
+      throw Error(formatProdErrorMessage(314));
+  }
+  null !== retryCache && retryCache.delete(wakeable);
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+}
+function scheduleCallback$1(priorityLevel, callback) {
+  return scheduleCallback$3(priorityLevel, callback);
+}
+var firstScheduledRoot = null,
+  lastScheduledRoot = null,
+  didScheduleMicrotask = !1,
+  mightHavePendingSyncWork = !1,
+  isFlushingWork = !1,
+  currentEventTransitionLane = 0;
+function ensureRootIsScheduled(root) {
+  root !== lastScheduledRoot &&
+    null === root.next &&
+    (null === lastScheduledRoot
+      ? (firstScheduledRoot = lastScheduledRoot = root)
+      : (lastScheduledRoot = lastScheduledRoot.next = root));
+  mightHavePendingSyncWork = !0;
+  didScheduleMicrotask ||
+    ((didScheduleMicrotask = !0), scheduleImmediateRootScheduleTask());
+}
+function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
+  if (!isFlushingWork && mightHavePendingSyncWork) {
+    isFlushingWork = !0;
+    do {
+      var didPerformSomeWork = !1;
+      for (var root$177 = firstScheduledRoot; null !== root$177; ) {
+        if (!onlyLegacy)
+          if (0 !== syncTransitionLanes) {
+            var pendingLanes = root$177.pendingLanes;
+            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
+            else {
+              var suspendedLanes = root$177.suspendedLanes,
+                pingedLanes = root$177.pingedLanes;
+              JSCompiler_inline_result =
+                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
+              JSCompiler_inline_result &=
+                pendingLanes & ~(suspendedLanes & ~pingedLanes);
+              JSCompiler_inline_result =
+                JSCompiler_inline_result & 201326677
+                  ? (JSCompiler_inline_result & 201326677) | 1
+                  : JSCompiler_inline_result
+                    ? JSCompiler_inline_result | 2
+                    : 0;
+            }
+            0 !== JSCompiler_inline_result &&
+              ((didPerformSomeWork = !0),
+              performSyncWorkOnRoot(root$177, JSCompiler_inline_result));
+          } else
+            (JSCompiler_inline_result = workInProgressRootRenderLanes),
+              (JSCompiler_inline_result = getNextLanes(
+                root$177,
+                root$177 === workInProgressRoot ? JSCompiler_inline_result : 0,
+                null !== root$177.cancelPendingCommit ||
+                  -1 !== root$177.timeoutHandle
+              )),
+              0 === (JSCompiler_inline_result & 3) ||
+                checkIfRootIsPrerendering(root$177, JSCompiler_inline_result) ||
+                ((didPerformSomeWork = !0),
+                performSyncWorkOnRoot(root$177, JSCompiler_inline_result));
+        root$177 = root$177.next;
+      }
+    } while (didPerformSomeWork);
+    isFlushingWork = !1;
+  }
+}
+function processRootScheduleInImmediateTask() {
+  processRootScheduleInMicrotask();
+}
+function processRootScheduleInMicrotask() {
+  mightHavePendingSyncWork = didScheduleMicrotask = !1;
+  var syncTransitionLanes = 0;
+  0 !== currentEventTransitionLane &&
+    (shouldAttemptEagerTransition() &&
+      (syncTransitionLanes = currentEventTransitionLane),
+    (currentEventTransitionLane = 0));
+  for (
+    var currentTime = now(), prev = null, root = firstScheduledRoot;
+    null !== root;
+
+  ) {
+    var next = root.next,
+      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
+    if (0 === nextLanes)
+      (root.next = null),
+        null === prev ? (firstScheduledRoot = next) : (prev.next = next),
+        null === next && (lastScheduledRoot = prev);
+    else if (
+      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
+    )
+      mightHavePendingSyncWork = !0;
+    root = next;
+  }
+  flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
+}
+function scheduleTaskForRootDuringMicrotask(root, currentTime) {
+  for (
+    var suspendedLanes = root.suspendedLanes,
+      pingedLanes = root.pingedLanes,
+      expirationTimes = root.expirationTimes,
+      lanes = root.pendingLanes & -62914561;
+    0 < lanes;
+
+  ) {
+    var index$3 = 31 - clz32(lanes),
+      lane = 1 << index$3,
+      expirationTime = expirationTimes[index$3];
+    if (-1 === expirationTime) {
+      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
+        expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
+    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
+    lanes &= ~lane;
+  }
+  currentTime = workInProgressRoot;
+  suspendedLanes = workInProgressRootRenderLanes;
+  suspendedLanes = getNextLanes(
+    root,
+    root === currentTime ? suspendedLanes : 0,
+    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
+  );
+  pingedLanes = root.callbackNode;
+  if (
+    0 === suspendedLanes ||
+    (root === currentTime &&
+      (2 === workInProgressSuspendedReason ||
+        9 === workInProgressSuspendedReason)) ||
+    null !== root.cancelPendingCommit
+  )
+    return (
+      null !== pingedLanes &&
+        null !== pingedLanes &&
+        cancelCallback$1(pingedLanes),
+      (root.callbackNode = null),
+      (root.callbackPriority = 0)
+    );
+  if (
+    0 === (suspendedLanes & 3) ||
+    checkIfRootIsPrerendering(root, suspendedLanes)
+  ) {
+    currentTime = suspendedLanes & -suspendedLanes;
+    if (currentTime === root.callbackPriority) return currentTime;
+    null !== pingedLanes && cancelCallback$1(pingedLanes);
+    switch (lanesToEventPriority(suspendedLanes)) {
+      case 2:
+      case 8:
+        suspendedLanes = UserBlockingPriority;
+        break;
+      case 32:
+        suspendedLanes = NormalPriority$1;
+        break;
+      case 268435456:
+        suspendedLanes = IdlePriority;
+        break;
+      default:
+        suspendedLanes = NormalPriority$1;
+    }
+    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
+    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
+    root.callbackPriority = currentTime;
+    root.callbackNode = suspendedLanes;
+    return currentTime;
+  }
+  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
+  root.callbackPriority = 2;
+  root.callbackNode = null;
+  return 2;
+}
+function performWorkOnRootViaSchedulerTask(root, didTimeout) {
+  if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
+    return (root.callbackNode = null), (root.callbackPriority = 0), null;
+  var originalCallbackNode = root.callbackNode;
+  if (flushPendingEffects(!0) && root.callbackNode !== originalCallbackNode)
+    return null;
+  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
+  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
+    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
+  );
+  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
+  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
+  scheduleTaskForRootDuringMicrotask(root, now());
+  return null != root.callbackNode && root.callbackNode === originalCallbackNode
+    ? performWorkOnRootViaSchedulerTask.bind(null, root)
+    : null;
+}
+function performSyncWorkOnRoot(root, lanes) {
+  if (flushPendingEffects()) return null;
+  performWorkOnRoot(root, lanes, !0);
+}
+function scheduleImmediateRootScheduleTask() {
+  scheduleMicrotask(function () {
+    0 !== (executionContext & 6)
+      ? scheduleCallback$3(
+          ImmediatePriority,
+          processRootScheduleInImmediateTask
+        )
+      : processRootScheduleInMicrotask();
+  });
+}
+function requestTransitionLane() {
+  0 === currentEventTransitionLane &&
+    (currentEventTransitionLane = claimNextTransitionLane());
+  return currentEventTransitionLane;
+}
+function coerceFormActionProp(actionProp) {
+  return null == actionProp ||
+    "symbol" === typeof actionProp ||
+    "boolean" === typeof actionProp
+    ? null
+    : "function" === typeof actionProp
+      ? actionProp
+      : sanitizeURL("" + actionProp);
+}
+function createFormDataWithSubmitter(form, submitter) {
+  var temp = submitter.ownerDocument.createElement("input");
+  temp.name = submitter.name;
+  temp.value = submitter.value;
+  form.id && temp.setAttribute("form", form.id);
+  submitter.parentNode.insertBefore(temp, submitter);
+  form = new FormData(form);
+  temp.parentNode.removeChild(temp);
+  return form;
+}
+function extractEvents$1(
+  dispatchQueue,
+  domEventName,
+  maybeTargetInst,
+  nativeEvent,
+  nativeEventTarget
+) {
+  if (
+    "submit" === domEventName &&
+    maybeTargetInst &&
+    maybeTargetInst.stateNode === nativeEventTarget
+  ) {
+    var action = coerceFormActionProp(
+        (nativeEventTarget[internalPropsKey] || null).action
+      ),
+      submitter = nativeEvent.submitter;
+    submitter &&
+      ((domEventName = (domEventName = submitter[internalPropsKey] || null)
+        ? coerceFormActionProp(domEventName.formAction)
+        : submitter.getAttribute("formAction")),
+      null !== domEventName && ((action = domEventName), (submitter = null)));
+    var event = new SyntheticEvent(
+      "action",
+      "action",
+      null,
+      nativeEvent,
+      nativeEventTarget
+    );
+    dispatchQueue.push({
+      event: event,
+      listeners: [
+        {
+          instance: null,
+          listener: function () {
+            if (nativeEvent.defaultPrevented) {
+              if (0 !== currentEventTransitionLane) {
+                var formData = submitter
+                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
+                  : new FormData(nativeEventTarget);
+                startHostTransition(
+                  maybeTargetInst,
+                  {
+                    pending: !0,
+                    data: formData,
+                    method: nativeEventTarget.method,
+                    action: action
+                  },
+                  null,
+                  formData
+                );
+              }
+            } else
+              "function" === typeof action &&
+                (event.preventDefault(),
+                (formData = submitter
+                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
+                  : new FormData(nativeEventTarget)),
+                startHostTransition(
+                  maybeTargetInst,
+                  {
+                    pending: !0,
+                    data: formData,
+                    method: nativeEventTarget.method,
+                    action: action
+                  },
+                  action,
+                  formData
+                ));
+          },
+          currentTarget: nativeEventTarget
+        }
+      ]
+    });
+  }
+}
+for (
+  var i$jscomp$inline_1581 = 0;
+  i$jscomp$inline_1581 < simpleEventPluginEvents.length;
+  i$jscomp$inline_1581++
+) {
+  var eventName$jscomp$inline_1582 =
+      simpleEventPluginEvents[i$jscomp$inline_1581],
+    domEventName$jscomp$inline_1583 =
+      eventName$jscomp$inline_1582.toLowerCase(),
+    capitalizedEvent$jscomp$inline_1584 =
+      eventName$jscomp$inline_1582[0].toUpperCase() +
+      eventName$jscomp$inline_1582.slice(1);
+  registerSimpleEvent(
+    domEventName$jscomp$inline_1583,
+    "on" + capitalizedEvent$jscomp$inline_1584
+  );
+}
+registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
+registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
+registerSimpleEvent(ANIMATION_START, "onAnimationStart");
+registerSimpleEvent("dblclick", "onDoubleClick");
+registerSimpleEvent("focusin", "onFocus");
+registerSimpleEvent("focusout", "onBlur");
+registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
+registerSimpleEvent(TRANSITION_START, "onTransitionStart");
+registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
+registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
+registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
+registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
+registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
+registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
+registerTwoPhaseEvent(
+  "onChange",
+  "change click focusin focusout input keydown keyup selectionchange".split(" ")
+);
+registerTwoPhaseEvent(
+  "onSelect",
+  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
+    " "
+  )
+);
+registerTwoPhaseEvent("onBeforeInput", [
+  "compositionend",
+  "keypress",
+  "textInput",
+  "paste"
+]);
+registerTwoPhaseEvent(
+  "onCompositionEnd",
+  "compositionend focusout keydown keypress keyup mousedown".split(" ")
+);
+registerTwoPhaseEvent(
+  "onCompositionStart",
+  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
+);
+registerTwoPhaseEvent(
+  "onCompositionUpdate",
+  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
+);
+var mediaEventTypes =
+    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
+      " "
+    ),
+  nonDelegatedEvents = new Set(
+    "beforetoggle cancel close invalid load scroll scrollend toggle"
+      .split(" ")
+      .concat(mediaEventTypes)
+  );
+function processDispatchQueue(dispatchQueue, eventSystemFlags) {
+  eventSystemFlags = 0 !== (eventSystemFlags & 4);
+  for (var i = 0; i < dispatchQueue.length; i++) {
+    var _dispatchQueue$i = dispatchQueue[i],
+      event = _dispatchQueue$i.event;
+    _dispatchQueue$i = _dispatchQueue$i.listeners;
+    a: {
+      var previousInstance = void 0;
+      if (eventSystemFlags)
+        for (
+          var i$jscomp$0 = _dispatchQueue$i.length - 1;
+          0 <= i$jscomp$0;
+          i$jscomp$0--
+        ) {
+          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
+            instance = _dispatchListeners$i.instance,
+            currentTarget = _dispatchListeners$i.currentTarget;
+          _dispatchListeners$i = _dispatchListeners$i.listener;
+          if (instance !== previousInstance && event.isPropagationStopped())
+            break a;
+          previousInstance = _dispatchListeners$i;
+          event.currentTarget = currentTarget;
+          try {
+            previousInstance(event);
+          } catch (error) {
+            reportGlobalError(error);
+          }
+          event.currentTarget = null;
+          previousInstance = instance;
+        }
+      else
+        for (
+          i$jscomp$0 = 0;
+          i$jscomp$0 < _dispatchQueue$i.length;
+          i$jscomp$0++
+        ) {
+          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
+          instance = _dispatchListeners$i.instance;
+          currentTarget = _dispatchListeners$i.currentTarget;
+          _dispatchListeners$i = _dispatchListeners$i.listener;
+          if (instance !== previousInstance && event.isPropagationStopped())
+            break a;
+          previousInstance = _dispatchListeners$i;
+          event.currentTarget = currentTarget;
+          try {
+            previousInstance(event);
+          } catch (error) {
+            reportGlobalError(error);
+          }
+          event.currentTarget = null;
+          previousInstance = instance;
+        }
+    }
+  }
+}
+function listenToNonDelegatedEvent(domEventName, targetElement) {
+  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
+  void 0 === JSCompiler_inline_result &&
+    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =
+      new Set());
+  var listenerSetKey = domEventName + "__bubble";
+  JSCompiler_inline_result.has(listenerSetKey) ||
+    (addTrappedEventListener(targetElement, domEventName, 2, !1),
+    JSCompiler_inline_result.add(listenerSetKey));
+}
+function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
+  var eventSystemFlags = 0;
+  isCapturePhaseListener && (eventSystemFlags |= 4);
+  addTrappedEventListener(
+    target,
+    domEventName,
+    eventSystemFlags,
+    isCapturePhaseListener
+  );
+}
+var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
+function listenToAllSupportedEvents(rootContainerElement) {
+  if (!rootContainerElement[listeningMarker]) {
+    rootContainerElement[listeningMarker] = !0;
+    allNativeEvents.forEach(function (domEventName) {
+      "selectionchange" !== domEventName &&
+        (nonDelegatedEvents.has(domEventName) ||
+          listenToNativeEvent(domEventName, !1, rootContainerElement),
+        listenToNativeEvent(domEventName, !0, rootContainerElement));
+    });
+    var ownerDocument =
+      9 === rootContainerElement.nodeType
+        ? rootContainerElement
+        : rootContainerElement.ownerDocument;
+    null === ownerDocument ||
+      ownerDocument[listeningMarker] ||
+      ((ownerDocument[listeningMarker] = !0),
+      listenToNativeEvent("selectionchange", !1, ownerDocument));
+  }
+}
+function addTrappedEventListener(
+  targetContainer,
+  domEventName,
+  eventSystemFlags,
+  isCapturePhaseListener
+) {
+  switch (getEventPriority(domEventName)) {
+    case 2:
+      var listenerWrapper = dispatchDiscreteEvent;
+      break;
+    case 8:
+      listenerWrapper = dispatchContinuousEvent;
+      break;
+    default:
+      listenerWrapper = dispatchEvent;
+  }
+  eventSystemFlags = listenerWrapper.bind(
+    null,
+    domEventName,
+    eventSystemFlags,
+    targetContainer
+  );
+  listenerWrapper = void 0;
+  !passiveBrowserEventsSupported ||
+    ("touchstart" !== domEventName &&
+      "touchmove" !== domEventName &&
+      "wheel" !== domEventName) ||
+    (listenerWrapper = !0);
+  isCapturePhaseListener
+    ? void 0 !== listenerWrapper
+      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
+          capture: !0,
+          passive: listenerWrapper
+        })
+      : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
+    : void 0 !== listenerWrapper
+      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
+          passive: listenerWrapper
+        })
+      : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
+}
+function dispatchEventForPluginEventSystem(
+  domEventName,
+  eventSystemFlags,
+  nativeEvent,
+  targetInst$jscomp$0,
+  targetContainer
+) {
+  var ancestorInst = targetInst$jscomp$0;
+  if (
+    0 === (eventSystemFlags & 1) &&
+    0 === (eventSystemFlags & 2) &&
+    null !== targetInst$jscomp$0
+  )
+    a: for (;;) {
+      if (null === targetInst$jscomp$0) return;
+      var nodeTag = targetInst$jscomp$0.tag;
+      if (3 === nodeTag || 4 === nodeTag) {
+        var container = targetInst$jscomp$0.stateNode.containerInfo;
+        if (
+          container === targetContainer ||
+          (8 === container.nodeType && container.parentNode === targetContainer)
+        )
+          break;
+        if (4 === nodeTag)
+          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
+            var grandTag = nodeTag.tag;
+            if (3 === grandTag || 4 === grandTag)
+              if (
+                ((grandTag = nodeTag.stateNode.containerInfo),
+                grandTag === targetContainer ||
+                  (8 === grandTag.nodeType &&
+                    grandTag.parentNode === targetContainer))
+              )
+                return;
+            nodeTag = nodeTag.return;
+          }
+        for (; null !== container; ) {
+          nodeTag = getClosestInstanceFromNode(container);
+          if (null === nodeTag) return;
+          grandTag = nodeTag.tag;
+          if (
+            5 === grandTag ||
+            6 === grandTag ||
+            26 === grandTag ||
+            27 === grandTag
+          ) {
+            targetInst$jscomp$0 = ancestorInst = nodeTag;
+            continue a;
+          }
+          container = container.parentNode;
+        }
+      }
+      targetInst$jscomp$0 = targetInst$jscomp$0.return;
+    }
+  batchedUpdates$1(function () {
+    var targetInst = ancestorInst,
+      nativeEventTarget = getEventTarget(nativeEvent),
+      dispatchQueue = [];
+    a: {
+      var reactName = topLevelEventsToReactNames.get(domEventName);
+      if (void 0 !== reactName) {
+        var SyntheticEventCtor = SyntheticEvent,
+          reactEventType = domEventName;
+        switch (domEventName) {
+          case "keypress":
+            if (0 === getEventCharCode(nativeEvent)) break a;
+          case "keydown":
+          case "keyup":
+            SyntheticEventCtor = SyntheticKeyboardEvent;
+            break;
+          case "focusin":
+            reactEventType = "focus";
+            SyntheticEventCtor = SyntheticFocusEvent;
+            break;
+          case "focusout":
+            reactEventType = "blur";
+            SyntheticEventCtor = SyntheticFocusEvent;
+            break;
+          case "beforeblur":
+          case "afterblur":
+            SyntheticEventCtor = SyntheticFocusEvent;
+            break;
+          case "click":
+            if (2 === nativeEvent.button) break a;
+          case "auxclick":
+          case "dblclick":
+          case "mousedown":
+          case "mousemove":
+          case "mouseup":
+          case "mouseout":
+          case "mouseover":
+          case "contextmenu":
+            SyntheticEventCtor = SyntheticMouseEvent;
+            break;
+          case "drag":
+          case "dragend":
+          case "dragenter":
+          case "dragexit":
+          case "dragleave":
+          case "dragover":
+          case "dragstart":
+          case "drop":
+            SyntheticEventCtor = SyntheticDragEvent;
+            break;
+          case "touchcancel":
+          case "touchend":
+          case "touchmove":
+          case "touchstart":
+            SyntheticEventCtor = SyntheticTouchEvent;
+            break;
+          case ANIMATION_END:
+          case ANIMATION_ITERATION:
+          case ANIMATION_START:
+            SyntheticEventCtor = SyntheticAnimationEvent;
+            break;
+          case TRANSITION_END:
+            SyntheticEventCtor = SyntheticTransitionEvent;
+            break;
+          case "scroll":
+          case "scrollend":
+            SyntheticEventCtor = SyntheticUIEvent;
+            break;
+          case "wheel":
+            SyntheticEventCtor = SyntheticWheelEvent;
+            break;
+          case "copy":
+          case "cut":
+          case "paste":
+            SyntheticEventCtor = SyntheticClipboardEvent;
+            break;
+          case "gotpointercapture":
+          case "lostpointercapture":
+          case "pointercancel":
+          case "pointerdown":
+          case "pointermove":
+          case "pointerout":
+          case "pointerover":
+          case "pointerup":
+            SyntheticEventCtor = SyntheticPointerEvent;
+            break;
+          case "toggle":
+          case "beforetoggle":
+            SyntheticEventCtor = SyntheticToggleEvent;
+        }
+        var inCapturePhase = 0 !== (eventSystemFlags & 4),
+          accumulateTargetOnly =
+            !inCapturePhase &&
+            ("scroll" === domEventName || "scrollend" === domEventName),
+          reactEventName = inCapturePhase
+            ? null !== reactName
+              ? reactName + "Capture"
+              : null
+            : reactName;
+        inCapturePhase = [];
+        for (
+          var instance = targetInst, lastHostComponent;
+          null !== instance;
+
+        ) {
+          var _instance = instance;
+          lastHostComponent = _instance.stateNode;
+          _instance = _instance.tag;
+          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
+            null === lastHostComponent ||
+            null === reactEventName ||
+            ((_instance = getListener(instance, reactEventName)),
+            null != _instance &&
+              inCapturePhase.push(
+                createDispatchListener(instance, _instance, lastHostComponent)
+              ));
+          if (accumulateTargetOnly) break;
+          instance = instance.return;
+        }
+        0 < inCapturePhase.length &&
+          ((reactName = new SyntheticEventCtor(
+            reactName,
+            reactEventType,
+            null,
+            nativeEvent,
+            nativeEventTarget
+          )),
+          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
+      }
+    }
+    if (0 === (eventSystemFlags & 7)) {
+      a: {
+        reactName =
+          "mouseover" === domEventName || "pointerover" === domEventName;
+        SyntheticEventCtor =
+          "mouseout" === domEventName || "pointerout" === domEventName;
+        if (
+          reactName &&
+          nativeEvent !== currentReplayingEvent &&
+          (reactEventType =
+            nativeEvent.relatedTarget || nativeEvent.fromElement) &&
+          (getClosestInstanceFromNode(reactEventType) ||
+            reactEventType[internalContainerInstanceKey])
+        )
+          break a;
+        if (SyntheticEventCtor || reactName) {
+          reactName =
+            nativeEventTarget.window === nativeEventTarget
+              ? nativeEventTarget
+              : (reactName = nativeEventTarget.ownerDocument)
+                ? reactName.defaultView || reactName.parentWindow
+                : window;
+          if (SyntheticEventCtor) {
+            if (
+              ((reactEventType =
+                nativeEvent.relatedTarget || nativeEvent.toElement),
+              (SyntheticEventCtor = targetInst),
+              (reactEventType = reactEventType
+                ? getClosestInstanceFromNode(reactEventType)
+                : null),
+              null !== reactEventType &&
+                ((accumulateTargetOnly =
+                  getNearestMountedFiber(reactEventType)),
+                (inCapturePhase = reactEventType.tag),
+                reactEventType !== accumulateTargetOnly ||
+                  (5 !== inCapturePhase &&
+                    27 !== inCapturePhase &&
+                    6 !== inCapturePhase)))
+            )
+              reactEventType = null;
+          } else (SyntheticEventCtor = null), (reactEventType = targetInst);
+          if (SyntheticEventCtor !== reactEventType) {
+            inCapturePhase = SyntheticMouseEvent;
+            _instance = "onMouseLeave";
+            reactEventName = "onMouseEnter";
+            instance = "mouse";
+            if ("pointerout" === domEventName || "pointerover" === domEventName)
+              (inCapturePhase = SyntheticPointerEvent),
+                (_instance = "onPointerLeave"),
+                (reactEventName = "onPointerEnter"),
+                (instance = "pointer");
+            accumulateTargetOnly =
+              null == SyntheticEventCtor
+                ? reactName
+                : getNodeFromInstance(SyntheticEventCtor);
+            lastHostComponent =
+              null == reactEventType
+                ? reactName
+                : getNodeFromInstance(reactEventType);
+            reactName = new inCapturePhase(
+              _instance,
+              instance + "leave",
+              SyntheticEventCtor,
+              nativeEvent,
+              nativeEventTarget
+            );
+            reactName.target = accumulateTargetOnly;
+            reactName.relatedTarget = lastHostComponent;
+            _instance = null;
+            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
+              ((inCapturePhase = new inCapturePhase(
+                reactEventName,
+                instance + "enter",
+                reactEventType,
+                nativeEvent,
+                nativeEventTarget
+              )),
+              (inCapturePhase.target = lastHostComponent),
+              (inCapturePhase.relatedTarget = accumulateTargetOnly),
+              (_instance = inCapturePhase));
+            accumulateTargetOnly = _instance;
+            if (SyntheticEventCtor && reactEventType)
+              b: {
+                inCapturePhase = SyntheticEventCtor;
+                reactEventName = reactEventType;
+                instance = 0;
+                for (
+                  lastHostComponent = inCapturePhase;
+                  lastHostComponent;
+                  lastHostComponent = getParent(lastHostComponent)
+                )
+                  instance++;
+                lastHostComponent = 0;
+                for (
+                  _instance = reactEventName;
+                  _instance;
+                  _instance = getParent(_instance)
+                )
+                  lastHostComponent++;
+                for (; 0 < instance - lastHostComponent; )
+                  (inCapturePhase = getParent(inCapturePhase)), instance--;
+                for (; 0 < lastHostComponent - instance; )
+                  (reactEventName = getParent(reactEventName)),
+                    lastHostComponent--;
+                for (; instance--; ) {
+                  if (
+                    inCapturePhase === reactEventName ||
+                    (null !== reactEventName &&
+                      inCapturePhase === reactEventName.alternate)
+                  )
+                    break b;
+                  inCapturePhase = getParent(inCapturePhase);
+                  reactEventName = getParent(reactEventName);
+                }
+                inCapturePhase = null;
+              }
+            else inCapturePhase = null;
+            null !== SyntheticEventCtor &&
+              accumulateEnterLeaveListenersForEvent(
+                dispatchQueue,
+                reactName,
+                SyntheticEventCtor,
+                inCapturePhase,
+                !1
+              );
+            null !== reactEventType &&
+              null !== accumulateTargetOnly &&
+              accumulateEnterLeaveListenersForEvent(
+                dispatchQueue,
+                accumulateTargetOnly,
+                reactEventType,
+                inCapturePhase,
+                !0
+              );
+          }
+        }
+      }
+      a: {
+        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
+        SyntheticEventCtor =
+          reactName.nodeName && reactName.nodeName.toLowerCase();
+        if (
+          "select" === SyntheticEventCtor ||
+          ("input" === SyntheticEventCtor && "file" === reactName.type)
+        )
+          var getTargetInstFunc = getTargetInstForChangeEvent;
+        else if (isTextInputElement(reactName))
+          if (isInputEventSupported)
+            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
+          else {
+            getTargetInstFunc = getTargetInstForInputEventPolyfill;
+            var handleEventFunc = handleEventsForInputEventPolyfill;
+          }
+        else
+          (SyntheticEventCtor = reactName.nodeName),
+            !SyntheticEventCtor ||
+            "input" !== SyntheticEventCtor.toLowerCase() ||
+            ("checkbox" !== reactName.type && "radio" !== reactName.type)
+              ? targetInst &&
+                isCustomElement(targetInst.elementType) &&
+                (getTargetInstFunc = getTargetInstForChangeEvent)
+              : (getTargetInstFunc = getTargetInstForClickEvent);
+        if (
+          getTargetInstFunc &&
+          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
+        ) {
+          createAndAccumulateChangeEvent(
+            dispatchQueue,
+            getTargetInstFunc,
+            nativeEvent,
+            nativeEventTarget
+          );
+          break a;
+        }
+        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
+        "focusout" === domEventName &&
+          targetInst &&
+          "number" === reactName.type &&
+          null != targetInst.memoizedProps.value &&
+          setDefaultValue(reactName, "number", reactName.value);
+      }
+      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
+      switch (domEventName) {
+        case "focusin":
+          if (
+            isTextInputElement(handleEventFunc) ||
+            "true" === handleEventFunc.contentEditable
+          )
+            (activeElement = handleEventFunc),
+              (activeElementInst = targetInst),
+              (lastSelection = null);
+          break;
+        case "focusout":
+          lastSelection = activeElementInst = activeElement = null;
+          break;
+        case "mousedown":
+          mouseDown = !0;
+          break;
+        case "contextmenu":
+        case "mouseup":
+        case "dragend":
+          mouseDown = !1;
+          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
+          break;
+        case "selectionchange":
+          if (skipSelectionChangeEvent) break;
+        case "keydown":
+        case "keyup":
+          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
+      }
+      var fallbackData;
+      if (canUseCompositionEvent)
+        b: {
+          switch (domEventName) {
+            case "compositionstart":
+              var eventType = "onCompositionStart";
+              break b;
+            case "compositionend":
+              eventType = "onCompositionEnd";
+              break b;
+            case "compositionupdate":
+              eventType = "onCompositionUpdate";
+              break b;
+          }
+          eventType = void 0;
+        }
+      else
+        isComposing
+          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
+            (eventType = "onCompositionEnd")
+          : "keydown" === domEventName &&
+            229 === nativeEvent.keyCode &&
+            (eventType = "onCompositionStart");
+      eventType &&
+        (useFallbackCompositionData &&
+          "ko" !== nativeEvent.locale &&
+          (isComposing || "onCompositionStart" !== eventType
+            ? "onCompositionEnd" === eventType &&
+              isComposing &&
+              (fallbackData = getData())
+            : ((root = nativeEventTarget),
+              (startText = "value" in root ? root.value : root.textContent),
+              (isComposing = !0))),
+        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),
+        0 < handleEventFunc.length &&
+          ((eventType = new SyntheticCompositionEvent(
+            eventType,
+            domEventName,
+            null,
+            nativeEvent,
+            nativeEventTarget
+          )),
+          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),
+          fallbackData
+            ? (eventType.data = fallbackData)
+            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
+              null !== fallbackData && (eventType.data = fallbackData))));
+      if (
+        (fallbackData = canUseTextInputEvent
+          ? getNativeBeforeInputChars(domEventName, nativeEvent)
+          : getFallbackBeforeInputChars(domEventName, nativeEvent))
+      )
+        (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")),
+          0 < eventType.length &&
+            ((handleEventFunc = new SyntheticCompositionEvent(
+              "onBeforeInput",
+              "beforeinput",
+              null,
+              nativeEvent,
+              nativeEventTarget
+            )),
+            dispatchQueue.push({
+              event: handleEventFunc,
+              listeners: eventType
+            }),
+            (handleEventFunc.data = fallbackData));
+      extractEvents$1(
+        dispatchQueue,
+        domEventName,
+        targetInst,
+        nativeEvent,
+        nativeEventTarget
+      );
+    }
+    processDispatchQueue(dispatchQueue, eventSystemFlags);
+  });
+}
+function createDispatchListener(instance, listener, currentTarget) {
+  return {
+    instance: instance,
+    listener: listener,
+    currentTarget: currentTarget
+  };
+}
+function accumulateTwoPhaseListeners(targetFiber, reactName) {
+  for (
+    var captureName = reactName + "Capture", listeners = [];
+    null !== targetFiber;
+
+  ) {
+    var _instance2 = targetFiber,
+      stateNode = _instance2.stateNode;
+    _instance2 = _instance2.tag;
+    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
+      null === stateNode ||
+      ((_instance2 = getListener(targetFiber, captureName)),
+      null != _instance2 &&
+        listeners.unshift(
+          createDispatchListener(targetFiber, _instance2, stateNode)
+        ),
+      (_instance2 = getListener(targetFiber, reactName)),
+      null != _instance2 &&
+        listeners.push(
+          createDispatchListener(targetFiber, _instance2, stateNode)
+        ));
+    targetFiber = targetFiber.return;
+  }
+  return listeners;
+}
+function getParent(inst) {
+  if (null === inst) return null;
+  do inst = inst.return;
+  while (inst && 5 !== inst.tag && 27 !== inst.tag);
+  return inst ? inst : null;
+}
+function accumulateEnterLeaveListenersForEvent(
+  dispatchQueue,
+  event,
+  target,
+  common,
+  inCapturePhase
+) {
+  for (
+    var registrationName = event._reactName, listeners = [];
+    null !== target && target !== common;
+
+  ) {
+    var _instance3 = target,
+      alternate = _instance3.alternate,
+      stateNode = _instance3.stateNode;
+    _instance3 = _instance3.tag;
+    if (null !== alternate && alternate === common) break;
+    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
+      null === stateNode ||
+      ((alternate = stateNode),
+      inCapturePhase
+        ? ((stateNode = getListener(target, registrationName)),
+          null != stateNode &&
+            listeners.unshift(
+              createDispatchListener(target, stateNode, alternate)
+            ))
+        : inCapturePhase ||
+          ((stateNode = getListener(target, registrationName)),
+          null != stateNode &&
+            listeners.push(
+              createDispatchListener(target, stateNode, alternate)
+            )));
+    target = target.return;
+  }
+  0 !== listeners.length &&
+    dispatchQueue.push({ event: event, listeners: listeners });
+}
+var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
+  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
+function normalizeMarkupForTextOrAttribute(markup) {
+  return ("string" === typeof markup ? markup : "" + markup)
+    .replace(NORMALIZE_NEWLINES_REGEX, "\n")
+    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
+}
+function checkForUnmatchedText(serverText, clientText) {
+  clientText = normalizeMarkupForTextOrAttribute(clientText);
+  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
+}
+function noop$1() {}
+function setProp(domElement, tag, key, value, props, prevValue) {
+  switch (key) {
+    case "children":
+      if ("string" === typeof value)
+        "body" === tag ||
+          ("textarea" === tag && "" === value) ||
+          setTextContent(domElement, value);
+      else if ("number" === typeof value || "bigint" === typeof value)
+        "body" !== tag && setTextContent(domElement, "" + value);
+      else return;
+      break;
+    case "className":
+      setValueForKnownAttribute(domElement, "class", value);
+      break;
+    case "tabIndex":
+      setValueForKnownAttribute(domElement, "tabindex", value);
+      break;
+    case "dir":
+    case "role":
+    case "viewBox":
+    case "width":
+    case "height":
+      setValueForKnownAttribute(domElement, key, value);
+      break;
+    case "style":
+      setValueForStyles(domElement, value, prevValue);
+      return;
+    case "data":
+      if ("object" !== tag) {
+        setValueForKnownAttribute(domElement, "data", value);
+        break;
+      }
+    case "src":
+    case "href":
+      if ("" === value && ("a" !== tag || "href" !== key)) {
+        domElement.removeAttribute(key);
+        break;
+      }
+      if (
+        null == value ||
+        "function" === typeof value ||
+        "symbol" === typeof value ||
+        "boolean" === typeof value
+      ) {
+        domElement.removeAttribute(key);
+        break;
+      }
+      value = sanitizeURL("" + value);
+      domElement.setAttribute(key, value);
+      break;
+    case "action":
+    case "formAction":
+      if ("function" === typeof value) {
+        domElement.setAttribute(
+          key,
+          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
+        );
+        break;
+      } else
+        "function" === typeof prevValue &&
+          ("formAction" === key
+            ? ("input" !== tag &&
+                setProp(domElement, tag, "name", props.name, props, null),
+              setProp(
+                domElement,
+                tag,
+                "formEncType",
+                props.formEncType,
+                props,
+                null
+              ),
+              setProp(
+                domElement,
+                tag,
+                "formMethod",
+                props.formMethod,
+                props,
+                null
+              ),
+              setProp(
+                domElement,
+                tag,
+                "formTarget",
+                props.formTarget,
+                props,
+                null
+              ))
+            : (setProp(domElement, tag, "encType", props.encType, props, null),
+              setProp(domElement, tag, "method", props.method, props, null),
+              setProp(domElement, tag, "target", props.target, props, null)));
+      if (
+        null == value ||
+        "symbol" === typeof value ||
+        "boolean" === typeof value
+      ) {
+        domElement.removeAttribute(key);
+        break;
+      }
+      value = sanitizeURL("" + value);
+      domElement.setAttribute(key, value);
+      break;
+    case "onClick":
+      null != value && (domElement.onclick = noop$1);
+      return;
+    case "onScroll":
+      null != value && listenToNonDelegatedEvent("scroll", domElement);
+      return;
+    case "onScrollEnd":
+      null != value && listenToNonDelegatedEvent("scrollend", domElement);
+      return;
+    case "dangerouslySetInnerHTML":
+      if (null != value) {
+        if ("object" !== typeof value || !("__html" in value))
+          throw Error(formatProdErrorMessage(61));
+        key = value.__html;
+        if (null != key) {
+          if (null != props.children) throw Error(formatProdErrorMessage(60));
+          domElement.innerHTML = key;
+        }
+      }
+      break;
+    case "multiple":
+      domElement.multiple =
+        value && "function" !== typeof value && "symbol" !== typeof value;
+      break;
+    case "muted":
+      domElement.muted =
+        value && "function" !== typeof value && "symbol" !== typeof value;
+      break;
+    case "suppressContentEditableWarning":
+    case "suppressHydrationWarning":
+    case "defaultValue":
+    case "defaultChecked":
+    case "innerHTML":
+    case "ref":
+      break;
+    case "autoFocus":
+      break;
+    case "xlinkHref":
+      if (
+        null == value ||
+        "function" === typeof value ||
+        "boolean" === typeof value ||
+        "symbol" === typeof value
+      ) {
+        domElement.removeAttribute("xlink:href");
+        break;
+      }
+      key = sanitizeURL("" + value);
+      domElement.setAttributeNS(
+        "http://www.w3.org/1999/xlink",
+        "xlink:href",
+        key
+      );
+      break;
+    case "contentEditable":
+    case "spellCheck":
+    case "draggable":
+    case "value":
+    case "autoReverse":
+    case "externalResourcesRequired":
+    case "focusable":
+    case "preserveAlpha":
+      null != value && "function" !== typeof value && "symbol" !== typeof value
+        ? domElement.setAttribute(key, "" + value)
+        : domElement.removeAttribute(key);
+      break;
+    case "inert":
+    case "allowFullScreen":
+    case "async":
+    case "autoPlay":
+    case "controls":
+    case "default":
+    case "defer":
+    case "disabled":
+    case "disablePictureInPicture":
+    case "disableRemotePlayback":
+    case "formNoValidate":
+    case "hidden":
+    case "loop":
+    case "noModule":
+    case "noValidate":
+    case "open":
+    case "playsInline":
+    case "readOnly":
+    case "required":
+    case "reversed":
+    case "scoped":
+    case "seamless":
+    case "itemScope":
+      value && "function" !== typeof value && "symbol" !== typeof value
+        ? domElement.setAttribute(key, "")
+        : domElement.removeAttribute(key);
+      break;
+    case "capture":
+    case "download":
+      !0 === value
+        ? domElement.setAttribute(key, "")
+        : !1 !== value &&
+            null != value &&
+            "function" !== typeof value &&
+            "symbol" !== typeof value
+          ? domElement.setAttribute(key, value)
+          : domElement.removeAttribute(key);
+      break;
+    case "cols":
+    case "rows":
+    case "size":
+    case "span":
+      null != value &&
+      "function" !== typeof value &&
+      "symbol" !== typeof value &&
+      !isNaN(value) &&
+      1 <= value
+        ? domElement.setAttribute(key, value)
+        : domElement.removeAttribute(key);
+      break;
+    case "rowSpan":
+    case "start":
+      null == value ||
+      "function" === typeof value ||
+      "symbol" === typeof value ||
+      isNaN(value)
+        ? domElement.removeAttribute(key)
+        : domElement.setAttribute(key, value);
+      break;
+    case "popover":
+      listenToNonDelegatedEvent("beforetoggle", domElement);
+      listenToNonDelegatedEvent("toggle", domElement);
+      setValueForAttribute(domElement, "popover", value);
+      break;
+    case "xlinkActuate":
+      setValueForNamespacedAttribute(
+        domElement,
+        "http://www.w3.org/1999/xlink",
+        "xlink:actuate",
+        value
+      );
+      break;
+    case "xlinkArcrole":
+      setValueForNamespacedAttribute(
+        domElement,
+        "http://www.w3.org/1999/xlink",
+        "xlink:arcrole",
+        value
+      );
+      break;
+    case "xlinkRole":
+      setValueForNamespacedAttribute(
+        domElement,
+        "http://www.w3.org/1999/xlink",
+        "xlink:role",
+        value
+      );
+      break;
+    case "xlinkShow":
+      setValueForNamespacedAttribute(
+        domElement,
+        "http://www.w3.org/1999/xlink",
+        "xlink:show",
+        value
+      );
+      break;
+    case "xlinkTitle":
+      setValueForNamespacedAttribute(
+        domElement,
+        "http://www.w3.org/1999/xlink",
+        "xlink:title",
+        value
+      );
+      break;
+    case "xlinkType":
+      setValueForNamespacedAttribute(
+        domElement,
+        "http://www.w3.org/1999/xlink",
+        "xlink:type",
+        value
+      );
+      break;
+    case "xmlBase":
+      setValueForNamespacedAttribute(
+        domElement,
+        "http://www.w3.org/XML/1998/namespace",
+        "xml:base",
+        value
+      );
+      break;
+    case "xmlLang":
+      setValueForNamespacedAttribute(
+        domElement,
+        "http://www.w3.org/XML/1998/namespace",
+        "xml:lang",
+        value
+      );
+      break;
+    case "xmlSpace":
+      setValueForNamespacedAttribute(
+        domElement,
+        "http://www.w3.org/XML/1998/namespace",
+        "xml:space",
+        value
+      );
+      break;
+    case "is":
+      setValueForAttribute(domElement, "is", value);
+      break;
+    case "innerText":
+    case "textContent":
+      return;
+    default:
+      if (
+        !(2 < key.length) ||
+        ("o" !== key[0] && "O" !== key[0]) ||
+        ("n" !== key[1] && "N" !== key[1])
+      )
+        (key = aliases.get(key) || key),
+          setValueForAttribute(domElement, key, value);
+      else return;
+  }
+  viewTransitionMutationContext = !0;
+}
+function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
+  switch (key) {
+    case "style":
+      setValueForStyles(domElement, value, prevValue);
+      return;
+    case "dangerouslySetInnerHTML":
+      if (null != value) {
+        if ("object" !== typeof value || !("__html" in value))
+          throw Error(formatProdErrorMessage(61));
+        key = value.__html;
+        if (null != key) {
+          if (null != props.children) throw Error(formatProdErrorMessage(60));
+          domElement.innerHTML = key;
+        }
+      }
+      break;
+    case "children":
+      if ("string" === typeof value) setTextContent(domElement, value);
+      else if ("number" === typeof value || "bigint" === typeof value)
+        setTextContent(domElement, "" + value);
+      else return;
+      break;
+    case "onScroll":
+      null != value && listenToNonDelegatedEvent("scroll", domElement);
+      return;
+    case "onScrollEnd":
+      null != value && listenToNonDelegatedEvent("scrollend", domElement);
+      return;
+    case "onClick":
+      null != value && (domElement.onclick = noop$1);
+      return;
+    case "suppressContentEditableWarning":
+    case "suppressHydrationWarning":
+    case "innerHTML":
+    case "ref":
+      return;
+    case "innerText":
+    case "textContent":
+      return;
+    default:
+      if (!registrationNameDependencies.hasOwnProperty(key))
+        a: {
+          if (
+            "o" === key[0] &&
+            "n" === key[1] &&
+            ((props = key.endsWith("Capture")),
+            (tag = key.slice(2, props ? key.length - 7 : void 0)),
+            (prevValue = domElement[internalPropsKey] || null),
+            (prevValue = null != prevValue ? prevValue[key] : null),
+            "function" === typeof prevValue &&
+              domElement.removeEventListener(tag, prevValue, props),
+            "function" === typeof value)
+          ) {
+            "function" !== typeof prevValue &&
+              null !== prevValue &&
+              (key in domElement
+                ? (domElement[key] = null)
+                : domElement.hasAttribute(key) &&
+                  domElement.removeAttribute(key));
+            domElement.addEventListener(tag, value, props);
+            break a;
+          }
+          viewTransitionMutationContext = !0;
+          key in domElement
+            ? (domElement[key] = value)
+            : !0 === value
+              ? domElement.setAttribute(key, "")
+              : setValueForAttribute(domElement, key, value);
+        }
+      return;
+  }
+  viewTransitionMutationContext = !0;
+}
+function setInitialProperties(domElement, tag, props) {
+  switch (tag) {
+    case "div":
+    case "span":
+    case "svg":
+    case "path":
+    case "a":
+    case "g":
+    case "p":
+    case "li":
+      break;
+    case "img":
+      listenToNonDelegatedEvent("error", domElement);
+      listenToNonDelegatedEvent("load", domElement);
+      var hasSrc = !1,
+        hasSrcSet = !1,
+        propKey;
+      for (propKey in props)
+        if (props.hasOwnProperty(propKey)) {
+          var propValue = props[propKey];
+          if (null != propValue)
+            switch (propKey) {
+              case "src":
+                hasSrc = !0;
+                break;
+              case "srcSet":
+                hasSrcSet = !0;
+                break;
+              case "children":
+              case "dangerouslySetInnerHTML":
+                throw Error(formatProdErrorMessage(137, tag));
+              default:
+                setProp(domElement, tag, propKey, propValue, props, null);
+            }
+        }
+      hasSrcSet &&
+        setProp(domElement, tag, "srcSet", props.srcSet, props, null);
+      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
+      return;
+    case "input":
+      listenToNonDelegatedEvent("invalid", domElement);
+      var defaultValue = (propKey = propValue = hasSrcSet = null),
+        checked = null,
+        defaultChecked = null;
+      for (hasSrc in props)
+        if (props.hasOwnProperty(hasSrc)) {
+          var propValue$191 = props[hasSrc];
+          if (null != propValue$191)
+            switch (hasSrc) {
+              case "name":
+                hasSrcSet = propValue$191;
+                break;
+              case "type":
+                propValue = propValue$191;
+                break;
+              case "checked":
+                checked = propValue$191;
+                break;
+              case "defaultChecked":
+                defaultChecked = propValue$191;
+                break;
+              case "value":
+                propKey = propValue$191;
+                break;
+              case "defaultValue":
+                defaultValue = propValue$191;
+                break;
+              case "children":
+              case "dangerouslySetInnerHTML":
+                if (null != propValue$191)
+                  throw Error(formatProdErrorMessage(137, tag));
+                break;
+              default:
+                setProp(domElement, tag, hasSrc, propValue$191, props, null);
+            }
+        }
+      initInput(
+        domElement,
+        propKey,
+        defaultValue,
+        checked,
+        defaultChecked,
+        propValue,
+        hasSrcSet,
+        !1
+      );
+      track(domElement);
+      return;
+    case "select":
+      listenToNonDelegatedEvent("invalid", domElement);
+      hasSrc = propValue = propKey = null;
+      for (hasSrcSet in props)
+        if (
+          props.hasOwnProperty(hasSrcSet) &&
+          ((defaultValue = props[hasSrcSet]), null != defaultValue)
+        )
+          switch (hasSrcSet) {
+            case "value":
+              propKey = defaultValue;
+              break;
+            case "defaultValue":
+              propValue = defaultValue;
+              break;
+            case "multiple":
+              hasSrc = defaultValue;
+            default:
+              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
+          }
+      tag = propKey;
+      props = propValue;
+      domElement.multiple = !!hasSrc;
+      null != tag
+        ? updateOptions(domElement, !!hasSrc, tag, !1)
+        : null != props && updateOptions(domElement, !!hasSrc, props, !0);
+      return;
+    case "textarea":
+      listenToNonDelegatedEvent("invalid", domElement);
+      propKey = hasSrcSet = hasSrc = null;
+      for (propValue in props)
+        if (
+          props.hasOwnProperty(propValue) &&
+          ((defaultValue = props[propValue]), null != defaultValue)
+        )
+          switch (propValue) {
+            case "value":
+              hasSrc = defaultValue;
+              break;
+            case "defaultValue":
+              hasSrcSet = defaultValue;
+              break;
+            case "children":
+              propKey = defaultValue;
+              break;
+            case "dangerouslySetInnerHTML":
+              if (null != defaultValue) throw Error(formatProdErrorMessage(91));
+              break;
+            default:
+              setProp(domElement, tag, propValue, defaultValue, props, null);
+          }
+      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
+      track(domElement);
+      return;
+    case "option":
+      for (checked in props)
+        if (
+          props.hasOwnProperty(checked) &&
+          ((hasSrc = props[checked]), null != hasSrc)
+        )
+          switch (checked) {
+            case "selected":
+              domElement.selected =
+                hasSrc &&
+                "function" !== typeof hasSrc &&
+                "symbol" !== typeof hasSrc;
+              break;
+            default:
+              setProp(domElement, tag, checked, hasSrc, props, null);
+          }
+      return;
+    case "dialog":
+      listenToNonDelegatedEvent("cancel", domElement);
+      listenToNonDelegatedEvent("close", domElement);
+      break;
+    case "iframe":
+    case "object":
+      listenToNonDelegatedEvent("load", domElement);
+      break;
+    case "video":
+    case "audio":
+      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
+        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
+      break;
+    case "image":
+      listenToNonDelegatedEvent("error", domElement);
+      listenToNonDelegatedEvent("load", domElement);
+      break;
+    case "details":
+      listenToNonDelegatedEvent("toggle", domElement);
+      break;
+    case "embed":
+    case "source":
+    case "link":
+      listenToNonDelegatedEvent("error", domElement),
+        listenToNonDelegatedEvent("load", domElement);
+    case "area":
+    case "base":
+    case "br":
+    case "col":
+    case "hr":
+    case "keygen":
+    case "meta":
+    case "param":
+    case "track":
+    case "wbr":
+    case "menuitem":
+      for (defaultChecked in props)
+        if (
+          props.hasOwnProperty(defaultChecked) &&
+          ((hasSrc = props[defaultChecked]), null != hasSrc)
+        )
+          switch (defaultChecked) {
+            case "children":
+            case "dangerouslySetInnerHTML":
+              throw Error(formatProdErrorMessage(137, tag));
+            default:
+              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
+          }
+      return;
+    default:
+      if (isCustomElement(tag)) {
+        for (propValue$191 in props)
+          props.hasOwnProperty(propValue$191) &&
+            ((hasSrc = props[propValue$191]),
+            void 0 !== hasSrc &&
+              setPropOnCustomElement(
+                domElement,
+                tag,
+                propValue$191,
+                hasSrc,
+                props,
+                void 0
+              ));
+        return;
+      }
+  }
+  for (defaultValue in props)
+    props.hasOwnProperty(defaultValue) &&
+      ((hasSrc = props[defaultValue]),
+      null != hasSrc &&
+        setProp(domElement, tag, defaultValue, hasSrc, props, null));
+}
+function updateProperties(domElement, tag, lastProps, nextProps) {
+  switch (tag) {
+    case "div":
+    case "span":
+    case "svg":
+    case "path":
+    case "a":
+    case "g":
+    case "p":
+    case "li":
+      break;
+    case "input":
+      var name = null,
+        type = null,
+        value = null,
+        defaultValue = null,
+        lastDefaultValue = null,
+        checked = null,
+        defaultChecked = null;
+      for (propKey in lastProps) {
+        var lastProp = lastProps[propKey];
+        if (lastProps.hasOwnProperty(propKey) && null != lastProp)
+          switch (propKey) {
+            case "checked":
+              break;
+            case "value":
+              break;
+            case "defaultValue":
+              lastDefaultValue = lastProp;
+            default:
+              nextProps.hasOwnProperty(propKey) ||
+                setProp(domElement, tag, propKey, null, nextProps, lastProp);
+          }
+      }
+      for (var propKey$208 in nextProps) {
+        var propKey = nextProps[propKey$208];
+        lastProp = lastProps[propKey$208];
+        if (
+          nextProps.hasOwnProperty(propKey$208) &&
+          (null != propKey || null != lastProp)
+        )
+          switch (propKey$208) {
+            case "type":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
+              type = propKey;
+              break;
+            case "name":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
+              name = propKey;
+              break;
+            case "checked":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
+              checked = propKey;
+              break;
+            case "defaultChecked":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
+              defaultChecked = propKey;
+              break;
+            case "value":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
+              value = propKey;
+              break;
+            case "defaultValue":
+              propKey !== lastProp && (viewTransitionMutationContext = !0);
+              defaultValue = propKey;
+              break;
+            case "children":
+            case "dangerouslySetInnerHTML":
+              if (null != propKey)
+                throw Error(formatProdErrorMessage(137, tag));
+              break;
+            default:
+              propKey !== lastProp &&
+                setProp(
+                  domElement,
+                  tag,
+                  propKey$208,
+                  propKey,
+                  nextProps,
+                  lastProp
+                );
+          }
+      }
+      updateInput(
+        domElement,
+        value,
+        defaultValue,
+        lastDefaultValue,
+        checked,
+        defaultChecked,
+        type,
+        name
+      );
+      return;
+    case "select":
+      propKey = value = defaultValue = propKey$208 = null;
+      for (type in lastProps)
+        if (
+          ((lastDefaultValue = lastProps[type]),
+          lastProps.hasOwnProperty(type) && null != lastDefaultValue)
+        )
+          switch (type) {
+            case "value":
+              break;
+            case "multiple":
+              propKey = lastDefaultValue;
+            default:
+              nextProps.hasOwnProperty(type) ||
+                setProp(
+                  domElement,
+                  tag,
+                  type,
+                  null,
+                  nextProps,
+                  lastDefaultValue
+                );
+          }
+      for (name in nextProps)
+        if (
+          ((type = nextProps[name]),
+          (lastDefaultValue = lastProps[name]),
+          nextProps.hasOwnProperty(name) &&
+            (null != type || null != lastDefaultValue))
+        )
+          switch (name) {
+            case "value":
+              type !== lastDefaultValue && (viewTransitionMutationContext = !0);
+              propKey$208 = type;
+              break;
+            case "defaultValue":
+              type !== lastDefaultValue && (viewTransitionMutationContext = !0);
+              defaultValue = type;
+              break;
+            case "multiple":
+              type !== lastDefaultValue && (viewTransitionMutationContext = !0),
+                (value = type);
+            default:
+              type !== lastDefaultValue &&
+                setProp(
+                  domElement,
+                  tag,
+                  name,
+                  type,
+                  nextProps,
+                  lastDefaultValue
+                );
+          }
+      tag = defaultValue;
+      lastProps = value;
+      nextProps = propKey;
+      null != propKey$208
+        ? updateOptions(domElement, !!lastProps, propKey$208, !1)
+        : !!nextProps !== !!lastProps &&
+          (null != tag
+            ? updateOptions(domElement, !!lastProps, tag, !0)
+            : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));
+      return;
+    case "textarea":
+      propKey = propKey$208 = null;
+      for (defaultValue in lastProps)
+        if (
+          ((name = lastProps[defaultValue]),
+          lastProps.hasOwnProperty(defaultValue) &&
+            null != name &&
+            !nextProps.hasOwnProperty(defaultValue))
+        )
+          switch (defaultValue) {
+            case "value":
+              break;
+            case "children":
+              break;
+            default:
+              setProp(domElement, tag, defaultValue, null, nextProps, name);
+          }
+      for (value in nextProps)
+        if (
+          ((name = nextProps[value]),
+          (type = lastProps[value]),
+          nextProps.hasOwnProperty(value) && (null != name || null != type))
+        )
+          switch (value) {
+            case "value":
+              name !== type && (viewTransitionMutationContext = !0);
+              propKey$208 = name;
+              break;
+            case "defaultValue":
+              name !== type && (viewTransitionMutationContext = !0);
+              propKey = name;
+              break;
+            case "children":
+              break;
+            case "dangerouslySetInnerHTML":
+              if (null != name) throw Error(formatProdErrorMessage(91));
+              break;
+            default:
+              name !== type &&
+                setProp(domElement, tag, value, name, nextProps, type);
+          }
+      updateTextarea(domElement, propKey$208, propKey);
+      return;
+    case "option":
+      for (var propKey$224 in lastProps)
+        if (
+          ((propKey$208 = lastProps[propKey$224]),
+          lastProps.hasOwnProperty(propKey$224) &&
+            null != propKey$208 &&
+            !nextProps.hasOwnProperty(propKey$224))
+        )
+          switch (propKey$224) {
+            case "selected":
+              domElement.selected = !1;
+              break;
+            default:
+              setProp(
+                domElement,
+                tag,
+                propKey$224,
+                null,
+                nextProps,
+                propKey$208
+              );
+          }
+      for (lastDefaultValue in nextProps)
+        if (
+          ((propKey$208 = nextProps[lastDefaultValue]),
+          (propKey = lastProps[lastDefaultValue]),
+          nextProps.hasOwnProperty(lastDefaultValue) &&
+            propKey$208 !== propKey &&
+            (null != propKey$208 || null != propKey))
+        )
+          switch (lastDefaultValue) {
+            case "selected":
+              propKey$208 !== propKey && (viewTransitionMutationContext = !0);
+              domElement.selected =
+                propKey$208 &&
+                "function" !== typeof propKey$208 &&
+                "symbol" !== typeof propKey$208;
+              break;
+            default:
+              setProp(
+                domElement,
+                tag,
+                lastDefaultValue,
+                propKey$208,
+                nextProps,
+                propKey
+              );
+          }
+      return;
+    case "img":
+    case "link":
+    case "area":
+    case "base":
+    case "br":
+    case "col":
+    case "embed":
+    case "hr":
+    case "keygen":
+    case "meta":
+    case "param":
+    case "source":
+    case "track":
+    case "wbr":
+    case "menuitem":
+      for (var propKey$229 in lastProps)
+        (propKey$208 = lastProps[propKey$229]),
+          lastProps.hasOwnProperty(propKey$229) &&
+            null != propKey$208 &&
+            !nextProps.hasOwnProperty(propKey$229) &&
+            setProp(domElement, tag, propKey$229, null, nextProps, propKey$208);
+      for (checked in nextProps)
+        if (
+          ((propKey$208 = nextProps[checked]),
+          (propKey = lastProps[checked]),
+          nextProps.hasOwnProperty(checked) &&
+            propKey$208 !== propKey &&
+            (null != propKey$208 || null != propKey))
+        )
+          switch (checked) {
+            case "children":
+            case "dangerouslySetInnerHTML":
+              if (null != propKey$208)
+                throw Error(formatProdErrorMessage(137, tag));
+              break;
+            default:
+              setProp(
+                domElement,
+                tag,
+                checked,
+                propKey$208,
+                nextProps,
+                propKey
+              );
+          }
+      return;
+    default:
+      if (isCustomElement(tag)) {
+        for (var propKey$234 in lastProps)
+          (propKey$208 = lastProps[propKey$234]),
+            lastProps.hasOwnProperty(propKey$234) &&
+              void 0 !== propKey$208 &&
+              !nextProps.hasOwnProperty(propKey$234) &&
+              setPropOnCustomElement(
+                domElement,
+                tag,
+                propKey$234,
+                void 0,
+                nextProps,
+                propKey$208
+              );
+        for (defaultChecked in nextProps)
+          (propKey$208 = nextProps[defaultChecked]),
+            (propKey = lastProps[defaultChecked]),
+            !nextProps.hasOwnProperty(defaultChecked) ||
+              propKey$208 === propKey ||
+              (void 0 === propKey$208 && void 0 === propKey) ||
+              setPropOnCustomElement(
+                domElement,
+                tag,
+                defaultChecked,
+                propKey$208,
+                nextProps,
+                propKey
+              );
+        return;
+      }
+  }
+  for (var propKey$239 in lastProps)
+    (propKey$208 = lastProps[propKey$239]),
+      lastProps.hasOwnProperty(propKey$239) &&
+        null != propKey$208 &&
+        !nextProps.hasOwnProperty(propKey$239) &&
+        setProp(domElement, tag, propKey$239, null, nextProps, propKey$208);
+  for (lastProp in nextProps)
+    (propKey$208 = nextProps[lastProp]),
+      (propKey = lastProps[lastProp]),
+      !nextProps.hasOwnProperty(lastProp) ||
+        propKey$208 === propKey ||
+        (null == propKey$208 && null == propKey) ||
+        setProp(domElement, tag, lastProp, propKey$208, nextProps, propKey);
+}
+var eventsEnabled = null,
+  selectionInformation = null;
+function getOwnerDocumentFromRootContainer(rootContainerElement) {
+  return 9 === rootContainerElement.nodeType
+    ? rootContainerElement
+    : rootContainerElement.ownerDocument;
+}
+function getOwnHostContext(namespaceURI) {
+  switch (namespaceURI) {
+    case "http://www.w3.org/2000/svg":
+      return 1;
+    case "http://www.w3.org/1998/Math/MathML":
+      return 2;
+    default:
+      return 0;
+  }
+}
+function getChildHostContextProd(parentNamespace, type) {
+  if (0 === parentNamespace)
+    switch (type) {
+      case "svg":
+        return 1;
+      case "math":
+        return 2;
+      default:
+        return 0;
+    }
+  return 1 === parentNamespace && "foreignObject" === type
+    ? 0
+    : parentNamespace;
+}
+function shouldSetTextContent(type, props) {
+  return (
+    "textarea" === type ||
+    "noscript" === type ||
+    "string" === typeof props.children ||
+    "number" === typeof props.children ||
+    "bigint" === typeof props.children ||
+    ("object" === typeof props.dangerouslySetInnerHTML &&
+      null !== props.dangerouslySetInnerHTML &&
+      null != props.dangerouslySetInnerHTML.__html)
+  );
+}
+var currentPopstateTransitionEvent = null;
+function shouldAttemptEagerTransition() {
+  var event = window.event;
+  if (event && "popstate" === event.type) {
+    if (event === currentPopstateTransitionEvent) return !1;
+    currentPopstateTransitionEvent = event;
+    return !0;
+  }
+  currentPopstateTransitionEvent = null;
+  return !1;
+}
+var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
+  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
+  localPromise = "function" === typeof Promise ? Promise : void 0,
+  scheduleMicrotask =
+    "function" === typeof queueMicrotask
+      ? queueMicrotask
+      : "undefined" !== typeof localPromise
+        ? function (callback) {
+            return localPromise
+              .resolve(null)
+              .then(callback)
+              .catch(handleErrorInNextTick);
+          }
+        : scheduleTimeout;
+function handleErrorInNextTick(error) {
+  setTimeout(function () {
+    throw error;
+  });
+}
+function clearSuspenseBoundary(parentInstance, suspenseInstance) {
+  var node = suspenseInstance,
+    depth = 0;
+  do {
+    var nextNode = node.nextSibling;
+    parentInstance.removeChild(node);
+    if (nextNode && 8 === nextNode.nodeType)
+      if (((node = nextNode.data), "/$" === node)) {
+        if (0 === depth) {
+          parentInstance.removeChild(nextNode);
+          retryIfBlockedOn(suspenseInstance);
+          return;
+        }
+        depth--;
+      } else ("$" !== node && "$?" !== node && "$!" !== node) || depth++;
+    node = nextNode;
+  } while (node);
+  retryIfBlockedOn(suspenseInstance);
+}
+function restoreViewTransitionName(instance, props) {
+  props = props.style;
+  var viewTransitionName =
+    null != props
+      ? props.hasOwnProperty("viewTransitionName")
+        ? props.viewTransitionName
+        : props.hasOwnProperty("view-transition-name")
+          ? props["view-transition-name"]
+          : null
+      : null;
+  instance.style.viewTransitionName =
+    null == viewTransitionName || "boolean" === typeof viewTransitionName
+      ? ""
+      : ("" + viewTransitionName).trim();
+  props =
+    null != props
+      ? props.hasOwnProperty("viewTransitionClass")
+        ? props.viewTransitionClass
+        : props.hasOwnProperty("view-transition-class")
+          ? props["view-transition-class"]
+          : null
+      : null;
+  instance.style.viewTransitionClass =
+    null == props || "boolean" === typeof props ? "" : ("" + props).trim();
+}
+function measureInstance(instance) {
+  var ownerWindow = instance.ownerDocument.defaultView,
+    rect = instance.getBoundingClientRect();
+  instance = getComputedStyle(instance);
+  return {
+    rect: rect,
+    abs: "absolute" === instance.position || "fixed" === instance.position,
+    clip:
+      "none" !== instance.clipPath ||
+      "visible" !== instance.overflow ||
+      "none" !== instance.filter ||
+      "none" !== instance.mask ||
+      "none" !== instance.mask ||
+      "0px" !== instance.borderRadius,
+    view:
+      0 <= rect.bottom &&
+      0 <= rect.right &&
+      rect.top <= ownerWindow.innerHeight &&
+      rect.left <= ownerWindow.innerWidth
+  };
+}
+function startViewTransition(
+  rootContainer,
+  mutationCallback,
+  layoutCallback,
+  afterMutationCallback,
+  spawnedWorkCallback,
+  passiveCallback
+) {
+  var ownerDocument =
+    9 === rootContainer.nodeType ? rootContainer : rootContainer.ownerDocument;
+  try {
+    var transition = ownerDocument.startViewTransition({
+      update: function () {
+        var ownerWindow = ownerDocument.defaultView;
+        ownerWindow =
+          ownerWindow.navigation && ownerWindow.navigation.transition;
+        var previousFontLoadingStatus = ownerDocument.fonts.status;
+        mutationCallback();
+        if (
+          "loaded" === previousFontLoadingStatus &&
+          (ownerDocument.documentElement.clientHeight,
+          "loading" === ownerDocument.fonts.status)
+        )
+          return (
+            (previousFontLoadingStatus = Promise.race([
+              ownerDocument.fonts.ready,
+              new Promise(function (resolve) {
+                return setTimeout(resolve, 500);
+              })
+            ]).then(layoutCallback, layoutCallback)),
+            (ownerWindow
+              ? Promise.allSettled([
+                  ownerWindow.finished,
+                  previousFontLoadingStatus
+                ])
+              : previousFontLoadingStatus
+            ).then(afterMutationCallback, afterMutationCallback)
+          );
+        layoutCallback();
+        if (ownerWindow)
+          return ownerWindow.finished.then(
+            afterMutationCallback,
+            afterMutationCallback
+          );
+        afterMutationCallback();
+      },
+      types: null
+    });
+    ownerDocument.__reactViewTransition = transition;
+    transition.ready.then(spawnedWorkCallback, spawnedWorkCallback);
+    transition.finished.then(function () {
+      ownerDocument.__reactViewTransition = null;
+      passiveCallback();
+    });
+    return !0;
+  } catch (x) {
+    return !1;
+  }
+}
+function ViewTransitionPseudoElement(pseudo, name) {
+  this._scope = document.documentElement;
+  this._selector = "::view-transition-" + pseudo + "(" + name + ")";
+}
+ViewTransitionPseudoElement.prototype.animate = function (keyframes, options) {
+  options =
+    "number" === typeof options ? { duration: options } : assign({}, options);
+  options.pseudoElement = this._selector;
+  return this._scope.animate(keyframes, options);
+};
+ViewTransitionPseudoElement.prototype.getAnimations = function () {
+  for (
+    var scope = this._scope,
+      selector = this._selector,
+      animations = scope.getAnimations({ subtree: !0 }),
+      result = [],
+      i = 0;
+    i < animations.length;
+    i++
+  ) {
+    var effect = animations[i].effect;
+    null !== effect &&
+      effect.target === scope &&
+      effect.pseudoElement === selector &&
+      result.push(animations[i]);
+  }
+  return result;
+};
+function createViewTransitionInstance(name) {
+  return {
+    name: name,
+    group: new ViewTransitionPseudoElement("group", name),
+    imagePair: new ViewTransitionPseudoElement("image-pair", name),
+    old: new ViewTransitionPseudoElement("old", name),
+    new: new ViewTransitionPseudoElement("new", name)
+  };
+}
+function clearContainerSparingly(container) {
+  var nextNode = container.firstChild;
+  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
+  for (; nextNode; ) {
+    var node = nextNode;
+    nextNode = nextNode.nextSibling;
+    switch (node.nodeName) {
+      case "HTML":
+      case "HEAD":
+      case "BODY":
+        clearContainerSparingly(node);
+        detachDeletedInstance(node);
+        continue;
+      case "SCRIPT":
+      case "STYLE":
+        continue;
+      case "LINK":
+        if ("stylesheet" === node.rel.toLowerCase()) continue;
+    }
+    container.removeChild(node);
+  }
+}
+function canHydrateInstance(instance, type, props, inRootOrSingleton) {
+  for (; 1 === instance.nodeType; ) {
+    var anyProps = props;
+    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
+      if (
+        !inRootOrSingleton &&
+        ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
+      )
+        break;
+    } else if (!inRootOrSingleton)
+      if ("input" === type && "hidden" === instance.type) {
+        var name = null == anyProps.name ? null : "" + anyProps.name;
+        if (
+          "hidden" === anyProps.type &&
+          instance.getAttribute("name") === name
+        )
+          return instance;
+      } else return instance;
+    else if (!instance[internalHoistableMarker])
+      switch (type) {
+        case "meta":
+          if (!instance.hasAttribute("itemprop")) break;
+          return instance;
+        case "link":
+          name = instance.getAttribute("rel");
+          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
+            break;
+          else if (
+            name !== anyProps.rel ||
+            instance.getAttribute("href") !==
+              (null == anyProps.href || "" === anyProps.href
+                ? null
+                : anyProps.href) ||
+            instance.getAttribute("crossorigin") !==
+              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||
+            instance.getAttribute("title") !==
+              (null == anyProps.title ? null : anyProps.title)
+          )
+            break;
+          return instance;
+        case "style":
+          if (instance.hasAttribute("data-precedence")) break;
+          return instance;
+        case "script":
+          name = instance.getAttribute("src");
+          if (
+            (name !== (null == anyProps.src ? null : anyProps.src) ||
+              instance.getAttribute("type") !==
+                (null == anyProps.type ? null : anyProps.type) ||
+              instance.getAttribute("crossorigin") !==
+                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&
+            name &&
+            instance.hasAttribute("async") &&
+            !instance.hasAttribute("itemprop")
+          )
+            break;
+          return instance;
+        default:
+          return instance;
+      }
+    instance = getNextHydratable(instance.nextSibling);
+    if (null === instance) break;
+  }
+  return null;
+}
+function canHydrateTextInstance(instance, text, inRootOrSingleton) {
+  if ("" === text) return null;
+  for (; 3 !== instance.nodeType; ) {
+    if (
+      (1 !== instance.nodeType ||
+        "INPUT" !== instance.nodeName ||
+        "hidden" !== instance.type) &&
+      !inRootOrSingleton
+    )
+      return null;
+    instance = getNextHydratable(instance.nextSibling);
+    if (null === instance) return null;
+  }
+  return instance;
+}
+function isSuspenseInstanceFallback(instance) {
+  return (
+    "$!" === instance.data ||
+    ("$?" === instance.data && "complete" === instance.ownerDocument.readyState)
+  );
+}
+function registerSuspenseInstanceRetry(instance, callback) {
+  var ownerDocument = instance.ownerDocument;
+  if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
+    callback();
+  else {
+    var listener = function () {
+      callback();
+      ownerDocument.removeEventListener("DOMContentLoaded", listener);
+    };
+    ownerDocument.addEventListener("DOMContentLoaded", listener);
+    instance._reactRetry = listener;
+  }
+}
+function getNextHydratable(node) {
+  for (; null != node; node = node.nextSibling) {
+    var nodeType = node.nodeType;
+    if (1 === nodeType || 3 === nodeType) break;
+    if (8 === nodeType) {
+      nodeType = node.data;
+      if (
+        "$" === nodeType ||
+        "$!" === nodeType ||
+        "$?" === nodeType ||
+        "F!" === nodeType ||
+        "F" === nodeType
+      )
+        break;
+      if ("/$" === nodeType) return null;
+    }
+  }
+  return node;
+}
+function getParentSuspenseInstance(targetInstance) {
+  targetInstance = targetInstance.previousSibling;
+  for (var depth = 0; targetInstance; ) {
+    if (8 === targetInstance.nodeType) {
+      var data = targetInstance.data;
+      if ("$" === data || "$!" === data || "$?" === data) {
+        if (0 === depth) return targetInstance;
+        depth--;
+      } else "/$" === data && depth++;
+    }
+    targetInstance = targetInstance.previousSibling;
+  }
+  return null;
+}
+function getBoundingRect(node) {
+  node = node.getBoundingClientRect();
+  return { x: node.left, y: node.top, width: node.width, height: node.height };
+}
+function isHiddenSubtree(fiber) {
+  return 5 === fiber.tag && !0 === fiber.memoizedProps.hidden;
+}
+function setFocusIfFocusable(node) {
+  function handleFocus() {
+    didFocus = !0;
+  }
+  var didFocus = !1;
+  try {
+    node.addEventListener("focus", handleFocus),
+      (node.focus || HTMLElement.prototype.focus).call(node);
+  } finally {
+    node.removeEventListener("focus", handleFocus);
+  }
+  return didFocus;
+}
+function setupIntersectionObserver(targets, callback, options) {
+  var rectRatioCache = new Map();
+  targets.forEach(function (target) {
+    rectRatioCache.set(target, { rect: getBoundingRect(target), ratio: 0 });
+  });
+  var observer = new IntersectionObserver(function (entries) {
+    entries.forEach(function (entry) {
+      var boundingClientRect = entry.boundingClientRect;
+      rectRatioCache.set(entry.target, {
+        rect: {
+          x: boundingClientRect.left,
+          y: boundingClientRect.top,
+          width: boundingClientRect.width,
+          height: boundingClientRect.height
+        },
+        ratio: entry.intersectionRatio
+      });
+    });
+    callback(Array.from(rectRatioCache.values()));
+  }, options);
+  targets.forEach(function (target) {
+    observer.observe(target);
+  });
+  return {
+    disconnect: function () {
+      return observer.disconnect();
+    },
+    observe: function (target) {
+      rectRatioCache.set(target, { rect: getBoundingRect(target), ratio: 0 });
+      observer.observe(target);
+    },
+    unobserve: function (target) {
+      rectRatioCache.delete(target);
+      observer.unobserve(target);
+    }
+  };
+}
+function resolveSingletonInstance(type, props, rootContainerInstance) {
+  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
+  switch (type) {
+    case "html":
+      type = props.documentElement;
+      if (!type) throw Error(formatProdErrorMessage(452));
+      return type;
+    case "head":
+      type = props.head;
+      if (!type) throw Error(formatProdErrorMessage(453));
+      return type;
+    case "body":
+      type = props.body;
+      if (!type) throw Error(formatProdErrorMessage(454));
+      return type;
+    default:
+      throw Error(formatProdErrorMessage(451));
+  }
+}
+var preloadPropsMap = new Map(),
+  preconnectsSet = new Set();
+function getHoistableRoot(container) {
+  return "function" === typeof container.getRootNode
+    ? container.getRootNode()
+    : container.ownerDocument;
+}
+var previousDispatcher = ReactDOMSharedInternals.d;
+ReactDOMSharedInternals.d = {
+  f: flushSyncWork,
+  r: requestFormReset,
+  D: prefetchDNS,
+  C: preconnect,
+  L: preload,
+  m: preloadModule,
+  X: preinitScript,
+  S: preinitStyle,
+  M: preinitModuleScript
+};
+function flushSyncWork() {
+  var previousWasRendering = previousDispatcher.f(),
+    wasRendering = flushSyncWork$1();
+  return previousWasRendering || wasRendering;
+}
+function requestFormReset(form) {
+  var formInst = getInstanceFromNode(form);
+  null !== formInst && 5 === formInst.tag && "form" === formInst.type
+    ? requestFormReset$1(formInst)
+    : previousDispatcher.r(form);
+}
+var globalDocument = "undefined" === typeof document ? null : document;
+function preconnectAs(rel, href, crossOrigin) {
+  var ownerDocument = globalDocument;
+  if (ownerDocument && "string" === typeof href && href) {
+    var limitedEscapedHref =
+      escapeSelectorAttributeValueInsideDoubleQuotes(href);
+    limitedEscapedHref =
+      'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
+    "string" === typeof crossOrigin &&
+      (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
+    preconnectsSet.has(limitedEscapedHref) ||
+      (preconnectsSet.add(limitedEscapedHref),
+      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
+      null === ownerDocument.querySelector(limitedEscapedHref) &&
+        ((href = ownerDocument.createElement("link")),
+        setInitialProperties(href, "link", rel),
+        markNodeAsHoistable(href),
+        ownerDocument.head.appendChild(href)));
+  }
+}
+function prefetchDNS(href) {
+  previousDispatcher.D(href);
+  preconnectAs("dns-prefetch", href, null);
+}
+function preconnect(href, crossOrigin) {
+  previousDispatcher.C(href, crossOrigin);
+  preconnectAs("preconnect", href, crossOrigin);
+}
+function preload(href, as, options) {
+  previousDispatcher.L(href, as, options);
+  var ownerDocument = globalDocument;
+  if (ownerDocument && href && as) {
+    var preloadSelector =
+      'link[rel="preload"][as="' +
+      escapeSelectorAttributeValueInsideDoubleQuotes(as) +
+      '"]';
+    "image" === as
+      ? options && options.imageSrcSet
+        ? ((preloadSelector +=
+            '[imagesrcset="' +
+            escapeSelectorAttributeValueInsideDoubleQuotes(
+              options.imageSrcSet
+            ) +
+            '"]'),
+          "string" === typeof options.imageSizes &&
+            (preloadSelector +=
+              '[imagesizes="' +
+              escapeSelectorAttributeValueInsideDoubleQuotes(
+                options.imageSizes
+              ) +
+              '"]'))
+        : (preloadSelector +=
+            '[href="' +
+            escapeSelectorAttributeValueInsideDoubleQuotes(href) +
+            '"]')
+      : (preloadSelector +=
+          '[href="' +
+          escapeSelectorAttributeValueInsideDoubleQuotes(href) +
+          '"]');
+    var key = preloadSelector;
+    switch (as) {
+      case "style":
+        key = getStyleKey(href);
+        break;
+      case "script":
+        key = getScriptKey(href);
+    }
+    preloadPropsMap.has(key) ||
+      ((href = assign(
+        {
+          rel: "preload",
+          href:
+            "image" === as && options && options.imageSrcSet ? void 0 : href,
+          as: as
+        },
+        options
+      )),
+      preloadPropsMap.set(key, href),
+      null !== ownerDocument.querySelector(preloadSelector) ||
+        ("style" === as &&
+          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||
+        ("script" === as &&
+          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
+        ((as = ownerDocument.createElement("link")),
+        setInitialProperties(as, "link", href),
+        markNodeAsHoistable(as),
+        ownerDocument.head.appendChild(as)));
+  }
+}
+function preloadModule(href, options) {
+  previousDispatcher.m(href, options);
+  var ownerDocument = globalDocument;
+  if (ownerDocument && href) {
+    var as = options && "string" === typeof options.as ? options.as : "script",
+      preloadSelector =
+        'link[rel="modulepreload"][as="' +
+        escapeSelectorAttributeValueInsideDoubleQuotes(as) +
+        '"][href="' +
+        escapeSelectorAttributeValueInsideDoubleQuotes(href) +
+        '"]',
+      key = preloadSelector;
+    switch (as) {
+      case "audioworklet":
+      case "paintworklet":
+      case "serviceworker":
+      case "sharedworker":
+      case "worker":
+      case "script":
+        key = getScriptKey(href);
+    }
+    if (
+      !preloadPropsMap.has(key) &&
+      ((href = assign({ rel: "modulepreload", href: href }, options)),
+      preloadPropsMap.set(key, href),
+      null === ownerDocument.querySelector(preloadSelector))
+    ) {
+      switch (as) {
+        case "audioworklet":
+        case "paintworklet":
+        case "serviceworker":
+        case "sharedworker":
+        case "worker":
+        case "script":
+          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
+            return;
+      }
+      as = ownerDocument.createElement("link");
+      setInitialProperties(as, "link", href);
+      markNodeAsHoistable(as);
+      ownerDocument.head.appendChild(as);
+    }
+  }
+}
+function preinitStyle(href, precedence, options) {
+  previousDispatcher.S(href, precedence, options);
+  var ownerDocument = globalDocument;
+  if (ownerDocument && href) {
+    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
+      key = getStyleKey(href);
+    precedence = precedence || "default";
+    var resource = styles.get(key);
+    if (!resource) {
+      var state = { loading: 0, preload: null };
+      if (
+        (resource = ownerDocument.querySelector(
+          getStylesheetSelectorFromKey(key)
+        ))
+      )
+        state.loading = 5;
+      else {
+        href = assign(
+          { rel: "stylesheet", href: href, "data-precedence": precedence },
+          options
+        );
+        (options = preloadPropsMap.get(key)) &&
+          adoptPreloadPropsForStylesheet(href, options);
+        var link = (resource = ownerDocument.createElement("link"));
+        markNodeAsHoistable(link);
+        setInitialProperties(link, "link", href);
+        link._p = new Promise(function (resolve, reject) {
+          link.onload = resolve;
+          link.onerror = reject;
+        });
+        link.addEventListener("load", function () {
+          state.loading |= 1;
+        });
+        link.addEventListener("error", function () {
+          state.loading |= 2;
+        });
+        state.loading |= 4;
+        insertStylesheet(resource, precedence, ownerDocument);
+      }
+      resource = {
+        type: "stylesheet",
+        instance: resource,
+        count: 1,
+        state: state
+      };
+      styles.set(key, resource);
+    }
+  }
+}
+function preinitScript(src, options) {
+  previousDispatcher.X(src, options);
+  var ownerDocument = globalDocument;
+  if (ownerDocument && src) {
+    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
+      key = getScriptKey(src),
+      resource = scripts.get(key);
+    resource ||
+      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
+      resource ||
+        ((src = assign({ src: src, async: !0 }, options)),
+        (options = preloadPropsMap.get(key)) &&
+          adoptPreloadPropsForScript(src, options),
+        (resource = ownerDocument.createElement("script")),
+        markNodeAsHoistable(resource),
+        setInitialProperties(resource, "link", src),
+        ownerDocument.head.appendChild(resource)),
+      (resource = {
+        type: "script",
+        instance: resource,
+        count: 1,
+        state: null
+      }),
+      scripts.set(key, resource));
+  }
+}
+function preinitModuleScript(src, options) {
+  previousDispatcher.M(src, options);
+  var ownerDocument = globalDocument;
+  if (ownerDocument && src) {
+    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
+      key = getScriptKey(src),
+      resource = scripts.get(key);
+    resource ||
+      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
+      resource ||
+        ((src = assign({ src: src, async: !0, type: "module" }, options)),
+        (options = preloadPropsMap.get(key)) &&
+          adoptPreloadPropsForScript(src, options),
+        (resource = ownerDocument.createElement("script")),
+        markNodeAsHoistable(resource),
+        setInitialProperties(resource, "link", src),
+        ownerDocument.head.appendChild(resource)),
+      (resource = {
+        type: "script",
+        instance: resource,
+        count: 1,
+        state: null
+      }),
+      scripts.set(key, resource));
+  }
+}
+function getResource(type, currentProps, pendingProps, currentResource) {
+  var JSCompiler_inline_result = (JSCompiler_inline_result =
+    rootInstanceStackCursor.current)
+    ? getHoistableRoot(JSCompiler_inline_result)
+    : null;
+  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
+  switch (type) {
+    case "meta":
+    case "title":
+      return null;
+    case "style":
+      return "string" === typeof pendingProps.precedence &&
+        "string" === typeof pendingProps.href
+        ? ((currentProps = getStyleKey(pendingProps.href)),
+          (pendingProps = getResourcesFromRoot(
+            JSCompiler_inline_result
+          ).hoistableStyles),
+          (currentResource = pendingProps.get(currentProps)),
+          currentResource ||
+            ((currentResource = {
+              type: "style",
+              instance: null,
+              count: 0,
+              state: null
+            }),
+            pendingProps.set(currentProps, currentResource)),
+          currentResource)
+        : { type: "void", instance: null, count: 0, state: null };
+    case "link":
+      if (
+        "stylesheet" === pendingProps.rel &&
+        "string" === typeof pendingProps.href &&
+        "string" === typeof pendingProps.precedence
+      ) {
+        type = getStyleKey(pendingProps.href);
+        var styles$247 = getResourcesFromRoot(
+            JSCompiler_inline_result
+          ).hoistableStyles,
+          resource$248 = styles$247.get(type);
+        resource$248 ||
+          ((JSCompiler_inline_result =
+            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
+          (resource$248 = {
+            type: "stylesheet",
+            instance: null,
+            count: 0,
+            state: { loading: 0, preload: null }
+          }),
+          styles$247.set(type, resource$248),
+          (styles$247 = JSCompiler_inline_result.querySelector(
+            getStylesheetSelectorFromKey(type)
+          )) &&
+            !styles$247._p &&
+            ((resource$248.instance = styles$247),
+            (resource$248.state.loading = 5)),
+          preloadPropsMap.has(type) ||
+            ((pendingProps = {
+              rel: "preload",
+              as: "style",
+              href: pendingProps.href,
+              crossOrigin: pendingProps.crossOrigin,
+              integrity: pendingProps.integrity,
+              media: pendingProps.media,
+              hrefLang: pendingProps.hrefLang,
+              referrerPolicy: pendingProps.referrerPolicy
+            }),
+            preloadPropsMap.set(type, pendingProps),
+            styles$247 ||
+              preloadStylesheet(
+                JSCompiler_inline_result,
+                type,
+                pendingProps,
+                resource$248.state
+              )));
+        if (currentProps && null === currentResource)
+          throw Error(formatProdErrorMessage(528, ""));
+        return resource$248;
+      }
+      if (currentProps && null !== currentResource)
+        throw Error(formatProdErrorMessage(529, ""));
+      return null;
+    case "script":
+      return (
+        (currentProps = pendingProps.async),
+        (pendingProps = pendingProps.src),
+        "string" === typeof pendingProps &&
+        currentProps &&
+        "function" !== typeof currentProps &&
+        "symbol" !== typeof currentProps
+          ? ((currentProps = getScriptKey(pendingProps)),
+            (pendingProps = getResourcesFromRoot(
+              JSCompiler_inline_result
+            ).hoistableScripts),
+            (currentResource = pendingProps.get(currentProps)),
+            currentResource ||
+              ((currentResource = {
+                type: "script",
+                instance: null,
+                count: 0,
+                state: null
+              }),
+              pendingProps.set(currentProps, currentResource)),
+            currentResource)
+          : { type: "void", instance: null, count: 0, state: null }
+      );
+    default:
+      throw Error(formatProdErrorMessage(444, type));
+  }
+}
+function getStyleKey(href) {
+  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
+}
+function getStylesheetSelectorFromKey(key) {
+  return 'link[rel="stylesheet"][' + key + "]";
+}
+function stylesheetPropsFromRawProps(rawProps) {
+  return assign({}, rawProps, {
+    "data-precedence": rawProps.precedence,
+    precedence: null
+  });
+}
+function preloadStylesheet(ownerDocument, key, preloadProps, state) {
+  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]")
+    ? (state.loading = 1)
+    : ((key = ownerDocument.createElement("link")),
+      (state.preload = key),
+      key.addEventListener("load", function () {
+        return (state.loading |= 1);
+      }),
+      key.addEventListener("error", function () {
+        return (state.loading |= 2);
+      }),
+      setInitialProperties(key, "link", preloadProps),
+      markNodeAsHoistable(key),
+      ownerDocument.head.appendChild(key));
+}
+function getScriptKey(src) {
+  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
+}
+function getScriptSelectorFromKey(key) {
+  return "script[async]" + key;
+}
+function acquireResource(hoistableRoot, resource, props) {
+  resource.count++;
+  if (null === resource.instance)
+    switch (resource.type) {
+      case "style":
+        var instance = hoistableRoot.querySelector(
+          'style[data-href~="' +
+            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
+            '"]'
+        );
+        if (instance)
+          return (
+            (resource.instance = instance),
+            markNodeAsHoistable(instance),
+            instance
+          );
+        var styleProps = assign({}, props, {
+          "data-href": props.href,
+          "data-precedence": props.precedence,
+          href: null,
+          precedence: null
+        });
+        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
+          "style"
+        );
+        markNodeAsHoistable(instance);
+        setInitialProperties(instance, "style", styleProps);
+        insertStylesheet(instance, props.precedence, hoistableRoot);
+        return (resource.instance = instance);
+      case "stylesheet":
+        styleProps = getStyleKey(props.href);
+        var instance$253 = hoistableRoot.querySelector(
+          getStylesheetSelectorFromKey(styleProps)
+        );
+        if (instance$253)
+          return (
+            (resource.state.loading |= 4),
+            (resource.instance = instance$253),
+            markNodeAsHoistable(instance$253),
+            instance$253
+          );
+        instance = stylesheetPropsFromRawProps(props);
+        (styleProps = preloadPropsMap.get(styleProps)) &&
+          adoptPreloadPropsForStylesheet(instance, styleProps);
+        instance$253 = (
+          hoistableRoot.ownerDocument || hoistableRoot
+        ).createElement("link");
+        markNodeAsHoistable(instance$253);
+        var linkInstance = instance$253;
+        linkInstance._p = new Promise(function (resolve, reject) {
+          linkInstance.onload = resolve;
+          linkInstance.onerror = reject;
+        });
+        setInitialProperties(instance$253, "link", instance);
+        resource.state.loading |= 4;
+        insertStylesheet(instance$253, props.precedence, hoistableRoot);
+        return (resource.instance = instance$253);
+      case "script":
+        instance$253 = getScriptKey(props.src);
+        if (
+          (styleProps = hoistableRoot.querySelector(
+            getScriptSelectorFromKey(instance$253)
+          ))
+        )
+          return (
+            (resource.instance = styleProps),
+            markNodeAsHoistable(styleProps),
+            styleProps
+          );
+        instance = props;
+        if ((styleProps = preloadPropsMap.get(instance$253)))
+          (instance = assign({}, props)),
+            adoptPreloadPropsForScript(instance, styleProps);
+        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
+        styleProps = hoistableRoot.createElement("script");
+        markNodeAsHoistable(styleProps);
+        setInitialProperties(styleProps, "link", instance);
+        hoistableRoot.head.appendChild(styleProps);
+        return (resource.instance = styleProps);
+      case "void":
+        return null;
+      default:
+        throw Error(formatProdErrorMessage(443, resource.type));
+    }
+  else
+    "stylesheet" === resource.type &&
+      0 === (resource.state.loading & 4) &&
+      ((instance = resource.instance),
+      (resource.state.loading |= 4),
+      insertStylesheet(instance, props.precedence, hoistableRoot));
+  return resource.instance;
+}
+function insertStylesheet(instance, precedence, root) {
+  for (
+    var nodes = root.querySelectorAll(
+        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
+      ),
+      last = nodes.length ? nodes[nodes.length - 1] : null,
+      prior = last,
+      i = 0;
+    i < nodes.length;
+    i++
+  ) {
+    var node = nodes[i];
+    if (node.dataset.precedence === precedence) prior = node;
+    else if (prior !== last) break;
+  }
+  prior
+    ? prior.parentNode.insertBefore(instance, prior.nextSibling)
+    : ((precedence = 9 === root.nodeType ? root.head : root),
+      precedence.insertBefore(instance, precedence.firstChild));
+}
+function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
+  null == stylesheetProps.crossOrigin &&
+    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
+  null == stylesheetProps.referrerPolicy &&
+    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
+  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
+}
+function adoptPreloadPropsForScript(scriptProps, preloadProps) {
+  null == scriptProps.crossOrigin &&
+    (scriptProps.crossOrigin = preloadProps.crossOrigin);
+  null == scriptProps.referrerPolicy &&
+    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
+  null == scriptProps.integrity &&
+    (scriptProps.integrity = preloadProps.integrity);
+}
+var tagCaches = null;
+function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
+  if (null === tagCaches) {
+    var cache = new Map();
+    var caches = (tagCaches = new Map());
+    caches.set(ownerDocument, cache);
+  } else
+    (caches = tagCaches),
+      (cache = caches.get(ownerDocument)),
+      cache || ((cache = new Map()), caches.set(ownerDocument, cache));
+  if (cache.has(type)) return cache;
+  cache.set(type, null);
+  ownerDocument = ownerDocument.getElementsByTagName(type);
+  for (caches = 0; caches < ownerDocument.length; caches++) {
+    var node = ownerDocument[caches];
+    if (
+      !(
+        node[internalHoistableMarker] ||
+        node[internalInstanceKey] ||
+        ("link" === type && "stylesheet" === node.getAttribute("rel"))
+      ) &&
+      "http://www.w3.org/2000/svg" !== node.namespaceURI
+    ) {
+      var nodeKey = node.getAttribute(keyAttribute) || "";
+      nodeKey = type + nodeKey;
+      var existing = cache.get(nodeKey);
+      existing ? existing.push(node) : cache.set(nodeKey, [node]);
+    }
+  }
+  return cache;
+}
+function mountHoistable(hoistableRoot, type, instance) {
+  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
+  hoistableRoot.head.insertBefore(
+    instance,
+    "title" === type ? hoistableRoot.querySelector("head > title") : null
+  );
+}
+function isHostHoistableType(type, props, hostContext) {
+  if (1 === hostContext || null != props.itemProp) return !1;
+  switch (type) {
+    case "meta":
+    case "title":
+      return !0;
+    case "style":
+      if (
+        "string" !== typeof props.precedence ||
+        "string" !== typeof props.href ||
+        "" === props.href
+      )
+        break;
+      return !0;
+    case "link":
+      if (
+        "string" !== typeof props.rel ||
+        "string" !== typeof props.href ||
+        "" === props.href ||
+        props.onLoad ||
+        props.onError
+      )
+        break;
+      switch (props.rel) {
+        case "stylesheet":
+          return (
+            (type = props.disabled),
+            "string" === typeof props.precedence && null == type
+          );
+        default:
+          return !0;
+      }
+    case "script":
+      if (
+        props.async &&
+        "function" !== typeof props.async &&
+        "symbol" !== typeof props.async &&
+        !props.onLoad &&
+        !props.onError &&
+        props.src &&
+        "string" === typeof props.src
+      )
+        return !0;
+  }
+  return !1;
+}
+function preloadResource(resource) {
+  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3)
+    ? !1
+    : !0;
+}
+var suspendedState = null;
+function noop() {}
+function suspendResource(hoistableRoot, resource, props) {
+  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
+  var state = suspendedState;
+  if (
+    "stylesheet" === resource.type &&
+    ("string" !== typeof props.media ||
+      !1 !== matchMedia(props.media).matches) &&
+    0 === (resource.state.loading & 4)
+  ) {
+    if (null === resource.instance) {
+      var key = getStyleKey(props.href),
+        instance = hoistableRoot.querySelector(
+          getStylesheetSelectorFromKey(key)
+        );
+      if (instance) {
+        hoistableRoot = instance._p;
+        null !== hoistableRoot &&
+          "object" === typeof hoistableRoot &&
+          "function" === typeof hoistableRoot.then &&
+          (state.count++,
+          (state = onUnsuspend.bind(state)),
+          hoistableRoot.then(state, state));
+        resource.state.loading |= 4;
+        resource.instance = instance;
+        markNodeAsHoistable(instance);
+        return;
+      }
+      instance = hoistableRoot.ownerDocument || hoistableRoot;
+      props = stylesheetPropsFromRawProps(props);
+      (key = preloadPropsMap.get(key)) &&
+        adoptPreloadPropsForStylesheet(props, key);
+      instance = instance.createElement("link");
+      markNodeAsHoistable(instance);
+      var linkInstance = instance;
+      linkInstance._p = new Promise(function (resolve, reject) {
+        linkInstance.onload = resolve;
+        linkInstance.onerror = reject;
+      });
+      setInitialProperties(instance, "link", props);
+      resource.instance = instance;
+    }
+    null === state.stylesheets && (state.stylesheets = new Map());
+    state.stylesheets.set(resource, hoistableRoot);
+    (hoistableRoot = resource.state.preload) &&
+      0 === (resource.state.loading & 3) &&
+      (state.count++,
+      (resource = onUnsuspend.bind(state)),
+      hoistableRoot.addEventListener("load", resource),
+      hoistableRoot.addEventListener("error", resource));
+  }
+}
+function waitForCommitToBeReady() {
+  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
+  var state = suspendedState;
+  state.stylesheets &&
+    0 === state.count &&
+    insertSuspendedStylesheets(state, state.stylesheets);
+  return 0 < state.count
+    ? function (commit) {
+        var stylesheetTimer = setTimeout(function () {
+          state.stylesheets &&
+            insertSuspendedStylesheets(state, state.stylesheets);
+          if (state.unsuspend) {
+            var unsuspend = state.unsuspend;
+            state.unsuspend = null;
+            unsuspend();
+          }
+        }, 6e4);
+        state.unsuspend = commit;
+        return function () {
+          state.unsuspend = null;
+          clearTimeout(stylesheetTimer);
+        };
+      }
+    : null;
+}
+function onUnsuspend() {
+  this.count--;
+  if (0 === this.count)
+    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
+    else if (this.unsuspend) {
+      var unsuspend = this.unsuspend;
+      this.unsuspend = null;
+      unsuspend();
+    }
+}
+var precedencesByRoot = null;
+function insertSuspendedStylesheets(state, resources) {
+  state.stylesheets = null;
+  null !== state.unsuspend &&
+    (state.count++,
+    (precedencesByRoot = new Map()),
+    resources.forEach(insertStylesheetIntoRoot, state),
+    (precedencesByRoot = null),
+    onUnsuspend.call(state));
+}
+function insertStylesheetIntoRoot(root, resource) {
+  if (!(resource.state.loading & 4)) {
+    var precedences = precedencesByRoot.get(root);
+    if (precedences) var last = precedences.get(null);
+    else {
+      precedences = new Map();
+      precedencesByRoot.set(root, precedences);
+      for (
+        var nodes = root.querySelectorAll(
+            "link[data-precedence],style[data-precedence]"
+          ),
+          i = 0;
+        i < nodes.length;
+        i++
+      ) {
+        var node = nodes[i];
+        if (
+          "LINK" === node.nodeName ||
+          "not all" !== node.getAttribute("media")
+        )
+          precedences.set(node.dataset.precedence, node), (last = node);
+      }
+      last && precedences.set(null, last);
+    }
+    nodes = resource.instance;
+    node = nodes.getAttribute("data-precedence");
+    i = precedences.get(node) || last;
+    i === last && precedences.set(null, nodes);
+    precedences.set(node, nodes);
+    this.count++;
+    last = onUnsuspend.bind(this);
+    nodes.addEventListener("load", last);
+    nodes.addEventListener("error", last);
+    i
+      ? i.parentNode.insertBefore(nodes, i.nextSibling)
+      : ((root = 9 === root.nodeType ? root.head : root),
+        root.insertBefore(nodes, root.firstChild));
+    resource.state.loading |= 4;
+  }
+}
+var HostTransitionContext = {
+  $$typeof: REACT_CONTEXT_TYPE,
+  Provider: null,
+  Consumer: null,
+  _currentValue: sharedNotPendingObject,
+  _currentValue2: sharedNotPendingObject,
+  _threadCount: 0
+};
+function FiberRootNode(
+  containerInfo,
+  tag,
+  hydrate,
+  identifierPrefix,
+  onUncaughtError,
+  onCaughtError,
+  onRecoverableError,
+  formState
+) {
+  this.tag = 1;
+  this.containerInfo = containerInfo;
+  this.pingCache = this.current = this.pendingChildren = null;
+  this.timeoutHandle = -1;
+  this.callbackNode =
+    this.next =
+    this.pendingContext =
+    this.context =
+    this.cancelPendingCommit =
+      null;
+  this.callbackPriority = 0;
+  this.expirationTimes = createLaneMap(-1);
+  this.entangledLanes =
+    this.shellSuspendCounter =
+    this.errorRecoveryDisabledLanes =
+    this.expiredLanes =
+    this.warmLanes =
+    this.pingedLanes =
+    this.suspendedLanes =
+    this.pendingLanes =
+      0;
+  this.entanglements = createLaneMap(0);
+  this.hiddenUpdates = createLaneMap(null);
+  this.identifierPrefix = identifierPrefix;
+  this.onUncaughtError = onUncaughtError;
+  this.onCaughtError = onCaughtError;
+  this.onRecoverableError = onRecoverableError;
+  this.pooledCache = null;
+  this.pooledCacheLanes = 0;
+  this.formState = formState;
+  this.incompleteTransitions = new Map();
+}
+function createFiberRoot(
+  containerInfo,
+  tag,
+  hydrate,
+  initialChildren,
+  hydrationCallbacks,
+  isStrictMode,
+  identifierPrefix,
+  onUncaughtError,
+  onCaughtError,
+  onRecoverableError,
+  transitionCallbacks,
+  formState
+) {
+  containerInfo = new FiberRootNode(
+    containerInfo,
+    tag,
+    hydrate,
+    identifierPrefix,
+    onUncaughtError,
+    onCaughtError,
+    onRecoverableError,
+    formState
+  );
+  tag = 1;
+  !0 === isStrictMode && (tag |= 24);
+  isStrictMode = createFiberImplClass(3, null, null, tag);
+  containerInfo.current = isStrictMode;
+  isStrictMode.stateNode = containerInfo;
+  tag = createCache();
+  tag.refCount++;
+  containerInfo.pooledCache = tag;
+  tag.refCount++;
+  isStrictMode.memoizedState = {
+    element: initialChildren,
+    isDehydrated: hydrate,
+    cache: tag
+  };
+  initializeUpdateQueue(isStrictMode);
+  return containerInfo;
+}
+function getContextForSubtree(parentComponent) {
+  if (!parentComponent) return emptyContextObject;
+  parentComponent = emptyContextObject;
+  return parentComponent;
+}
+function updateContainerImpl(
+  rootFiber,
+  lane,
+  element,
+  container,
+  parentComponent,
+  callback
+) {
+  parentComponent = getContextForSubtree(parentComponent);
+  null === container.context
+    ? (container.context = parentComponent)
+    : (container.pendingContext = parentComponent);
+  container = createUpdate(lane);
+  container.payload = { element: element };
+  callback = void 0 === callback ? null : callback;
+  null !== callback && (container.callback = callback);
+  element = enqueueUpdate(rootFiber, container, lane);
+  null !== element &&
+    (scheduleUpdateOnFiber(element, rootFiber, lane),
+    entangleTransitions(element, rootFiber, lane));
+}
+function markRetryLaneImpl(fiber, retryLane) {
+  fiber = fiber.memoizedState;
+  if (null !== fiber && null !== fiber.dehydrated) {
+    var a = fiber.retryLane;
+    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
+  }
+}
+function markRetryLaneIfNotHydrated(fiber, retryLane) {
+  markRetryLaneImpl(fiber, retryLane);
+  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
+}
+function attemptContinuousHydration(fiber) {
+  if (13 === fiber.tag) {
+    var root = enqueueConcurrentRenderForLane(fiber, 67108864);
+    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
+    markRetryLaneIfNotHydrated(fiber, 67108864);
+  }
+}
+var _enabled = !0;
+function dispatchDiscreteEvent(
+  domEventName,
+  eventSystemFlags,
+  container,
+  nativeEvent
+) {
+  var prevTransition = ReactSharedInternals.T;
+  ReactSharedInternals.T = null;
+  var previousPriority = ReactDOMSharedInternals.p;
+  try {
+    (ReactDOMSharedInternals.p = 2),
+      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
+  } finally {
+    (ReactDOMSharedInternals.p = previousPriority),
+      (ReactSharedInternals.T = prevTransition);
+  }
+}
+function dispatchContinuousEvent(
+  domEventName,
+  eventSystemFlags,
+  container,
+  nativeEvent
+) {
+  var prevTransition = ReactSharedInternals.T;
+  ReactSharedInternals.T = null;
+  var previousPriority = ReactDOMSharedInternals.p;
+  try {
+    (ReactDOMSharedInternals.p = 8),
+      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
+  } finally {
+    (ReactDOMSharedInternals.p = previousPriority),
+      (ReactSharedInternals.T = prevTransition);
+  }
+}
+function dispatchEvent(
+  domEventName,
+  eventSystemFlags,
+  targetContainer,
+  nativeEvent
+) {
+  if (_enabled) {
+    var blockedOn = findInstanceBlockingEvent(nativeEvent);
+    if (null === blockedOn)
+      dispatchEventForPluginEventSystem(
+        domEventName,
+        eventSystemFlags,
+        nativeEvent,
+        return_targetInst,
+        targetContainer
+      ),
+        clearIfContinuousEvent(domEventName, nativeEvent);
+    else if (
+      queueIfContinuousEvent(
+        blockedOn,
+        domEventName,
+        eventSystemFlags,
+        targetContainer,
+        nativeEvent
+      )
+    )
+      nativeEvent.stopPropagation();
+    else if (
+      (clearIfContinuousEvent(domEventName, nativeEvent),
+      eventSystemFlags & 4 &&
+        -1 < discreteReplayableEvents.indexOf(domEventName))
+    ) {
+      for (; null !== blockedOn; ) {
+        var fiber = getInstanceFromNode(blockedOn);
+        if (null !== fiber)
+          switch (fiber.tag) {
+            case 3:
+              fiber = fiber.stateNode;
+              if (fiber.current.memoizedState.isDehydrated) {
+                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
+                if (0 !== lanes) {
+                  var root = fiber;
+                  root.pendingLanes |= 2;
+                  for (root.entangledLanes |= 2; lanes; ) {
+                    var lane = 1 << (31 - clz32(lanes));
+                    root.entanglements[1] |= lane;
+                    lanes &= ~lane;
+                  }
+                  ensureRootIsScheduled(fiber);
+                  0 === (executionContext & 6) &&
+                    ((workInProgressRootRenderTargetTime = now() + 500),
+                    flushSyncWorkAcrossRoots_impl(0, !1));
+                }
+              }
+              break;
+            case 13:
+              (root = enqueueConcurrentRenderForLane(fiber, 2)),
+                null !== root && scheduleUpdateOnFiber(root, fiber, 2),
+                flushSyncWork$1(),
+                markRetryLaneIfNotHydrated(fiber, 2);
+          }
+        fiber = findInstanceBlockingEvent(nativeEvent);
+        null === fiber &&
+          dispatchEventForPluginEventSystem(
+            domEventName,
+            eventSystemFlags,
+            nativeEvent,
+            return_targetInst,
+            targetContainer
+          );
+        if (fiber === blockedOn) break;
+        blockedOn = fiber;
+      }
+      null !== blockedOn && nativeEvent.stopPropagation();
+    } else
+      dispatchEventForPluginEventSystem(
+        domEventName,
+        eventSystemFlags,
+        nativeEvent,
+        null,
+        targetContainer
+      );
+  }
+}
+function findInstanceBlockingEvent(nativeEvent) {
+  nativeEvent = getEventTarget(nativeEvent);
+  return findInstanceBlockingTarget(nativeEvent);
+}
+var return_targetInst = null;
+function findInstanceBlockingTarget(targetNode) {
+  return_targetInst = null;
+  targetNode = getClosestInstanceFromNode(targetNode);
+  if (null !== targetNode) {
+    var nearestMounted = getNearestMountedFiber(targetNode);
+    if (null === nearestMounted) targetNode = null;
+    else {
+      var tag = nearestMounted.tag;
+      if (13 === tag) {
+        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
+        if (null !== targetNode) return targetNode;
+        targetNode = null;
+      } else if (3 === tag) {
+        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
+          return 3 === nearestMounted.tag
+            ? nearestMounted.stateNode.containerInfo
+            : null;
+        targetNode = null;
+      } else nearestMounted !== targetNode && (targetNode = null);
+    }
+  }
+  return_targetInst = targetNode;
+  return null;
+}
+function getEventPriority(domEventName) {
+  switch (domEventName) {
+    case "beforetoggle":
+    case "cancel":
+    case "click":
+    case "close":
+    case "contextmenu":
+    case "copy":
+    case "cut":
+    case "auxclick":
+    case "dblclick":
+    case "dragend":
+    case "dragstart":
+    case "drop":
+    case "focusin":
+    case "focusout":
+    case "input":
+    case "invalid":
+    case "keydown":
+    case "keypress":
+    case "keyup":
+    case "mousedown":
+    case "mouseup":
+    case "paste":
+    case "pause":
+    case "play":
+    case "pointercancel":
+    case "pointerdown":
+    case "pointerup":
+    case "ratechange":
+    case "reset":
+    case "resize":
+    case "seeked":
+    case "submit":
+    case "toggle":
+    case "touchcancel":
+    case "touchend":
+    case "touchstart":
+    case "volumechange":
+    case "change":
+    case "selectionchange":
+    case "textInput":
+    case "compositionstart":
+    case "compositionend":
+    case "compositionupdate":
+    case "beforeblur":
+    case "afterblur":
+    case "beforeinput":
+    case "blur":
+    case "fullscreenchange":
+    case "focus":
+    case "hashchange":
+    case "popstate":
+    case "select":
+    case "selectstart":
+      return 2;
+    case "drag":
+    case "dragenter":
+    case "dragexit":
+    case "dragleave":
+    case "dragover":
+    case "mousemove":
+    case "mouseout":
+    case "mouseover":
+    case "pointermove":
+    case "pointerout":
+    case "pointerover":
+    case "scroll":
+    case "touchmove":
+    case "wheel":
+    case "mouseenter":
+    case "mouseleave":
+    case "pointerenter":
+    case "pointerleave":
+      return 8;
+    case "message":
+      switch (getCurrentPriorityLevel()) {
+        case ImmediatePriority:
+          return 2;
+        case UserBlockingPriority:
+          return 8;
+        case NormalPriority$1:
+        case LowPriority:
+          return 32;
+        case IdlePriority:
+          return 268435456;
+        default:
+          return 32;
+      }
+    default:
+      return 32;
+  }
+}
+var hasScheduledReplayAttempt = !1,
+  queuedFocus = null,
+  queuedDrag = null,
+  queuedMouse = null,
+  queuedPointers = new Map(),
+  queuedPointerCaptures = new Map(),
+  queuedExplicitHydrationTargets = [],
+  discreteReplayableEvents =
+    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
+      " "
+    );
+function clearIfContinuousEvent(domEventName, nativeEvent) {
+  switch (domEventName) {
+    case "focusin":
+    case "focusout":
+      queuedFocus = null;
+      break;
+    case "dragenter":
+    case "dragleave":
+      queuedDrag = null;
+      break;
+    case "mouseover":
+    case "mouseout":
+      queuedMouse = null;
+      break;
+    case "pointerover":
+    case "pointerout":
+      queuedPointers.delete(nativeEvent.pointerId);
+      break;
+    case "gotpointercapture":
+    case "lostpointercapture":
+      queuedPointerCaptures.delete(nativeEvent.pointerId);
+  }
+}
+function accumulateOrCreateContinuousQueuedReplayableEvent(
+  existingQueuedEvent,
+  blockedOn,
+  domEventName,
+  eventSystemFlags,
+  targetContainer,
+  nativeEvent
+) {
+  if (
+    null === existingQueuedEvent ||
+    existingQueuedEvent.nativeEvent !== nativeEvent
+  )
+    return (
+      (existingQueuedEvent = {
+        blockedOn: blockedOn,
+        domEventName: domEventName,
+        eventSystemFlags: eventSystemFlags,
+        nativeEvent: nativeEvent,
+        targetContainers: [targetContainer]
+      }),
+      null !== blockedOn &&
+        ((blockedOn = getInstanceFromNode(blockedOn)),
+        null !== blockedOn && attemptContinuousHydration(blockedOn)),
+      existingQueuedEvent
+    );
+  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
+  blockedOn = existingQueuedEvent.targetContainers;
+  null !== targetContainer &&
+    -1 === blockedOn.indexOf(targetContainer) &&
+    blockedOn.push(targetContainer);
+  return existingQueuedEvent;
+}
+function queueIfContinuousEvent(
+  blockedOn,
+  domEventName,
+  eventSystemFlags,
+  targetContainer,
+  nativeEvent
+) {
+  switch (domEventName) {
+    case "focusin":
+      return (
+        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
+          queuedFocus,
+          blockedOn,
+          domEventName,
+          eventSystemFlags,
+          targetContainer,
+          nativeEvent
+        )),
+        !0
+      );
+    case "dragenter":
+      return (
+        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
+          queuedDrag,
+          blockedOn,
+          domEventName,
+          eventSystemFlags,
+          targetContainer,
+          nativeEvent
+        )),
+        !0
+      );
+    case "mouseover":
+      return (
+        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
+          queuedMouse,
+          blockedOn,
+          domEventName,
+          eventSystemFlags,
+          targetContainer,
+          nativeEvent
+        )),
+        !0
+      );
+    case "pointerover":
+      var pointerId = nativeEvent.pointerId;
+      queuedPointers.set(
+        pointerId,
+        accumulateOrCreateContinuousQueuedReplayableEvent(
+          queuedPointers.get(pointerId) || null,
+          blockedOn,
+          domEventName,
+          eventSystemFlags,
+          targetContainer,
+          nativeEvent
+        )
+      );
+      return !0;
+    case "gotpointercapture":
+      return (
+        (pointerId = nativeEvent.pointerId),
+        queuedPointerCaptures.set(
+          pointerId,
+          accumulateOrCreateContinuousQueuedReplayableEvent(
+            queuedPointerCaptures.get(pointerId) || null,
+            blockedOn,
+            domEventName,
+            eventSystemFlags,
+            targetContainer,
+            nativeEvent
+          )
+        ),
+        !0
+      );
+  }
+  return !1;
+}
+function attemptExplicitHydrationTarget(queuedTarget) {
+  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
+  if (null !== targetInst) {
+    var nearestMounted = getNearestMountedFiber(targetInst);
+    if (null !== nearestMounted)
+      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
+        if (
+          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
+          null !== targetInst)
+        ) {
+          queuedTarget.blockedOn = targetInst;
+          runWithPriority(queuedTarget.priority, function () {
+            if (13 === nearestMounted.tag) {
+              var lane = requestUpdateLane();
+              lane = getBumpedLaneForHydrationByLane(lane);
+              var root = enqueueConcurrentRenderForLane(nearestMounted, lane);
+              null !== root &&
+                scheduleUpdateOnFiber(root, nearestMounted, lane);
+              markRetryLaneIfNotHydrated(nearestMounted, lane);
+            }
+          });
+          return;
+        }
+      } else if (
+        3 === targetInst &&
+        nearestMounted.stateNode.current.memoizedState.isDehydrated
+      ) {
+        queuedTarget.blockedOn =
+          3 === nearestMounted.tag
+            ? nearestMounted.stateNode.containerInfo
+            : null;
+        return;
+      }
+  }
+  queuedTarget.blockedOn = null;
+}
+function attemptReplayContinuousQueuedEvent(queuedEvent) {
+  if (null !== queuedEvent.blockedOn) return !1;
+  for (
+    var targetContainers = queuedEvent.targetContainers;
+    0 < targetContainers.length;
+
+  ) {
+    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
+    if (null === nextBlockedOn) {
+      nextBlockedOn = queuedEvent.nativeEvent;
+      var nativeEventClone = new nextBlockedOn.constructor(
+        nextBlockedOn.type,
+        nextBlockedOn
+      );
+      currentReplayingEvent = nativeEventClone;
+      nextBlockedOn.target.dispatchEvent(nativeEventClone);
+      currentReplayingEvent = null;
+    } else
+      return (
+        (targetContainers = getInstanceFromNode(nextBlockedOn)),
+        null !== targetContainers &&
+          attemptContinuousHydration(targetContainers),
+        (queuedEvent.blockedOn = nextBlockedOn),
+        !1
+      );
+    targetContainers.shift();
+  }
+  return !0;
+}
+function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
+  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
+}
+function replayUnblockedEvents() {
+  hasScheduledReplayAttempt = !1;
+  null !== queuedFocus &&
+    attemptReplayContinuousQueuedEvent(queuedFocus) &&
+    (queuedFocus = null);
+  null !== queuedDrag &&
+    attemptReplayContinuousQueuedEvent(queuedDrag) &&
+    (queuedDrag = null);
+  null !== queuedMouse &&
+    attemptReplayContinuousQueuedEvent(queuedMouse) &&
+    (queuedMouse = null);
+  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
+  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
+}
+function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
+  queuedEvent.blockedOn === unblocked &&
+    ((queuedEvent.blockedOn = null),
+    hasScheduledReplayAttempt ||
+      ((hasScheduledReplayAttempt = !0),
+      Scheduler.unstable_scheduleCallback(
+        Scheduler.unstable_NormalPriority,
+        replayUnblockedEvents
+      )));
+}
+var lastScheduledReplayQueue = null;
+function scheduleReplayQueueIfNeeded(formReplayingQueue) {
+  lastScheduledReplayQueue !== formReplayingQueue &&
+    ((lastScheduledReplayQueue = formReplayingQueue),
+    Scheduler.unstable_scheduleCallback(
+      Scheduler.unstable_NormalPriority,
+      function () {
+        lastScheduledReplayQueue === formReplayingQueue &&
+          (lastScheduledReplayQueue = null);
+        for (var i = 0; i < formReplayingQueue.length; i += 3) {
+          var form = formReplayingQueue[i],
+            submitterOrAction = formReplayingQueue[i + 1],
+            formData = formReplayingQueue[i + 2];
+          if ("function" !== typeof submitterOrAction)
+            if (null === findInstanceBlockingTarget(submitterOrAction || form))
+              continue;
+            else break;
+          var formInst = getInstanceFromNode(form);
+          null !== formInst &&
+            (formReplayingQueue.splice(i, 3),
+            (i -= 3),
+            startHostTransition(
+              formInst,
+              {
+                pending: !0,
+                data: formData,
+                method: form.method,
+                action: submitterOrAction
+              },
+              submitterOrAction,
+              formData
+            ));
+        }
+      }
+    ));
+}
+function retryIfBlockedOn(unblocked) {
+  function unblock(queuedEvent) {
+    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
+  }
+  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
+  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
+  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
+  queuedPointers.forEach(unblock);
+  queuedPointerCaptures.forEach(unblock);
+  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
+    var queuedTarget = queuedExplicitHydrationTargets[i];
+    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
+  }
+  for (
+    ;
+    0 < queuedExplicitHydrationTargets.length &&
+    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);
+
+  )
+    attemptExplicitHydrationTarget(i),
+      null === i.blockedOn && queuedExplicitHydrationTargets.shift();
+  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
+  if (null != i)
+    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
+      var form = i[queuedTarget],
+        submitterOrAction = i[queuedTarget + 1],
+        formProps = form[internalPropsKey] || null;
+      if ("function" === typeof submitterOrAction)
+        formProps || scheduleReplayQueueIfNeeded(i);
+      else if (formProps) {
+        var action = null;
+        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
+          if (
+            ((form = submitterOrAction),
+            (formProps = submitterOrAction[internalPropsKey] || null))
+          )
+            action = formProps.formAction;
+          else {
+            if (null !== findInstanceBlockingTarget(form)) continue;
+          }
+        else action = formProps.action;
+        "function" === typeof action
+          ? (i[queuedTarget + 1] = action)
+          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
+        scheduleReplayQueueIfNeeded(i);
+      }
+    }
+}
+function ReactDOMRoot(internalRoot) {
+  this._internalRoot = internalRoot;
+}
+ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
+  function (children) {
+    var root = this._internalRoot;
+    if (null === root) throw Error(formatProdErrorMessage(409));
+    var current = root.current,
+      lane = requestUpdateLane();
+    updateContainerImpl(current, lane, children, root, null, null);
+  };
+ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
+  function () {
+    var root = this._internalRoot;
+    if (null !== root) {
+      this._internalRoot = null;
+      var container = root.containerInfo;
+      updateContainerImpl(root.current, 2, null, root, null, null);
+      flushSyncWork$1();
+      container[internalContainerInstanceKey] = null;
+    }
+  };
+function ReactDOMHydrationRoot(internalRoot) {
+  this._internalRoot = internalRoot;
+}
+ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
+  if (target) {
+    var updatePriority = resolveUpdatePriority();
+    target = { blockedOn: null, target: target, priority: updatePriority };
+    for (
+      var i = 0;
+      i < queuedExplicitHydrationTargets.length &&
+      0 !== updatePriority &&
+      updatePriority < queuedExplicitHydrationTargets[i].priority;
+      i++
+    );
+    queuedExplicitHydrationTargets.splice(i, 0, target);
+    0 === i && attemptExplicitHydrationTarget(target);
+  }
+};
+var isomorphicReactPackageVersion$jscomp$inline_1828 = React.version;
+if (
+  "19.1.0-experimental-b3a95caf-20250113" !==
+  isomorphicReactPackageVersion$jscomp$inline_1828
+)
+  throw Error(
+    formatProdErrorMessage(
+      527,
+      isomorphicReactPackageVersion$jscomp$inline_1828,
+      "19.1.0-experimental-b3a95caf-20250113"
+    )
+  );
+ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
+  var fiber = componentOrElement._reactInternals;
+  if (void 0 === fiber) {
+    if ("function" === typeof componentOrElement.render)
+      throw Error(formatProdErrorMessage(188));
+    componentOrElement = Object.keys(componentOrElement).join(",");
+    throw Error(formatProdErrorMessage(268, componentOrElement));
+  }
+  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
+  componentOrElement =
+    null !== componentOrElement
+      ? findCurrentHostFiberImpl(componentOrElement)
+      : null;
+  componentOrElement =
+    null === componentOrElement ? null : componentOrElement.stateNode;
+  return componentOrElement;
+};
+var internals$jscomp$inline_2364 = {
+  bundleType: 0,
+  version: "19.1.0-experimental-b3a95caf-20250113",
+  rendererPackageName: "react-dom",
+  currentDispatcherRef: ReactSharedInternals,
+  reconcilerVersion: "19.1.0-experimental-b3a95caf-20250113"
+};
+if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
+  var hook$jscomp$inline_2365 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+  if (
+    !hook$jscomp$inline_2365.isDisabled &&
+    hook$jscomp$inline_2365.supportsFiber
+  )
+    try {
+      (rendererID = hook$jscomp$inline_2365.inject(
+        internals$jscomp$inline_2364
+      )),
+        (injectedHook = hook$jscomp$inline_2365);
+    } catch (err) {}
+}
+exports.createComponentSelector = function (component) {
+  return { $$typeof: COMPONENT_TYPE, value: component };
+};
+exports.createHasPseudoClassSelector = function (selectors) {
+  return { $$typeof: HAS_PSEUDO_CLASS_TYPE, value: selectors };
+};
+exports.createRoleSelector = function (role) {
+  return { $$typeof: ROLE_TYPE, value: role };
+};
+exports.createRoot = function (container, options) {
+  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
+  var isStrictMode = !1,
+    identifierPrefix = "",
+    onUncaughtError = defaultOnUncaughtError,
+    onCaughtError = defaultOnCaughtError,
+    onRecoverableError = defaultOnRecoverableError,
+    transitionCallbacks = null;
+  null !== options &&
+    void 0 !== options &&
+    (!0 === options.unstable_strictMode && (isStrictMode = !0),
+    void 0 !== options.identifierPrefix &&
+      (identifierPrefix = options.identifierPrefix),
+    void 0 !== options.onUncaughtError &&
+      (onUncaughtError = options.onUncaughtError),
+    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
+    void 0 !== options.onRecoverableError &&
+      (onRecoverableError = options.onRecoverableError),
+    void 0 !== options.unstable_transitionCallbacks &&
+      (transitionCallbacks = options.unstable_transitionCallbacks));
+  options = createFiberRoot(
+    container,
+    1,
+    !1,
+    null,
+    null,
+    isStrictMode,
+    identifierPrefix,
+    onUncaughtError,
+    onCaughtError,
+    onRecoverableError,
+    transitionCallbacks,
+    null
+  );
+  container[internalContainerInstanceKey] = options.current;
+  listenToAllSupportedEvents(
+    8 === container.nodeType ? container.parentNode : container
+  );
+  return new ReactDOMRoot(options);
+};
+exports.createTestNameSelector = function (id) {
+  return { $$typeof: TEST_NAME_TYPE, value: id };
+};
+exports.createTextSelector = function (text) {
+  return { $$typeof: TEXT_TYPE, value: text };
+};
+exports.findAllNodes = findAllNodes;
+exports.findBoundingRects = function (hostRoot, selectors) {
+  selectors = findAllNodes(hostRoot, selectors);
+  hostRoot = [];
+  for (var i = 0; i < selectors.length; i++)
+    hostRoot.push(getBoundingRect(selectors[i]));
+  for (selectors = hostRoot.length - 1; 0 < selectors; selectors--) {
+    i = hostRoot[selectors];
+    for (
+      var targetLeft = i.x,
+        targetRight = targetLeft + i.width,
+        targetTop = i.y,
+        targetBottom = targetTop + i.height,
+        j = selectors - 1;
+      0 <= j;
+      j--
+    )
+      if (selectors !== j) {
+        var otherRect = hostRoot[j],
+          otherLeft = otherRect.x,
+          otherRight = otherLeft + otherRect.width,
+          otherTop = otherRect.y,
+          otherBottom = otherTop + otherRect.height;
+        if (
+          targetLeft >= otherLeft &&
+          targetTop >= otherTop &&
+          targetRight <= otherRight &&
+          targetBottom <= otherBottom
+        ) {
+          hostRoot.splice(selectors, 1);
+          break;
+        } else if (
+          !(
+            targetLeft !== otherLeft ||
+            i.width !== otherRect.width ||
+            otherBottom < targetTop ||
+            otherTop > targetBottom
+          )
+        ) {
+          otherTop > targetTop &&
+            ((otherRect.height += otherTop - targetTop),
+            (otherRect.y = targetTop));
+          otherBottom < targetBottom &&
+            (otherRect.height = targetBottom - otherTop);
+          hostRoot.splice(selectors, 1);
+          break;
+        } else if (
+          !(
+            targetTop !== otherTop ||
+            i.height !== otherRect.height ||
+            otherRight < targetLeft ||
+            otherLeft > targetRight
+          )
+        ) {
+          otherLeft > targetLeft &&
+            ((otherRect.width += otherLeft - targetLeft),
+            (otherRect.x = targetLeft));
+          otherRight < targetRight &&
+            (otherRect.width = targetRight - otherLeft);
+          hostRoot.splice(selectors, 1);
+          break;
+        }
+      }
+  }
+  return hostRoot;
+};
+exports.focusWithin = function (hostRoot, selectors) {
+  hostRoot = findFiberRootForHostRoot(hostRoot);
+  selectors = findPaths(hostRoot, selectors);
+  selectors = Array.from(selectors);
+  for (hostRoot = 0; hostRoot < selectors.length; ) {
+    var fiber = selectors[hostRoot++],
+      tag = fiber.tag;
+    if (!isHiddenSubtree(fiber)) {
+      if (
+        (5 === tag || 26 === tag || 27 === tag) &&
+        setFocusIfFocusable(fiber.stateNode)
+      )
+        return !0;
+      for (fiber = fiber.child; null !== fiber; )
+        selectors.push(fiber), (fiber = fiber.sibling);
+    }
+  }
+  return !1;
+};
+exports.getFindAllNodesFailureDescription = function (hostRoot, selectors) {
+  var maxSelectorIndex = 0,
+    matchedNames = [];
+  hostRoot = [findFiberRootForHostRoot(hostRoot), 0];
+  for (var index = 0; index < hostRoot.length; ) {
+    var fiber = hostRoot[index++],
+      tag = fiber.tag,
+      selectorIndex = hostRoot[index++],
+      selector = selectors[selectorIndex];
+    if ((5 !== tag && 26 !== tag && 27 !== tag) || !isHiddenSubtree(fiber))
+      if (
+        (matchSelector(fiber, selector) &&
+          (matchedNames.push(selectorToString(selector)),
+          selectorIndex++,
+          selectorIndex > maxSelectorIndex &&
+            (maxSelectorIndex = selectorIndex)),
+        selectorIndex < selectors.length)
+      )
+        for (fiber = fiber.child; null !== fiber; )
+          hostRoot.push(fiber, selectorIndex), (fiber = fiber.sibling);
+  }
+  if (maxSelectorIndex < selectors.length) {
+    for (hostRoot = []; maxSelectorIndex < selectors.length; maxSelectorIndex++)
+      hostRoot.push(selectorToString(selectors[maxSelectorIndex]));
+    return (
+      "findAllNodes was able to match part of the selector:\n  " +
+      (matchedNames.join(" > ") +
+        "\n\nNo matching component was found for:\n  ") +
+      hostRoot.join(" > ")
+    );
+  }
+  return null;
+};
+exports.hydrateRoot = function (container, initialChildren, options) {
+  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
+  var isStrictMode = !1,
+    identifierPrefix = "",
+    onUncaughtError = defaultOnUncaughtError,
+    onCaughtError = defaultOnCaughtError,
+    onRecoverableError = defaultOnRecoverableError,
+    transitionCallbacks = null,
+    formState = null;
+  null !== options &&
+    void 0 !== options &&
+    (!0 === options.unstable_strictMode && (isStrictMode = !0),
+    void 0 !== options.identifierPrefix &&
+      (identifierPrefix = options.identifierPrefix),
+    void 0 !== options.onUncaughtError &&
+      (onUncaughtError = options.onUncaughtError),
+    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
+    void 0 !== options.onRecoverableError &&
+      (onRecoverableError = options.onRecoverableError),
+    void 0 !== options.unstable_transitionCallbacks &&
+      (transitionCallbacks = options.unstable_transitionCallbacks),
+    void 0 !== options.formState && (formState = options.formState));
+  initialChildren = createFiberRoot(
+    container,
+    1,
+    !0,
+    initialChildren,
+    null != options ? options : null,
+    isStrictMode,
+    identifierPrefix,
+    onUncaughtError,
+    onCaughtError,
+    onRecoverableError,
+    transitionCallbacks,
+    formState
+  );
+  initialChildren.context = getContextForSubtree(null);
+  options = initialChildren.current;
+  isStrictMode = requestUpdateLane();
+  isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
+  identifierPrefix = createUpdate(isStrictMode);
+  identifierPrefix.callback = null;
+  enqueueUpdate(options, identifierPrefix, isStrictMode);
+  options = isStrictMode;
+  initialChildren.current.lanes = options;
+  markRootUpdated$1(initialChildren, options);
+  ensureRootIsScheduled(initialChildren);
+  container[internalContainerInstanceKey] = initialChildren.current;
+  listenToAllSupportedEvents(container);
+  return new ReactDOMHydrationRoot(initialChildren);
+};
+exports.observeVisibleRects = function (
+  hostRoot,
+  selectors,
+  callback,
+  options
+) {
+  hostRoot = findAllNodes(hostRoot, selectors);
+  var disconnect = setupIntersectionObserver(
+    hostRoot,
+    callback,
+    options
+  ).disconnect;
+  return {
+    disconnect: function () {
+      disconnect();
+    }
+  };
+};
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
diff --git a/node_modules/react-dom/cjs/react-dom.development.js b/node_modules/react-dom/cjs/react-dom.development.js
index f4ebc83..1cbf70e 100644
--- a/node_modules/react-dom/cjs/react-dom.development.js
+++ b/node_modules/react-dom/cjs/react-dom.development.js
@@ -416,7 +416,7 @@
     exports.useFormStatus = function () {
       return resolveDispatcher().useHostTransitionStatus();
     };
-    exports.version = "19.1.0-canary-c492f975-20250128";
+    exports.version = "19.1.0-experimental-b3a95caf-20250113";
     "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
       "function" ===
         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
diff --git a/node_modules/react-dom/cjs/react-dom.production.js b/node_modules/react-dom/cjs/react-dom.production.js
index 62eb2ae..0f86700 100644
--- a/node_modules/react-dom/cjs/react-dom.production.js
+++ b/node_modules/react-dom/cjs/react-dom.production.js
@@ -207,4 +207,4 @@ exports.useFormState = function (action, initialState, permalink) {
 exports.useFormStatus = function () {
   return ReactSharedInternals.H.useHostTransitionStatus();
 };
-exports.version = "19.1.0-canary-c492f975-20250128";
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
diff --git a/node_modules/react-dom/cjs/react-dom.react-server.development.js b/node_modules/react-dom/cjs/react-dom.react-server.development.js
index 29e57d1..c369d3a 100644
--- a/node_modules/react-dom/cjs/react-dom.react-server.development.js
+++ b/node_modules/react-dom/cjs/react-dom.react-server.development.js
@@ -336,5 +336,5 @@
             }))
           : Internals.d.m(href));
     };
-    exports.version = "19.1.0-canary-c492f975-20250128";
+    exports.version = "19.1.0-experimental-b3a95caf-20250113";
   })();
diff --git a/node_modules/react-dom/cjs/react-dom.react-server.production.js b/node_modules/react-dom/cjs/react-dom.react-server.production.js
index ea01503..8b3624a 100644
--- a/node_modules/react-dom/cjs/react-dom.react-server.production.js
+++ b/node_modules/react-dom/cjs/react-dom.react-server.production.js
@@ -149,4 +149,4 @@ exports.preloadModule = function (href, options) {
       });
     } else Internals.d.m(href);
 };
-exports.version = "19.1.0-canary-c492f975-20250128";
+exports.version = "19.1.0-experimental-b3a95caf-20250113";
diff --git a/node_modules/react-dom/unstable_server-external-runtime.js b/node_modules/react-dom/unstable_server-external-runtime.js
new file mode 100644
index 0000000..5c3cbb1
--- /dev/null
+++ b/node_modules/react-dom/unstable_server-external-runtime.js
@@ -0,0 +1,236 @@
+(function () {
+  function completeBoundary(suspenseBoundaryID, contentID, errorDigest) {
+    contentID = document.getElementById(contentID);
+    contentID.parentNode.removeChild(contentID);
+    var suspenseIdNode = document.getElementById(suspenseBoundaryID);
+    if (suspenseIdNode) {
+      suspenseBoundaryID = suspenseIdNode.previousSibling;
+      if (errorDigest)
+        (suspenseBoundaryID.data = "$!"),
+          suspenseIdNode.setAttribute("data-dgst", errorDigest);
+      else {
+        errorDigest = suspenseBoundaryID.parentNode;
+        suspenseIdNode = suspenseBoundaryID.nextSibling;
+        var depth = 0;
+        do {
+          if (suspenseIdNode && 8 === suspenseIdNode.nodeType) {
+            var data = suspenseIdNode.data;
+            if ("/$" === data)
+              if (0 === depth) break;
+              else depth--;
+            else ("$" !== data && "$?" !== data && "$!" !== data) || depth++;
+          }
+          data = suspenseIdNode.nextSibling;
+          errorDigest.removeChild(suspenseIdNode);
+          suspenseIdNode = data;
+        } while (suspenseIdNode);
+        for (; contentID.firstChild; )
+          errorDigest.insertBefore(contentID.firstChild, suspenseIdNode);
+        suspenseBoundaryID.data = "$";
+      }
+      suspenseBoundaryID._reactRetry && suspenseBoundaryID._reactRetry();
+    }
+  }
+  function completeBoundaryWithStyles(
+    suspenseBoundaryID,
+    contentID,
+    stylesheetDescriptors
+  ) {
+    function cleanupWith(cb) {
+      this._p = null;
+      cb();
+    }
+    for (
+      var precedences = new Map(),
+        thisDocument = document,
+        lastResource,
+        node,
+        nodes = thisDocument.querySelectorAll(
+          "link[data-precedence],style[data-precedence]"
+        ),
+        styleTagsToHoist = [],
+        i$0 = 0;
+      (node = nodes[i$0++]);
+
+    )
+      "not all" === node.getAttribute("media")
+        ? styleTagsToHoist.push(node)
+        : ("LINK" === node.tagName &&
+            resourceMap.set(node.getAttribute("href"), node),
+          precedences.set(node.dataset.precedence, (lastResource = node)));
+    node = 0;
+    nodes = [];
+    var precedence, resourceEl;
+    for (i$0 = !0; ; ) {
+      if (i$0) {
+        var stylesheetDescriptor = stylesheetDescriptors[node++];
+        if (!stylesheetDescriptor) {
+          i$0 = !1;
+          node = 0;
+          continue;
+        }
+        var avoidInsert = !1,
+          j = 0;
+        var href = stylesheetDescriptor[j++];
+        if ((resourceEl = resourceMap.get(href))) {
+          var attr = resourceEl._p;
+          avoidInsert = !0;
+        } else {
+          resourceEl = thisDocument.createElement("link");
+          resourceEl.href = href;
+          resourceEl.rel = "stylesheet";
+          for (
+            resourceEl.dataset.precedence = precedence =
+              stylesheetDescriptor[j++];
+            (attr = stylesheetDescriptor[j++]);
+
+          )
+            resourceEl.setAttribute(attr, stylesheetDescriptor[j++]);
+          attr = resourceEl._p = new Promise(function (resolve, reject) {
+            resourceEl.onload = cleanupWith.bind(resourceEl, resolve);
+            resourceEl.onerror = cleanupWith.bind(resourceEl, reject);
+          });
+          resourceMap.set(href, resourceEl);
+        }
+        href = resourceEl.getAttribute("media");
+        !attr || (href && !window.matchMedia(href).matches) || nodes.push(attr);
+        if (avoidInsert) continue;
+      } else {
+        resourceEl = styleTagsToHoist[node++];
+        if (!resourceEl) break;
+        precedence = resourceEl.getAttribute("data-precedence");
+        resourceEl.removeAttribute("media");
+      }
+      avoidInsert = precedences.get(precedence) || lastResource;
+      avoidInsert === lastResource && (lastResource = resourceEl);
+      precedences.set(precedence, resourceEl);
+      avoidInsert
+        ? avoidInsert.parentNode.insertBefore(
+            resourceEl,
+            avoidInsert.nextSibling
+          )
+        : ((avoidInsert = thisDocument.head),
+          avoidInsert.insertBefore(resourceEl, avoidInsert.firstChild));
+    }
+    Promise.all(nodes).then(
+      completeBoundary.bind(null, suspenseBoundaryID, contentID, ""),
+      completeBoundary.bind(
+        null,
+        suspenseBoundaryID,
+        contentID,
+        "Resource failed to load"
+      )
+    );
+  }
+  function handleExistingNodes(target) {
+    target = target.querySelectorAll("template");
+    for (var i = 0; i < target.length; i++) handleNode(target[i]);
+  }
+  function installFizzInstrObserver(target) {
+    function handleMutations(mutations) {
+      for (var i = 0; i < mutations.length; i++)
+        for (
+          var addedNodes = mutations[i].addedNodes, j = 0;
+          j < addedNodes.length;
+          j++
+        )
+          addedNodes[j].parentNode && handleNode(addedNodes[j]);
+    }
+    var fizzInstrObserver = new MutationObserver(handleMutations);
+    fizzInstrObserver.observe(target, { childList: !0 });
+    window.addEventListener("DOMContentLoaded", function () {
+      handleMutations(fizzInstrObserver.takeRecords());
+      fizzInstrObserver.disconnect();
+    });
+  }
+  function handleNode(node_) {
+    if (1 === node_.nodeType && node_.dataset) {
+      var dataset = node_.dataset;
+      if (null != dataset.rxi) {
+        var errorDigest = dataset.dgst,
+          errorMsg = dataset.msg,
+          errorStack = dataset.stck,
+          errorComponentStack = dataset.cstck,
+          suspenseIdNode = document.getElementById(dataset.bid);
+        suspenseIdNode &&
+          ((dataset = suspenseIdNode.previousSibling),
+          (dataset.data = "$!"),
+          (suspenseIdNode = suspenseIdNode.dataset),
+          errorDigest && (suspenseIdNode.dgst = errorDigest),
+          errorMsg && (suspenseIdNode.msg = errorMsg),
+          errorStack && (suspenseIdNode.stck = errorStack),
+          errorComponentStack && (suspenseIdNode.cstck = errorComponentStack),
+          dataset._reactRetry && dataset._reactRetry());
+        node_.remove();
+      } else if (null != dataset.rri)
+        completeBoundaryWithStyles(
+          dataset.bid,
+          dataset.sid,
+          JSON.parse(dataset.sty)
+        ),
+          node_.remove();
+      else if (null != dataset.rci)
+        completeBoundary(dataset.bid, dataset.sid), node_.remove();
+      else if (null != dataset.rsi) {
+        errorDigest = dataset.pid;
+        errorMsg = document.getElementById(dataset.sid);
+        errorDigest = document.getElementById(errorDigest);
+        for (errorMsg.parentNode.removeChild(errorMsg); errorMsg.firstChild; )
+          errorDigest.parentNode.insertBefore(errorMsg.firstChild, errorDigest);
+        errorDigest.parentNode.removeChild(errorDigest);
+        node_.remove();
+      }
+    }
+  }
+  var resourceMap = new Map();
+  (function () {
+    addEventListener("submit", function (event) {
+      if (!event.defaultPrevented) {
+        var form = event.target,
+          submitter = event.submitter,
+          action = form.action,
+          formDataSubmitter = submitter;
+        if (submitter) {
+          var submitterAction = submitter.getAttribute("formAction");
+          null != submitterAction &&
+            ((action = submitterAction), (formDataSubmitter = null));
+        }
+        "javascript:throw new Error('React form unexpectedly submitted.')" ===
+          action &&
+          (event.preventDefault(),
+          formDataSubmitter
+            ? ((event = document.createElement("input")),
+              (event.name = formDataSubmitter.name),
+              (event.value = formDataSubmitter.value),
+              formDataSubmitter.parentNode.insertBefore(
+                event,
+                formDataSubmitter
+              ),
+              (formDataSubmitter = new FormData(form)),
+              event.parentNode.removeChild(event))
+            : (formDataSubmitter = new FormData(form)),
+          (event = form.ownerDocument || form),
+          (event.$$reactFormReplay = event.$$reactFormReplay || []).push(
+            form,
+            submitter,
+            formDataSubmitter
+          ));
+      }
+    });
+  })();
+  window.$RC || ((window.$RC = completeBoundary), (window.$RM = new Map()));
+  if (null != document.body)
+    "loading" === document.readyState &&
+      installFizzInstrObserver(document.body),
+      handleExistingNodes(document.body);
+  else {
+    var domBodyObserver = new MutationObserver(function () {
+      null != document.body &&
+        ("loading" === document.readyState &&
+          installFizzInstrObserver(document.body),
+        handleExistingNodes(document.body),
+        domBodyObserver.disconnect());
+    });
+    domBodyObserver.observe(document.documentElement, { childList: !0 });
+  }
+})();
diff --git a/node_modules/react-dom/unstable_testing.js b/node_modules/react-dom/unstable_testing.js
new file mode 100644
index 0000000..7cc1d5a
--- /dev/null
+++ b/node_modules/react-dom/unstable_testing.js
@@ -0,0 +1,38 @@
+'use strict';
+
+function checkDCE() {
+  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
+  if (
+    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
+    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
+  ) {
+    return;
+  }
+  if (process.env.NODE_ENV !== 'production') {
+    // This branch is unreachable because this function is only called
+    // in production, but the condition is true only in development.
+    // Therefore if the branch is still here, dead code elimination wasn't
+    // properly applied.
+    // Don't change the message. React DevTools relies on it. Also make sure
+    // this message doesn't occur elsewhere in this function, or it will cause
+    // a false positive.
+    throw new Error('^_^');
+  }
+  try {
+    // Verify that the code above has been dead code eliminated (DCE'd).
+    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
+  } catch (err) {
+    // DevTools shouldn't crash React, no matter what.
+    // We should still report in case we break this code.
+    console.error(err);
+  }
+}
+
+if (process.env.NODE_ENV === 'production') {
+  // DCE check should happen before ReactDOM bundle executes so that
+  // DevTools can report bad minification during injection.
+  checkDCE();
+  module.exports = require('./cjs/react-dom-unstable_testing.production.js');
+} else {
+  module.exports = require('./cjs/react-dom-unstable_testing.development.js');
+}
diff --git a/node_modules/react-dom/unstable_testing.react-server.js b/node_modules/react-dom/unstable_testing.react-server.js
new file mode 100644
index 0000000..e2611f1
--- /dev/null
+++ b/node_modules/react-dom/unstable_testing.react-server.js
@@ -0,0 +1,5 @@
+'use strict';
+
+throw new Error(
+  'react-dom/unstable_testing is not supported in React Server Components.'
+);
